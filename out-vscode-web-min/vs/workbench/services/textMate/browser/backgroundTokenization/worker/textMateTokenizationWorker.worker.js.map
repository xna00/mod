{"version":3,"sources":["out-vscode-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/fake","out-vscode-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/mod/mod/buildvscode/vscode/src/vs/base/common/amd.ts","out-vscode-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/mod/mod/buildvscode/vscode/src/vs/base/common/observableInternal/debugName.ts","out-vscode-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/mod/mod/buildvscode/vscode/src/vs/base/common/observableInternal/logging.ts","out-vscode-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/mod/mod/buildvscode/vscode/src/vs/base/common/observableInternal/autorun.ts","out-vscode-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/mod/mod/buildvscode/vscode/src/vs/base/common/observableInternal/base.ts","out-vscode-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/mod/mod/buildvscode/vscode/src/vs/base/common/observableInternal/derived.ts","out-vscode-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/mod/mod/buildvscode/vscode/src/vs/base/common/observableInternal/utils.ts","out-vscode-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/mod/mod/buildvscode/vscode/src/vs/base/common/observableInternal/promise.ts","out-vscode-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/mod/mod/buildvscode/vscode/src/vs/base/common/observable.ts","out-vscode-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/mod/mod/buildvscode/vscode/src/vs/base/common/stream.ts","out-vscode-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/mod/mod/buildvscode/vscode/src/vs/base/common/buffer.ts","out-vscode-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/mod/mod/buildvscode/vscode/src/vs/base/common/symbols.ts","out-vscode-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/mod/mod/buildvscode/vscode/src/vs/editor/common/core/eolCounter.ts","out-vscode-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/mod/mod/buildvscode/vscode/src/vs/editor/common/encodedTokenAttributes.ts","out-vscode-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/mod/mod/buildvscode/vscode/src/vs/editor/common/model/fixedArray.ts","out-vscode-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/mod/mod/buildvscode/vscode/src/vs/editor/common/tokens/lineTokens.ts","out-vscode-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/mod/mod/buildvscode/vscode/src/vs/editor/common/tokens/contiguousTokensEditing.ts","out-vscode-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/mod/mod/buildvscode/vscode/src/vs/editor/common/tokens/contiguousMultilineTokens.ts","out-vscode-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/mod/mod/buildvscode/vscode/src/vs/editor/common/tokens/contiguousMultilineTokensBuilder.ts","out-vscode-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/mod/mod/buildvscode/vscode/src/vs/base/common/extpath.ts","out-vscode-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/mod/mod/buildvscode/vscode/src/vs/base/common/network.ts","out-vscode-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/mod/mod/buildvscode/vscode/src/vs/amdX.ts","out-vscode-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/mod/mod/buildvscode/vscode/src/vs/base/common/resources.ts","out-vscode-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/mod/mod/buildvscode/vscode/src/vs/base/common/async.ts","out-vscode-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/mod/mod/buildvscode/vscode/src/vs/editor/common/languages/nullTokenize.ts","out-vscode-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/mod/mod/buildvscode/vscode/src/vs/editor/common/model/textModelTokens.ts","out-vscode-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/mod/mod/buildvscode/vscode/src/vs/workbench/services/textMate/browser/tokenizationSupport/textMateTokenizationSupport.ts","out-vscode-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/mod/mod/buildvscode/vscode/src/vs/workbench/services/textMate/browser/tokenizationSupport/tokenizationSupportWithLineLimit.ts","out-vscode-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/mod/mod/buildvscode/vscode/src/vs/workbench/services/textMate/browser/backgroundTokenization/worker/textMateWorkerTokenizer.ts","out-vscode-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/mod/mod/buildvscode/vscode/src/vs/workbench/services/textMate/common/TMScopeRegistry.ts","out-vscode-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/mod/mod/buildvscode/vscode/src/vs/workbench/services/textMate/common/TMGrammarFactory.ts","out-vscode-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/mod/mod/buildvscode/vscode/src/vs/workbench/services/textMate/browser/backgroundTokenization/worker/textMateTokenizationWorker.worker.ts"],"sourcesContent":["}).call(this);","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n// ESM-comment-begin\nexport const isESM = false;\n// ESM-comment-end\n// ESM-uncomment-begin\n// export const isESM = true;\n// ESM-uncomment-end\n\nexport abstract class LoaderStats {\n\tabstract get amdLoad(): [string, number][];\n\tabstract get amdInvoke(): [string, number][];\n\tabstract get nodeRequire(): [string, number][];\n\tabstract get nodeEval(): [string, number][];\n\tabstract get nodeRequireTotal(): number;\n\n\tstatic get(): LoaderStats {\n\t\tconst amdLoadScript = new Map<string, number>();\n\t\tconst amdInvokeFactory = new Map<string, number>();\n\t\tconst nodeRequire = new Map<string, number>();\n\t\tconst nodeEval = new Map<string, number>();\n\n\t\tfunction mark(map: Map<string, number>, stat: LoaderEvent) {\n\t\t\tif (map.has(stat.detail)) {\n\t\t\t\t// console.warn('BAD events, DOUBLE start', stat);\n\t\t\t\t// map.delete(stat.detail);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmap.set(stat.detail, -stat.timestamp);\n\t\t}\n\n\t\tfunction diff(map: Map<string, number>, stat: LoaderEvent) {\n\t\t\tconst duration = map.get(stat.detail);\n\t\t\tif (!duration) {\n\t\t\t\t// console.warn('BAD events, end WITHOUT start', stat);\n\t\t\t\t// map.delete(stat.detail);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (duration >= 0) {\n\t\t\t\t// console.warn('BAD events, DOUBLE end', stat);\n\t\t\t\t// map.delete(stat.detail);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmap.set(stat.detail, duration + stat.timestamp);\n\t\t}\n\n\t\tlet stats: readonly LoaderEvent[] = [];\n\t\tif (typeof require === 'function' && typeof require.getStats === 'function') {\n\t\t\tstats = require.getStats().slice(0).sort((a, b) => a.timestamp - b.timestamp);\n\t\t}\n\n\t\tfor (const stat of stats) {\n\t\t\tswitch (stat.type) {\n\t\t\t\tcase LoaderEventType.BeginLoadingScript:\n\t\t\t\t\tmark(amdLoadScript, stat);\n\t\t\t\t\tbreak;\n\t\t\t\tcase LoaderEventType.EndLoadingScriptOK:\n\t\t\t\tcase LoaderEventType.EndLoadingScriptError:\n\t\t\t\t\tdiff(amdLoadScript, stat);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase LoaderEventType.BeginInvokeFactory:\n\t\t\t\t\tmark(amdInvokeFactory, stat);\n\t\t\t\t\tbreak;\n\t\t\t\tcase LoaderEventType.EndInvokeFactory:\n\t\t\t\t\tdiff(amdInvokeFactory, stat);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase LoaderEventType.NodeBeginNativeRequire:\n\t\t\t\t\tmark(nodeRequire, stat);\n\t\t\t\t\tbreak;\n\t\t\t\tcase LoaderEventType.NodeEndNativeRequire:\n\t\t\t\t\tdiff(nodeRequire, stat);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase LoaderEventType.NodeBeginEvaluatingScript:\n\t\t\t\t\tmark(nodeEval, stat);\n\t\t\t\t\tbreak;\n\t\t\t\tcase LoaderEventType.NodeEndEvaluatingScript:\n\t\t\t\t\tdiff(nodeEval, stat);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tlet nodeRequireTotal = 0;\n\t\tnodeRequire.forEach(value => nodeRequireTotal += value);\n\n\t\tfunction to2dArray(map: Map<string, number>): [string, number][] {\n\t\t\tconst res: [string, number][] = [];\n\t\t\tmap.forEach((value, index) => res.push([index, value]));\n\t\t\treturn res;\n\t\t}\n\n\t\treturn {\n\t\t\tamdLoad: to2dArray(amdLoadScript),\n\t\t\tamdInvoke: to2dArray(amdInvokeFactory),\n\t\t\tnodeRequire: to2dArray(nodeRequire),\n\t\t\tnodeEval: to2dArray(nodeEval),\n\t\t\tnodeRequireTotal\n\t\t};\n\t}\n\n\tstatic toMarkdownTable(header: string[], rows: Array<Array<{ toString(): string } | undefined>>): string {\n\t\tlet result = '';\n\n\t\tconst lengths: number[] = [];\n\t\theader.forEach((cell, ci) => {\n\t\t\tlengths[ci] = cell.length;\n\t\t});\n\t\trows.forEach(row => {\n\t\t\trow.forEach((cell, ci) => {\n\t\t\t\tif (typeof cell === 'undefined') {\n\t\t\t\t\tcell = row[ci] = '-';\n\t\t\t\t}\n\t\t\t\tconst len = cell.toString().length;\n\t\t\t\tlengths[ci] = Math.max(len, lengths[ci]);\n\t\t\t});\n\t\t});\n\n\t\t// header\n\t\theader.forEach((cell, ci) => { result += `| ${cell + ' '.repeat(lengths[ci] - cell.toString().length)} `; });\n\t\tresult += '|\\n';\n\t\theader.forEach((_cell, ci) => { result += `| ${'-'.repeat(lengths[ci])} `; });\n\t\tresult += '|\\n';\n\n\t\t// cells\n\t\trows.forEach(row => {\n\t\t\trow.forEach((cell, ci) => {\n\t\t\t\tif (typeof cell !== 'undefined') {\n\t\t\t\t\tresult += `| ${cell + ' '.repeat(lengths[ci] - cell.toString().length)} `;\n\t\t\t\t}\n\t\t\t});\n\t\t\tresult += '|\\n';\n\t\t});\n\n\t\treturn result;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport interface IDebugNameData {\n\t/**\n\t * The owner object of an observable.\n\t * Used for debugging only, such as computing a name for the observable by iterating over the fields of the owner.\n\t */\n\treadonly owner?: Owner | undefined;\n\n\t/**\n\t * A string or function that returns a string that represents the name of the observable.\n\t * Used for debugging only.\n\t */\n\treadonly debugName?: DebugNameSource | undefined;\n\n\t/**\n\t * A function that points to the defining function of the object.\n\t * Used for debugging only.\n\t */\n\treadonly debugReferenceFn?: Function | undefined;\n}\n\nexport class DebugNameData {\n\tconstructor(\n\t\tpublic readonly owner: Owner | undefined,\n\t\tpublic readonly debugNameSource: DebugNameSource | undefined,\n\t\tpublic readonly referenceFn: Function | undefined,\n\t) { }\n\n\tpublic getDebugName(target: object): string | undefined {\n\t\treturn getDebugName(target, this);\n\t}\n}\n\n/**\n * The owner object of an observable.\n * Is only used for debugging purposes, such as computing a name for the observable by iterating over the fields of the owner.\n */\nexport type Owner = object | undefined;\nexport type DebugNameSource = string | (() => string | undefined);\n\nconst countPerName = new Map<string, number>();\nconst cachedDebugName = new WeakMap<object, string>();\n\nexport function getDebugName(target: object, data: DebugNameData): string | undefined {\n\tconst cached = cachedDebugName.get(target);\n\tif (cached) {\n\t\treturn cached;\n\t}\n\n\tconst dbgName = computeDebugName(target, data);\n\tif (dbgName) {\n\t\tlet count = countPerName.get(dbgName) ?? 0;\n\t\tcount++;\n\t\tcountPerName.set(dbgName, count);\n\t\tconst result = count === 1 ? dbgName : `${dbgName}#${count}`;\n\t\tcachedDebugName.set(target, result);\n\t\treturn result;\n\t}\n\treturn undefined;\n}\n\nfunction computeDebugName(self: object, data: DebugNameData): string | undefined {\n\tconst cached = cachedDebugName.get(self);\n\tif (cached) {\n\t\treturn cached;\n\t}\n\n\tconst ownerStr = data.owner ? formatOwner(data.owner) + `.` : '';\n\n\tlet result: string | undefined;\n\tconst debugNameSource = data.debugNameSource;\n\tif (debugNameSource !== undefined) {\n\t\tif (typeof debugNameSource === 'function') {\n\t\t\tresult = debugNameSource();\n\t\t\tif (result !== undefined) {\n\t\t\t\treturn ownerStr + result;\n\t\t\t}\n\t\t} else {\n\t\t\treturn ownerStr + debugNameSource;\n\t\t}\n\t}\n\n\tconst referenceFn = data.referenceFn;\n\tif (referenceFn !== undefined) {\n\t\tresult = getFunctionName(referenceFn);\n\t\tif (result !== undefined) {\n\t\t\treturn ownerStr + result;\n\t\t}\n\t}\n\n\tif (data.owner !== undefined) {\n\t\tconst key = findKey(data.owner, self);\n\t\tif (key !== undefined) {\n\t\t\treturn ownerStr + key;\n\t\t}\n\t}\n\treturn undefined;\n}\n\nfunction findKey(obj: object, value: object): string | undefined {\n\tfor (const key in obj) {\n\t\tif ((obj as any)[key] === value) {\n\t\t\treturn key;\n\t\t}\n\t}\n\treturn undefined;\n}\n\nconst countPerClassName = new Map<string, number>();\nconst ownerId = new WeakMap<object, string>();\n\nfunction formatOwner(owner: object): string {\n\tconst id = ownerId.get(owner);\n\tif (id) {\n\t\treturn id;\n\t}\n\tconst className = getClassName(owner);\n\tlet count = countPerClassName.get(className) ?? 0;\n\tcount++;\n\tcountPerClassName.set(className, count);\n\tconst result = count === 1 ? className : `${className}#${count}`;\n\townerId.set(owner, result);\n\treturn result;\n}\n\nfunction getClassName(obj: object): string {\n\tconst ctor = obj.constructor;\n\tif (ctor) {\n\t\treturn ctor.name;\n\t}\n\treturn 'Object';\n}\n\nexport function getFunctionName(fn: Function): string | undefined {\n\tconst fnSrc = fn.toString();\n\t// Pattern: /** @description ... */\n\tconst regexp = /\\/\\*\\*\\s*@description\\s*([^*]*)\\*\\//;\n\tconst match = regexp.exec(fnSrc);\n\tconst result = match ? match[1] : undefined;\n\treturn result?.trim();\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { AutorunObserver } from 'vs/base/common/observableInternal/autorun';\nimport { IObservable, ObservableValue, TransactionImpl } from 'vs/base/common/observableInternal/base';\nimport { Derived } from 'vs/base/common/observableInternal/derived';\nimport { FromEventObservable } from 'vs/base/common/observableInternal/utils';\n\nlet globalObservableLogger: IObservableLogger | undefined;\n\nexport function setLogger(logger: IObservableLogger): void {\n\tglobalObservableLogger = logger;\n}\n\nexport function getLogger(): IObservableLogger | undefined {\n\treturn globalObservableLogger;\n}\n\ninterface IChangeInformation {\n\toldValue: unknown;\n\tnewValue: unknown;\n\tchange: unknown;\n\tdidChange: boolean;\n\thadValue: boolean;\n}\n\nexport interface IObservableLogger {\n\thandleObservableChanged(observable: ObservableValue<any, any>, info: IChangeInformation): void;\n\thandleFromEventObservableTriggered(observable: FromEventObservable<any, any>, info: IChangeInformation): void;\n\n\thandleAutorunCreated(autorun: AutorunObserver): void;\n\thandleAutorunTriggered(autorun: AutorunObserver): void;\n\thandleAutorunFinished(autorun: AutorunObserver): void;\n\n\thandleDerivedCreated(observable: Derived<any>): void;\n\thandleDerivedRecomputed(observable: Derived<any>, info: IChangeInformation): void;\n\n\thandleBeginTransaction(transaction: TransactionImpl): void;\n\thandleEndTransaction(): void;\n}\n\nexport class ConsoleObservableLogger implements IObservableLogger {\n\tprivate indentation = 0;\n\n\tprivate textToConsoleArgs(text: ConsoleText): unknown[] {\n\t\treturn consoleTextToArgs([\n\t\t\tnormalText(repeat('|  ', this.indentation)),\n\t\t\ttext,\n\t\t]);\n\t}\n\n\tprivate formatInfo(info: IChangeInformation): ConsoleText[] {\n\t\tif (!info.hadValue) {\n\t\t\treturn [\n\t\t\t\tnormalText(` `),\n\t\t\t\tstyled(formatValue(info.newValue, 60), {\n\t\t\t\t\tcolor: 'green',\n\t\t\t\t}),\n\t\t\t\tnormalText(` (initial)`),\n\t\t\t];\n\t\t}\n\t\treturn info.didChange\n\t\t\t? [\n\t\t\t\tnormalText(` `),\n\t\t\t\tstyled(formatValue(info.oldValue, 70), {\n\t\t\t\t\tcolor: 'red',\n\t\t\t\t\tstrikeThrough: true,\n\t\t\t\t}),\n\t\t\t\tnormalText(` `),\n\t\t\t\tstyled(formatValue(info.newValue, 60), {\n\t\t\t\t\tcolor: 'green',\n\t\t\t\t}),\n\t\t\t]\n\t\t\t: [normalText(` (unchanged)`)];\n\t}\n\n\thandleObservableChanged(observable: IObservable<unknown, unknown>, info: IChangeInformation): void {\n\t\tconsole.log(...this.textToConsoleArgs([\n\t\t\tformatKind('observable value changed'),\n\t\t\tstyled(observable.debugName, { color: 'BlueViolet' }),\n\t\t\t...this.formatInfo(info),\n\t\t]));\n\t}\n\n\tprivate readonly changedObservablesSets = new WeakMap<object, Set<IObservable<any, any>>>();\n\n\tformatChanges(changes: Set<IObservable<any, any>>): ConsoleText | undefined {\n\t\tif (changes.size === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn styled(\n\t\t\t' (changed deps: ' +\n\t\t\t[...changes].map((o) => o.debugName).join(', ') +\n\t\t\t')',\n\t\t\t{ color: 'gray' }\n\t\t);\n\t}\n\n\thandleDerivedCreated(derived: Derived<unknown>): void {\n\t\tconst existingHandleChange = derived.handleChange;\n\t\tthis.changedObservablesSets.set(derived, new Set());\n\t\tderived.handleChange = (observable, change) => {\n\t\t\tthis.changedObservablesSets.get(derived)!.add(observable);\n\t\t\treturn existingHandleChange.apply(derived, [observable, change]);\n\t\t};\n\t}\n\n\thandleDerivedRecomputed(derived: Derived<unknown>, info: IChangeInformation): void {\n\t\tconst changedObservables = this.changedObservablesSets.get(derived)!;\n\t\tconsole.log(...this.textToConsoleArgs([\n\t\t\tformatKind('derived recomputed'),\n\t\t\tstyled(derived.debugName, { color: 'BlueViolet' }),\n\t\t\t...this.formatInfo(info),\n\t\t\tthis.formatChanges(changedObservables),\n\t\t\t{ data: [{ fn: derived._computeFn }] }\n\t\t]));\n\t\tchangedObservables.clear();\n\t}\n\n\thandleFromEventObservableTriggered(observable: FromEventObservable<any, any>, info: IChangeInformation): void {\n\t\tconsole.log(...this.textToConsoleArgs([\n\t\t\tformatKind('observable from event triggered'),\n\t\t\tstyled(observable.debugName, { color: 'BlueViolet' }),\n\t\t\t...this.formatInfo(info),\n\t\t\t{ data: [{ fn: observable._getValue }] }\n\t\t]));\n\t}\n\n\thandleAutorunCreated(autorun: AutorunObserver): void {\n\t\tconst existingHandleChange = autorun.handleChange;\n\t\tthis.changedObservablesSets.set(autorun, new Set());\n\t\tautorun.handleChange = (observable, change) => {\n\t\t\tthis.changedObservablesSets.get(autorun)!.add(observable);\n\t\t\treturn existingHandleChange.apply(autorun, [observable, change]);\n\t\t};\n\t}\n\n\thandleAutorunTriggered(autorun: AutorunObserver): void {\n\t\tconst changedObservables = this.changedObservablesSets.get(autorun)!;\n\t\tconsole.log(...this.textToConsoleArgs([\n\t\t\tformatKind('autorun'),\n\t\t\tstyled(autorun.debugName, { color: 'BlueViolet' }),\n\t\t\tthis.formatChanges(changedObservables),\n\t\t\t{ data: [{ fn: autorun._runFn }] }\n\t\t]));\n\t\tchangedObservables.clear();\n\t\tthis.indentation++;\n\t}\n\n\thandleAutorunFinished(autorun: AutorunObserver): void {\n\t\tthis.indentation--;\n\t}\n\n\thandleBeginTransaction(transaction: TransactionImpl): void {\n\t\tlet transactionName = transaction.getDebugName();\n\t\tif (transactionName === undefined) {\n\t\t\ttransactionName = '';\n\t\t}\n\t\tconsole.log(...this.textToConsoleArgs([\n\t\t\tformatKind('transaction'),\n\t\t\tstyled(transactionName, { color: 'BlueViolet' }),\n\t\t\t{ data: [{ fn: transaction._fn }] }\n\t\t]));\n\t\tthis.indentation++;\n\t}\n\n\thandleEndTransaction(): void {\n\t\tthis.indentation--;\n\t}\n}\n\ntype ConsoleText =\n\t| (ConsoleText | undefined)[]\n\t| { text: string; style: string; data?: unknown[] }\n\t| { data: unknown[] };\n\nfunction consoleTextToArgs(text: ConsoleText): unknown[] {\n\tconst styles = new Array<any>();\n\tconst data: unknown[] = [];\n\tlet firstArg = '';\n\n\tfunction process(t: ConsoleText): void {\n\t\tif ('length' in t) {\n\t\t\tfor (const item of t) {\n\t\t\t\tif (item) {\n\t\t\t\t\tprocess(item);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ('text' in t) {\n\t\t\tfirstArg += `%c${t.text}`;\n\t\t\tstyles.push(t.style);\n\t\t\tif (t.data) {\n\t\t\t\tdata.push(...t.data);\n\t\t\t}\n\t\t} else if ('data' in t) {\n\t\t\tdata.push(...t.data);\n\t\t}\n\t}\n\n\tprocess(text);\n\n\tconst result = [firstArg, ...styles];\n\tresult.push(...data);\n\treturn result;\n}\n\nfunction normalText(text: string): ConsoleText {\n\treturn styled(text, { color: 'black' });\n}\n\nfunction formatKind(kind: string): ConsoleText {\n\treturn styled(padStr(`${kind}: `, 10), { color: 'black', bold: true });\n}\n\nfunction styled(\n\ttext: string,\n\toptions: { color: string; strikeThrough?: boolean; bold?: boolean } = {\n\t\tcolor: 'black',\n\t}\n): ConsoleText {\n\tfunction objToCss(styleObj: Record<string, string>): string {\n\t\treturn Object.entries(styleObj).reduce(\n\t\t\t(styleString, [propName, propValue]) => {\n\t\t\t\treturn `${styleString}${propName}:${propValue};`;\n\t\t\t},\n\t\t\t''\n\t\t);\n\t}\n\n\tconst style: Record<string, string> = {\n\t\tcolor: options.color,\n\t};\n\tif (options.strikeThrough) {\n\t\tstyle['text-decoration'] = 'line-through';\n\t}\n\tif (options.bold) {\n\t\tstyle['font-weight'] = 'bold';\n\t}\n\n\treturn {\n\t\ttext,\n\t\tstyle: objToCss(style),\n\t};\n}\n\nfunction formatValue(value: unknown, availableLen: number): string {\n\tswitch (typeof value) {\n\t\tcase 'number':\n\t\t\treturn '' + value;\n\t\tcase 'string':\n\t\t\tif (value.length + 2 <= availableLen) {\n\t\t\t\treturn `\"${value}\"`;\n\t\t\t}\n\t\t\treturn `\"${value.substr(0, availableLen - 7)}\"+...`;\n\n\t\tcase 'boolean':\n\t\t\treturn value ? 'true' : 'false';\n\t\tcase 'undefined':\n\t\t\treturn 'undefined';\n\t\tcase 'object':\n\t\t\tif (value === null) {\n\t\t\t\treturn 'null';\n\t\t\t}\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\treturn formatArray(value, availableLen);\n\t\t\t}\n\t\t\treturn formatObject(value, availableLen);\n\t\tcase 'symbol':\n\t\t\treturn value.toString();\n\t\tcase 'function':\n\t\t\treturn `[[Function${value.name ? ' ' + value.name : ''}]]`;\n\t\tdefault:\n\t\t\treturn '' + value;\n\t}\n}\n\nfunction formatArray(value: unknown[], availableLen: number): string {\n\tlet result = '[ ';\n\tlet first = true;\n\tfor (const val of value) {\n\t\tif (!first) {\n\t\t\tresult += ', ';\n\t\t}\n\t\tif (result.length - 5 > availableLen) {\n\t\t\tresult += '...';\n\t\t\tbreak;\n\t\t}\n\t\tfirst = false;\n\t\tresult += `${formatValue(val, availableLen - result.length)}`;\n\t}\n\tresult += ' ]';\n\treturn result;\n}\n\nfunction formatObject(value: object, availableLen: number): string {\n\tlet result = '{ ';\n\tlet first = true;\n\tfor (const [key, val] of Object.entries(value)) {\n\t\tif (!first) {\n\t\t\tresult += ', ';\n\t\t}\n\t\tif (result.length - 5 > availableLen) {\n\t\t\tresult += '...';\n\t\t\tbreak;\n\t\t}\n\t\tfirst = false;\n\t\tresult += `${key}: ${formatValue(val, availableLen - result.length)}`;\n\t}\n\tresult += ' }';\n\treturn result;\n}\n\nfunction repeat(str: string, count: number): string {\n\tlet result = '';\n\tfor (let i = 1; i <= count; i++) {\n\t\tresult += str;\n\t}\n\treturn result;\n}\n\nfunction padStr(str: string, length: number): string {\n\twhile (str.length < length) {\n\t\tstr += ' ';\n\t}\n\treturn str;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { assertFn } from 'vs/base/common/assert';\nimport { DisposableStore, IDisposable, markAsDisposed, toDisposable, trackDisposable } from 'vs/base/common/lifecycle';\nimport { IReader, IObservable, IObserver, IChangeContext } from 'vs/base/common/observableInternal/base';\nimport { DebugNameData, IDebugNameData } from 'vs/base/common/observableInternal/debugName';\nimport { getLogger } from 'vs/base/common/observableInternal/logging';\n\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n */\nexport function autorun(fn: (reader: IReader) => void): IDisposable {\n\treturn new AutorunObserver(\n\t\tnew DebugNameData(undefined, undefined, fn),\n\t\tfn,\n\t\tundefined,\n\t\tundefined\n\t);\n}\n\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n */\nexport function autorunOpts(options: IDebugNameData & {}, fn: (reader: IReader) => void): IDisposable {\n\treturn new AutorunObserver(\n\t\tnew DebugNameData(options.owner, options.debugName, options.debugReferenceFn ?? fn),\n\t\tfn,\n\t\tundefined,\n\t\tundefined\n\t);\n}\n\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n *\n * Use `createEmptyChangeSummary` to create a \"change summary\" that can collect the changes.\n * Use `handleChange` to add a reported change to the change summary.\n * The run function is given the last change summary.\n * The change summary is discarded after the run function was called.\n *\n * @see autorun\n */\nexport function autorunHandleChanges<TChangeSummary>(\n\toptions: IDebugNameData & {\n\t\tcreateEmptyChangeSummary?: () => TChangeSummary;\n\t\thandleChange: (context: IChangeContext, changeSummary: TChangeSummary) => boolean;\n\t},\n\tfn: (reader: IReader, changeSummary: TChangeSummary) => void\n): IDisposable {\n\treturn new AutorunObserver(\n\t\tnew DebugNameData(options.owner, options.debugName, options.debugReferenceFn ?? fn),\n\t\tfn,\n\t\toptions.createEmptyChangeSummary,\n\t\toptions.handleChange\n\t);\n}\n\n/**\n * @see autorunHandleChanges (but with a disposable store that is cleared before the next run or on dispose)\n */\nexport function autorunWithStoreHandleChanges<TChangeSummary>(\n\toptions: IDebugNameData & {\n\t\tcreateEmptyChangeSummary?: () => TChangeSummary;\n\t\thandleChange: (context: IChangeContext, changeSummary: TChangeSummary) => boolean;\n\t},\n\tfn: (reader: IReader, changeSummary: TChangeSummary, store: DisposableStore) => void\n): IDisposable {\n\tconst store = new DisposableStore();\n\tconst disposable = autorunHandleChanges(\n\t\t{\n\t\t\towner: options.owner,\n\t\t\tdebugName: options.debugName,\n\t\t\tdebugReferenceFn: options.debugReferenceFn,\n\t\t\tcreateEmptyChangeSummary: options.createEmptyChangeSummary,\n\t\t\thandleChange: options.handleChange,\n\t\t},\n\t\t(reader, changeSummary) => {\n\t\t\tstore.clear();\n\t\t\tfn(reader, changeSummary, store);\n\t\t}\n\t);\n\treturn toDisposable(() => {\n\t\tdisposable.dispose();\n\t\tstore.dispose();\n\t});\n}\n\n/**\n * @see autorun (but with a disposable store that is cleared before the next run or on dispose)\n */\nexport function autorunWithStore(fn: (reader: IReader, store: DisposableStore) => void): IDisposable {\n\tconst store = new DisposableStore();\n\tconst disposable = autorunOpts(\n\t\t{\n\t\t\towner: undefined,\n\t\t\tdebugName: undefined,\n\t\t\tdebugReferenceFn: fn,\n\t\t},\n\t\treader => {\n\t\t\tstore.clear();\n\t\t\tfn(reader, store);\n\t\t}\n\t);\n\treturn toDisposable(() => {\n\t\tdisposable.dispose();\n\t\tstore.dispose();\n\t});\n}\n\nexport function autorunDelta<T>(\n\tobservable: IObservable<T>,\n\thandler: (args: { lastValue: T | undefined; newValue: T }) => void\n): IDisposable {\n\tlet _lastValue: T | undefined;\n\treturn autorunOpts({ debugReferenceFn: handler }, (reader) => {\n\t\tconst newValue = observable.read(reader);\n\t\tconst lastValue = _lastValue;\n\t\t_lastValue = newValue;\n\t\thandler({ lastValue, newValue });\n\t});\n}\n\n\nconst enum AutorunState {\n\t/**\n\t * A dependency could have changed.\n\t * We need to explicitly ask them if at least one dependency changed.\n\t */\n\tdependenciesMightHaveChanged = 1,\n\n\t/**\n\t * A dependency changed and we need to recompute.\n\t */\n\tstale = 2,\n\tupToDate = 3,\n}\n\nexport class AutorunObserver<TChangeSummary = any> implements IObserver, IReader, IDisposable {\n\tprivate state = AutorunState.stale;\n\tprivate updateCount = 0;\n\tprivate disposed = false;\n\tprivate dependencies = new Set<IObservable<any>>();\n\tprivate dependenciesToBeRemoved = new Set<IObservable<any>>();\n\tprivate changeSummary: TChangeSummary | undefined;\n\n\tpublic get debugName(): string {\n\t\treturn this._debugNameData.getDebugName(this) ?? '(anonymous)';\n\t}\n\n\tconstructor(\n\t\tprivate readonly _debugNameData: DebugNameData,\n\t\tpublic readonly _runFn: (reader: IReader, changeSummary: TChangeSummary) => void,\n\t\tprivate readonly createChangeSummary: (() => TChangeSummary) | undefined,\n\t\tprivate readonly _handleChange: ((context: IChangeContext, summary: TChangeSummary) => boolean) | undefined,\n\t) {\n\t\tthis.changeSummary = this.createChangeSummary?.();\n\t\tgetLogger()?.handleAutorunCreated(this);\n\t\tthis._runIfNeeded();\n\n\t\ttrackDisposable(this);\n\t}\n\n\tpublic dispose(): void {\n\t\tthis.disposed = true;\n\t\tfor (const o of this.dependencies) {\n\t\t\to.removeObserver(this);\n\t\t}\n\t\tthis.dependencies.clear();\n\n\t\tmarkAsDisposed(this);\n\t}\n\n\tprivate _runIfNeeded() {\n\t\tif (this.state === AutorunState.upToDate) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst emptySet = this.dependenciesToBeRemoved;\n\t\tthis.dependenciesToBeRemoved = this.dependencies;\n\t\tthis.dependencies = emptySet;\n\n\t\tthis.state = AutorunState.upToDate;\n\n\t\tconst isDisposed = this.disposed;\n\t\ttry {\n\t\t\tif (!isDisposed) {\n\t\t\t\tgetLogger()?.handleAutorunTriggered(this);\n\t\t\t\tconst changeSummary = this.changeSummary!;\n\t\t\t\tthis.changeSummary = this.createChangeSummary?.();\n\t\t\t\tthis._runFn(this, changeSummary);\n\t\t\t}\n\t\t} finally {\n\t\t\tif (!isDisposed) {\n\t\t\t\tgetLogger()?.handleAutorunFinished(this);\n\t\t\t}\n\t\t\t// We don't want our observed observables to think that they are (not even temporarily) not being observed.\n\t\t\t// Thus, we only unsubscribe from observables that are definitely not read anymore.\n\t\t\tfor (const o of this.dependenciesToBeRemoved) {\n\t\t\t\to.removeObserver(this);\n\t\t\t}\n\t\t\tthis.dependenciesToBeRemoved.clear();\n\t\t}\n\t}\n\n\tpublic toString(): string {\n\t\treturn `Autorun<${this.debugName}>`;\n\t}\n\n\t// IObserver implementation\n\tpublic beginUpdate(): void {\n\t\tif (this.state === AutorunState.upToDate) {\n\t\t\tthis.state = AutorunState.dependenciesMightHaveChanged;\n\t\t}\n\t\tthis.updateCount++;\n\t}\n\n\tpublic endUpdate(): void {\n\t\tif (this.updateCount === 1) {\n\t\t\tdo {\n\t\t\t\tif (this.state === AutorunState.dependenciesMightHaveChanged) {\n\t\t\t\t\tthis.state = AutorunState.upToDate;\n\t\t\t\t\tfor (const d of this.dependencies) {\n\t\t\t\t\t\td.reportChanges();\n\t\t\t\t\t\tif (this.state as AutorunState === AutorunState.stale) {\n\t\t\t\t\t\t\t// The other dependencies will refresh on demand\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis._runIfNeeded();\n\t\t\t} while (this.state !== AutorunState.upToDate);\n\t\t}\n\t\tthis.updateCount--;\n\n\t\tassertFn(() => this.updateCount >= 0);\n\t}\n\n\tpublic handlePossibleChange(observable: IObservable<any>): void {\n\t\tif (this.state === AutorunState.upToDate && this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n\t\t\tthis.state = AutorunState.dependenciesMightHaveChanged;\n\t\t}\n\t}\n\n\tpublic handleChange<T, TChange>(observable: IObservable<T, TChange>, change: TChange): void {\n\t\tif (this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n\t\t\tconst shouldReact = this._handleChange ? this._handleChange({\n\t\t\t\tchangedObservable: observable,\n\t\t\t\tchange,\n\t\t\t\tdidChange: o => o === observable as any,\n\t\t\t}, this.changeSummary!) : true;\n\t\t\tif (shouldReact) {\n\t\t\t\tthis.state = AutorunState.stale;\n\t\t\t}\n\t\t}\n\t}\n\n\t// IReader implementation\n\tpublic readObservable<T>(observable: IObservable<T>): T {\n\t\t// In case the run action disposes the autorun\n\t\tif (this.disposed) {\n\t\t\treturn observable.get();\n\t\t}\n\n\t\tobservable.addObserver(this);\n\t\tconst value = observable.get();\n\t\tthis.dependencies.add(observable);\n\t\tthis.dependenciesToBeRemoved.delete(observable);\n\t\treturn value;\n\t}\n}\n\nexport namespace autorun {\n\texport const Observer = AutorunObserver;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { DisposableStore, IDisposable } from 'vs/base/common/lifecycle';\nimport { keepObserved, recomputeInitiallyAndOnChange } from 'vs/base/common/observable';\nimport { DebugNameData, Owner, getFunctionName } from 'vs/base/common/observableInternal/debugName';\nimport type { derivedOpts } from 'vs/base/common/observableInternal/derived';\nimport { getLogger } from 'vs/base/common/observableInternal/logging';\n\n/**\n * Represents an observable value.\n *\n * @template T The type of the values the observable can hold.\n * @template TChange The type used to describe value changes\n * (usually `void` and only used in advanced scenarios).\n * While observers can miss temporary values of an observable,\n * they will receive all change values (as long as they are subscribed)!\n */\nexport interface IObservable<T, TChange = unknown> {\n\t/**\n\t * Returns the current value.\n\t *\n\t * Calls {@link IObserver.handleChange} if the observable notices that the value changed.\n\t * Must not be called from {@link IObserver.handleChange}!\n\t */\n\tget(): T;\n\n\t/**\n\t * Forces the observable to check for changes and report them.\n\t *\n\t * Has the same effect as calling {@link IObservable.get}, but does not force the observable\n\t * to actually construct the value, e.g. if change deltas are used.\n\t * Calls {@link IObserver.handleChange} if the observable notices that the value changed.\n\t * Must not be called from {@link IObserver.handleChange}!\n\t */\n\treportChanges(): void;\n\n\t/**\n\t * Adds the observer to the set of subscribed observers.\n\t * This method is idempotent.\n\t */\n\taddObserver(observer: IObserver): void;\n\n\t/**\n\t * Removes the observer from the set of subscribed observers.\n\t * This method is idempotent.\n\t */\n\tremoveObserver(observer: IObserver): void;\n\n\t/**\n\t * Reads the current value and subscribes the reader to this observable.\n\t *\n\t * Calls {@link IReader.readObservable} if a reader is given, otherwise {@link IObservable.get}\n\t * (see {@link ConvenientObservable.read} for the implementation).\n\t */\n\tread(reader: IReader | undefined): T;\n\n\t/**\n\t * Creates a derived observable that depends on this observable.\n\t * Use the reader to read other observables\n\t * (see {@link ConvenientObservable.map} for the implementation).\n\t */\n\tmap<TNew>(fn: (value: T, reader: IReader) => TNew): IObservable<TNew>;\n\tmap<TNew>(owner: object, fn: (value: T, reader: IReader) => TNew): IObservable<TNew>;\n\n\t/**\n\t * Makes sure this value is computed eagerly.\n\t */\n\trecomputeInitiallyAndOnChange(store: DisposableStore, handleValue?: (value: T) => void): IObservable<T>;\n\n\t/**\n\t * Makes sure this value is cached.\n\t */\n\tkeepObserved(store: DisposableStore): IObservable<T>;\n\n\t/**\n\t * A human-readable name for debugging purposes.\n\t */\n\treadonly debugName: string;\n\n\t/**\n\t * This property captures the type of the change object. Do not use it at runtime!\n\t */\n\treadonly TChange: TChange;\n}\n\nexport interface IReader {\n\t/**\n\t * Reads the value of an observable and subscribes to it.\n\t */\n\treadObservable<T>(observable: IObservable<T, any>): T;\n}\n\n/**\n * Represents an observer that can be subscribed to an observable.\n *\n * If an observer is subscribed to an observable and that observable didn't signal\n * a change through one of the observer methods, the observer can assume that the\n * observable didn't change.\n * If an observable reported a possible change, {@link IObservable.reportChanges} forces\n * the observable to report an actual change if there was one.\n */\nexport interface IObserver {\n\t/**\n\t * Signals that the given observable might have changed and a transaction potentially modifying that observable started.\n\t * Before the given observable can call this method again, is must call {@link IObserver.endUpdate}.\n\t *\n\t * Implementations must not get/read the value of other observables, as they might not have received this event yet!\n\t * The method {@link IObservable.reportChanges} can be used to force the observable to report the changes.\n\t */\n\tbeginUpdate<T>(observable: IObservable<T>): void;\n\n\t/**\n\t * Signals that the transaction that potentially modified the given observable ended.\n\t * This is a good place to react to (potential) changes.\n\t */\n\tendUpdate<T>(observable: IObservable<T>): void;\n\n\t/**\n\t * Signals that the given observable might have changed.\n\t * The method {@link IObservable.reportChanges} can be used to force the observable to report the changes.\n\t *\n\t * Implementations must not get/read the value of other observables, as they might not have received this event yet!\n\t * The change should be processed lazily or in {@link IObserver.endUpdate}.\n\t */\n\thandlePossibleChange<T>(observable: IObservable<T>): void;\n\n\t/**\n\t * Signals that the given {@link observable} changed.\n\t *\n\t * Implementations must not get/read the value of other observables, as they might not have received this event yet!\n\t * The change should be processed lazily or in {@link IObserver.endUpdate}.\n\t *\n\t * @param change Indicates how or why the value changed.\n\t */\n\thandleChange<T, TChange>(observable: IObservable<T, TChange>, change: TChange): void;\n}\n\nexport interface ISettable<T, TChange = void> {\n\t/**\n\t * Sets the value of the observable.\n\t * Use a transaction to batch multiple changes (with a transaction, observers only react at the end of the transaction).\n\t *\n\t * @param transaction When given, value changes are handled on demand or when the transaction ends.\n\t * @param change Describes how or why the value changed.\n\t */\n\tset(value: T, transaction: ITransaction | undefined, change: TChange): void;\n}\n\nexport interface ITransaction {\n\t/**\n\t * Calls {@link Observer.beginUpdate} immediately\n\t * and {@link Observer.endUpdate} when the transaction ends.\n\t */\n\tupdateObserver(observer: IObserver, observable: IObservable<any, any>): void;\n}\n\nlet _recomputeInitiallyAndOnChange: typeof recomputeInitiallyAndOnChange;\nexport function _setRecomputeInitiallyAndOnChange(recomputeInitiallyAndOnChange: typeof _recomputeInitiallyAndOnChange) {\n\t_recomputeInitiallyAndOnChange = recomputeInitiallyAndOnChange;\n}\n\nlet _keepObserved: typeof keepObserved;\nexport function _setKeepObserved(keepObserved: typeof _keepObserved) {\n\t_keepObserved = keepObserved;\n}\n\n\nlet _derived: typeof derivedOpts;\n/**\n * @internal\n * This is to allow splitting files.\n*/\nexport function _setDerivedOpts(derived: typeof _derived) {\n\t_derived = derived;\n}\n\nexport abstract class ConvenientObservable<T, TChange> implements IObservable<T, TChange> {\n\tget TChange(): TChange { return null!; }\n\n\tpublic abstract get(): T;\n\n\tpublic reportChanges(): void {\n\t\tthis.get();\n\t}\n\n\tpublic abstract addObserver(observer: IObserver): void;\n\tpublic abstract removeObserver(observer: IObserver): void;\n\n\t/** @sealed */\n\tpublic read(reader: IReader | undefined): T {\n\t\tif (reader) {\n\t\t\treturn reader.readObservable(this);\n\t\t} else {\n\t\t\treturn this.get();\n\t\t}\n\t}\n\n\t/** @sealed */\n\tpublic map<TNew>(fn: (value: T, reader: IReader) => TNew): IObservable<TNew>;\n\tpublic map<TNew>(owner: Owner, fn: (value: T, reader: IReader) => TNew): IObservable<TNew>;\n\tpublic map<TNew>(fnOrOwner: Owner | ((value: T, reader: IReader) => TNew), fnOrUndefined?: (value: T, reader: IReader) => TNew): IObservable<TNew> {\n\t\tconst owner = fnOrUndefined === undefined ? undefined : fnOrOwner as Owner;\n\t\tconst fn = fnOrUndefined === undefined ? fnOrOwner as (value: T, reader: IReader) => TNew : fnOrUndefined;\n\n\t\treturn _derived(\n\t\t\t{\n\t\t\t\towner,\n\t\t\t\tdebugName: () => {\n\t\t\t\t\tconst name = getFunctionName(fn);\n\t\t\t\t\tif (name !== undefined) {\n\t\t\t\t\t\treturn name;\n\t\t\t\t\t}\n\n\t\t\t\t\t// regexp to match `x => x.y` or `x => x?.y` where x and y can be arbitrary identifiers (uses backref):\n\t\t\t\t\tconst regexp = /^\\s*\\(?\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*\\)?\\s*=>\\s*\\1(?:\\??)\\.([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*$/;\n\t\t\t\t\tconst match = regexp.exec(fn.toString());\n\t\t\t\t\tif (match) {\n\t\t\t\t\t\treturn `${this.debugName}.${match[2]}`;\n\t\t\t\t\t}\n\t\t\t\t\tif (!owner) {\n\t\t\t\t\t\treturn `${this.debugName} (mapped)`;\n\t\t\t\t\t}\n\t\t\t\t\treturn undefined;\n\t\t\t\t},\n\t\t\t},\n\t\t\t(reader) => fn(this.read(reader), reader),\n\t\t);\n\t}\n\n\tpublic recomputeInitiallyAndOnChange(store: DisposableStore, handleValue?: (value: T) => void): IObservable<T> {\n\t\tstore.add(_recomputeInitiallyAndOnChange!(this, handleValue));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Ensures that this observable is observed. This keeps the cache alive.\n\t * However, in case of deriveds, it does not force eager evaluation (only when the value is read/get).\n\t * Use `recomputeInitiallyAndOnChange` for eager evaluation.\n\t */\n\tpublic keepObserved(store: DisposableStore): IObservable<T> {\n\t\tstore.add(_keepObserved!(this));\n\t\treturn this;\n\t}\n\n\tpublic abstract get debugName(): string;\n}\n\nexport abstract class BaseObservable<T, TChange = void> extends ConvenientObservable<T, TChange> {\n\tprotected readonly observers = new Set<IObserver>();\n\n\tpublic addObserver(observer: IObserver): void {\n\t\tconst len = this.observers.size;\n\t\tthis.observers.add(observer);\n\t\tif (len === 0) {\n\t\t\tthis.onFirstObserverAdded();\n\t\t}\n\t}\n\n\tpublic removeObserver(observer: IObserver): void {\n\t\tconst deleted = this.observers.delete(observer);\n\t\tif (deleted && this.observers.size === 0) {\n\t\t\tthis.onLastObserverRemoved();\n\t\t}\n\t}\n\n\tprotected onFirstObserverAdded(): void { }\n\tprotected onLastObserverRemoved(): void { }\n}\n\n/**\n * Starts a transaction in which many observables can be changed at once.\n * {@link fn} should start with a JS Doc using `@description` to give the transaction a debug name.\n * Reaction run on demand or when the transaction ends.\n */\n\nexport function transaction(fn: (tx: ITransaction) => void, getDebugName?: () => string): void {\n\tconst tx = new TransactionImpl(fn, getDebugName);\n\ttry {\n\t\tfn(tx);\n\t} finally {\n\t\ttx.finish();\n\t}\n}\n\nlet _globalTransaction: ITransaction | undefined = undefined;\n\nexport function globalTransaction(fn: (tx: ITransaction) => void) {\n\tif (_globalTransaction) {\n\t\tfn(_globalTransaction);\n\t} else {\n\t\tconst tx = new TransactionImpl(fn, undefined);\n\t\t_globalTransaction = tx;\n\t\ttry {\n\t\t\tfn(tx);\n\t\t} finally {\n\t\t\ttx.finish(); // During finish, more actions might be added to the transaction.\n\t\t\t// Which is why we only clear the global transaction after finish.\n\t\t\t_globalTransaction = undefined;\n\t\t}\n\t}\n}\n\nexport async function asyncTransaction(fn: (tx: ITransaction) => Promise<void>, getDebugName?: () => string): Promise<void> {\n\tconst tx = new TransactionImpl(fn, getDebugName);\n\ttry {\n\t\tawait fn(tx);\n\t} finally {\n\t\ttx.finish();\n\t}\n}\n\n/**\n * Allows to chain transactions.\n */\nexport function subtransaction(tx: ITransaction | undefined, fn: (tx: ITransaction) => void, getDebugName?: () => string): void {\n\tif (!tx) {\n\t\ttransaction(fn, getDebugName);\n\t} else {\n\t\tfn(tx);\n\t}\n}\n\nexport class TransactionImpl implements ITransaction {\n\tprivate updatingObservers: { observer: IObserver; observable: IObservable<any> }[] | null = [];\n\n\tconstructor(public readonly _fn: Function, private readonly _getDebugName?: () => string) {\n\t\tgetLogger()?.handleBeginTransaction(this);\n\t}\n\n\tpublic getDebugName(): string | undefined {\n\t\tif (this._getDebugName) {\n\t\t\treturn this._getDebugName();\n\t\t}\n\t\treturn getFunctionName(this._fn);\n\t}\n\n\tpublic updateObserver(observer: IObserver, observable: IObservable<any>): void {\n\t\t// When this gets called while finish is active, they will still get considered\n\t\tthis.updatingObservers!.push({ observer, observable });\n\t\tobserver.beginUpdate(observable);\n\t}\n\n\tpublic finish(): void {\n\t\tconst updatingObservers = this.updatingObservers!;\n\t\tfor (let i = 0; i < updatingObservers.length; i++) {\n\t\t\tconst { observer, observable } = updatingObservers[i];\n\t\t\tobserver.endUpdate(observable);\n\t\t}\n\t\t// Prevent anyone from updating observers from now on.\n\t\tthis.updatingObservers = null;\n\t\tgetLogger()?.handleEndTransaction();\n\t}\n}\n\n/**\n * A settable observable.\n */\nexport interface ISettableObservable<T, TChange = void> extends IObservable<T, TChange>, ISettable<T, TChange> {\n}\n\n/**\n * Creates an observable value.\n * Observers get informed when the value changes.\n * @template TChange An arbitrary type to describe how or why the value changed. Defaults to `void`.\n * Observers will receive every single change value.\n */\nexport function observableValue<T, TChange = void>(name: string, initialValue: T): ISettableObservable<T, TChange>;\nexport function observableValue<T, TChange = void>(owner: object, initialValue: T): ISettableObservable<T, TChange>;\nexport function observableValue<T, TChange = void>(nameOrOwner: string | object, initialValue: T): ISettableObservable<T, TChange> {\n\tif (typeof nameOrOwner === 'string') {\n\t\treturn new ObservableValue(undefined, nameOrOwner, initialValue);\n\t} else {\n\t\treturn new ObservableValue(nameOrOwner, undefined, initialValue);\n\t}\n}\n\nexport class ObservableValue<T, TChange = void>\n\textends BaseObservable<T, TChange>\n\timplements ISettableObservable<T, TChange> {\n\tprotected _value: T;\n\n\tget debugName() {\n\t\treturn new DebugNameData(this._owner, this._debugName, undefined).getDebugName(this) ?? 'ObservableValue';\n\t}\n\n\tconstructor(\n\t\tprivate readonly _owner: Owner,\n\t\tprivate readonly _debugName: string | undefined,\n\t\tinitialValue: T,\n\t) {\n\t\tsuper();\n\t\tthis._value = initialValue;\n\t}\n\tpublic override get(): T {\n\t\treturn this._value;\n\t}\n\n\tpublic set(value: T, tx: ITransaction | undefined, change: TChange): void {\n\t\tif (this._value === value) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet _tx: TransactionImpl | undefined;\n\t\tif (!tx) {\n\t\t\ttx = _tx = new TransactionImpl(() => { }, () => `Setting ${this.debugName}`);\n\t\t}\n\t\ttry {\n\t\t\tconst oldValue = this._value;\n\t\t\tthis._setValue(value);\n\t\t\tgetLogger()?.handleObservableChanged(this, { oldValue, newValue: value, change, didChange: true, hadValue: true });\n\n\t\t\tfor (const observer of this.observers) {\n\t\t\t\ttx.updateObserver(observer, this);\n\t\t\t\tobserver.handleChange(this, change);\n\t\t\t}\n\t\t} finally {\n\t\t\tif (_tx) {\n\t\t\t\t_tx.finish();\n\t\t\t}\n\t\t}\n\t}\n\n\toverride toString(): string {\n\t\treturn `${this.debugName}: ${this._value}`;\n\t}\n\n\tprotected _setValue(newValue: T): void {\n\t\tthis._value = newValue;\n\t}\n}\n\n/**\n * A disposable observable. When disposed, its value is also disposed.\n * When a new value is set, the previous value is disposed.\n */\nexport function disposableObservableValue<T extends IDisposable | undefined, TChange = void>(nameOrOwner: string | object, initialValue: T): ISettableObservable<T, TChange> & IDisposable {\n\tif (typeof nameOrOwner === 'string') {\n\t\treturn new DisposableObservableValue(undefined, nameOrOwner, initialValue);\n\t} else {\n\t\treturn new DisposableObservableValue(nameOrOwner, undefined, initialValue);\n\t}\n}\n\nexport class DisposableObservableValue<T extends IDisposable | undefined, TChange = void> extends ObservableValue<T, TChange> implements IDisposable {\n\tprotected override _setValue(newValue: T): void {\n\t\tif (this._value === newValue) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._value) {\n\t\t\tthis._value.dispose();\n\t\t}\n\t\tthis._value = newValue;\n\t}\n\n\tpublic dispose(): void {\n\t\tthis._value?.dispose();\n\t}\n}\n\nexport interface IChangeTracker {\n\t/**\n\t * Returns if this change should cause an invalidation.\n\t * Implementations can record changes.\n\t*/\n\thandleChange(context: IChangeContext): boolean;\n}\n\nexport interface IChangeContext {\n\treadonly changedObservable: IObservable<any, any>;\n\treadonly change: unknown;\n\n\t/**\n\t * Returns if the given observable caused the change.\n\t */\n\tdidChange<T, TChange>(observable: IObservable<T, TChange>): this is { change: TChange };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { assertFn } from 'vs/base/common/assert';\nimport { DisposableStore, IDisposable } from 'vs/base/common/lifecycle';\nimport { BaseObservable, IChangeContext, IObservable, IObserver, IReader, _setDerivedOpts } from 'vs/base/common/observableInternal/base';\nimport { DebugNameData, IDebugNameData, Owner } from 'vs/base/common/observableInternal/debugName';\nimport { getLogger } from 'vs/base/common/observableInternal/logging';\n\nexport type EqualityComparer<T> = (a: T, b: T) => boolean;\nexport const defaultEqualityComparer: EqualityComparer<any> = (a, b) => a === b;\n\n/**\n * Creates an observable that is derived from other observables.\n * The value is only recomputed when absolutely needed.\n *\n * {@link computeFn} should start with a JS Doc using `@description` to name the derived.\n */\nexport function derived<T>(computeFn: (reader: IReader) => T): IObservable<T>;\nexport function derived<T>(owner: object, computeFn: (reader: IReader) => T): IObservable<T>;\nexport function derived<T>(computeFnOrOwner: ((reader: IReader) => T) | object, computeFn?: ((reader: IReader) => T) | undefined): IObservable<T> {\n\tif (computeFn !== undefined) {\n\t\treturn new Derived(\n\t\t\tnew DebugNameData(computeFnOrOwner, undefined, computeFn),\n\t\t\tcomputeFn,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tdefaultEqualityComparer\n\t\t);\n\t}\n\treturn new Derived(\n\t\tnew DebugNameData(undefined, undefined, computeFnOrOwner as any),\n\t\tcomputeFnOrOwner as any,\n\t\tundefined,\n\t\tundefined,\n\t\tundefined,\n\t\tdefaultEqualityComparer\n\t);\n}\n\nexport function derivedOpts<T>(\n\toptions: IDebugNameData & {\n\t\tequalityComparer?: EqualityComparer<T>;\n\t\tonLastObserverRemoved?: (() => void);\n\t},\n\tcomputeFn: (reader: IReader) => T\n): IObservable<T> {\n\treturn new Derived(\n\t\tnew DebugNameData(options.owner, options.debugName, options.debugReferenceFn),\n\t\tcomputeFn,\n\t\tundefined,\n\t\tundefined,\n\t\toptions.onLastObserverRemoved,\n\t\toptions.equalityComparer ?? defaultEqualityComparer\n\t);\n}\n\n_setDerivedOpts(derivedOpts);\n\n/**\n * Represents an observable that is derived from other observables.\n * The value is only recomputed when absolutely needed.\n *\n * {@link computeFn} should start with a JS Doc using `@description` to name the derived.\n *\n * Use `createEmptyChangeSummary` to create a \"change summary\" that can collect the changes.\n * Use `handleChange` to add a reported change to the change summary.\n * The compute function is given the last change summary.\n * The change summary is discarded after the compute function was called.\n *\n * @see derived\n */\nexport function derivedHandleChanges<T, TChangeSummary>(\n\toptions: IDebugNameData & {\n\t\tcreateEmptyChangeSummary: () => TChangeSummary;\n\t\thandleChange: (context: IChangeContext, changeSummary: TChangeSummary) => boolean;\n\t\tequalityComparer?: EqualityComparer<T>;\n\t},\n\tcomputeFn: (reader: IReader, changeSummary: TChangeSummary) => T\n): IObservable<T> {\n\treturn new Derived(\n\t\tnew DebugNameData(options.owner, options.debugName, undefined),\n\t\tcomputeFn,\n\t\toptions.createEmptyChangeSummary,\n\t\toptions.handleChange,\n\t\tundefined,\n\t\toptions.equalityComparer ?? defaultEqualityComparer\n\t);\n}\n\nexport function derivedWithStore<T>(computeFn: (reader: IReader, store: DisposableStore) => T): IObservable<T>;\nexport function derivedWithStore<T>(owner: object, computeFn: (reader: IReader, store: DisposableStore) => T): IObservable<T>;\nexport function derivedWithStore<T>(computeFnOrOwner: ((reader: IReader, store: DisposableStore) => T) | object, computeFnOrUndefined?: ((reader: IReader, store: DisposableStore) => T)): IObservable<T> {\n\tlet computeFn: (reader: IReader, store: DisposableStore) => T;\n\tlet owner: Owner;\n\tif (computeFnOrUndefined === undefined) {\n\t\tcomputeFn = computeFnOrOwner as any;\n\t\towner = undefined;\n\t} else {\n\t\towner = computeFnOrOwner;\n\t\tcomputeFn = computeFnOrUndefined as any;\n\t}\n\n\tconst store = new DisposableStore();\n\treturn new Derived(\n\t\tnew DebugNameData(owner, undefined, computeFn),\n\t\tr => {\n\t\t\tstore.clear();\n\t\t\treturn computeFn(r, store);\n\t\t}, undefined,\n\t\tundefined,\n\t\t() => store.dispose(),\n\t\tdefaultEqualityComparer\n\t);\n}\n\nexport function derivedDisposable<T extends IDisposable | undefined>(computeFn: (reader: IReader) => T): IObservable<T>;\nexport function derivedDisposable<T extends IDisposable | undefined>(owner: Owner, computeFn: (reader: IReader) => T): IObservable<T>;\nexport function derivedDisposable<T extends IDisposable | undefined>(computeFnOrOwner: ((reader: IReader) => T) | Owner, computeFnOrUndefined?: ((reader: IReader) => T)): IObservable<T> {\n\tlet computeFn: (reader: IReader) => T;\n\tlet owner: Owner;\n\tif (computeFnOrUndefined === undefined) {\n\t\tcomputeFn = computeFnOrOwner as any;\n\t\towner = undefined;\n\t} else {\n\t\towner = computeFnOrOwner;\n\t\tcomputeFn = computeFnOrUndefined as any;\n\t}\n\n\tconst store = new DisposableStore();\n\treturn new Derived(\n\t\tnew DebugNameData(owner, undefined, computeFn),\n\t\tr => {\n\t\t\tstore.clear();\n\t\t\tconst result = computeFn(r);\n\t\t\tif (result) {\n\t\t\t\tstore.add(result);\n\t\t\t}\n\t\t\treturn result;\n\t\t}, undefined,\n\t\tundefined,\n\t\t() => store.dispose(),\n\t\tdefaultEqualityComparer\n\t);\n}\n\nconst enum DerivedState {\n\t/** Initial state, no previous value, recomputation needed */\n\tinitial = 0,\n\n\t/**\n\t * A dependency could have changed.\n\t * We need to explicitly ask them if at least one dependency changed.\n\t */\n\tdependenciesMightHaveChanged = 1,\n\n\t/**\n\t * A dependency changed and we need to recompute.\n\t * After recomputation, we need to check the previous value to see if we changed as well.\n\t */\n\tstale = 2,\n\n\t/**\n\t * No change reported, our cached value is up to date.\n\t */\n\tupToDate = 3,\n}\n\nexport class Derived<T, TChangeSummary = any> extends BaseObservable<T, void> implements IReader, IObserver {\n\tprivate state = DerivedState.initial;\n\tprivate value: T | undefined = undefined;\n\tprivate updateCount = 0;\n\tprivate dependencies = new Set<IObservable<any>>();\n\tprivate dependenciesToBeRemoved = new Set<IObservable<any>>();\n\tprivate changeSummary: TChangeSummary | undefined = undefined;\n\n\tpublic override get debugName(): string {\n\t\treturn this._debugNameData.getDebugName(this) ?? '(anonymous)';\n\t}\n\n\tconstructor(\n\t\tprivate readonly _debugNameData: DebugNameData,\n\t\tpublic readonly _computeFn: (reader: IReader, changeSummary: TChangeSummary) => T,\n\t\tprivate readonly createChangeSummary: (() => TChangeSummary) | undefined,\n\t\tprivate readonly _handleChange: ((context: IChangeContext, summary: TChangeSummary) => boolean) | undefined,\n\t\tprivate readonly _handleLastObserverRemoved: (() => void) | undefined = undefined,\n\t\tprivate readonly _equalityComparator: EqualityComparer<T>,\n\t) {\n\t\tsuper();\n\t\tthis.changeSummary = this.createChangeSummary?.();\n\t\tgetLogger()?.handleDerivedCreated(this);\n\t}\n\n\tprotected override onLastObserverRemoved(): void {\n\t\t/**\n\t\t * We are not tracking changes anymore, thus we have to assume\n\t\t * that our cache is invalid.\n\t\t */\n\t\tthis.state = DerivedState.initial;\n\t\tthis.value = undefined;\n\t\tfor (const d of this.dependencies) {\n\t\t\td.removeObserver(this);\n\t\t}\n\t\tthis.dependencies.clear();\n\n\t\tthis._handleLastObserverRemoved?.();\n\t}\n\n\tpublic override get(): T {\n\t\tif (this.observers.size === 0) {\n\t\t\t// Without observers, we don't know when to clean up stuff.\n\t\t\t// Thus, we don't cache anything to prevent memory leaks.\n\t\t\tconst result = this._computeFn(this, this.createChangeSummary?.()!);\n\t\t\t// Clear new dependencies\n\t\t\tthis.onLastObserverRemoved();\n\t\t\treturn result;\n\t\t} else {\n\t\t\tdo {\n\t\t\t\t// We might not get a notification for a dependency that changed while it is updating,\n\t\t\t\t// thus we also have to ask all our depedencies if they changed in this case.\n\t\t\t\tif (this.state === DerivedState.dependenciesMightHaveChanged) {\n\t\t\t\t\tfor (const d of this.dependencies) {\n\t\t\t\t\t\t/** might call {@link handleChange} indirectly, which could make us stale */\n\t\t\t\t\t\td.reportChanges();\n\n\t\t\t\t\t\tif (this.state as DerivedState === DerivedState.stale) {\n\t\t\t\t\t\t\t// The other dependencies will refresh on demand, so early break\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// We called report changes of all dependencies.\n\t\t\t\t// If we are still not stale, we can assume to be up to date again.\n\t\t\t\tif (this.state === DerivedState.dependenciesMightHaveChanged) {\n\t\t\t\t\tthis.state = DerivedState.upToDate;\n\t\t\t\t}\n\n\t\t\t\tthis._recomputeIfNeeded();\n\t\t\t\t// In case recomputation changed one of our dependencies, we need to recompute again.\n\t\t\t} while (this.state !== DerivedState.upToDate);\n\t\t\treturn this.value!;\n\t\t}\n\t}\n\n\tprivate _recomputeIfNeeded() {\n\t\tif (this.state === DerivedState.upToDate) {\n\t\t\treturn;\n\t\t}\n\t\tconst emptySet = this.dependenciesToBeRemoved;\n\t\tthis.dependenciesToBeRemoved = this.dependencies;\n\t\tthis.dependencies = emptySet;\n\n\t\tconst hadValue = this.state !== DerivedState.initial;\n\t\tconst oldValue = this.value;\n\t\tthis.state = DerivedState.upToDate;\n\n\t\tconst changeSummary = this.changeSummary!;\n\t\tthis.changeSummary = this.createChangeSummary?.();\n\t\ttry {\n\t\t\t/** might call {@link handleChange} indirectly, which could invalidate us */\n\t\t\tthis.value = this._computeFn(this, changeSummary);\n\t\t} finally {\n\t\t\t// We don't want our observed observables to think that they are (not even temporarily) not being observed.\n\t\t\t// Thus, we only unsubscribe from observables that are definitely not read anymore.\n\t\t\tfor (const o of this.dependenciesToBeRemoved) {\n\t\t\t\to.removeObserver(this);\n\t\t\t}\n\t\t\tthis.dependenciesToBeRemoved.clear();\n\t\t}\n\n\t\tconst didChange = hadValue && !(this._equalityComparator(oldValue!, this.value));\n\n\t\tgetLogger()?.handleDerivedRecomputed(this, {\n\t\t\toldValue,\n\t\t\tnewValue: this.value,\n\t\t\tchange: undefined,\n\t\t\tdidChange,\n\t\t\thadValue,\n\t\t});\n\n\t\tif (didChange) {\n\t\t\tfor (const r of this.observers) {\n\t\t\t\tr.handleChange(this, undefined);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic override toString(): string {\n\t\treturn `LazyDerived<${this.debugName}>`;\n\t}\n\n\t// IObserver Implementation\n\tpublic beginUpdate<T>(_observable: IObservable<T>): void {\n\t\tthis.updateCount++;\n\t\tconst propagateBeginUpdate = this.updateCount === 1;\n\t\tif (this.state === DerivedState.upToDate) {\n\t\t\tthis.state = DerivedState.dependenciesMightHaveChanged;\n\t\t\t// If we propagate begin update, that will already signal a possible change.\n\t\t\tif (!propagateBeginUpdate) {\n\t\t\t\tfor (const r of this.observers) {\n\t\t\t\t\tr.handlePossibleChange(this);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (propagateBeginUpdate) {\n\t\t\tfor (const r of this.observers) {\n\t\t\t\tr.beginUpdate(this); // This signals a possible change\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic endUpdate<T>(_observable: IObservable<T>): void {\n\t\tthis.updateCount--;\n\t\tif (this.updateCount === 0) {\n\t\t\t// End update could change the observer list.\n\t\t\tconst observers = [...this.observers];\n\t\t\tfor (const r of observers) {\n\t\t\t\tr.endUpdate(this);\n\t\t\t}\n\t\t}\n\t\tassertFn(() => this.updateCount >= 0);\n\t}\n\n\tpublic handlePossibleChange<T>(observable: IObservable<T, unknown>): void {\n\t\t// In all other states, observers already know that we might have changed.\n\t\tif (this.state === DerivedState.upToDate && this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n\t\t\tthis.state = DerivedState.dependenciesMightHaveChanged;\n\t\t\tfor (const r of this.observers) {\n\t\t\t\tr.handlePossibleChange(this);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic handleChange<T, TChange>(observable: IObservable<T, TChange>, change: TChange): void {\n\t\tif (this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n\t\t\tconst shouldReact = this._handleChange ? this._handleChange({\n\t\t\t\tchangedObservable: observable,\n\t\t\t\tchange,\n\t\t\t\tdidChange: o => o === observable as any,\n\t\t\t}, this.changeSummary!) : true;\n\t\t\tconst wasUpToDate = this.state === DerivedState.upToDate;\n\t\t\tif (shouldReact && (this.state === DerivedState.dependenciesMightHaveChanged || wasUpToDate)) {\n\t\t\t\tthis.state = DerivedState.stale;\n\t\t\t\tif (wasUpToDate) {\n\t\t\t\t\tfor (const r of this.observers) {\n\t\t\t\t\t\tr.handlePossibleChange(this);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// IReader Implementation\n\tpublic readObservable<T>(observable: IObservable<T>): T {\n\t\t// Subscribe before getting the value to enable caching\n\t\tobservable.addObserver(this);\n\t\t/** This might call {@link handleChange} indirectly, which could invalidate us */\n\t\tconst value = observable.get();\n\t\t// Which is why we only add the observable to the dependencies now.\n\t\tthis.dependencies.add(observable);\n\t\tthis.dependenciesToBeRemoved.delete(observable);\n\t\treturn value;\n\t}\n\n\tpublic override addObserver(observer: IObserver): void {\n\t\tconst shouldCallBeginUpdate = !this.observers.has(observer) && this.updateCount > 0;\n\t\tsuper.addObserver(observer);\n\n\t\tif (shouldCallBeginUpdate) {\n\t\t\tobserver.beginUpdate(this);\n\t\t}\n\t}\n\n\tpublic override removeObserver(observer: IObserver): void {\n\t\tconst shouldCallEndUpdate = this.observers.has(observer) && this.updateCount > 0;\n\t\tsuper.removeObserver(observer);\n\n\t\tif (shouldCallEndUpdate) {\n\t\t\t// Calling end update after removing the observer makes sure endUpdate cannot be called twice here.\n\t\t\tobserver.endUpdate(this);\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from 'vs/base/common/event';\nimport { DisposableStore, IDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { autorun } from 'vs/base/common/observableInternal/autorun';\nimport { BaseObservable, ConvenientObservable, IObservable, IObserver, IReader, ITransaction, _setKeepObserved, _setRecomputeInitiallyAndOnChange, observableValue, subtransaction, transaction } from 'vs/base/common/observableInternal/base';\nimport { DebugNameData, Owner, getFunctionName } from 'vs/base/common/observableInternal/debugName';\nimport { derived, derivedOpts } from 'vs/base/common/observableInternal/derived';\nimport { getLogger } from 'vs/base/common/observableInternal/logging';\n\n/**\n * Represents an efficient observable whose value never changes.\n */\nexport function constObservable<T>(value: T): IObservable<T> {\n\treturn new ConstObservable(value);\n}\n\nclass ConstObservable<T> extends ConvenientObservable<T, void> {\n\tconstructor(private readonly value: T) {\n\t\tsuper();\n\t}\n\n\tpublic override get debugName(): string {\n\t\treturn this.toString();\n\t}\n\n\tpublic get(): T {\n\t\treturn this.value;\n\t}\n\tpublic addObserver(observer: IObserver): void {\n\t\t// NO OP\n\t}\n\tpublic removeObserver(observer: IObserver): void {\n\t\t// NO OP\n\t}\n\n\toverride toString(): string {\n\t\treturn `Const: ${this.value}`;\n\t}\n}\n\n\nexport function observableFromPromise<T>(promise: Promise<T>): IObservable<{ value?: T }> {\n\tconst observable = observableValue<{ value?: T }>('promiseValue', {});\n\tpromise.then((value) => {\n\t\tobservable.set({ value }, undefined);\n\t});\n\treturn observable;\n}\n\nexport function observableFromEvent<T, TArgs = unknown>(\n\tevent: Event<TArgs>,\n\tgetValue: (args: TArgs | undefined) => T\n): IObservable<T> {\n\treturn new FromEventObservable(event, getValue);\n}\n\nexport class FromEventObservable<TArgs, T> extends BaseObservable<T> {\n\tpublic static globalTransaction: ITransaction | undefined;\n\n\tprivate value: T | undefined;\n\tprivate hasValue = false;\n\tprivate subscription: IDisposable | undefined;\n\n\tconstructor(\n\t\tprivate readonly event: Event<TArgs>,\n\t\tpublic readonly _getValue: (args: TArgs | undefined) => T\n\t) {\n\t\tsuper();\n\t}\n\n\tprivate getDebugName(): string | undefined {\n\t\treturn getFunctionName(this._getValue);\n\t}\n\n\tpublic get debugName(): string {\n\t\tconst name = this.getDebugName();\n\t\treturn 'From Event' + (name ? `: ${name}` : '');\n\t}\n\n\tprotected override onFirstObserverAdded(): void {\n\t\tthis.subscription = this.event(this.handleEvent);\n\t}\n\n\tprivate readonly handleEvent = (args: TArgs | undefined) => {\n\t\tconst newValue = this._getValue(args);\n\t\tconst oldValue = this.value;\n\n\t\tconst didChange = !this.hasValue || oldValue !== newValue;\n\t\tlet didRunTransaction = false;\n\n\t\tif (didChange) {\n\t\t\tthis.value = newValue;\n\n\t\t\tif (this.hasValue) {\n\t\t\t\tdidRunTransaction = true;\n\t\t\t\tsubtransaction(\n\t\t\t\t\tFromEventObservable.globalTransaction,\n\t\t\t\t\t(tx) => {\n\t\t\t\t\t\tgetLogger()?.handleFromEventObservableTriggered(this, { oldValue, newValue, change: undefined, didChange, hadValue: this.hasValue });\n\n\t\t\t\t\t\tfor (const o of this.observers) {\n\t\t\t\t\t\t\ttx.updateObserver(o, this);\n\t\t\t\t\t\t\to.handleChange(this, undefined);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t() => {\n\t\t\t\t\t\tconst name = this.getDebugName();\n\t\t\t\t\t\treturn 'Event fired' + (name ? `: ${name}` : '');\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t\tthis.hasValue = true;\n\t\t}\n\n\t\tif (!didRunTransaction) {\n\t\t\tgetLogger()?.handleFromEventObservableTriggered(this, { oldValue, newValue, change: undefined, didChange, hadValue: this.hasValue });\n\t\t}\n\t};\n\n\tprotected override onLastObserverRemoved(): void {\n\t\tthis.subscription!.dispose();\n\t\tthis.subscription = undefined;\n\t\tthis.hasValue = false;\n\t\tthis.value = undefined;\n\t}\n\n\tpublic get(): T {\n\t\tif (this.subscription) {\n\t\t\tif (!this.hasValue) {\n\t\t\t\tthis.handleEvent(undefined);\n\t\t\t}\n\t\t\treturn this.value!;\n\t\t} else {\n\t\t\t// no cache, as there are no subscribers to keep it updated\n\t\t\treturn this._getValue(undefined);\n\t\t}\n\t}\n}\n\nexport namespace observableFromEvent {\n\texport const Observer = FromEventObservable;\n\n\texport function batchEventsGlobally(tx: ITransaction, fn: () => void): void {\n\t\tlet didSet = false;\n\t\tif (FromEventObservable.globalTransaction === undefined) {\n\t\t\tFromEventObservable.globalTransaction = tx;\n\t\t\tdidSet = true;\n\t\t}\n\t\ttry {\n\t\t\tfn();\n\t\t} finally {\n\t\t\tif (didSet) {\n\t\t\t\tFromEventObservable.globalTransaction = undefined;\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport function observableSignalFromEvent(\n\tdebugName: string,\n\tevent: Event<any>\n): IObservable<void> {\n\treturn new FromEventObservableSignal(debugName, event);\n}\n\nclass FromEventObservableSignal extends BaseObservable<void> {\n\tprivate subscription: IDisposable | undefined;\n\n\tconstructor(\n\t\tpublic readonly debugName: string,\n\t\tprivate readonly event: Event<any>,\n\t) {\n\t\tsuper();\n\t}\n\n\tprotected override onFirstObserverAdded(): void {\n\t\tthis.subscription = this.event(this.handleEvent);\n\t}\n\n\tprivate readonly handleEvent = () => {\n\t\ttransaction(\n\t\t\t(tx) => {\n\t\t\t\tfor (const o of this.observers) {\n\t\t\t\t\ttx.updateObserver(o, this);\n\t\t\t\t\to.handleChange(this, undefined);\n\t\t\t\t}\n\t\t\t},\n\t\t\t() => this.debugName\n\t\t);\n\t};\n\n\tprotected override onLastObserverRemoved(): void {\n\t\tthis.subscription!.dispose();\n\t\tthis.subscription = undefined;\n\t}\n\n\tpublic override get(): void {\n\t\t// NO OP\n\t}\n}\n\n/**\n * Creates a signal that can be triggered to invalidate observers.\n * Signals don't have a value - when they are triggered they indicate a change.\n * However, signals can carry a delta that is passed to observers.\n */\nexport function observableSignal<TDelta = void>(debugName: string): IObservableSignal<TDelta>;\nexport function observableSignal<TDelta = void>(owner: object): IObservableSignal<TDelta>;\nexport function observableSignal<TDelta = void>(debugNameOrOwner: string | object): IObservableSignal<TDelta> {\n\tif (typeof debugNameOrOwner === 'string') {\n\t\treturn new ObservableSignal<TDelta>(debugNameOrOwner);\n\t} else {\n\t\treturn new ObservableSignal<TDelta>(undefined, debugNameOrOwner);\n\t}\n}\n\nexport interface IObservableSignal<TChange> extends IObservable<void, TChange> {\n\ttrigger(tx: ITransaction | undefined, change: TChange): void;\n}\n\nclass ObservableSignal<TChange> extends BaseObservable<void, TChange> implements IObservableSignal<TChange> {\n\tpublic get debugName() {\n\t\treturn new DebugNameData(this._owner, this._debugName, undefined).getDebugName(this) ?? 'Observable Signal';\n\t}\n\n\tconstructor(\n\t\tprivate readonly _debugName: string | undefined,\n\t\tprivate readonly _owner?: object,\n\t) {\n\t\tsuper();\n\t}\n\n\tpublic trigger(tx: ITransaction | undefined, change: TChange): void {\n\t\tif (!tx) {\n\t\t\ttransaction(tx => {\n\t\t\t\tthis.trigger(tx, change);\n\t\t\t}, () => `Trigger signal ${this.debugName}`);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const o of this.observers) {\n\t\t\ttx.updateObserver(o, this);\n\t\t\to.handleChange(this, change);\n\t\t}\n\t}\n\n\tpublic override get(): void {\n\t\t// NO OP\n\t}\n}\n\n/**\n * @deprecated Use `debouncedObservable2` instead.\n */\nexport function debouncedObservable<T>(observable: IObservable<T>, debounceMs: number, disposableStore: DisposableStore): IObservable<T | undefined> {\n\tconst debouncedObservable = observableValue<T | undefined>('debounced', undefined);\n\n\tlet timeout: any = undefined;\n\n\tdisposableStore.add(autorun(reader => {\n\t\t/** @description debounce */\n\t\tconst value = observable.read(reader);\n\n\t\tif (timeout) {\n\t\t\tclearTimeout(timeout);\n\t\t}\n\t\ttimeout = setTimeout(() => {\n\t\t\ttransaction(tx => {\n\t\t\t\tdebouncedObservable.set(value, tx);\n\t\t\t});\n\t\t}, debounceMs);\n\n\t}));\n\n\treturn debouncedObservable;\n}\n\n/**\n * Creates an observable that debounces the input observable.\n */\nexport function debouncedObservable2<T>(observable: IObservable<T>, debounceMs: number): IObservable<T> {\n\tlet hasValue = false;\n\tlet lastValue: T | undefined;\n\n\tlet timeout: any = undefined;\n\n\treturn observableFromEvent<T, void>(cb => {\n\t\tconst d = autorun(reader => {\n\t\t\tconst value = observable.read(reader);\n\n\t\t\tif (!hasValue) {\n\t\t\t\thasValue = true;\n\t\t\t\tlastValue = value;\n\t\t\t} else {\n\t\t\t\tif (timeout) {\n\t\t\t\t\tclearTimeout(timeout);\n\t\t\t\t}\n\t\t\t\ttimeout = setTimeout(() => {\n\t\t\t\t\tlastValue = value;\n\t\t\t\t\tcb();\n\t\t\t\t}, debounceMs);\n\t\t\t}\n\t\t});\n\t\treturn {\n\t\t\tdispose() {\n\t\t\t\td.dispose();\n\t\t\t\thasValue = false;\n\t\t\t\tlastValue = undefined;\n\t\t\t},\n\t\t};\n\t}, () => {\n\t\tif (hasValue) {\n\t\t\treturn lastValue!;\n\t\t} else {\n\t\t\treturn observable.get();\n\t\t}\n\t});\n}\n\nexport function wasEventTriggeredRecently(event: Event<any>, timeoutMs: number, disposableStore: DisposableStore): IObservable<boolean> {\n\tconst observable = observableValue('triggeredRecently', false);\n\n\tlet timeout: any = undefined;\n\n\tdisposableStore.add(event(() => {\n\t\tobservable.set(true, undefined);\n\n\t\tif (timeout) {\n\t\t\tclearTimeout(timeout);\n\t\t}\n\t\ttimeout = setTimeout(() => {\n\t\t\tobservable.set(false, undefined);\n\t\t}, timeoutMs);\n\t}));\n\n\treturn observable;\n}\n\n/**\n * This makes sure the observable is being observed and keeps its cache alive.\n */\nexport function keepObserved<T>(observable: IObservable<T>): IDisposable {\n\tconst o = new KeepAliveObserver(false, undefined);\n\tobservable.addObserver(o);\n\treturn toDisposable(() => {\n\t\tobservable.removeObserver(o);\n\t});\n}\n\n_setKeepObserved(keepObserved);\n\n/**\n * This converts the given observable into an autorun.\n */\nexport function recomputeInitiallyAndOnChange<T>(observable: IObservable<T>, handleValue?: (value: T) => void): IDisposable {\n\tconst o = new KeepAliveObserver(true, handleValue);\n\tobservable.addObserver(o);\n\tif (handleValue) {\n\t\thandleValue(observable.get());\n\t} else {\n\t\tobservable.reportChanges();\n\t}\n\n\treturn toDisposable(() => {\n\t\tobservable.removeObserver(o);\n\t});\n}\n\n_setRecomputeInitiallyAndOnChange(recomputeInitiallyAndOnChange);\n\nexport class KeepAliveObserver implements IObserver {\n\tprivate _counter = 0;\n\n\tconstructor(\n\t\tprivate readonly _forceRecompute: boolean,\n\t\tprivate readonly _handleValue: ((value: any) => void) | undefined,\n\t) { }\n\n\tbeginUpdate<T>(observable: IObservable<T, void>): void {\n\t\tthis._counter++;\n\t}\n\n\tendUpdate<T>(observable: IObservable<T, void>): void {\n\t\tthis._counter--;\n\t\tif (this._counter === 0 && this._forceRecompute) {\n\t\t\tif (this._handleValue) {\n\t\t\t\tthis._handleValue(observable.get());\n\t\t\t} else {\n\t\t\t\tobservable.reportChanges();\n\t\t\t}\n\t\t}\n\t}\n\n\thandlePossibleChange<T>(observable: IObservable<T, unknown>): void {\n\t\t// NO OP\n\t}\n\n\thandleChange<T, TChange>(observable: IObservable<T, TChange>, change: TChange): void {\n\t\t// NO OP\n\t}\n}\n\nexport function derivedObservableWithCache<T>(computeFn: (reader: IReader, lastValue: T | undefined) => T): IObservable<T> {\n\tlet lastValue: T | undefined = undefined;\n\tconst observable = derived(reader => {\n\t\tlastValue = computeFn(reader, lastValue);\n\t\treturn lastValue;\n\t});\n\treturn observable;\n}\n\nexport function derivedObservableWithWritableCache<T>(owner: object, computeFn: (reader: IReader, lastValue: T | undefined) => T): IObservable<T> & { clearCache(transaction: ITransaction): void } {\n\tlet lastValue: T | undefined = undefined;\n\tconst counter = observableValue('derivedObservableWithWritableCache.counter', 0);\n\tconst observable = derived(owner, reader => {\n\t\tcounter.read(reader);\n\t\tlastValue = computeFn(reader, lastValue);\n\t\treturn lastValue;\n\t});\n\treturn Object.assign(observable, {\n\t\tclearCache: (transaction: ITransaction) => {\n\t\t\tlastValue = undefined;\n\t\t\tcounter.set(counter.get() + 1, transaction);\n\t\t},\n\t});\n}\n\n/**\n * When the items array changes, referential equal items are not mapped again.\n */\nexport function mapObservableArrayCached<TIn, TOut, TKey = TIn>(owner: Owner, items: IObservable<readonly TIn[]>, map: (input: TIn, store: DisposableStore) => TOut, keySelector?: (input: TIn) => TKey): IObservable<readonly TOut[]> {\n\tlet m = new ArrayMap(map, keySelector);\n\tconst self = derivedOpts({\n\t\tdebugReferenceFn: map,\n\t\towner,\n\t\tonLastObserverRemoved: () => {\n\t\t\tm.dispose();\n\t\t\tm = new ArrayMap(map);\n\t\t}\n\t}, (reader) => {\n\t\tm.setItems(items.read(reader));\n\t\treturn m.getItems();\n\t});\n\treturn self;\n}\n\nclass ArrayMap<TIn, TOut, TKey> implements IDisposable {\n\tprivate readonly _cache = new Map<TKey, { out: TOut; store: DisposableStore }>();\n\tprivate _items: TOut[] = [];\n\tconstructor(\n\t\tprivate readonly _map: (input: TIn, store: DisposableStore) => TOut,\n\t\tprivate readonly _keySelector?: (input: TIn) => TKey,\n\t) {\n\t}\n\n\tpublic dispose(): void {\n\t\tthis._cache.forEach(entry => entry.store.dispose());\n\t\tthis._cache.clear();\n\t}\n\n\tpublic setItems(items: readonly TIn[]): void {\n\t\tconst newItems: TOut[] = [];\n\t\tconst itemsToRemove = new Set(this._cache.keys());\n\n\t\tfor (const item of items) {\n\t\t\tconst key = this._keySelector ? this._keySelector(item) : item as unknown as TKey;\n\n\t\t\tlet entry = this._cache.get(key);\n\t\t\tif (!entry) {\n\t\t\t\tconst store = new DisposableStore();\n\t\t\t\tconst out = this._map(item, store);\n\t\t\t\tentry = { out, store };\n\t\t\t\tthis._cache.set(key, entry);\n\t\t\t} else {\n\t\t\t\titemsToRemove.delete(key);\n\t\t\t}\n\t\t\tnewItems.push(entry.out);\n\t\t}\n\n\t\tfor (const item of itemsToRemove) {\n\t\t\tconst entry = this._cache.get(item)!;\n\t\t\tentry.store.dispose();\n\t\t\tthis._cache.delete(item);\n\t\t}\n\n\t\tthis._items = newItems;\n\t}\n\n\tpublic getItems(): TOut[] {\n\t\treturn this._items;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { autorun } from 'vs/base/common/observableInternal/autorun';\nimport { IObservable, IReader, observableValue, transaction } from './base';\nimport { Derived, defaultEqualityComparer, derived } from 'vs/base/common/observableInternal/derived';\nimport { CancellationToken, CancellationTokenSource } from 'vs/base/common/cancellation';\nimport { DebugNameData, Owner } from 'vs/base/common/observableInternal/debugName';\n\nexport class ObservableLazy<T> {\n\tprivate readonly _value = observableValue<T | undefined>(this, undefined);\n\n\t/**\n\t * The cached value.\n\t * Does not force a computation of the value.\n\t */\n\tpublic get cachedValue(): IObservable<T | undefined> { return this._value; }\n\n\tconstructor(private readonly _computeValue: () => T) {\n\t}\n\n\t/**\n\t * Returns the cached value.\n\t * Computes the value if the value has not been cached yet.\n\t */\n\tpublic getValue() {\n\t\tlet v = this._value.get();\n\t\tif (!v) {\n\t\t\tv = this._computeValue();\n\t\t\tthis._value.set(v, undefined);\n\t\t}\n\t\treturn v;\n\t}\n}\n\n/**\n * A promise whose state is observable.\n */\nexport class ObservablePromise<T> {\n\tprivate readonly _value = observableValue<PromiseResult<T> | undefined>(this, undefined);\n\n\t/**\n\t * The promise that this object wraps.\n\t */\n\tpublic readonly promise: Promise<T>;\n\n\t/**\n\t * The current state of the promise.\n\t * Is `undefined` if the promise didn't resolve yet.\n\t */\n\tpublic readonly promiseResult: IObservable<PromiseResult<T> | undefined> = this._value;\n\n\tconstructor(promise: Promise<T>) {\n\t\tthis.promise = promise.then(value => {\n\t\t\ttransaction(tx => {\n\t\t\t\t/** @description onPromiseResolved */\n\t\t\t\tthis._value.set(new PromiseResult(value, undefined), tx);\n\t\t\t});\n\t\t\treturn value;\n\t\t}, error => {\n\t\t\ttransaction(tx => {\n\t\t\t\t/** @description onPromiseRejected */\n\t\t\t\tthis._value.set(new PromiseResult<T>(undefined, error), tx);\n\t\t\t});\n\t\t\tthrow error;\n\t\t});\n\t}\n}\n\nexport class PromiseResult<T> {\n\tconstructor(\n\t\t/**\n\t\t * The value of the resolved promise.\n\t\t * Undefined if the promise rejected.\n\t\t */\n\t\tpublic readonly data: T | undefined,\n\n\t\t/**\n\t\t * The error in case of a rejected promise.\n\t\t * Undefined if the promise resolved.\n\t\t */\n\t\tpublic readonly error: unknown | undefined,\n\t) {\n\t}\n\n\t/**\n\t * Returns the value if the promise resolved, otherwise throws the error.\n\t */\n\tpublic getDataOrThrow(): T {\n\t\tif (this.error) {\n\t\t\tthrow this.error;\n\t\t}\n\t\treturn this.data!;\n\t}\n}\n\n/**\n * A lazy promise whose state is observable.\n */\nexport class ObservableLazyPromise<T> {\n\tprivate readonly _lazyValue = new ObservableLazy(() => new ObservablePromise(this._computePromise()));\n\n\t/**\n\t * Does not enforce evaluation of the promise compute function.\n\t * Is undefined if the promise has not been computed yet.\n\t */\n\tpublic readonly cachedPromiseResult = derived(this, reader => this._lazyValue.cachedValue.read(reader)?.promiseResult.read(reader));\n\n\tconstructor(private readonly _computePromise: () => Promise<T>) {\n\t}\n\n\tpublic getPromise(): Promise<T> {\n\t\treturn this._lazyValue.getValue().promise;\n\t}\n}\n\n/**\n * Resolves the promise when the observables state matches the predicate.\n */\nexport function waitForState<T, TState extends T>(observable: IObservable<T>, predicate: (state: T) => state is TState, isError?: (state: T) => boolean | unknown | undefined): Promise<TState>;\nexport function waitForState<T>(observable: IObservable<T>, predicate: (state: T) => boolean, isError?: (state: T) => boolean | unknown | undefined): Promise<T>;\nexport function waitForState<T>(observable: IObservable<T>, predicate: (state: T) => boolean, isError?: (state: T) => boolean | unknown | undefined): Promise<T> {\n\treturn new Promise((resolve, reject) => {\n\t\tlet isImmediateRun = true;\n\t\tlet shouldDispose = false;\n\t\tconst stateObs = observable.map(state => {\n\t\t\t/** @description waitForState.state */\n\t\t\treturn {\n\t\t\t\tisFinished: predicate(state),\n\t\t\t\terror: isError ? isError(state) : false,\n\t\t\t\tstate\n\t\t\t};\n\t\t});\n\t\tconst d = autorun(reader => {\n\t\t\t/** @description waitForState */\n\t\t\tconst { isFinished, error, state } = stateObs.read(reader);\n\t\t\tif (isFinished || error) {\n\t\t\t\tif (isImmediateRun) {\n\t\t\t\t\t// The variable `d` is not initialized yet\n\t\t\t\t\tshouldDispose = true;\n\t\t\t\t} else {\n\t\t\t\t\td.dispose();\n\t\t\t\t}\n\t\t\t\tif (error) {\n\t\t\t\t\treject(error === true ? state : error);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(state);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tisImmediateRun = false;\n\t\tif (shouldDispose) {\n\t\t\td.dispose();\n\t\t}\n\t});\n}\n\nexport function derivedWithCancellationToken<T>(computeFn: (reader: IReader, cancellationToken: CancellationToken) => T): IObservable<T>;\nexport function derivedWithCancellationToken<T>(owner: object, computeFn: (reader: IReader, cancellationToken: CancellationToken) => T): IObservable<T>;\nexport function derivedWithCancellationToken<T>(computeFnOrOwner: ((reader: IReader, cancellationToken: CancellationToken) => T) | object, computeFnOrUndefined?: ((reader: IReader, cancellationToken: CancellationToken) => T)): IObservable<T> {\n\tlet computeFn: (reader: IReader, store: CancellationToken) => T;\n\tlet owner: Owner;\n\tif (computeFnOrUndefined === undefined) {\n\t\tcomputeFn = computeFnOrOwner as any;\n\t\towner = undefined;\n\t} else {\n\t\towner = computeFnOrOwner;\n\t\tcomputeFn = computeFnOrUndefined as any;\n\t}\n\n\tlet cancellationTokenSource: CancellationTokenSource | undefined = undefined;\n\treturn new Derived(\n\t\tnew DebugNameData(owner, undefined, computeFn),\n\t\tr => {\n\t\t\tif (cancellationTokenSource) {\n\t\t\t\tcancellationTokenSource.dispose(true);\n\t\t\t}\n\t\t\tcancellationTokenSource = new CancellationTokenSource();\n\t\t\treturn computeFn(r, cancellationTokenSource.token);\n\t\t}, undefined,\n\t\tundefined,\n\t\t() => cancellationTokenSource?.dispose(),\n\t\tdefaultEqualityComparer,\n\t);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n// This is a facade for the observable implementation. Only import from here!\n\nexport {\n\tIObservable,\n\tIObserver,\n\tIReader,\n\tISettable,\n\tISettableObservable,\n\tITransaction,\n\tIChangeContext,\n\tIChangeTracker,\n\tobservableValue,\n\tdisposableObservableValue,\n\ttransaction,\n\tsubtransaction,\n} from 'vs/base/common/observableInternal/base';\nexport {\n\tderived,\n\tderivedOpts,\n\tderivedHandleChanges,\n\tderivedWithStore,\n} from 'vs/base/common/observableInternal/derived';\nexport {\n\tautorun,\n\tautorunDelta,\n\tautorunHandleChanges,\n\tautorunWithStore,\n\tautorunOpts,\n\tautorunWithStoreHandleChanges,\n} from 'vs/base/common/observableInternal/autorun';\nexport {\n\tIObservableSignal,\n\tconstObservable,\n\tdebouncedObservable,\n\tderivedObservableWithCache,\n\tderivedObservableWithWritableCache,\n\tkeepObserved,\n\trecomputeInitiallyAndOnChange,\n\tobservableFromEvent,\n\tobservableFromPromise,\n\tobservableSignal,\n\tobservableSignalFromEvent,\n\twasEventTriggeredRecently,\n} from 'vs/base/common/observableInternal/utils';\nexport {\n\tObservableLazy,\n\tObservableLazyPromise,\n\tObservablePromise,\n\tPromiseResult,\n\twaitForState,\n\tderivedWithCancellationToken,\n} from 'vs/base/common/observableInternal/promise';\n\nimport { ConsoleObservableLogger, setLogger } from 'vs/base/common/observableInternal/logging';\n\n// Remove \"//\" in the next line to enable logging\nconst enableLogging = false\n\t// || Boolean(\"true\") // done \"weirdly\" so that a lint warning prevents you from pushing this\n\t;\n\nif (enableLogging) {\n\tsetLogger(new ConsoleObservableLogger());\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { onUnexpectedError } from 'vs/base/common/errors';\nimport { DisposableStore, toDisposable } from 'vs/base/common/lifecycle';\n\n/**\n * The payload that flows in readable stream events.\n */\nexport type ReadableStreamEventPayload<T> = T | Error | 'end';\n\nexport interface ReadableStreamEvents<T> {\n\n\t/**\n\t * The 'data' event is emitted whenever the stream is\n\t * relinquishing ownership of a chunk of data to a consumer.\n\t *\n\t * NOTE: PLEASE UNDERSTAND THAT ADDING A DATA LISTENER CAN\n\t * TURN THE STREAM INTO FLOWING MODE. IT IS THEREFOR THE\n\t * LAST LISTENER THAT SHOULD BE ADDED AND NOT THE FIRST\n\t *\n\t * Use `listenStream` as a helper method to listen to\n\t * stream events in the right order.\n\t */\n\ton(event: 'data', callback: (data: T) => void): void;\n\n\t/**\n\t * Emitted when any error occurs.\n\t */\n\ton(event: 'error', callback: (err: Error) => void): void;\n\n\t/**\n\t * The 'end' event is emitted when there is no more data\n\t * to be consumed from the stream. The 'end' event will\n\t * not be emitted unless the data is completely consumed.\n\t */\n\ton(event: 'end', callback: () => void): void;\n}\n\n/**\n * A interface that emulates the API shape of a node.js readable\n * stream for use in native and web environments.\n */\nexport interface ReadableStream<T> extends ReadableStreamEvents<T> {\n\n\t/**\n\t * Stops emitting any events until resume() is called.\n\t */\n\tpause(): void;\n\n\t/**\n\t * Starts emitting events again after pause() was called.\n\t */\n\tresume(): void;\n\n\t/**\n\t * Destroys the stream and stops emitting any event.\n\t */\n\tdestroy(): void;\n\n\t/**\n\t * Allows to remove a listener that was previously added.\n\t */\n\tremoveListener(event: string, callback: Function): void;\n}\n\n/**\n * A interface that emulates the API shape of a node.js readable\n * for use in native and web environments.\n */\nexport interface Readable<T> {\n\n\t/**\n\t * Read data from the underlying source. Will return\n\t * null to indicate that no more data can be read.\n\t */\n\tread(): T | null;\n}\n\nexport function isReadable<T>(obj: unknown): obj is Readable<T> {\n\tconst candidate = obj as Readable<T> | undefined;\n\tif (!candidate) {\n\t\treturn false;\n\t}\n\n\treturn typeof candidate.read === 'function';\n}\n\n/**\n * A interface that emulates the API shape of a node.js writeable\n * stream for use in native and web environments.\n */\nexport interface WriteableStream<T> extends ReadableStream<T> {\n\n\t/**\n\t * Writing data to the stream will trigger the on('data')\n\t * event listener if the stream is flowing and buffer the\n\t * data otherwise until the stream is flowing.\n\t *\n\t * If a `highWaterMark` is configured and writing to the\n\t * stream reaches this mark, a promise will be returned\n\t * that should be awaited on before writing more data.\n\t * Otherwise there is a risk of buffering a large number\n\t * of data chunks without consumer.\n\t */\n\twrite(data: T): void | Promise<void>;\n\n\t/**\n\t * Signals an error to the consumer of the stream via the\n\t * on('error') handler if the stream is flowing.\n\t *\n\t * NOTE: call `end` to signal that the stream has ended,\n\t * this DOES NOT happen automatically from `error`.\n\t */\n\terror(error: Error): void;\n\n\t/**\n\t * Signals the end of the stream to the consumer. If the\n\t * result is provided, will trigger the on('data') event\n\t * listener if the stream is flowing and buffer the data\n\t * otherwise until the stream is flowing.\n\t */\n\tend(result?: T): void;\n}\n\n/**\n * A stream that has a buffer already read. Returns the original stream\n * that was read as well as the chunks that got read.\n *\n * The `ended` flag indicates if the stream has been fully consumed.\n */\nexport interface ReadableBufferedStream<T> {\n\n\t/**\n\t * The original stream that is being read.\n\t */\n\tstream: ReadableStream<T>;\n\n\t/**\n\t * An array of chunks already read from this stream.\n\t */\n\tbuffer: T[];\n\n\t/**\n\t * Signals if the stream has ended or not. If not, consumers\n\t * should continue to read from the stream until consumed.\n\t */\n\tended: boolean;\n}\n\nexport function isReadableStream<T>(obj: unknown): obj is ReadableStream<T> {\n\tconst candidate = obj as ReadableStream<T> | undefined;\n\tif (!candidate) {\n\t\treturn false;\n\t}\n\n\treturn [candidate.on, candidate.pause, candidate.resume, candidate.destroy].every(fn => typeof fn === 'function');\n}\n\nexport function isReadableBufferedStream<T>(obj: unknown): obj is ReadableBufferedStream<T> {\n\tconst candidate = obj as ReadableBufferedStream<T> | undefined;\n\tif (!candidate) {\n\t\treturn false;\n\t}\n\n\treturn isReadableStream(candidate.stream) && Array.isArray(candidate.buffer) && typeof candidate.ended === 'boolean';\n}\n\nexport interface IReducer<T, R = T> {\n\t(data: T[]): R;\n}\n\nexport interface IDataTransformer<Original, Transformed> {\n\t(data: Original): Transformed;\n}\n\nexport interface IErrorTransformer {\n\t(error: Error): Error;\n}\n\nexport interface ITransformer<Original, Transformed> {\n\tdata: IDataTransformer<Original, Transformed>;\n\terror?: IErrorTransformer;\n}\n\nexport function newWriteableStream<T>(reducer: IReducer<T>, options?: WriteableStreamOptions): WriteableStream<T> {\n\treturn new WriteableStreamImpl<T>(reducer, options);\n}\n\nexport interface WriteableStreamOptions {\n\n\t/**\n\t * The number of objects to buffer before WriteableStream#write()\n\t * signals back that the buffer is full. Can be used to reduce\n\t * the memory pressure when the stream is not flowing.\n\t */\n\thighWaterMark?: number;\n}\n\nclass WriteableStreamImpl<T> implements WriteableStream<T> {\n\n\tprivate readonly state = {\n\t\tflowing: false,\n\t\tended: false,\n\t\tdestroyed: false\n\t};\n\n\tprivate readonly buffer = {\n\t\tdata: [] as T[],\n\t\terror: [] as Error[]\n\t};\n\n\tprivate readonly listeners = {\n\t\tdata: [] as { (data: T): void }[],\n\t\terror: [] as { (error: Error): void }[],\n\t\tend: [] as { (): void }[]\n\t};\n\n\tprivate readonly pendingWritePromises: Function[] = [];\n\n\tconstructor(private reducer: IReducer<T>, private options?: WriteableStreamOptions) { }\n\n\tpause(): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.state.flowing = false;\n\t}\n\n\tresume(): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.state.flowing) {\n\t\t\tthis.state.flowing = true;\n\n\t\t\t// emit buffered events\n\t\t\tthis.flowData();\n\t\t\tthis.flowErrors();\n\t\t\tthis.flowEnd();\n\t\t}\n\t}\n\n\twrite(data: T): void | Promise<void> {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\t// flowing: directly send the data to listeners\n\t\tif (this.state.flowing) {\n\t\t\tthis.emitData(data);\n\t\t}\n\n\t\t// not yet flowing: buffer data until flowing\n\t\telse {\n\t\t\tthis.buffer.data.push(data);\n\n\t\t\t// highWaterMark: if configured, signal back when buffer reached limits\n\t\t\tif (typeof this.options?.highWaterMark === 'number' && this.buffer.data.length > this.options.highWaterMark) {\n\t\t\t\treturn new Promise(resolve => this.pendingWritePromises.push(resolve));\n\t\t\t}\n\t\t}\n\t}\n\n\terror(error: Error): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\t// flowing: directly send the error to listeners\n\t\tif (this.state.flowing) {\n\t\t\tthis.emitError(error);\n\t\t}\n\n\t\t// not yet flowing: buffer errors until flowing\n\t\telse {\n\t\t\tthis.buffer.error.push(error);\n\t\t}\n\t}\n\n\tend(result?: T): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\t// end with data if provided\n\t\tif (typeof result !== 'undefined') {\n\t\t\tthis.write(result);\n\t\t}\n\n\t\t// flowing: send end event to listeners\n\t\tif (this.state.flowing) {\n\t\t\tthis.emitEnd();\n\n\t\t\tthis.destroy();\n\t\t}\n\n\t\t// not yet flowing: remember state\n\t\telse {\n\t\t\tthis.state.ended = true;\n\t\t}\n\t}\n\n\tprivate emitData(data: T): void {\n\t\tthis.listeners.data.slice(0).forEach(listener => listener(data)); // slice to avoid listener mutation from delivering event\n\t}\n\n\tprivate emitError(error: Error): void {\n\t\tif (this.listeners.error.length === 0) {\n\t\t\tonUnexpectedError(error); // nobody listened to this error so we log it as unexpected\n\t\t} else {\n\t\t\tthis.listeners.error.slice(0).forEach(listener => listener(error)); // slice to avoid listener mutation from delivering event\n\t\t}\n\t}\n\n\tprivate emitEnd(): void {\n\t\tthis.listeners.end.slice(0).forEach(listener => listener()); // slice to avoid listener mutation from delivering event\n\t}\n\n\ton(event: 'data', callback: (data: T) => void): void;\n\ton(event: 'error', callback: (err: Error) => void): void;\n\ton(event: 'end', callback: () => void): void;\n\ton(event: 'data' | 'error' | 'end', callback: (arg0?: any) => void): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (event) {\n\t\t\tcase 'data':\n\t\t\t\tthis.listeners.data.push(callback);\n\n\t\t\t\t// switch into flowing mode as soon as the first 'data'\n\t\t\t\t// listener is added and we are not yet in flowing mode\n\t\t\t\tthis.resume();\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'end':\n\t\t\t\tthis.listeners.end.push(callback);\n\n\t\t\t\t// emit 'end' event directly if we are flowing\n\t\t\t\t// and the end has already been reached\n\t\t\t\t//\n\t\t\t\t// finish() when it went through\n\t\t\t\tif (this.state.flowing && this.flowEnd()) {\n\t\t\t\t\tthis.destroy();\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'error':\n\t\t\t\tthis.listeners.error.push(callback);\n\n\t\t\t\t// emit buffered 'error' events unless done already\n\t\t\t\t// now that we know that we have at least one listener\n\t\t\t\tif (this.state.flowing) {\n\t\t\t\t\tthis.flowErrors();\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tremoveListener(event: string, callback: Function): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet listeners: unknown[] | undefined = undefined;\n\n\t\tswitch (event) {\n\t\t\tcase 'data':\n\t\t\t\tlisteners = this.listeners.data;\n\t\t\t\tbreak;\n\n\t\t\tcase 'end':\n\t\t\t\tlisteners = this.listeners.end;\n\t\t\t\tbreak;\n\n\t\t\tcase 'error':\n\t\t\t\tlisteners = this.listeners.error;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (listeners) {\n\t\t\tconst index = listeners.indexOf(callback);\n\t\t\tif (index >= 0) {\n\t\t\t\tlisteners.splice(index, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate flowData(): void {\n\t\tif (this.buffer.data.length > 0) {\n\t\t\tconst fullDataBuffer = this.reducer(this.buffer.data);\n\n\t\t\tthis.emitData(fullDataBuffer);\n\n\t\t\tthis.buffer.data.length = 0;\n\n\t\t\t// When the buffer is empty, resolve all pending writers\n\t\t\tconst pendingWritePromises = [...this.pendingWritePromises];\n\t\t\tthis.pendingWritePromises.length = 0;\n\t\t\tpendingWritePromises.forEach(pendingWritePromise => pendingWritePromise());\n\t\t}\n\t}\n\n\tprivate flowErrors(): void {\n\t\tif (this.listeners.error.length > 0) {\n\t\t\tfor (const error of this.buffer.error) {\n\t\t\t\tthis.emitError(error);\n\t\t\t}\n\n\t\t\tthis.buffer.error.length = 0;\n\t\t}\n\t}\n\n\tprivate flowEnd(): boolean {\n\t\tif (this.state.ended) {\n\t\t\tthis.emitEnd();\n\n\t\t\treturn this.listeners.end.length > 0;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tdestroy(): void {\n\t\tif (!this.state.destroyed) {\n\t\t\tthis.state.destroyed = true;\n\t\t\tthis.state.ended = true;\n\n\t\t\tthis.buffer.data.length = 0;\n\t\t\tthis.buffer.error.length = 0;\n\n\t\t\tthis.listeners.data.length = 0;\n\t\t\tthis.listeners.error.length = 0;\n\t\t\tthis.listeners.end.length = 0;\n\n\t\t\tthis.pendingWritePromises.length = 0;\n\t\t}\n\t}\n}\n\n/**\n * Helper to fully read a T readable into a T.\n */\nexport function consumeReadable<T>(readable: Readable<T>, reducer: IReducer<T>): T {\n\tconst chunks: T[] = [];\n\n\tlet chunk: T | null;\n\twhile ((chunk = readable.read()) !== null) {\n\t\tchunks.push(chunk);\n\t}\n\n\treturn reducer(chunks);\n}\n\n/**\n * Helper to read a T readable up to a maximum of chunks. If the limit is\n * reached, will return a readable instead to ensure all data can still\n * be read.\n */\nexport function peekReadable<T>(readable: Readable<T>, reducer: IReducer<T>, maxChunks: number): T | Readable<T> {\n\tconst chunks: T[] = [];\n\n\tlet chunk: T | null | undefined = undefined;\n\twhile ((chunk = readable.read()) !== null && chunks.length < maxChunks) {\n\t\tchunks.push(chunk);\n\t}\n\n\t// If the last chunk is null, it means we reached the end of\n\t// the readable and return all the data at once\n\tif (chunk === null && chunks.length > 0) {\n\t\treturn reducer(chunks);\n\t}\n\n\t// Otherwise, we still have a chunk, it means we reached the maxChunks\n\t// value and as such we return a new Readable that first returns\n\t// the existing read chunks and then continues with reading from\n\t// the underlying readable.\n\treturn {\n\t\tread: () => {\n\n\t\t\t// First consume chunks from our array\n\t\t\tif (chunks.length > 0) {\n\t\t\t\treturn chunks.shift()!;\n\t\t\t}\n\n\t\t\t// Then ensure to return our last read chunk\n\t\t\tif (typeof chunk !== 'undefined') {\n\t\t\t\tconst lastReadChunk = chunk;\n\n\t\t\t\t// explicitly use undefined here to indicate that we consumed\n\t\t\t\t// the chunk, which could have either been null or valued.\n\t\t\t\tchunk = undefined;\n\n\t\t\t\treturn lastReadChunk;\n\t\t\t}\n\n\t\t\t// Finally delegate back to the Readable\n\t\t\treturn readable.read();\n\t\t}\n\t};\n}\n\n/**\n * Helper to fully read a T stream into a T or consuming\n * a stream fully, awaiting all the events without caring\n * about the data.\n */\nexport function consumeStream<T, R = T>(stream: ReadableStreamEvents<T>, reducer: IReducer<T, R>): Promise<R>;\nexport function consumeStream(stream: ReadableStreamEvents<unknown>): Promise<undefined>;\nexport function consumeStream<T, R = T>(stream: ReadableStreamEvents<T>, reducer?: IReducer<T, R>): Promise<R | undefined> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst chunks: T[] = [];\n\n\t\tlistenStream(stream, {\n\t\t\tonData: chunk => {\n\t\t\t\tif (reducer) {\n\t\t\t\t\tchunks.push(chunk);\n\t\t\t\t}\n\t\t\t},\n\t\t\tonError: error => {\n\t\t\t\tif (reducer) {\n\t\t\t\t\treject(error);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(undefined);\n\t\t\t\t}\n\t\t\t},\n\t\t\tonEnd: () => {\n\t\t\t\tif (reducer) {\n\t\t\t\t\tresolve(reducer(chunks));\n\t\t\t\t} else {\n\t\t\t\t\tresolve(undefined);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\nexport interface IStreamListener<T> {\n\n\t/**\n\t * The 'data' event is emitted whenever the stream is\n\t * relinquishing ownership of a chunk of data to a consumer.\n\t */\n\tonData(data: T): void;\n\n\t/**\n\t * Emitted when any error occurs.\n\t */\n\tonError(err: Error): void;\n\n\t/**\n\t * The 'end' event is emitted when there is no more data\n\t * to be consumed from the stream. The 'end' event will\n\t * not be emitted unless the data is completely consumed.\n\t */\n\tonEnd(): void;\n}\n\n/**\n * Helper to listen to all events of a T stream in proper order.\n */\nexport function listenStream<T>(stream: ReadableStreamEvents<T>, listener: IStreamListener<T>, token?: CancellationToken): void {\n\n\tstream.on('error', error => {\n\t\tif (!token?.isCancellationRequested) {\n\t\t\tlistener.onError(error);\n\t\t}\n\t});\n\n\tstream.on('end', () => {\n\t\tif (!token?.isCancellationRequested) {\n\t\t\tlistener.onEnd();\n\t\t}\n\t});\n\n\t// Adding the `data` listener will turn the stream\n\t// into flowing mode. As such it is important to\n\t// add this listener last (DO NOT CHANGE!)\n\tstream.on('data', data => {\n\t\tif (!token?.isCancellationRequested) {\n\t\t\tlistener.onData(data);\n\t\t}\n\t});\n}\n\n/**\n * Helper to peek up to `maxChunks` into a stream. The return type signals if\n * the stream has ended or not. If not, caller needs to add a `data` listener\n * to continue reading.\n */\nexport function peekStream<T>(stream: ReadableStream<T>, maxChunks: number): Promise<ReadableBufferedStream<T>> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst streamListeners = new DisposableStore();\n\t\tconst buffer: T[] = [];\n\n\t\t// Data Listener\n\t\tconst dataListener = (chunk: T) => {\n\n\t\t\t// Add to buffer\n\t\t\tbuffer.push(chunk);\n\n\t\t\t// We reached maxChunks and thus need to return\n\t\t\tif (buffer.length > maxChunks) {\n\n\t\t\t\t// Dispose any listeners and ensure to pause the\n\t\t\t\t// stream so that it can be consumed again by caller\n\t\t\t\tstreamListeners.dispose();\n\t\t\t\tstream.pause();\n\n\t\t\t\treturn resolve({ stream, buffer, ended: false });\n\t\t\t}\n\t\t};\n\n\t\t// Error Listener\n\t\tconst errorListener = (error: Error) => {\n\t\t\tstreamListeners.dispose();\n\n\t\t\treturn reject(error);\n\t\t};\n\n\t\t// End Listener\n\t\tconst endListener = () => {\n\t\t\tstreamListeners.dispose();\n\n\t\t\treturn resolve({ stream, buffer, ended: true });\n\t\t};\n\n\t\tstreamListeners.add(toDisposable(() => stream.removeListener('error', errorListener)));\n\t\tstream.on('error', errorListener);\n\n\t\tstreamListeners.add(toDisposable(() => stream.removeListener('end', endListener)));\n\t\tstream.on('end', endListener);\n\n\t\t// Important: leave the `data` listener last because\n\t\t// this can turn the stream into flowing mode and we\n\t\t// want `error` events to be received as well.\n\t\tstreamListeners.add(toDisposable(() => stream.removeListener('data', dataListener)));\n\t\tstream.on('data', dataListener);\n\t});\n}\n\n/**\n * Helper to create a readable stream from an existing T.\n */\nexport function toStream<T>(t: T, reducer: IReducer<T>): ReadableStream<T> {\n\tconst stream = newWriteableStream<T>(reducer);\n\n\tstream.end(t);\n\n\treturn stream;\n}\n\n/**\n * Helper to create an empty stream\n */\nexport function emptyStream(): ReadableStream<never> {\n\tconst stream = newWriteableStream<never>(() => { throw new Error('not supported'); });\n\tstream.end();\n\n\treturn stream;\n}\n\n/**\n * Helper to convert a T into a Readable<T>.\n */\nexport function toReadable<T>(t: T): Readable<T> {\n\tlet consumed = false;\n\n\treturn {\n\t\tread: () => {\n\t\t\tif (consumed) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconsumed = true;\n\n\t\t\treturn t;\n\t\t}\n\t};\n}\n\n/**\n * Helper to transform a readable stream into another stream.\n */\nexport function transform<Original, Transformed>(stream: ReadableStreamEvents<Original>, transformer: ITransformer<Original, Transformed>, reducer: IReducer<Transformed>): ReadableStream<Transformed> {\n\tconst target = newWriteableStream<Transformed>(reducer);\n\n\tlistenStream(stream, {\n\t\tonData: data => target.write(transformer.data(data)),\n\t\tonError: error => target.error(transformer.error ? transformer.error(error) : error),\n\t\tonEnd: () => target.end()\n\t});\n\n\treturn target;\n}\n\n/**\n * Helper to take an existing readable that will\n * have a prefix injected to the beginning.\n */\nexport function prefixedReadable<T>(prefix: T, readable: Readable<T>, reducer: IReducer<T>): Readable<T> {\n\tlet prefixHandled = false;\n\n\treturn {\n\t\tread: () => {\n\t\t\tconst chunk = readable.read();\n\n\t\t\t// Handle prefix only once\n\t\t\tif (!prefixHandled) {\n\t\t\t\tprefixHandled = true;\n\n\t\t\t\t// If we have also a read-result, make\n\t\t\t\t// sure to reduce it to a single result\n\t\t\t\tif (chunk !== null) {\n\t\t\t\t\treturn reducer([prefix, chunk]);\n\t\t\t\t}\n\n\t\t\t\t// Otherwise, just return prefix directly\n\t\t\t\treturn prefix;\n\t\t\t}\n\n\t\t\treturn chunk;\n\t\t}\n\t};\n}\n\n/**\n * Helper to take an existing stream that will\n * have a prefix injected to the beginning.\n */\nexport function prefixedStream<T>(prefix: T, stream: ReadableStream<T>, reducer: IReducer<T>): ReadableStream<T> {\n\tlet prefixHandled = false;\n\n\tconst target = newWriteableStream<T>(reducer);\n\n\tlistenStream(stream, {\n\t\tonData: data => {\n\n\t\t\t// Handle prefix only once\n\t\t\tif (!prefixHandled) {\n\t\t\t\tprefixHandled = true;\n\n\t\t\t\treturn target.write(reducer([prefix, data]));\n\t\t\t}\n\n\t\t\treturn target.write(data);\n\t\t},\n\t\tonError: error => target.error(error),\n\t\tonEnd: () => {\n\n\t\t\t// Handle prefix only once\n\t\t\tif (!prefixHandled) {\n\t\t\t\tprefixHandled = true;\n\n\t\t\t\ttarget.write(prefix);\n\t\t\t}\n\n\t\t\ttarget.end();\n\t\t}\n\t});\n\n\treturn target;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Lazy } from 'vs/base/common/lazy';\nimport * as streams from 'vs/base/common/stream';\n\ndeclare const Buffer: any;\n\nconst hasBuffer = (typeof Buffer !== 'undefined');\nconst indexOfTable = new Lazy(() => new Uint8Array(256));\n\nlet textEncoder: TextEncoder | null;\nlet textDecoder: TextDecoder | null;\n\nexport class VSBuffer {\n\n\t/**\n\t * When running in a nodejs context, the backing store for the returned `VSBuffer` instance\n\t * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.\n\t */\n\tstatic alloc(byteLength: number): VSBuffer {\n\t\tif (hasBuffer) {\n\t\t\treturn new VSBuffer(Buffer.allocUnsafe(byteLength));\n\t\t} else {\n\t\t\treturn new VSBuffer(new Uint8Array(byteLength));\n\t\t}\n\t}\n\n\t/**\n\t * When running in a nodejs context, if `actual` is not a nodejs Buffer, the backing store for\n\t * the returned `VSBuffer` instance might use a nodejs Buffer allocated from node's Buffer pool,\n\t * which is not transferrable.\n\t */\n\tstatic wrap(actual: Uint8Array): VSBuffer {\n\t\tif (hasBuffer && !(Buffer.isBuffer(actual))) {\n\t\t\t// https://nodejs.org/dist/latest-v10.x/docs/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length\n\t\t\t// Create a zero-copy Buffer wrapper around the ArrayBuffer pointed to by the Uint8Array\n\t\t\tactual = Buffer.from(actual.buffer, actual.byteOffset, actual.byteLength);\n\t\t}\n\t\treturn new VSBuffer(actual);\n\t}\n\n\t/**\n\t * When running in a nodejs context, the backing store for the returned `VSBuffer` instance\n\t * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.\n\t */\n\tstatic fromString(source: string, options?: { dontUseNodeBuffer?: boolean }): VSBuffer {\n\t\tconst dontUseNodeBuffer = options?.dontUseNodeBuffer || false;\n\t\tif (!dontUseNodeBuffer && hasBuffer) {\n\t\t\treturn new VSBuffer(Buffer.from(source));\n\t\t} else {\n\t\t\tif (!textEncoder) {\n\t\t\t\ttextEncoder = new TextEncoder();\n\t\t\t}\n\t\t\treturn new VSBuffer(textEncoder.encode(source));\n\t\t}\n\t}\n\n\t/**\n\t * When running in a nodejs context, the backing store for the returned `VSBuffer` instance\n\t * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.\n\t */\n\tstatic fromByteArray(source: number[]): VSBuffer {\n\t\tconst result = VSBuffer.alloc(source.length);\n\t\tfor (let i = 0, len = source.length; i < len; i++) {\n\t\t\tresult.buffer[i] = source[i];\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * When running in a nodejs context, the backing store for the returned `VSBuffer` instance\n\t * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.\n\t */\n\tstatic concat(buffers: VSBuffer[], totalLength?: number): VSBuffer {\n\t\tif (typeof totalLength === 'undefined') {\n\t\t\ttotalLength = 0;\n\t\t\tfor (let i = 0, len = buffers.length; i < len; i++) {\n\t\t\t\ttotalLength += buffers[i].byteLength;\n\t\t\t}\n\t\t}\n\n\t\tconst ret = VSBuffer.alloc(totalLength);\n\t\tlet offset = 0;\n\t\tfor (let i = 0, len = buffers.length; i < len; i++) {\n\t\t\tconst element = buffers[i];\n\t\t\tret.set(element, offset);\n\t\t\toffset += element.byteLength;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\treadonly buffer: Uint8Array;\n\treadonly byteLength: number;\n\n\tprivate constructor(buffer: Uint8Array) {\n\t\tthis.buffer = buffer;\n\t\tthis.byteLength = this.buffer.byteLength;\n\t}\n\n\t/**\n\t * When running in a nodejs context, the backing store for the returned `VSBuffer` instance\n\t * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.\n\t */\n\tclone(): VSBuffer {\n\t\tconst result = VSBuffer.alloc(this.byteLength);\n\t\tresult.set(this);\n\t\treturn result;\n\t}\n\n\ttoString(): string {\n\t\tif (hasBuffer) {\n\t\t\treturn this.buffer.toString();\n\t\t} else {\n\t\t\tif (!textDecoder) {\n\t\t\t\ttextDecoder = new TextDecoder();\n\t\t\t}\n\t\t\treturn textDecoder.decode(this.buffer);\n\t\t}\n\t}\n\n\tslice(start?: number, end?: number): VSBuffer {\n\t\t// IMPORTANT: use subarray instead of slice because TypedArray#slice\n\t\t// creates shallow copy and NodeBuffer#slice doesn't. The use of subarray\n\t\t// ensures the same, performance, behaviour.\n\t\treturn new VSBuffer(this.buffer.subarray(start, end));\n\t}\n\n\tset(array: VSBuffer, offset?: number): void;\n\tset(array: Uint8Array, offset?: number): void;\n\tset(array: ArrayBuffer, offset?: number): void;\n\tset(array: ArrayBufferView, offset?: number): void;\n\tset(array: VSBuffer | Uint8Array | ArrayBuffer | ArrayBufferView, offset?: number): void;\n\tset(array: VSBuffer | Uint8Array | ArrayBuffer | ArrayBufferView, offset?: number): void {\n\t\tif (array instanceof VSBuffer) {\n\t\t\tthis.buffer.set(array.buffer, offset);\n\t\t} else if (array instanceof Uint8Array) {\n\t\t\tthis.buffer.set(array, offset);\n\t\t} else if (array instanceof ArrayBuffer) {\n\t\t\tthis.buffer.set(new Uint8Array(array), offset);\n\t\t} else if (ArrayBuffer.isView(array)) {\n\t\t\tthis.buffer.set(new Uint8Array(array.buffer, array.byteOffset, array.byteLength), offset);\n\t\t} else {\n\t\t\tthrow new Error(`Unknown argument 'array'`);\n\t\t}\n\t}\n\n\treadUInt32BE(offset: number): number {\n\t\treturn readUInt32BE(this.buffer, offset);\n\t}\n\n\twriteUInt32BE(value: number, offset: number): void {\n\t\twriteUInt32BE(this.buffer, value, offset);\n\t}\n\n\treadUInt32LE(offset: number): number {\n\t\treturn readUInt32LE(this.buffer, offset);\n\t}\n\n\twriteUInt32LE(value: number, offset: number): void {\n\t\twriteUInt32LE(this.buffer, value, offset);\n\t}\n\n\treadUInt8(offset: number): number {\n\t\treturn readUInt8(this.buffer, offset);\n\t}\n\n\twriteUInt8(value: number, offset: number): void {\n\t\twriteUInt8(this.buffer, value, offset);\n\t}\n\n\tindexOf(subarray: VSBuffer | Uint8Array, offset = 0) {\n\t\treturn binaryIndexOf(this.buffer, subarray instanceof VSBuffer ? subarray.buffer : subarray, offset);\n\t}\n}\n\n/**\n * Like String.indexOf, but works on Uint8Arrays.\n * Uses the boyer-moore-horspool algorithm to be reasonably speedy.\n */\nexport function binaryIndexOf(haystack: Uint8Array, needle: Uint8Array, offset = 0): number {\n\tconst needleLen = needle.byteLength;\n\tconst haystackLen = haystack.byteLength;\n\n\tif (needleLen === 0) {\n\t\treturn 0;\n\t}\n\n\tif (needleLen === 1) {\n\t\treturn haystack.indexOf(needle[0]);\n\t}\n\n\tif (needleLen > haystackLen - offset) {\n\t\treturn -1;\n\t}\n\n\t// find index of the subarray using boyer-moore-horspool algorithm\n\tconst table = indexOfTable.value;\n\ttable.fill(needle.length);\n\tfor (let i = 0; i < needle.length; i++) {\n\t\ttable[needle[i]] = needle.length - i - 1;\n\t}\n\n\tlet i = offset + needle.length - 1;\n\tlet j = i;\n\tlet result = -1;\n\twhile (i < haystackLen) {\n\t\tif (haystack[i] === needle[j]) {\n\t\t\tif (j === 0) {\n\t\t\t\tresult = i;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ti--;\n\t\t\tj--;\n\t\t} else {\n\t\t\ti += Math.max(needle.length - j, table[haystack[i]]);\n\t\t\tj = needle.length - 1;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nexport function readUInt16LE(source: Uint8Array, offset: number): number {\n\treturn (\n\t\t((source[offset + 0] << 0) >>> 0) |\n\t\t((source[offset + 1] << 8) >>> 0)\n\t);\n}\n\nexport function writeUInt16LE(destination: Uint8Array, value: number, offset: number): void {\n\tdestination[offset + 0] = (value & 0b11111111);\n\tvalue = value >>> 8;\n\tdestination[offset + 1] = (value & 0b11111111);\n}\n\nexport function readUInt32BE(source: Uint8Array, offset: number): number {\n\treturn (\n\t\tsource[offset] * 2 ** 24\n\t\t+ source[offset + 1] * 2 ** 16\n\t\t+ source[offset + 2] * 2 ** 8\n\t\t+ source[offset + 3]\n\t);\n}\n\nexport function writeUInt32BE(destination: Uint8Array, value: number, offset: number): void {\n\tdestination[offset + 3] = value;\n\tvalue = value >>> 8;\n\tdestination[offset + 2] = value;\n\tvalue = value >>> 8;\n\tdestination[offset + 1] = value;\n\tvalue = value >>> 8;\n\tdestination[offset] = value;\n}\n\nexport function readUInt32LE(source: Uint8Array, offset: number): number {\n\treturn (\n\t\t((source[offset + 0] << 0) >>> 0) |\n\t\t((source[offset + 1] << 8) >>> 0) |\n\t\t((source[offset + 2] << 16) >>> 0) |\n\t\t((source[offset + 3] << 24) >>> 0)\n\t);\n}\n\nexport function writeUInt32LE(destination: Uint8Array, value: number, offset: number): void {\n\tdestination[offset + 0] = (value & 0b11111111);\n\tvalue = value >>> 8;\n\tdestination[offset + 1] = (value & 0b11111111);\n\tvalue = value >>> 8;\n\tdestination[offset + 2] = (value & 0b11111111);\n\tvalue = value >>> 8;\n\tdestination[offset + 3] = (value & 0b11111111);\n}\n\nexport function readUInt8(source: Uint8Array, offset: number): number {\n\treturn source[offset];\n}\n\nexport function writeUInt8(destination: Uint8Array, value: number, offset: number): void {\n\tdestination[offset] = value;\n}\n\nexport interface VSBufferReadable extends streams.Readable<VSBuffer> { }\n\nexport interface VSBufferReadableStream extends streams.ReadableStream<VSBuffer> { }\n\nexport interface VSBufferWriteableStream extends streams.WriteableStream<VSBuffer> { }\n\nexport interface VSBufferReadableBufferedStream extends streams.ReadableBufferedStream<VSBuffer> { }\n\nexport function readableToBuffer(readable: VSBufferReadable): VSBuffer {\n\treturn streams.consumeReadable<VSBuffer>(readable, chunks => VSBuffer.concat(chunks));\n}\n\nexport function bufferToReadable(buffer: VSBuffer): VSBufferReadable {\n\treturn streams.toReadable<VSBuffer>(buffer);\n}\n\nexport function streamToBuffer(stream: streams.ReadableStream<VSBuffer>): Promise<VSBuffer> {\n\treturn streams.consumeStream<VSBuffer>(stream, chunks => VSBuffer.concat(chunks));\n}\n\nexport async function bufferedStreamToBuffer(bufferedStream: streams.ReadableBufferedStream<VSBuffer>): Promise<VSBuffer> {\n\tif (bufferedStream.ended) {\n\t\treturn VSBuffer.concat(bufferedStream.buffer);\n\t}\n\n\treturn VSBuffer.concat([\n\n\t\t// Include already read chunks...\n\t\t...bufferedStream.buffer,\n\n\t\t// ...and all additional chunks\n\t\tawait streamToBuffer(bufferedStream.stream)\n\t]);\n}\n\nexport function bufferToStream(buffer: VSBuffer): streams.ReadableStream<VSBuffer> {\n\treturn streams.toStream<VSBuffer>(buffer, chunks => VSBuffer.concat(chunks));\n}\n\nexport function streamToBufferReadableStream(stream: streams.ReadableStreamEvents<Uint8Array | string>): streams.ReadableStream<VSBuffer> {\n\treturn streams.transform<Uint8Array | string, VSBuffer>(stream, { data: data => typeof data === 'string' ? VSBuffer.fromString(data) : VSBuffer.wrap(data) }, chunks => VSBuffer.concat(chunks));\n}\n\nexport function newWriteableBufferStream(options?: streams.WriteableStreamOptions): streams.WriteableStream<VSBuffer> {\n\treturn streams.newWriteableStream<VSBuffer>(chunks => VSBuffer.concat(chunks), options);\n}\n\nexport function prefixedBufferReadable(prefix: VSBuffer, readable: VSBufferReadable): VSBufferReadable {\n\treturn streams.prefixedReadable(prefix, readable, chunks => VSBuffer.concat(chunks));\n}\n\nexport function prefixedBufferStream(prefix: VSBuffer, stream: VSBufferReadableStream): VSBufferReadableStream {\n\treturn streams.prefixedStream(prefix, stream, chunks => VSBuffer.concat(chunks));\n}\n\n/** Decodes base64 to a uint8 array. URL-encoded and unpadded base64 is allowed. */\nexport function decodeBase64(encoded: string) {\n\tlet building = 0;\n\tlet remainder = 0;\n\tlet bufi = 0;\n\n\t// The simpler way to do this is `Uint8Array.from(atob(str), c => c.charCodeAt(0))`,\n\t// but that's about 10-20x slower than this function in current Chromium versions.\n\n\tconst buffer = new Uint8Array(Math.floor(encoded.length / 4 * 3));\n\tconst append = (value: number) => {\n\t\tswitch (remainder) {\n\t\t\tcase 3:\n\t\t\t\tbuffer[bufi++] = building | value;\n\t\t\t\tremainder = 0;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tbuffer[bufi++] = building | (value >>> 2);\n\t\t\t\tbuilding = value << 6;\n\t\t\t\tremainder = 3;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tbuffer[bufi++] = building | (value >>> 4);\n\t\t\t\tbuilding = value << 4;\n\t\t\t\tremainder = 2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbuilding = value << 2;\n\t\t\t\tremainder = 1;\n\t\t}\n\t};\n\n\tfor (let i = 0; i < encoded.length; i++) {\n\t\tconst code = encoded.charCodeAt(i);\n\t\t// See https://datatracker.ietf.org/doc/html/rfc4648#section-4\n\t\t// This branchy code is about 3x faster than an indexOf on a base64 char string.\n\t\tif (code >= 65 && code <= 90) {\n\t\t\tappend(code - 65); // A-Z starts ranges from char code 65 to 90\n\t\t} else if (code >= 97 && code <= 122) {\n\t\t\tappend(code - 97 + 26); // a-z starts ranges from char code 97 to 122, starting at byte 26\n\t\t} else if (code >= 48 && code <= 57) {\n\t\t\tappend(code - 48 + 52); // 0-9 starts ranges from char code 48 to 58, starting at byte 52\n\t\t} else if (code === 43 || code === 45) {\n\t\t\tappend(62); // \"+\" or \"-\" for URLS\n\t\t} else if (code === 47 || code === 95) {\n\t\t\tappend(63); // \"/\" or \"_\" for URLS\n\t\t} else if (code === 61) {\n\t\t\tbreak; // \"=\"\n\t\t} else {\n\t\t\tthrow new SyntaxError(`Unexpected base64 character ${encoded[i]}`);\n\t\t}\n\t}\n\n\tconst unpadded = bufi;\n\twhile (remainder > 0) {\n\t\tappend(0);\n\t}\n\n\t// slice is needed to account for overestimation due to padding\n\treturn VSBuffer.wrap(buffer).slice(0, unpadded);\n}\n\nconst base64Alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nconst base64UrlSafeAlphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';\n\n/** Encodes a buffer to a base64 string. */\nexport function encodeBase64({ buffer }: VSBuffer, padded = true, urlSafe = false) {\n\tconst dictionary = urlSafe ? base64UrlSafeAlphabet : base64Alphabet;\n\tlet output = '';\n\n\tconst remainder = buffer.byteLength % 3;\n\n\tlet i = 0;\n\tfor (; i < buffer.byteLength - remainder; i += 3) {\n\t\tconst a = buffer[i + 0];\n\t\tconst b = buffer[i + 1];\n\t\tconst c = buffer[i + 2];\n\n\t\toutput += dictionary[a >>> 2];\n\t\toutput += dictionary[(a << 4 | b >>> 4) & 0b111111];\n\t\toutput += dictionary[(b << 2 | c >>> 6) & 0b111111];\n\t\toutput += dictionary[c & 0b111111];\n\t}\n\n\tif (remainder === 1) {\n\t\tconst a = buffer[i + 0];\n\t\toutput += dictionary[a >>> 2];\n\t\toutput += dictionary[(a << 4) & 0b111111];\n\t\tif (padded) { output += '=='; }\n\t} else if (remainder === 2) {\n\t\tconst a = buffer[i + 0];\n\t\tconst b = buffer[i + 1];\n\t\toutput += dictionary[a >>> 2];\n\t\toutput += dictionary[(a << 4 | b >>> 4) & 0b111111];\n\t\toutput += dictionary[(b << 2) & 0b111111];\n\t\tif (padded) { output += '='; }\n\t}\n\n\treturn output;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * Can be passed into the Delayed to defer using a microtask\n * */\nexport const MicrotaskDelay = Symbol('MicrotaskDelay');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\n\nexport const enum StringEOL {\n\tUnknown = 0,\n\tInvalid = 3,\n\tLF = 1,\n\tCRLF = 2\n}\n\nexport function countEOL(text: string): [number, number, number, StringEOL] {\n\tlet eolCount = 0;\n\tlet firstLineLength = 0;\n\tlet lastLineStart = 0;\n\tlet eol: StringEOL = StringEOL.Unknown;\n\tfor (let i = 0, len = text.length; i < len; i++) {\n\t\tconst chr = text.charCodeAt(i);\n\n\t\tif (chr === CharCode.CarriageReturn) {\n\t\t\tif (eolCount === 0) {\n\t\t\t\tfirstLineLength = i;\n\t\t\t}\n\t\t\teolCount++;\n\t\t\tif (i + 1 < len && text.charCodeAt(i + 1) === CharCode.LineFeed) {\n\t\t\t\t// \\r\\n... case\n\t\t\t\teol |= StringEOL.CRLF;\n\t\t\t\ti++; // skip \\n\n\t\t\t} else {\n\t\t\t\t// \\r... case\n\t\t\t\teol |= StringEOL.Invalid;\n\t\t\t}\n\t\t\tlastLineStart = i + 1;\n\t\t} else if (chr === CharCode.LineFeed) {\n\t\t\t// \\n... case\n\t\t\teol |= StringEOL.LF;\n\t\t\tif (eolCount === 0) {\n\t\t\t\tfirstLineLength = i;\n\t\t\t}\n\t\t\teolCount++;\n\t\t\tlastLineStart = i + 1;\n\t\t}\n\t}\n\tif (eolCount === 0) {\n\t\tfirstLineLength = text.length;\n\t}\n\treturn [eolCount, firstLineLength, text.length - lastLineStart, eol];\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * Open ended enum at runtime\n */\nexport const enum LanguageId {\n\tNull = 0,\n\tPlainText = 1\n}\n\n/**\n * A font style. Values are 2^x such that a bit mask can be used.\n */\nexport const enum FontStyle {\n\tNotSet = -1,\n\tNone = 0,\n\tItalic = 1,\n\tBold = 2,\n\tUnderline = 4,\n\tStrikethrough = 8,\n}\n\n/**\n * Open ended enum at runtime\n */\nexport const enum ColorId {\n\tNone = 0,\n\tDefaultForeground = 1,\n\tDefaultBackground = 2\n}\n\n/**\n * A standard token type.\n */\nexport const enum StandardTokenType {\n\tOther = 0,\n\tComment = 1,\n\tString = 2,\n\tRegEx = 3\n}\n\n/**\n * Helpers to manage the \"collapsed\" metadata of an entire StackElement stack.\n * The following assumptions have been made:\n *  - languageId < 256 => needs 8 bits\n *  - unique color count < 512 => needs 9 bits\n *\n * The binary format is:\n * - -------------------------------------------\n *     3322 2222 2222 1111 1111 1100 0000 0000\n *     1098 7654 3210 9876 5432 1098 7654 3210\n * - -------------------------------------------\n *     xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx\n *     bbbb bbbb ffff ffff fFFF FBTT LLLL LLLL\n * - -------------------------------------------\n *  - L = LanguageId (8 bits)\n *  - T = StandardTokenType (2 bits)\n *  - B = Balanced bracket (1 bit)\n *  - F = FontStyle (4 bits)\n *  - f = foreground color (9 bits)\n *  - b = background color (9 bits)\n *\n */\nexport const enum MetadataConsts {\n\tLANGUAGEID_MASK = 0b00000000000000000000000011111111,\n\tTOKEN_TYPE_MASK = 0b00000000000000000000001100000000,\n\tBALANCED_BRACKETS_MASK = 0b00000000000000000000010000000000,\n\tFONT_STYLE_MASK = 0b00000000000000000111100000000000,\n\tFOREGROUND_MASK = 0b00000000111111111000000000000000,\n\tBACKGROUND_MASK = 0b11111111000000000000000000000000,\n\n\tITALIC_MASK = 0b00000000000000000000100000000000,\n\tBOLD_MASK = 0b00000000000000000001000000000000,\n\tUNDERLINE_MASK = 0b00000000000000000010000000000000,\n\tSTRIKETHROUGH_MASK = 0b00000000000000000100000000000000,\n\n\t// Semantic tokens cannot set the language id, so we can\n\t// use the first 8 bits for control purposes\n\tSEMANTIC_USE_ITALIC = 0b00000000000000000000000000000001,\n\tSEMANTIC_USE_BOLD = 0b00000000000000000000000000000010,\n\tSEMANTIC_USE_UNDERLINE = 0b00000000000000000000000000000100,\n\tSEMANTIC_USE_STRIKETHROUGH = 0b00000000000000000000000000001000,\n\tSEMANTIC_USE_FOREGROUND = 0b00000000000000000000000000010000,\n\tSEMANTIC_USE_BACKGROUND = 0b00000000000000000000000000100000,\n\n\tLANGUAGEID_OFFSET = 0,\n\tTOKEN_TYPE_OFFSET = 8,\n\tBALANCED_BRACKETS_OFFSET = 10,\n\tFONT_STYLE_OFFSET = 11,\n\tFOREGROUND_OFFSET = 15,\n\tBACKGROUND_OFFSET = 24\n}\n\n/**\n */\nexport class TokenMetadata {\n\n\tpublic static getLanguageId(metadata: number): LanguageId {\n\t\treturn (metadata & MetadataConsts.LANGUAGEID_MASK) >>> MetadataConsts.LANGUAGEID_OFFSET;\n\t}\n\n\tpublic static getTokenType(metadata: number): StandardTokenType {\n\t\treturn (metadata & MetadataConsts.TOKEN_TYPE_MASK) >>> MetadataConsts.TOKEN_TYPE_OFFSET;\n\t}\n\n\tpublic static containsBalancedBrackets(metadata: number): boolean {\n\t\treturn (metadata & MetadataConsts.BALANCED_BRACKETS_MASK) !== 0;\n\t}\n\n\tpublic static getFontStyle(metadata: number): FontStyle {\n\t\treturn (metadata & MetadataConsts.FONT_STYLE_MASK) >>> MetadataConsts.FONT_STYLE_OFFSET;\n\t}\n\n\tpublic static getForeground(metadata: number): ColorId {\n\t\treturn (metadata & MetadataConsts.FOREGROUND_MASK) >>> MetadataConsts.FOREGROUND_OFFSET;\n\t}\n\n\tpublic static getBackground(metadata: number): ColorId {\n\t\treturn (metadata & MetadataConsts.BACKGROUND_MASK) >>> MetadataConsts.BACKGROUND_OFFSET;\n\t}\n\n\tpublic static getClassNameFromMetadata(metadata: number): string {\n\t\tconst foreground = this.getForeground(metadata);\n\t\tlet className = 'mtk' + foreground;\n\n\t\tconst fontStyle = this.getFontStyle(metadata);\n\t\tif (fontStyle & FontStyle.Italic) {\n\t\t\tclassName += ' mtki';\n\t\t}\n\t\tif (fontStyle & FontStyle.Bold) {\n\t\t\tclassName += ' mtkb';\n\t\t}\n\t\tif (fontStyle & FontStyle.Underline) {\n\t\t\tclassName += ' mtku';\n\t\t}\n\t\tif (fontStyle & FontStyle.Strikethrough) {\n\t\t\tclassName += ' mtks';\n\t\t}\n\n\t\treturn className;\n\t}\n\n\tpublic static getInlineStyleFromMetadata(metadata: number, colorMap: string[]): string {\n\t\tconst foreground = this.getForeground(metadata);\n\t\tconst fontStyle = this.getFontStyle(metadata);\n\n\t\tlet result = `color: ${colorMap[foreground]};`;\n\t\tif (fontStyle & FontStyle.Italic) {\n\t\t\tresult += 'font-style: italic;';\n\t\t}\n\t\tif (fontStyle & FontStyle.Bold) {\n\t\t\tresult += 'font-weight: bold;';\n\t\t}\n\t\tlet textDecoration = '';\n\t\tif (fontStyle & FontStyle.Underline) {\n\t\t\ttextDecoration += ' underline';\n\t\t}\n\t\tif (fontStyle & FontStyle.Strikethrough) {\n\t\t\ttextDecoration += ' line-through';\n\t\t}\n\t\tif (textDecoration) {\n\t\t\tresult += `text-decoration:${textDecoration};`;\n\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static getPresentationFromMetadata(metadata: number): ITokenPresentation {\n\t\tconst foreground = this.getForeground(metadata);\n\t\tconst fontStyle = this.getFontStyle(metadata);\n\n\t\treturn {\n\t\t\tforeground: foreground,\n\t\t\titalic: Boolean(fontStyle & FontStyle.Italic),\n\t\t\tbold: Boolean(fontStyle & FontStyle.Bold),\n\t\t\tunderline: Boolean(fontStyle & FontStyle.Underline),\n\t\t\tstrikethrough: Boolean(fontStyle & FontStyle.Strikethrough),\n\t\t};\n\t}\n}\n\n/**\n */\nexport interface ITokenPresentation {\n\tforeground: ColorId;\n\titalic: boolean;\n\tbold: boolean;\n\tunderline: boolean;\n\tstrikethrough: boolean;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { arrayInsert } from 'vs/base/common/arrays';\n\n/**\n * An array that avoids being sparse by always\n * filling up unused indices with a default value.\n */\nexport class FixedArray<T> {\n\tprivate _store: T[] = [];\n\n\tconstructor(\n\t\tprivate readonly _default: T\n\t) { }\n\n\tpublic get(index: number): T {\n\t\tif (index < this._store.length) {\n\t\t\treturn this._store[index];\n\t\t}\n\t\treturn this._default;\n\t}\n\n\tpublic set(index: number, value: T): void {\n\t\twhile (index >= this._store.length) {\n\t\t\tthis._store[this._store.length] = this._default;\n\t\t}\n\t\tthis._store[index] = value;\n\t}\n\n\tpublic replace(index: number, oldLength: number, newLength: number): void {\n\t\tif (index >= this._store.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (oldLength === 0) {\n\t\t\tthis.insert(index, newLength);\n\t\t\treturn;\n\t\t} else if (newLength === 0) {\n\t\t\tthis.delete(index, oldLength);\n\t\t\treturn;\n\t\t}\n\n\t\tconst before = this._store.slice(0, index);\n\t\tconst after = this._store.slice(index + oldLength);\n\t\tconst insertArr = arrayFill(newLength, this._default);\n\t\tthis._store = before.concat(insertArr, after);\n\t}\n\n\tpublic delete(deleteIndex: number, deleteCount: number): void {\n\t\tif (deleteCount === 0 || deleteIndex >= this._store.length) {\n\t\t\treturn;\n\t\t}\n\t\tthis._store.splice(deleteIndex, deleteCount);\n\t}\n\n\tpublic insert(insertIndex: number, insertCount: number): void {\n\t\tif (insertCount === 0 || insertIndex >= this._store.length) {\n\t\t\treturn;\n\t\t}\n\t\tconst arr: T[] = [];\n\t\tfor (let i = 0; i < insertCount; i++) {\n\t\t\tarr[i] = this._default;\n\t\t}\n\t\tthis._store = arrayInsert(this._store, insertIndex, arr);\n\t}\n}\n\nfunction arrayFill<T>(length: number, value: T): T[] {\n\tconst arr: T[] = [];\n\tfor (let i = 0; i < length; i++) {\n\t\tarr[i] = value;\n\t}\n\treturn arr;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ILanguageIdCodec } from 'vs/editor/common/languages';\nimport { FontStyle, ColorId, StandardTokenType, MetadataConsts, TokenMetadata, ITokenPresentation } from 'vs/editor/common/encodedTokenAttributes';\n\nexport interface IViewLineTokens {\n\tequals(other: IViewLineTokens): boolean;\n\tgetCount(): number;\n\tgetForeground(tokenIndex: number): ColorId;\n\tgetEndOffset(tokenIndex: number): number;\n\tgetClassName(tokenIndex: number): string;\n\tgetInlineStyle(tokenIndex: number, colorMap: string[]): string;\n\tgetPresentation(tokenIndex: number): ITokenPresentation;\n\tfindTokenIndexAtOffset(offset: number): number;\n\tgetLineContent(): string;\n\tgetMetadata(tokenIndex: number): number;\n\tgetLanguageId(tokenIndex: number): string;\n}\n\nexport class LineTokens implements IViewLineTokens {\n\t_lineTokensBrand: void = undefined;\n\n\tprivate readonly _tokens: Uint32Array;\n\tprivate readonly _tokensCount: number;\n\tprivate readonly _text: string;\n\tprivate readonly _languageIdCodec: ILanguageIdCodec;\n\n\tpublic static defaultTokenMetadata = (\n\t\t(FontStyle.None << MetadataConsts.FONT_STYLE_OFFSET)\n\t\t| (ColorId.DefaultForeground << MetadataConsts.FOREGROUND_OFFSET)\n\t\t| (ColorId.DefaultBackground << MetadataConsts.BACKGROUND_OFFSET)\n\t) >>> 0;\n\n\tpublic static createEmpty(lineContent: string, decoder: ILanguageIdCodec): LineTokens {\n\t\tconst defaultMetadata = LineTokens.defaultTokenMetadata;\n\n\t\tconst tokens = new Uint32Array(2);\n\t\ttokens[0] = lineContent.length;\n\t\ttokens[1] = defaultMetadata;\n\n\t\treturn new LineTokens(tokens, lineContent, decoder);\n\t}\n\n\tconstructor(tokens: Uint32Array, text: string, decoder: ILanguageIdCodec) {\n\t\tthis._tokens = tokens;\n\t\tthis._tokensCount = (this._tokens.length >>> 1);\n\t\tthis._text = text;\n\t\tthis._languageIdCodec = decoder;\n\t}\n\n\tpublic equals(other: IViewLineTokens): boolean {\n\t\tif (other instanceof LineTokens) {\n\t\t\treturn this.slicedEquals(other, 0, this._tokensCount);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic slicedEquals(other: LineTokens, sliceFromTokenIndex: number, sliceTokenCount: number): boolean {\n\t\tif (this._text !== other._text) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this._tokensCount !== other._tokensCount) {\n\t\t\treturn false;\n\t\t}\n\t\tconst from = (sliceFromTokenIndex << 1);\n\t\tconst to = from + (sliceTokenCount << 1);\n\t\tfor (let i = from; i < to; i++) {\n\t\t\tif (this._tokens[i] !== other._tokens[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic getLineContent(): string {\n\t\treturn this._text;\n\t}\n\n\tpublic getCount(): number {\n\t\treturn this._tokensCount;\n\t}\n\n\tpublic getStartOffset(tokenIndex: number): number {\n\t\tif (tokenIndex > 0) {\n\t\t\treturn this._tokens[(tokenIndex - 1) << 1];\n\t\t}\n\t\treturn 0;\n\t}\n\n\tpublic getMetadata(tokenIndex: number): number {\n\t\tconst metadata = this._tokens[(tokenIndex << 1) + 1];\n\t\treturn metadata;\n\t}\n\n\tpublic getLanguageId(tokenIndex: number): string {\n\t\tconst metadata = this._tokens[(tokenIndex << 1) + 1];\n\t\tconst languageId = TokenMetadata.getLanguageId(metadata);\n\t\treturn this._languageIdCodec.decodeLanguageId(languageId);\n\t}\n\n\tpublic getStandardTokenType(tokenIndex: number): StandardTokenType {\n\t\tconst metadata = this._tokens[(tokenIndex << 1) + 1];\n\t\treturn TokenMetadata.getTokenType(metadata);\n\t}\n\n\tpublic getForeground(tokenIndex: number): ColorId {\n\t\tconst metadata = this._tokens[(tokenIndex << 1) + 1];\n\t\treturn TokenMetadata.getForeground(metadata);\n\t}\n\n\tpublic getClassName(tokenIndex: number): string {\n\t\tconst metadata = this._tokens[(tokenIndex << 1) + 1];\n\t\treturn TokenMetadata.getClassNameFromMetadata(metadata);\n\t}\n\n\tpublic getInlineStyle(tokenIndex: number, colorMap: string[]): string {\n\t\tconst metadata = this._tokens[(tokenIndex << 1) + 1];\n\t\treturn TokenMetadata.getInlineStyleFromMetadata(metadata, colorMap);\n\t}\n\n\tpublic getPresentation(tokenIndex: number): ITokenPresentation {\n\t\tconst metadata = this._tokens[(tokenIndex << 1) + 1];\n\t\treturn TokenMetadata.getPresentationFromMetadata(metadata);\n\t}\n\n\tpublic getEndOffset(tokenIndex: number): number {\n\t\treturn this._tokens[tokenIndex << 1];\n\t}\n\n\t/**\n\t * Find the token containing offset `offset`.\n\t * @param offset The search offset\n\t * @return The index of the token containing the offset.\n\t */\n\tpublic findTokenIndexAtOffset(offset: number): number {\n\t\treturn LineTokens.findIndexInTokensArray(this._tokens, offset);\n\t}\n\n\tpublic inflate(): IViewLineTokens {\n\t\treturn this;\n\t}\n\n\tpublic sliceAndInflate(startOffset: number, endOffset: number, deltaOffset: number): IViewLineTokens {\n\t\treturn new SliceLineTokens(this, startOffset, endOffset, deltaOffset);\n\t}\n\n\tpublic static convertToEndOffset(tokens: Uint32Array, lineTextLength: number): void {\n\t\tconst tokenCount = (tokens.length >>> 1);\n\t\tconst lastTokenIndex = tokenCount - 1;\n\t\tfor (let tokenIndex = 0; tokenIndex < lastTokenIndex; tokenIndex++) {\n\t\t\ttokens[tokenIndex << 1] = tokens[(tokenIndex + 1) << 1];\n\t\t}\n\t\ttokens[lastTokenIndex << 1] = lineTextLength;\n\t}\n\n\tpublic static findIndexInTokensArray(tokens: Uint32Array, desiredIndex: number): number {\n\t\tif (tokens.length <= 2) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tlet low = 0;\n\t\tlet high = (tokens.length >>> 1) - 1;\n\n\t\twhile (low < high) {\n\n\t\t\tconst mid = low + Math.floor((high - low) / 2);\n\t\t\tconst endOffset = tokens[(mid << 1)];\n\n\t\t\tif (endOffset === desiredIndex) {\n\t\t\t\treturn mid + 1;\n\t\t\t} else if (endOffset < desiredIndex) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else if (endOffset > desiredIndex) {\n\t\t\t\thigh = mid;\n\t\t\t}\n\t\t}\n\n\t\treturn low;\n\t}\n\n\t/**\n\t * @pure\n\t * @param insertTokens Must be sorted by offset.\n\t*/\n\tpublic withInserted(insertTokens: { offset: number; text: string; tokenMetadata: number }[]): LineTokens {\n\t\tif (insertTokens.length === 0) {\n\t\t\treturn this;\n\t\t}\n\n\t\tlet nextOriginalTokenIdx = 0;\n\t\tlet nextInsertTokenIdx = 0;\n\t\tlet text = '';\n\t\tconst newTokens = new Array<number>();\n\n\t\tlet originalEndOffset = 0;\n\t\twhile (true) {\n\t\t\tconst nextOriginalTokenEndOffset = nextOriginalTokenIdx < this._tokensCount ? this._tokens[nextOriginalTokenIdx << 1] : -1;\n\t\t\tconst nextInsertToken = nextInsertTokenIdx < insertTokens.length ? insertTokens[nextInsertTokenIdx] : null;\n\n\t\t\tif (nextOriginalTokenEndOffset !== -1 && (nextInsertToken === null || nextOriginalTokenEndOffset <= nextInsertToken.offset)) {\n\t\t\t\t// original token ends before next insert token\n\t\t\t\ttext += this._text.substring(originalEndOffset, nextOriginalTokenEndOffset);\n\t\t\t\tconst metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];\n\t\t\t\tnewTokens.push(text.length, metadata);\n\t\t\t\tnextOriginalTokenIdx++;\n\t\t\t\toriginalEndOffset = nextOriginalTokenEndOffset;\n\n\t\t\t} else if (nextInsertToken) {\n\t\t\t\tif (nextInsertToken.offset > originalEndOffset) {\n\t\t\t\t\t// insert token is in the middle of the next token.\n\t\t\t\t\ttext += this._text.substring(originalEndOffset, nextInsertToken.offset);\n\t\t\t\t\tconst metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];\n\t\t\t\t\tnewTokens.push(text.length, metadata);\n\t\t\t\t\toriginalEndOffset = nextInsertToken.offset;\n\t\t\t\t}\n\n\t\t\t\ttext += nextInsertToken.text;\n\t\t\t\tnewTokens.push(text.length, nextInsertToken.tokenMetadata);\n\t\t\t\tnextInsertTokenIdx++;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn new LineTokens(new Uint32Array(newTokens), text, this._languageIdCodec);\n\t}\n}\n\nclass SliceLineTokens implements IViewLineTokens {\n\n\tprivate readonly _source: LineTokens;\n\tprivate readonly _startOffset: number;\n\tprivate readonly _endOffset: number;\n\tprivate readonly _deltaOffset: number;\n\n\tprivate readonly _firstTokenIndex: number;\n\tprivate readonly _tokensCount: number;\n\n\tconstructor(source: LineTokens, startOffset: number, endOffset: number, deltaOffset: number) {\n\t\tthis._source = source;\n\t\tthis._startOffset = startOffset;\n\t\tthis._endOffset = endOffset;\n\t\tthis._deltaOffset = deltaOffset;\n\t\tthis._firstTokenIndex = source.findTokenIndexAtOffset(startOffset);\n\n\t\tthis._tokensCount = 0;\n\t\tfor (let i = this._firstTokenIndex, len = source.getCount(); i < len; i++) {\n\t\t\tconst tokenStartOffset = source.getStartOffset(i);\n\t\t\tif (tokenStartOffset >= endOffset) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis._tokensCount++;\n\t\t}\n\t}\n\n\tpublic getMetadata(tokenIndex: number): number {\n\t\treturn this._source.getMetadata(this._firstTokenIndex + tokenIndex);\n\t}\n\n\tpublic getLanguageId(tokenIndex: number): string {\n\t\treturn this._source.getLanguageId(this._firstTokenIndex + tokenIndex);\n\t}\n\n\tpublic getLineContent(): string {\n\t\treturn this._source.getLineContent().substring(this._startOffset, this._endOffset);\n\t}\n\n\tpublic equals(other: IViewLineTokens): boolean {\n\t\tif (other instanceof SliceLineTokens) {\n\t\t\treturn (\n\t\t\t\tthis._startOffset === other._startOffset\n\t\t\t\t&& this._endOffset === other._endOffset\n\t\t\t\t&& this._deltaOffset === other._deltaOffset\n\t\t\t\t&& this._source.slicedEquals(other._source, this._firstTokenIndex, this._tokensCount)\n\t\t\t);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic getCount(): number {\n\t\treturn this._tokensCount;\n\t}\n\n\tpublic getForeground(tokenIndex: number): ColorId {\n\t\treturn this._source.getForeground(this._firstTokenIndex + tokenIndex);\n\t}\n\n\tpublic getEndOffset(tokenIndex: number): number {\n\t\tconst tokenEndOffset = this._source.getEndOffset(this._firstTokenIndex + tokenIndex);\n\t\treturn Math.min(this._endOffset, tokenEndOffset) - this._startOffset + this._deltaOffset;\n\t}\n\n\tpublic getClassName(tokenIndex: number): string {\n\t\treturn this._source.getClassName(this._firstTokenIndex + tokenIndex);\n\t}\n\n\tpublic getInlineStyle(tokenIndex: number, colorMap: string[]): string {\n\t\treturn this._source.getInlineStyle(this._firstTokenIndex + tokenIndex, colorMap);\n\t}\n\n\tpublic getPresentation(tokenIndex: number): ITokenPresentation {\n\t\treturn this._source.getPresentation(this._firstTokenIndex + tokenIndex);\n\t}\n\n\tpublic findTokenIndexAtOffset(offset: number): number {\n\t\treturn this._source.findTokenIndexAtOffset(offset + this._startOffset - this._deltaOffset) - this._firstTokenIndex;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { LineTokens } from 'vs/editor/common/tokens/lineTokens';\n\nexport const EMPTY_LINE_TOKENS = (new Uint32Array(0)).buffer;\n\nexport class ContiguousTokensEditing {\n\n\tpublic static deleteBeginning(lineTokens: Uint32Array | ArrayBuffer | null, toChIndex: number): Uint32Array | ArrayBuffer | null {\n\t\tif (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n\t\t\treturn lineTokens;\n\t\t}\n\t\treturn ContiguousTokensEditing.delete(lineTokens, 0, toChIndex);\n\t}\n\n\tpublic static deleteEnding(lineTokens: Uint32Array | ArrayBuffer | null, fromChIndex: number): Uint32Array | ArrayBuffer | null {\n\t\tif (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n\t\t\treturn lineTokens;\n\t\t}\n\n\t\tconst tokens = toUint32Array(lineTokens);\n\t\tconst lineTextLength = tokens[tokens.length - 2];\n\t\treturn ContiguousTokensEditing.delete(lineTokens, fromChIndex, lineTextLength);\n\t}\n\n\tpublic static delete(lineTokens: Uint32Array | ArrayBuffer | null, fromChIndex: number, toChIndex: number): Uint32Array | ArrayBuffer | null {\n\t\tif (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS || fromChIndex === toChIndex) {\n\t\t\treturn lineTokens;\n\t\t}\n\n\t\tconst tokens = toUint32Array(lineTokens);\n\t\tconst tokensCount = (tokens.length >>> 1);\n\n\t\t// special case: deleting everything\n\t\tif (fromChIndex === 0 && tokens[tokens.length - 2] === toChIndex) {\n\t\t\treturn EMPTY_LINE_TOKENS;\n\t\t}\n\n\t\tconst fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, fromChIndex);\n\t\tconst fromTokenStartOffset = (fromTokenIndex > 0 ? tokens[(fromTokenIndex - 1) << 1] : 0);\n\t\tconst fromTokenEndOffset = tokens[fromTokenIndex << 1];\n\n\t\tif (toChIndex < fromTokenEndOffset) {\n\t\t\t// the delete range is inside a single token\n\t\t\tconst delta = (toChIndex - fromChIndex);\n\t\t\tfor (let i = fromTokenIndex; i < tokensCount; i++) {\n\t\t\t\ttokens[i << 1] -= delta;\n\t\t\t}\n\t\t\treturn lineTokens;\n\t\t}\n\n\t\tlet dest: number;\n\t\tlet lastEnd: number;\n\t\tif (fromTokenStartOffset !== fromChIndex) {\n\t\t\ttokens[fromTokenIndex << 1] = fromChIndex;\n\t\t\tdest = ((fromTokenIndex + 1) << 1);\n\t\t\tlastEnd = fromChIndex;\n\t\t} else {\n\t\t\tdest = (fromTokenIndex << 1);\n\t\t\tlastEnd = fromTokenStartOffset;\n\t\t}\n\n\t\tconst delta = (toChIndex - fromChIndex);\n\t\tfor (let tokenIndex = fromTokenIndex + 1; tokenIndex < tokensCount; tokenIndex++) {\n\t\t\tconst tokenEndOffset = tokens[tokenIndex << 1] - delta;\n\t\t\tif (tokenEndOffset > lastEnd) {\n\t\t\t\ttokens[dest++] = tokenEndOffset;\n\t\t\t\ttokens[dest++] = tokens[(tokenIndex << 1) + 1];\n\t\t\t\tlastEnd = tokenEndOffset;\n\t\t\t}\n\t\t}\n\n\t\tif (dest === tokens.length) {\n\t\t\t// nothing to trim\n\t\t\treturn lineTokens;\n\t\t}\n\n\t\tconst tmp = new Uint32Array(dest);\n\t\ttmp.set(tokens.subarray(0, dest), 0);\n\t\treturn tmp.buffer;\n\t}\n\n\tpublic static append(lineTokens: Uint32Array | ArrayBuffer | null, _otherTokens: Uint32Array | ArrayBuffer | null): Uint32Array | ArrayBuffer | null {\n\t\tif (_otherTokens === EMPTY_LINE_TOKENS) {\n\t\t\treturn lineTokens;\n\t\t}\n\t\tif (lineTokens === EMPTY_LINE_TOKENS) {\n\t\t\treturn _otherTokens;\n\t\t}\n\t\tif (lineTokens === null) {\n\t\t\treturn lineTokens;\n\t\t}\n\t\tif (_otherTokens === null) {\n\t\t\t// cannot determine combined line length...\n\t\t\treturn null;\n\t\t}\n\t\tconst myTokens = toUint32Array(lineTokens);\n\t\tconst otherTokens = toUint32Array(_otherTokens);\n\t\tconst otherTokensCount = (otherTokens.length >>> 1);\n\n\t\tconst result = new Uint32Array(myTokens.length + otherTokens.length);\n\t\tresult.set(myTokens, 0);\n\t\tlet dest = myTokens.length;\n\t\tconst delta = myTokens[myTokens.length - 2];\n\t\tfor (let i = 0; i < otherTokensCount; i++) {\n\t\t\tresult[dest++] = otherTokens[(i << 1)] + delta;\n\t\t\tresult[dest++] = otherTokens[(i << 1) + 1];\n\t\t}\n\t\treturn result.buffer;\n\t}\n\n\tpublic static insert(lineTokens: Uint32Array | ArrayBuffer | null, chIndex: number, textLength: number): Uint32Array | ArrayBuffer | null {\n\t\tif (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n\t\t\t// nothing to do\n\t\t\treturn lineTokens;\n\t\t}\n\n\t\tconst tokens = toUint32Array(lineTokens);\n\t\tconst tokensCount = (tokens.length >>> 1);\n\n\t\tlet fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, chIndex);\n\t\tif (fromTokenIndex > 0) {\n\t\t\tconst fromTokenStartOffset = tokens[(fromTokenIndex - 1) << 1];\n\t\t\tif (fromTokenStartOffset === chIndex) {\n\t\t\t\tfromTokenIndex--;\n\t\t\t}\n\t\t}\n\t\tfor (let tokenIndex = fromTokenIndex; tokenIndex < tokensCount; tokenIndex++) {\n\t\t\ttokens[tokenIndex << 1] += textLength;\n\t\t}\n\t\treturn lineTokens;\n\t}\n}\n\nexport function toUint32Array(arr: Uint32Array | ArrayBuffer): Uint32Array {\n\tif (arr instanceof Uint32Array) {\n\t\treturn arr;\n\t} else {\n\t\treturn new Uint32Array(arr);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as arrays from 'vs/base/common/arrays';\nimport { readUInt32BE, writeUInt32BE } from 'vs/base/common/buffer';\nimport { Position } from 'vs/editor/common/core/position';\nimport { IRange } from 'vs/editor/common/core/range';\nimport { countEOL } from 'vs/editor/common/core/eolCounter';\nimport { ContiguousTokensEditing } from 'vs/editor/common/tokens/contiguousTokensEditing';\nimport { LineRange } from 'vs/editor/common/core/lineRange';\n\n/**\n * Represents contiguous tokens over a contiguous range of lines.\n */\nexport class ContiguousMultilineTokens {\n\tpublic static deserialize(buff: Uint8Array, offset: number, result: ContiguousMultilineTokens[]): number {\n\t\tconst view32 = new Uint32Array(buff.buffer);\n\t\tconst startLineNumber = readUInt32BE(buff, offset); offset += 4;\n\t\tconst count = readUInt32BE(buff, offset); offset += 4;\n\t\tconst tokens: Uint32Array[] = [];\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tconst byteCount = readUInt32BE(buff, offset); offset += 4;\n\t\t\ttokens.push(view32.subarray(offset / 4, offset / 4 + byteCount / 4));\n\t\t\toffset += byteCount;\n\t\t}\n\t\tresult.push(new ContiguousMultilineTokens(startLineNumber, tokens));\n\t\treturn offset;\n\t}\n\n\t/**\n\t * The start line number for this block of tokens.\n\t */\n\tprivate _startLineNumber: number;\n\n\t/**\n\t * The tokens are stored in a binary format. There is an element for each line,\n\t * so `tokens[index]` contains all tokens on line `startLineNumber + index`.\n\t *\n\t * On a specific line, each token occupies two array indices. For token i:\n\t *  - at offset 2*i => endOffset\n\t *  - at offset 2*i + 1 => metadata\n\t *\n\t */\n\tprivate _tokens: (Uint32Array | ArrayBuffer | null)[];\n\n\t/**\n\t * (Inclusive) start line number for these tokens.\n\t */\n\tpublic get startLineNumber(): number {\n\t\treturn this._startLineNumber;\n\t}\n\n\t/**\n\t * (Inclusive) end line number for these tokens.\n\t */\n\tpublic get endLineNumber(): number {\n\t\treturn this._startLineNumber + this._tokens.length - 1;\n\t}\n\n\tconstructor(startLineNumber: number, tokens: Uint32Array[]) {\n\t\tthis._startLineNumber = startLineNumber;\n\t\tthis._tokens = tokens;\n\t}\n\n\tgetLineRange(): LineRange {\n\t\treturn new LineRange(this._startLineNumber, this._startLineNumber + this._tokens.length);\n\t}\n\n\t/**\n\t * @see {@link _tokens}\n\t */\n\tpublic getLineTokens(lineNumber: number): Uint32Array | ArrayBuffer | null {\n\t\treturn this._tokens[lineNumber - this._startLineNumber];\n\t}\n\n\tpublic appendLineTokens(lineTokens: Uint32Array): void {\n\t\tthis._tokens.push(lineTokens);\n\t}\n\n\tpublic serializeSize(): number {\n\t\tlet result = 0;\n\t\tresult += 4; // 4 bytes for the start line number\n\t\tresult += 4; // 4 bytes for the line count\n\t\tfor (let i = 0; i < this._tokens.length; i++) {\n\t\t\tconst lineTokens = this._tokens[i];\n\t\t\tif (!(lineTokens instanceof Uint32Array)) {\n\t\t\t\tthrow new Error(`Not supported!`);\n\t\t\t}\n\t\t\tresult += 4; // 4 bytes for the byte count\n\t\t\tresult += lineTokens.byteLength;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic serialize(destination: Uint8Array, offset: number): number {\n\t\twriteUInt32BE(destination, this._startLineNumber, offset); offset += 4;\n\t\twriteUInt32BE(destination, this._tokens.length, offset); offset += 4;\n\t\tfor (let i = 0; i < this._tokens.length; i++) {\n\t\t\tconst lineTokens = this._tokens[i];\n\t\t\tif (!(lineTokens instanceof Uint32Array)) {\n\t\t\t\tthrow new Error(`Not supported!`);\n\t\t\t}\n\t\t\twriteUInt32BE(destination, lineTokens.byteLength, offset); offset += 4;\n\t\t\tdestination.set(new Uint8Array(lineTokens.buffer), offset); offset += lineTokens.byteLength;\n\t\t}\n\t\treturn offset;\n\t}\n\n\tpublic applyEdit(range: IRange, text: string): void {\n\t\tconst [eolCount, firstLineLength] = countEOL(text);\n\t\tthis._acceptDeleteRange(range);\n\t\tthis._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength);\n\t}\n\n\tprivate _acceptDeleteRange(range: IRange): void {\n\t\tif (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n\t\t\t// Nothing to delete\n\t\t\treturn;\n\t\t}\n\n\t\tconst firstLineIndex = range.startLineNumber - this._startLineNumber;\n\t\tconst lastLineIndex = range.endLineNumber - this._startLineNumber;\n\n\t\tif (lastLineIndex < 0) {\n\t\t\t// this deletion occurs entirely before this block, so we only need to adjust line numbers\n\t\t\tconst deletedLinesCount = lastLineIndex - firstLineIndex;\n\t\t\tthis._startLineNumber -= deletedLinesCount;\n\t\t\treturn;\n\t\t}\n\n\t\tif (firstLineIndex >= this._tokens.length) {\n\t\t\t// this deletion occurs entirely after this block, so there is nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tif (firstLineIndex < 0 && lastLineIndex >= this._tokens.length) {\n\t\t\t// this deletion completely encompasses this block\n\t\t\tthis._startLineNumber = 0;\n\t\t\tthis._tokens = [];\n\t\t\treturn;\n\t\t}\n\n\t\tif (firstLineIndex === lastLineIndex) {\n\t\t\t// a delete on a single line\n\t\t\tthis._tokens[firstLineIndex] = ContiguousTokensEditing.delete(this._tokens[firstLineIndex], range.startColumn - 1, range.endColumn - 1);\n\t\t\treturn;\n\t\t}\n\n\t\tif (firstLineIndex >= 0) {\n\t\t\t// The first line survives\n\t\t\tthis._tokens[firstLineIndex] = ContiguousTokensEditing.deleteEnding(this._tokens[firstLineIndex], range.startColumn - 1);\n\n\t\t\tif (lastLineIndex < this._tokens.length) {\n\t\t\t\t// The last line survives\n\t\t\t\tconst lastLineTokens = ContiguousTokensEditing.deleteBeginning(this._tokens[lastLineIndex], range.endColumn - 1);\n\n\t\t\t\t// Take remaining text on last line and append it to remaining text on first line\n\t\t\t\tthis._tokens[firstLineIndex] = ContiguousTokensEditing.append(this._tokens[firstLineIndex], lastLineTokens);\n\n\t\t\t\t// Delete middle lines\n\t\t\t\tthis._tokens.splice(firstLineIndex + 1, lastLineIndex - firstLineIndex);\n\t\t\t} else {\n\t\t\t\t// The last line does not survive\n\n\t\t\t\t// Take remaining text on last line and append it to remaining text on first line\n\t\t\t\tthis._tokens[firstLineIndex] = ContiguousTokensEditing.append(this._tokens[firstLineIndex], null);\n\n\t\t\t\t// Delete lines\n\t\t\t\tthis._tokens = this._tokens.slice(0, firstLineIndex + 1);\n\t\t\t}\n\t\t} else {\n\t\t\t// The first line does not survive\n\n\t\t\tconst deletedBefore = -firstLineIndex;\n\t\t\tthis._startLineNumber -= deletedBefore;\n\n\t\t\t// Remove beginning from last line\n\t\t\tthis._tokens[lastLineIndex] = ContiguousTokensEditing.deleteBeginning(this._tokens[lastLineIndex], range.endColumn - 1);\n\n\t\t\t// Delete lines\n\t\t\tthis._tokens = this._tokens.slice(lastLineIndex);\n\t\t}\n\t}\n\n\tprivate _acceptInsertText(position: Position, eolCount: number, firstLineLength: number): void {\n\n\t\tif (eolCount === 0 && firstLineLength === 0) {\n\t\t\t// Nothing to insert\n\t\t\treturn;\n\t\t}\n\n\t\tconst lineIndex = position.lineNumber - this._startLineNumber;\n\n\t\tif (lineIndex < 0) {\n\t\t\t// this insertion occurs before this block, so we only need to adjust line numbers\n\t\t\tthis._startLineNumber += eolCount;\n\t\t\treturn;\n\t\t}\n\n\t\tif (lineIndex >= this._tokens.length) {\n\t\t\t// this insertion occurs after this block, so there is nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tif (eolCount === 0) {\n\t\t\t// Inserting text on one line\n\t\t\tthis._tokens[lineIndex] = ContiguousTokensEditing.insert(this._tokens[lineIndex], position.column - 1, firstLineLength);\n\t\t\treturn;\n\t\t}\n\n\t\tthis._tokens[lineIndex] = ContiguousTokensEditing.deleteEnding(this._tokens[lineIndex], position.column - 1);\n\t\tthis._tokens[lineIndex] = ContiguousTokensEditing.insert(this._tokens[lineIndex], position.column - 1, firstLineLength);\n\n\t\tthis._insertLines(position.lineNumber, eolCount);\n\t}\n\n\tprivate _insertLines(insertIndex: number, insertCount: number): void {\n\t\tif (insertCount === 0) {\n\t\t\treturn;\n\t\t}\n\t\tconst lineTokens: (Uint32Array | ArrayBuffer | null)[] = [];\n\t\tfor (let i = 0; i < insertCount; i++) {\n\t\t\tlineTokens[i] = null;\n\t\t}\n\t\tthis._tokens = arrays.arrayInsert(this._tokens, insertIndex, lineTokens);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { readUInt32BE, writeUInt32BE } from 'vs/base/common/buffer';\nimport { ContiguousMultilineTokens } from 'vs/editor/common/tokens/contiguousMultilineTokens';\n\nexport class ContiguousMultilineTokensBuilder {\n\n\tpublic static deserialize(buff: Uint8Array): ContiguousMultilineTokens[] {\n\t\tlet offset = 0;\n\t\tconst count = readUInt32BE(buff, offset); offset += 4;\n\t\tconst result: ContiguousMultilineTokens[] = [];\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\toffset = ContiguousMultilineTokens.deserialize(buff, offset, result);\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate readonly _tokens: ContiguousMultilineTokens[];\n\n\tconstructor() {\n\t\tthis._tokens = [];\n\t}\n\n\tpublic add(lineNumber: number, lineTokens: Uint32Array): void {\n\t\tif (this._tokens.length > 0) {\n\t\t\tconst last = this._tokens[this._tokens.length - 1];\n\t\t\tif (last.endLineNumber + 1 === lineNumber) {\n\t\t\t\t// append\n\t\t\t\tlast.appendLineTokens(lineTokens);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tthis._tokens.push(new ContiguousMultilineTokens(lineNumber, [lineTokens]));\n\t}\n\n\tpublic finalize(): ContiguousMultilineTokens[] {\n\t\treturn this._tokens;\n\t}\n\n\tpublic serialize(): Uint8Array {\n\t\tconst size = this._serializeSize();\n\t\tconst result = new Uint8Array(size);\n\t\tthis._serialize(result);\n\t\treturn result;\n\t}\n\n\tprivate _serializeSize(): number {\n\t\tlet result = 0;\n\t\tresult += 4; // 4 bytes for the count\n\t\tfor (let i = 0; i < this._tokens.length; i++) {\n\t\t\tresult += this._tokens[i].serializeSize();\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate _serialize(destination: Uint8Array): void {\n\t\tlet offset = 0;\n\t\twriteUInt32BE(destination, this._tokens.length, offset); offset += 4;\n\t\tfor (let i = 0; i < this._tokens.length; i++) {\n\t\t\toffset = this._tokens[i].serialize(destination, offset);\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport { isAbsolute, join, normalize, posix, sep } from 'vs/base/common/path';\nimport { isWindows } from 'vs/base/common/platform';\nimport { equalsIgnoreCase, rtrim, startsWithIgnoreCase } from 'vs/base/common/strings';\nimport { isNumber } from 'vs/base/common/types';\n\nexport function isPathSeparator(code: number) {\n\treturn code === CharCode.Slash || code === CharCode.Backslash;\n}\n\n/**\n * Takes a Windows OS path and changes backward slashes to forward slashes.\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\nexport function toSlashes(osPath: string) {\n\treturn osPath.replace(/[\\\\/]/g, posix.sep);\n}\n\n/**\n * Takes a Windows OS path (using backward or forward slashes) and turns it into a posix path:\n * - turns backward slashes into forward slashes\n * - makes it absolute if it starts with a drive letter\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\nexport function toPosixPath(osPath: string) {\n\tif (osPath.indexOf('/') === -1) {\n\t\tosPath = toSlashes(osPath);\n\t}\n\tif (/^[a-zA-Z]:(\\/|$)/.test(osPath)) { // starts with a drive letter\n\t\tosPath = '/' + osPath;\n\t}\n\treturn osPath;\n}\n\n/**\n * Computes the _root_ this path, like `getRoot('c:\\files') === c:\\`,\n * `getRoot('files:///files/path') === files:///`,\n * or `getRoot('\\\\server\\shares\\path') === \\\\server\\shares\\`\n */\nexport function getRoot(path: string, sep: string = posix.sep): string {\n\tif (!path) {\n\t\treturn '';\n\t}\n\n\tconst len = path.length;\n\tconst firstLetter = path.charCodeAt(0);\n\tif (isPathSeparator(firstLetter)) {\n\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t// UNC candidate \\\\localhost\\shares\\ddd\n\t\t\t//               ^^^^^^^^^^^^^^^^^^^\n\t\t\tif (!isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\tlet pos = 3;\n\t\t\t\tconst start = pos;\n\t\t\t\tfor (; pos < len; pos++) {\n\t\t\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (start !== pos && !isPathSeparator(path.charCodeAt(pos + 1))) {\n\t\t\t\t\tpos += 1;\n\t\t\t\t\tfor (; pos < len; pos++) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\t\t\t\treturn path.slice(0, pos + 1) // consume this separator\n\t\t\t\t\t\t\t\t.replace(/[\\\\/]/g, sep);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// /user/far\n\t\t// ^\n\t\treturn sep;\n\n\t} else if (isWindowsDriveLetter(firstLetter)) {\n\t\t// check for windows drive letter c:\\ or c:\n\n\t\tif (path.charCodeAt(1) === CharCode.Colon) {\n\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t// C:\\fff\n\t\t\t\t// ^^^\n\t\t\t\treturn path.slice(0, 2) + sep;\n\t\t\t} else {\n\t\t\t\t// C:\n\t\t\t\t// ^^\n\t\t\t\treturn path.slice(0, 2);\n\t\t\t}\n\t\t}\n\t}\n\n\t// check for URI\n\t// scheme://authority/path\n\t// ^^^^^^^^^^^^^^^^^^^\n\tlet pos = path.indexOf('://');\n\tif (pos !== -1) {\n\t\tpos += 3; // 3 -> \"://\".length\n\t\tfor (; pos < len; pos++) {\n\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\treturn path.slice(0, pos + 1); // consume this separator\n\t\t\t}\n\t\t}\n\t}\n\n\treturn '';\n}\n\n/**\n * Check if the path follows this pattern: `\\\\hostname\\sharename`.\n *\n * @see https://msdn.microsoft.com/en-us/library/gg465305.aspx\n * @return A boolean indication if the path is a UNC path, on none-windows\n * always false.\n */\nexport function isUNC(path: string): boolean {\n\tif (!isWindows) {\n\t\t// UNC is a windows concept\n\t\treturn false;\n\t}\n\n\tif (!path || path.length < 5) {\n\t\t// at least \\\\a\\b\n\t\treturn false;\n\t}\n\n\tlet code = path.charCodeAt(0);\n\tif (code !== CharCode.Backslash) {\n\t\treturn false;\n\t}\n\n\tcode = path.charCodeAt(1);\n\n\tif (code !== CharCode.Backslash) {\n\t\treturn false;\n\t}\n\n\tlet pos = 2;\n\tconst start = pos;\n\tfor (; pos < path.length; pos++) {\n\t\tcode = path.charCodeAt(pos);\n\t\tif (code === CharCode.Backslash) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (start === pos) {\n\t\treturn false;\n\t}\n\n\tcode = path.charCodeAt(pos + 1);\n\n\tif (isNaN(code) || code === CharCode.Backslash) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n// Reference: https://en.wikipedia.org/wiki/Filename\nconst WINDOWS_INVALID_FILE_CHARS = /[\\\\/:\\*\\?\"<>\\|]/g;\nconst UNIX_INVALID_FILE_CHARS = /[\\\\/]/g;\nconst WINDOWS_FORBIDDEN_NAMES = /^(con|prn|aux|clock\\$|nul|lpt[0-9]|com[0-9])(\\.(.*?))?$/i;\nexport function isValidBasename(name: string | null | undefined, isWindowsOS: boolean = isWindows): boolean {\n\tconst invalidFileChars = isWindowsOS ? WINDOWS_INVALID_FILE_CHARS : UNIX_INVALID_FILE_CHARS;\n\n\tif (!name || name.length === 0 || /^\\s+$/.test(name)) {\n\t\treturn false; // require a name that is not just whitespace\n\t}\n\n\tinvalidFileChars.lastIndex = 0; // the holy grail of software development\n\tif (invalidFileChars.test(name)) {\n\t\treturn false; // check for certain invalid file characters\n\t}\n\n\tif (isWindowsOS && WINDOWS_FORBIDDEN_NAMES.test(name)) {\n\t\treturn false; // check for certain invalid file names\n\t}\n\n\tif (name === '.' || name === '..') {\n\t\treturn false; // check for reserved values\n\t}\n\n\tif (isWindowsOS && name[name.length - 1] === '.') {\n\t\treturn false; // Windows: file cannot end with a \".\"\n\t}\n\n\tif (isWindowsOS && name.length !== name.trim().length) {\n\t\treturn false; // Windows: file cannot end with a whitespace\n\t}\n\n\tif (name.length > 255) {\n\t\treturn false; // most file systems do not allow files > 255 length\n\t}\n\n\treturn true;\n}\n\n/**\n * @deprecated please use `IUriIdentityService.extUri.isEqual` instead. If you are\n * in a context without services, consider to pass down the `extUri` from the outside\n * or use `extUriBiasedIgnorePathCase` if you know what you are doing.\n */\nexport function isEqual(pathA: string, pathB: string, ignoreCase?: boolean): boolean {\n\tconst identityEquals = (pathA === pathB);\n\tif (!ignoreCase || identityEquals) {\n\t\treturn identityEquals;\n\t}\n\n\tif (!pathA || !pathB) {\n\t\treturn false;\n\t}\n\n\treturn equalsIgnoreCase(pathA, pathB);\n}\n\n/**\n * @deprecated please use `IUriIdentityService.extUri.isEqualOrParent` instead. If\n * you are in a context without services, consider to pass down the `extUri` from the\n * outside, or use `extUriBiasedIgnorePathCase` if you know what you are doing.\n */\nexport function isEqualOrParent(base: string, parentCandidate: string, ignoreCase?: boolean, separator = sep): boolean {\n\tif (base === parentCandidate) {\n\t\treturn true;\n\t}\n\n\tif (!base || !parentCandidate) {\n\t\treturn false;\n\t}\n\n\tif (parentCandidate.length > base.length) {\n\t\treturn false;\n\t}\n\n\tif (ignoreCase) {\n\t\tconst beginsWith = startsWithIgnoreCase(base, parentCandidate);\n\t\tif (!beginsWith) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (parentCandidate.length === base.length) {\n\t\t\treturn true; // same path, different casing\n\t\t}\n\n\t\tlet sepOffset = parentCandidate.length;\n\t\tif (parentCandidate.charAt(parentCandidate.length - 1) === separator) {\n\t\t\tsepOffset--; // adjust the expected sep offset in case our candidate already ends in separator character\n\t\t}\n\n\t\treturn base.charAt(sepOffset) === separator;\n\t}\n\n\tif (parentCandidate.charAt(parentCandidate.length - 1) !== separator) {\n\t\tparentCandidate += separator;\n\t}\n\n\treturn base.indexOf(parentCandidate) === 0;\n}\n\nexport function isWindowsDriveLetter(char0: number): boolean {\n\treturn char0 >= CharCode.A && char0 <= CharCode.Z || char0 >= CharCode.a && char0 <= CharCode.z;\n}\n\nexport function sanitizeFilePath(candidate: string, cwd: string): string {\n\n\t// Special case: allow to open a drive letter without trailing backslash\n\tif (isWindows && candidate.endsWith(':')) {\n\t\tcandidate += sep;\n\t}\n\n\t// Ensure absolute\n\tif (!isAbsolute(candidate)) {\n\t\tcandidate = join(cwd, candidate);\n\t}\n\n\t// Ensure normalized\n\tcandidate = normalize(candidate);\n\n\t// Ensure no trailing slash/backslash\n\tif (isWindows) {\n\t\tcandidate = rtrim(candidate, sep);\n\n\t\t// Special case: allow to open drive root ('C:\\')\n\t\tif (candidate.endsWith(':')) {\n\t\t\tcandidate += sep;\n\t\t}\n\n\t} else {\n\t\tcandidate = rtrim(candidate, sep);\n\n\t\t// Special case: allow to open root ('/')\n\t\tif (!candidate) {\n\t\t\tcandidate = sep;\n\t\t}\n\t}\n\n\treturn candidate;\n}\n\nexport function isRootOrDriveLetter(path: string): boolean {\n\tconst pathNormalized = normalize(path);\n\n\tif (isWindows) {\n\t\tif (path.length > 3) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn hasDriveLetter(pathNormalized) &&\n\t\t\t(path.length === 2 || pathNormalized.charCodeAt(2) === CharCode.Backslash);\n\t}\n\n\treturn pathNormalized === posix.sep;\n}\n\nexport function hasDriveLetter(path: string, isWindowsOS: boolean = isWindows): boolean {\n\tif (isWindowsOS) {\n\t\treturn isWindowsDriveLetter(path.charCodeAt(0)) && path.charCodeAt(1) === CharCode.Colon;\n\t}\n\n\treturn false;\n}\n\nexport function getDriveLetter(path: string, isWindowsOS: boolean = isWindows): string | undefined {\n\treturn hasDriveLetter(path, isWindowsOS) ? path[0] : undefined;\n}\n\nexport function indexOfPath(path: string, candidate: string, ignoreCase?: boolean): number {\n\tif (candidate.length > path.length) {\n\t\treturn -1;\n\t}\n\n\tif (path === candidate) {\n\t\treturn 0;\n\t}\n\n\tif (ignoreCase) {\n\t\tpath = path.toLowerCase();\n\t\tcandidate = candidate.toLowerCase();\n\t}\n\n\treturn path.indexOf(candidate);\n}\n\nexport interface IPathWithLineAndColumn {\n\tpath: string;\n\tline?: number;\n\tcolumn?: number;\n}\n\nexport function parseLineAndColumnAware(rawPath: string): IPathWithLineAndColumn {\n\tconst segments = rawPath.split(':'); // C:\\file.txt:<line>:<column>\n\n\tlet path: string | undefined = undefined;\n\tlet line: number | undefined = undefined;\n\tlet column: number | undefined = undefined;\n\n\tfor (const segment of segments) {\n\t\tconst segmentAsNumber = Number(segment);\n\t\tif (!isNumber(segmentAsNumber)) {\n\t\t\tpath = !!path ? [path, segment].join(':') : segment; // a colon can well be part of a path (e.g. C:\\...)\n\t\t} else if (line === undefined) {\n\t\t\tline = segmentAsNumber;\n\t\t} else if (column === undefined) {\n\t\t\tcolumn = segmentAsNumber;\n\t\t}\n\t}\n\n\tif (!path) {\n\t\tthrow new Error('Format for `--goto` should be: `FILE:LINE(:COLUMN)`');\n\t}\n\n\treturn {\n\t\tpath,\n\t\tline: line !== undefined ? line : undefined,\n\t\tcolumn: column !== undefined ? column : line !== undefined ? 1 : undefined // if we have a line, make sure column is also set\n\t};\n}\n\nconst pathChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\nconst windowsSafePathFirstChars = 'BDEFGHIJKMOQRSTUVWXYZbdefghijkmoqrstuvwxyz0123456789';\n\nexport function randomPath(parent?: string, prefix?: string, randomLength = 8): string {\n\tlet suffix = '';\n\tfor (let i = 0; i < randomLength; i++) {\n\t\tlet pathCharsTouse: string;\n\t\tif (i === 0 && isWindows && !prefix && (randomLength === 3 || randomLength === 4)) {\n\n\t\t\t// Windows has certain reserved file names that cannot be used, such\n\t\t\t// as AUX, CON, PRN, etc. We want to avoid generating a random name\n\t\t\t// that matches that pattern, so we use a different set of characters\n\t\t\t// for the first character of the name that does not include any of\n\t\t\t// the reserved names first characters.\n\n\t\t\tpathCharsTouse = windowsSafePathFirstChars;\n\t\t} else {\n\t\t\tpathCharsTouse = pathChars;\n\t\t}\n\n\t\tsuffix += pathCharsTouse.charAt(Math.floor(Math.random() * pathCharsTouse.length));\n\t}\n\n\tlet randomFileName: string;\n\tif (prefix) {\n\t\trandomFileName = `${prefix}-${suffix}`;\n\t} else {\n\t\trandomFileName = suffix;\n\t}\n\n\tif (parent) {\n\t\treturn join(parent, randomFileName);\n\t}\n\n\treturn randomFileName;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as errors from 'vs/base/common/errors';\nimport * as platform from 'vs/base/common/platform';\nimport { equalsIgnoreCase, startsWithIgnoreCase } from 'vs/base/common/strings';\nimport { URI } from 'vs/base/common/uri';\nimport * as paths from 'vs/base/common/path';\n\nexport namespace Schemas {\n\n\t/**\n\t * A schema that is used for models that exist in memory\n\t * only and that have no correspondence on a server or such.\n\t */\n\texport const inMemory = 'inmemory';\n\n\t/**\n\t * A schema that is used for setting files\n\t */\n\texport const vscode = 'vscode';\n\n\t/**\n\t * A schema that is used for internal private files\n\t */\n\texport const internal = 'private';\n\n\t/**\n\t * A walk-through document.\n\t */\n\texport const walkThrough = 'walkThrough';\n\n\t/**\n\t * An embedded code snippet.\n\t */\n\texport const walkThroughSnippet = 'walkThroughSnippet';\n\n\texport const http = 'http';\n\n\texport const https = 'https';\n\n\texport const file = 'file';\n\n\texport const mailto = 'mailto';\n\n\texport const untitled = 'untitled';\n\n\texport const data = 'data';\n\n\texport const command = 'command';\n\n\texport const vscodeRemote = 'vscode-remote';\n\n\texport const vscodeRemoteResource = 'vscode-remote-resource';\n\n\texport const vscodeManagedRemoteResource = 'vscode-managed-remote-resource';\n\n\texport const vscodeUserData = 'vscode-userdata';\n\n\texport const vscodeCustomEditor = 'vscode-custom-editor';\n\n\texport const vscodeNotebookCell = 'vscode-notebook-cell';\n\texport const vscodeNotebookCellMetadata = 'vscode-notebook-cell-metadata';\n\texport const vscodeNotebookCellOutput = 'vscode-notebook-cell-output';\n\texport const vscodeInteractiveInput = 'vscode-interactive-input';\n\n\texport const vscodeSettings = 'vscode-settings';\n\n\texport const vscodeWorkspaceTrust = 'vscode-workspace-trust';\n\n\texport const vscodeTerminal = 'vscode-terminal';\n\n\t/** Scheme used for code blocks in chat. */\n\texport const vscodeChatCodeBlock = 'vscode-chat-code-block';\n\t/** Scheme used for the chat input editor. */\n\texport const vscodeChatSesssion = 'vscode-chat-editor';\n\n\t/**\n\t * Scheme used internally for webviews that aren't linked to a resource (i.e. not custom editors)\n\t */\n\texport const webviewPanel = 'webview-panel';\n\n\t/**\n\t * Scheme used for loading the wrapper html and script in webviews.\n\t */\n\texport const vscodeWebview = 'vscode-webview';\n\n\t/**\n\t * Scheme used for extension pages\n\t */\n\texport const extension = 'extension';\n\n\t/**\n\t * Scheme used as a replacement of `file` scheme to load\n\t * files with our custom protocol handler (desktop only).\n\t */\n\texport const vscodeFileResource = 'vscode-file';\n\n\t/**\n\t * Scheme used for temporary resources\n\t */\n\texport const tmp = 'tmp';\n\n\t/**\n\t * Scheme used vs live share\n\t */\n\texport const vsls = 'vsls';\n\n\t/**\n\t * Scheme used for the Source Control commit input's text document\n\t */\n\texport const vscodeSourceControl = 'vscode-scm';\n\n\t/**\n\t * Scheme used for special rendering of settings in the release notes\n\t */\n\texport const codeSetting = 'code-setting';\n}\n\nexport function matchesScheme(target: URI | string, scheme: string): boolean {\n\tif (URI.isUri(target)) {\n\t\treturn equalsIgnoreCase(target.scheme, scheme);\n\t} else {\n\t\treturn startsWithIgnoreCase(target, scheme + ':');\n\t}\n}\n\nexport function matchesSomeScheme(target: URI | string, ...schemes: string[]): boolean {\n\treturn schemes.some(scheme => matchesScheme(target, scheme));\n}\n\nexport const connectionTokenCookieName = 'vscode-tkn';\nexport const connectionTokenQueryName = 'tkn';\n\nclass RemoteAuthoritiesImpl {\n\tprivate readonly _hosts: { [authority: string]: string | undefined } = Object.create(null);\n\tprivate readonly _ports: { [authority: string]: number | undefined } = Object.create(null);\n\tprivate readonly _connectionTokens: { [authority: string]: string | undefined } = Object.create(null);\n\tprivate _preferredWebSchema: 'http' | 'https' = 'http';\n\tprivate _delegate: ((uri: URI) => URI) | null = null;\n\tprivate _serverRootPath: string = '/';\n\n\tsetPreferredWebSchema(schema: 'http' | 'https') {\n\t\tthis._preferredWebSchema = schema;\n\t}\n\n\tsetDelegate(delegate: (uri: URI) => URI): void {\n\t\tthis._delegate = delegate;\n\t}\n\n\tsetServerRootPath(product: { quality?: string; commit?: string }, serverBasePath: string | undefined): void {\n\t\tthis._serverRootPath = getServerRootPath(product, serverBasePath);\n\t}\n\n\tgetServerRootPath(): string {\n\t\treturn this._serverRootPath;\n\t}\n\n\tprivate get _remoteResourcesPath(): string {\n\t\treturn paths.posix.join(this._serverRootPath, Schemas.vscodeRemoteResource);\n\t}\n\n\tset(authority: string, host: string, port: number): void {\n\t\tthis._hosts[authority] = host;\n\t\tthis._ports[authority] = port;\n\t}\n\n\tsetConnectionToken(authority: string, connectionToken: string): void {\n\t\tthis._connectionTokens[authority] = connectionToken;\n\t}\n\n\tgetPreferredWebSchema(): 'http' | 'https' {\n\t\treturn this._preferredWebSchema;\n\t}\n\n\trewrite(uri: URI): URI {\n\t\tif (this._delegate) {\n\t\t\ttry {\n\t\t\t\treturn this._delegate(uri);\n\t\t\t} catch (err) {\n\t\t\t\terrors.onUnexpectedError(err);\n\t\t\t\treturn uri;\n\t\t\t}\n\t\t}\n\t\tconst authority = uri.authority;\n\t\tlet host = this._hosts[authority];\n\t\tif (host && host.indexOf(':') !== -1 && host.indexOf('[') === -1) {\n\t\t\thost = `[${host}]`;\n\t\t}\n\t\tconst port = this._ports[authority];\n\t\tconst connectionToken = this._connectionTokens[authority];\n\t\tlet query = `path=${encodeURIComponent(uri.path)}`;\n\t\tif (typeof connectionToken === 'string') {\n\t\t\tquery += `&${connectionTokenQueryName}=${encodeURIComponent(connectionToken)}`;\n\t\t}\n\t\treturn URI.from({\n\t\t\tscheme: platform.isWeb ? this._preferredWebSchema : Schemas.vscodeRemoteResource,\n\t\t\tauthority: `${host}:${port}`,\n\t\t\tpath: this._remoteResourcesPath,\n\t\t\tquery\n\t\t});\n\t}\n}\n\nexport const RemoteAuthorities = new RemoteAuthoritiesImpl();\n\nexport function getServerRootPath(product: { quality?: string; commit?: string }, basePath: string | undefined): string {\n\treturn paths.posix.join(basePath ?? '/', `${product.quality ?? 'oss'}-${product.commit ?? 'dev'}`);\n}\n\n/**\n * A string pointing to a path inside the app. It should not begin with ./ or ../\n */\nexport type AppResourcePath = (\n\t`a${string}` | `b${string}` | `c${string}` | `d${string}` | `e${string}` | `f${string}`\n\t| `g${string}` | `h${string}` | `i${string}` | `j${string}` | `k${string}` | `l${string}`\n\t| `m${string}` | `n${string}` | `o${string}` | `p${string}` | `q${string}` | `r${string}`\n\t| `s${string}` | `t${string}` | `u${string}` | `v${string}` | `w${string}` | `x${string}`\n\t| `y${string}` | `z${string}`\n);\n\nexport const builtinExtensionsPath: AppResourcePath = 'vs/../../extensions';\nexport const nodeModulesPath: AppResourcePath = 'vs/../../node_modules';\nexport const nodeModulesAsarPath: AppResourcePath = 'vs/../../node_modules.asar';\nexport const nodeModulesAsarUnpackedPath: AppResourcePath = 'vs/../../node_modules.asar.unpacked';\n\nexport const VSCODE_AUTHORITY = 'vscode-app';\n\nclass FileAccessImpl {\n\n\tprivate static readonly FALLBACK_AUTHORITY = VSCODE_AUTHORITY;\n\n\t/**\n\t * Returns a URI to use in contexts where the browser is responsible\n\t * for loading (e.g. fetch()) or when used within the DOM.\n\t *\n\t * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.\n\t */\n\tasBrowserUri(resourcePath: AppResourcePath | ''): URI {\n\t\tconst uri = this.toUri(resourcePath, require);\n\t\treturn this.uriToBrowserUri(uri);\n\t}\n\n\t/**\n\t * Returns a URI to use in contexts where the browser is responsible\n\t * for loading (e.g. fetch()) or when used within the DOM.\n\t *\n\t * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.\n\t */\n\turiToBrowserUri(uri: URI): URI {\n\t\t// Handle remote URIs via `RemoteAuthorities`\n\t\tif (uri.scheme === Schemas.vscodeRemote) {\n\t\t\treturn RemoteAuthorities.rewrite(uri);\n\t\t}\n\n\t\t// Convert to `vscode-file` resource..\n\t\tif (\n\t\t\t// ...only ever for `file` resources\n\t\t\turi.scheme === Schemas.file &&\n\t\t\t(\n\t\t\t\t// ...and we run in native environments\n\t\t\t\tplatform.isNative ||\n\t\t\t\t// ...or web worker extensions on desktop\n\t\t\t\t(platform.webWorkerOrigin === `${Schemas.vscodeFileResource}://${FileAccessImpl.FALLBACK_AUTHORITY}`)\n\t\t\t)\n\t\t) {\n\t\t\treturn uri.with({\n\t\t\t\tscheme: Schemas.vscodeFileResource,\n\t\t\t\t// We need to provide an authority here so that it can serve\n\t\t\t\t// as origin for network and loading matters in chromium.\n\t\t\t\t// If the URI is not coming with an authority already, we\n\t\t\t\t// add our own\n\t\t\t\tauthority: uri.authority || FileAccessImpl.FALLBACK_AUTHORITY,\n\t\t\t\tquery: null,\n\t\t\t\tfragment: null\n\t\t\t});\n\t\t}\n\n\t\treturn uri;\n\t}\n\n\t/**\n\t * Returns the `file` URI to use in contexts where node.js\n\t * is responsible for loading.\n\t */\n\tasFileUri(resourcePath: AppResourcePath | ''): URI {\n\t\tconst uri = this.toUri(resourcePath, require);\n\t\treturn this.uriToFileUri(uri);\n\t}\n\n\t/**\n\t * Returns the `file` URI to use in contexts where node.js\n\t * is responsible for loading.\n\t */\n\turiToFileUri(uri: URI): URI {\n\t\t// Only convert the URI if it is `vscode-file:` scheme\n\t\tif (uri.scheme === Schemas.vscodeFileResource) {\n\t\t\treturn uri.with({\n\t\t\t\tscheme: Schemas.file,\n\t\t\t\t// Only preserve the `authority` if it is different from\n\t\t\t\t// our fallback authority. This ensures we properly preserve\n\t\t\t\t// Windows UNC paths that come with their own authority.\n\t\t\t\tauthority: uri.authority !== FileAccessImpl.FALLBACK_AUTHORITY ? uri.authority : null,\n\t\t\t\tquery: null,\n\t\t\t\tfragment: null\n\t\t\t});\n\t\t}\n\n\t\treturn uri;\n\t}\n\n\tprivate toUri(uriOrModule: URI | string, moduleIdToUrl: { toUrl(moduleId: string): string }): URI {\n\t\tif (URI.isUri(uriOrModule)) {\n\t\t\treturn uriOrModule;\n\t\t}\n\n\t\treturn URI.parse(moduleIdToUrl.toUrl(uriOrModule));\n\t}\n}\n\nexport const FileAccess = new FileAccessImpl();\n\n\nexport namespace COI {\n\n\tconst coiHeaders = new Map<'3' | '2' | '1' | string, Record<string, string>>([\n\t\t['1', { 'Cross-Origin-Opener-Policy': 'same-origin' }],\n\t\t['2', { 'Cross-Origin-Embedder-Policy': 'require-corp' }],\n\t\t['3', { 'Cross-Origin-Opener-Policy': 'same-origin', 'Cross-Origin-Embedder-Policy': 'require-corp' }],\n\t]);\n\n\texport const CoopAndCoep = Object.freeze(coiHeaders.get('3'));\n\n\tconst coiSearchParamName = 'vscode-coi';\n\n\t/**\n\t * Extract desired headers from `vscode-coi` invocation\n\t */\n\texport function getHeadersFromQuery(url: string | URI | URL): Record<string, string> | undefined {\n\t\tlet params: URLSearchParams | undefined;\n\t\tif (typeof url === 'string') {\n\t\t\tparams = new URL(url).searchParams;\n\t\t} else if (url instanceof URL) {\n\t\t\tparams = url.searchParams;\n\t\t} else if (URI.isUri(url)) {\n\t\t\tparams = new URL(url.toString(true)).searchParams;\n\t\t}\n\t\tconst value = params?.get(coiSearchParamName);\n\t\tif (!value) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn coiHeaders.get(value);\n\t}\n\n\t/**\n\t * Add the `vscode-coi` query attribute based on wanting `COOP` and `COEP`. Will be a noop when `crossOriginIsolated`\n\t * isn't enabled the current context\n\t */\n\texport function addSearchParam(urlOrSearch: URLSearchParams | Record<string, string>, coop: boolean, coep: boolean): void {\n\t\tif (!(<any>globalThis).crossOriginIsolated) {\n\t\t\t// depends on the current context being COI\n\t\t\treturn;\n\t\t}\n\t\tconst value = coop && coep ? '3' : coep ? '2' : '1';\n\t\tif (urlOrSearch instanceof URLSearchParams) {\n\t\t\turlOrSearch.set(coiSearchParamName, value);\n\t\t} else {\n\t\t\t(<Record<string, string>>urlOrSearch)[coiSearchParamName] = value;\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { isESM } from 'vs/base/common/amd';\nimport { AppResourcePath, FileAccess, nodeModulesAsarPath, nodeModulesPath } from 'vs/base/common/network';\nimport * as platform from 'vs/base/common/platform';\nimport { IProductConfiguration } from 'vs/base/common/product';\nimport { URI } from 'vs/base/common/uri';\n\n\nclass DefineCall {\n\tconstructor(\n\t\tpublic readonly id: string | null | undefined,\n\t\tpublic readonly dependencies: string[] | null | undefined,\n\t\tpublic readonly callback: any\n\t) { }\n}\n\nclass AMDModuleImporter {\n\tpublic static INSTANCE = new AMDModuleImporter();\n\n\tprivate readonly _isWebWorker = (typeof self === 'object' && self.constructor && self.constructor.name === 'DedicatedWorkerGlobalScope');\n\tprivate readonly _isRenderer = typeof document === 'object';\n\n\tprivate readonly _defineCalls: DefineCall[] = [];\n\tprivate _initialized = false;\n\tprivate _amdPolicy: Pick<TrustedTypePolicy<{\n\t\tcreateScriptURL(value: string): string;\n\t}>, 'name' | 'createScriptURL'> | undefined;\n\n\tconstructor() { }\n\n\tprivate _initialize(): void {\n\t\tif (this._initialized) {\n\t\t\treturn;\n\t\t}\n\t\tthis._initialized = true;\n\n\t\t(<any>globalThis).define = (id: any, dependencies: any, callback: any) => {\n\t\t\tif (typeof id !== 'string') {\n\t\t\t\tcallback = dependencies;\n\t\t\t\tdependencies = id;\n\t\t\t\tid = null;\n\t\t\t}\n\t\t\tif (typeof dependencies !== 'object' || !Array.isArray(dependencies)) {\n\t\t\t\tcallback = dependencies;\n\t\t\t\tdependencies = null;\n\t\t\t}\n\t\t\t// if (!dependencies) {\n\t\t\t// \tdependencies = ['require', 'exports', 'module'];\n\t\t\t// }\n\t\t\tthis._defineCalls.push(new DefineCall(id, dependencies, callback));\n\t\t};\n\n\t\t(<any>globalThis).define.amd = true;\n\n\t\tif (this._isRenderer) {\n\t\t\t// eslint-disable-next-line no-restricted-globals\n\t\t\tthis._amdPolicy = window.trustedTypes?.createPolicy('amdLoader', {\n\t\t\t\tcreateScriptURL(value) {\n\t\t\t\t\t// eslint-disable-next-line no-restricted-globals\n\t\t\t\t\tif (value.startsWith(window.location.origin)) {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t\tif (value.startsWith('vscode-file://vscode-app')) {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t\tthrow new Error(`[trusted_script_src] Invalid script url: ${value}`);\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (this._isWebWorker) {\n\t\t\tthis._amdPolicy = (<any>globalThis).trustedTypes?.createPolicy('amdLoader', {\n\t\t\t\tcreateScriptURL(value: string) {\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tpublic async load<T>(scriptSrc: string): Promise<T> {\n\t\tthis._initialize();\n\t\tconst defineCall = await (this._isWebWorker ? this._workerLoadScript(scriptSrc) : this._isRenderer ? this._rendererLoadScript(scriptSrc) : this._nodeJSLoadScript(scriptSrc));\n\t\tif (!defineCall) {\n\t\t\tthrow new Error(`Did not receive a define call from script ${scriptSrc}`);\n\t\t}\n\t\t// TODO require, exports, module\n\t\tif (Array.isArray(defineCall.dependencies) && defineCall.dependencies.length > 0) {\n\t\t\tthrow new Error(`Cannot resolve dependencies for script ${scriptSrc}. The dependencies are: ${defineCall.dependencies.join(', ')}`);\n\t\t}\n\t\tif (typeof defineCall.callback === 'function') {\n\t\t\treturn defineCall.callback([]);\n\t\t} else {\n\t\t\treturn defineCall.callback;\n\t\t}\n\t}\n\n\tprivate _rendererLoadScript(scriptSrc: string): Promise<DefineCall | undefined> {\n\t\treturn new Promise<DefineCall | undefined>((resolve, reject) => {\n\t\t\tconst scriptElement = document.createElement('script');\n\t\t\tscriptElement.setAttribute('async', 'async');\n\t\t\tscriptElement.setAttribute('type', 'text/javascript');\n\n\t\t\tconst unbind = () => {\n\t\t\t\tscriptElement.removeEventListener('load', loadEventListener);\n\t\t\t\tscriptElement.removeEventListener('error', errorEventListener);\n\t\t\t};\n\n\t\t\tconst loadEventListener = (e: any) => {\n\t\t\t\tunbind();\n\t\t\t\tresolve(this._defineCalls.pop());\n\t\t\t};\n\n\t\t\tconst errorEventListener = (e: any) => {\n\t\t\t\tunbind();\n\t\t\t\treject(e);\n\t\t\t};\n\n\t\t\tscriptElement.addEventListener('load', loadEventListener);\n\t\t\tscriptElement.addEventListener('error', errorEventListener);\n\t\t\tif (this._amdPolicy) {\n\t\t\t\tscriptSrc = this._amdPolicy.createScriptURL(scriptSrc) as any as string;\n\t\t\t}\n\t\t\tscriptElement.setAttribute('src', scriptSrc);\n\t\t\t// eslint-disable-next-line no-restricted-globals\n\t\t\twindow.document.getElementsByTagName('head')[0].appendChild(scriptElement);\n\t\t});\n\t}\n\n\tprivate _workerLoadScript(scriptSrc: string): Promise<DefineCall | undefined> {\n\t\treturn new Promise<DefineCall | undefined>((resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tif (this._amdPolicy) {\n\t\t\t\t\tscriptSrc = this._amdPolicy.createScriptURL(scriptSrc) as any as string;\n\t\t\t\t}\n\t\t\t\timportScripts(scriptSrc);\n\t\t\t\tresolve(this._defineCalls.pop());\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate async _nodeJSLoadScript(scriptSrc: string): Promise<DefineCall | undefined> {\n\t\ttry {\n\t\t\tconst fs = <typeof import('fs')>globalThis._VSCODE_NODE_MODULES['fs'];\n\t\t\tconst vm = <typeof import('vm')>globalThis._VSCODE_NODE_MODULES['vm'];\n\t\t\tconst module = <typeof import('module')>globalThis._VSCODE_NODE_MODULES['module'];\n\n\t\t\tconst filePath = URI.parse(scriptSrc).fsPath;\n\t\t\tconst content = fs.readFileSync(filePath).toString();\n\t\t\tconst scriptSource = module.wrap(content.replace(/^#!.*/, ''));\n\t\t\tconst script = new vm.Script(scriptSource);\n\t\t\tconst compileWrapper = script.runInThisContext();\n\t\t\tcompileWrapper.apply();\n\t\t\treturn this._defineCalls.pop();\n\n\t\t} catch (error) {\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n\nconst cache = new Map<string, Promise<any>>();\n\nlet _paths: Record<string, string> = {};\nif (typeof globalThis.require === 'object') {\n\t_paths = (<Record<string, any>>globalThis.require).paths ?? {};\n}\n\n/**\n * Utility for importing an AMD node module. This util supports AMD and ESM contexts and should be used while the ESM adoption\n * is on its way.\n *\n * e.g. pass in `vscode-textmate/release/main.js`\n */\nexport async function importAMDNodeModule<T>(nodeModuleName: string, pathInsideNodeModule: string, isBuilt?: boolean): Promise<T> {\n\tif (isESM) {\n\n\t\tif (isBuilt === undefined) {\n\t\t\tconst product = globalThis._VSCODE_PRODUCT_JSON as unknown as IProductConfiguration;\n\t\t\tisBuilt = Boolean((product ?? (<any>globalThis).vscode?.context?.configuration()?.product)?.commit);\n\t\t}\n\n\t\tif (_paths[nodeModuleName]) {\n\t\t\tnodeModuleName = _paths[nodeModuleName];\n\t\t}\n\n\t\tconst nodeModulePath = `${nodeModuleName}/${pathInsideNodeModule}`;\n\t\tif (cache.has(nodeModulePath)) {\n\t\t\treturn cache.get(nodeModulePath)!;\n\t\t}\n\t\tlet scriptSrc: string;\n\t\tif (/^\\w[\\w\\d+.-]*:\\/\\//.test(nodeModulePath)) {\n\t\t\t// looks like a URL\n\t\t\t// bit of a special case for: src/vs/workbench/services/languageDetection/browser/languageDetectionSimpleWorker.ts\n\t\t\tscriptSrc = nodeModulePath;\n\t\t} else {\n\t\t\tconst useASAR = (isBuilt && !platform.isWeb);\n\t\t\tconst actualNodeModulesPath = (useASAR ? nodeModulesAsarPath : nodeModulesPath);\n\t\t\tconst resourcePath: AppResourcePath = `${actualNodeModulesPath}/${nodeModulePath}`;\n\t\t\tscriptSrc = FileAccess.asBrowserUri(resourcePath).toString(true);\n\t\t}\n\t\tconst result = AMDModuleImporter.INSTANCE.load<T>(scriptSrc);\n\t\tcache.set(nodeModulePath, result);\n\t\treturn result;\n\t} else {\n\t\treturn await import(nodeModuleName);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport * as extpath from 'vs/base/common/extpath';\nimport { Schemas } from 'vs/base/common/network';\nimport * as paths from 'vs/base/common/path';\nimport { isLinux, isWindows } from 'vs/base/common/platform';\nimport { compare as strCompare, equalsIgnoreCase } from 'vs/base/common/strings';\nimport { URI, uriToFsPath } from 'vs/base/common/uri';\n\nexport function originalFSPath(uri: URI): string {\n\treturn uriToFsPath(uri, true);\n}\n\n//#region IExtUri\n\nexport interface IExtUri {\n\n\t// --- identity\n\n\t/**\n\t * Compares two uris.\n\t *\n\t * @param uri1 Uri\n\t * @param uri2 Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tcompare(uri1: URI, uri2: URI, ignoreFragment?: boolean): number;\n\n\t/**\n\t * Tests whether two uris are equal\n\t *\n\t * @param uri1 Uri\n\t * @param uri2 Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tisEqual(uri1: URI | undefined, uri2: URI | undefined, ignoreFragment?: boolean): boolean;\n\n\t/**\n\t * Tests whether a `candidate` URI is a parent or equal of a given `base` URI.\n\t *\n\t * @param base A uri which is \"longer\" or at least same length as `parentCandidate`\n\t * @param parentCandidate A uri which is \"shorter\" or up to same length as `base`\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tisEqualOrParent(base: URI, parentCandidate: URI, ignoreFragment?: boolean): boolean;\n\n\t/**\n\t * Creates a key from a resource URI to be used to resource comparison and for resource maps.\n\t * @see {@link ResourceMap}\n\t * @param uri Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tgetComparisonKey(uri: URI, ignoreFragment?: boolean): string;\n\n\t/**\n\t * Whether the casing of the path-component of the uri should be ignored.\n\t */\n\tignorePathCasing(uri: URI): boolean;\n\n\t// --- path math\n\n\tbasenameOrAuthority(resource: URI): string;\n\n\t/**\n\t * Returns the basename of the path component of an uri.\n\t * @param resource\n\t */\n\tbasename(resource: URI): string;\n\n\t/**\n\t * Returns the extension of the path component of an uri.\n\t * @param resource\n\t */\n\textname(resource: URI): string;\n\t/**\n\t * Return a URI representing the directory of a URI path.\n\t *\n\t * @param resource The input URI.\n\t * @returns The URI representing the directory of the input URI.\n\t */\n\tdirname(resource: URI): URI;\n\t/**\n\t * Join a URI path with path fragments and normalizes the resulting path.\n\t *\n\t * @param resource The input URI.\n\t * @param pathFragment The path fragment to add to the URI path.\n\t * @returns The resulting URI.\n\t */\n\tjoinPath(resource: URI, ...pathFragment: string[]): URI;\n\t/**\n\t * Normalizes the path part of a URI: Resolves `.` and `..` elements with directory names.\n\t *\n\t * @param resource The URI to normalize the path.\n\t * @returns The URI with the normalized path.\n\t */\n\tnormalizePath(resource: URI): URI;\n\t/**\n\t *\n\t * @param from\n\t * @param to\n\t */\n\trelativePath(from: URI, to: URI): string | undefined;\n\t/**\n\t * Resolves an absolute or relative path against a base URI.\n\t * The path can be relative or absolute posix or a Windows path\n\t */\n\tresolvePath(base: URI, path: string): URI;\n\n\t// --- misc\n\n\t/**\n\t * Returns true if the URI path is absolute.\n\t */\n\tisAbsolutePath(resource: URI): boolean;\n\t/**\n\t * Tests whether the two authorities are the same\n\t */\n\tisEqualAuthority(a1: string, a2: string): boolean;\n\t/**\n\t * Returns true if the URI path has a trailing path separator\n\t */\n\thasTrailingPathSeparator(resource: URI, sep?: string): boolean;\n\t/**\n\t * Removes a trailing path separator, if there's one.\n\t * Important: Doesn't remove the first slash, it would make the URI invalid\n\t */\n\tremoveTrailingPathSeparator(resource: URI, sep?: string): URI;\n\t/**\n\t * Adds a trailing path separator to the URI if there isn't one already.\n\t * For example, c:\\ would be unchanged, but c:\\users would become c:\\users\\\n\t */\n\taddTrailingPathSeparator(resource: URI, sep?: string): URI;\n}\n\nexport class ExtUri implements IExtUri {\n\n\tconstructor(private _ignorePathCasing: (uri: URI) => boolean) { }\n\n\tcompare(uri1: URI, uri2: URI, ignoreFragment: boolean = false): number {\n\t\tif (uri1 === uri2) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn strCompare(this.getComparisonKey(uri1, ignoreFragment), this.getComparisonKey(uri2, ignoreFragment));\n\t}\n\n\tisEqual(uri1: URI | undefined, uri2: URI | undefined, ignoreFragment: boolean = false): boolean {\n\t\tif (uri1 === uri2) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!uri1 || !uri2) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this.getComparisonKey(uri1, ignoreFragment) === this.getComparisonKey(uri2, ignoreFragment);\n\t}\n\n\tgetComparisonKey(uri: URI, ignoreFragment: boolean = false): string {\n\t\treturn uri.with({\n\t\t\tpath: this._ignorePathCasing(uri) ? uri.path.toLowerCase() : undefined,\n\t\t\tfragment: ignoreFragment ? null : undefined\n\t\t}).toString();\n\t}\n\n\tignorePathCasing(uri: URI): boolean {\n\t\treturn this._ignorePathCasing(uri);\n\t}\n\n\tisEqualOrParent(base: URI, parentCandidate: URI, ignoreFragment: boolean = false): boolean {\n\t\tif (base.scheme === parentCandidate.scheme) {\n\t\t\tif (base.scheme === Schemas.file) {\n\t\t\t\treturn extpath.isEqualOrParent(originalFSPath(base), originalFSPath(parentCandidate), this._ignorePathCasing(base)) && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n\t\t\t}\n\t\t\tif (isEqualAuthority(base.authority, parentCandidate.authority)) {\n\t\t\t\treturn extpath.isEqualOrParent(base.path, parentCandidate.path, this._ignorePathCasing(base), '/') && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t// --- path math\n\n\tjoinPath(resource: URI, ...pathFragment: string[]): URI {\n\t\treturn URI.joinPath(resource, ...pathFragment);\n\t}\n\n\tbasenameOrAuthority(resource: URI): string {\n\t\treturn basename(resource) || resource.authority;\n\t}\n\n\tbasename(resource: URI): string {\n\t\treturn paths.posix.basename(resource.path);\n\t}\n\n\textname(resource: URI): string {\n\t\treturn paths.posix.extname(resource.path);\n\t}\n\n\tdirname(resource: URI): URI {\n\t\tif (resource.path.length === 0) {\n\t\t\treturn resource;\n\t\t}\n\t\tlet dirname;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tdirname = URI.file(paths.dirname(originalFSPath(resource))).path;\n\t\t} else {\n\t\t\tdirname = paths.posix.dirname(resource.path);\n\t\t\tif (resource.authority && dirname.length && dirname.charCodeAt(0) !== CharCode.Slash) {\n\t\t\t\tconsole.error(`dirname(\"${resource.toString})) resulted in a relative path`);\n\t\t\t\tdirname = '/'; // If a URI contains an authority component, then the path component must either be empty or begin with a CharCode.Slash (\"/\") character\n\t\t\t}\n\t\t}\n\t\treturn resource.with({\n\t\t\tpath: dirname\n\t\t});\n\t}\n\n\tnormalizePath(resource: URI): URI {\n\t\tif (!resource.path.length) {\n\t\t\treturn resource;\n\t\t}\n\t\tlet normalizedPath: string;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tnormalizedPath = URI.file(paths.normalize(originalFSPath(resource))).path;\n\t\t} else {\n\t\t\tnormalizedPath = paths.posix.normalize(resource.path);\n\t\t}\n\t\treturn resource.with({\n\t\t\tpath: normalizedPath\n\t\t});\n\t}\n\n\trelativePath(from: URI, to: URI): string | undefined {\n\t\tif (from.scheme !== to.scheme || !isEqualAuthority(from.authority, to.authority)) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (from.scheme === Schemas.file) {\n\t\t\tconst relativePath = paths.relative(originalFSPath(from), originalFSPath(to));\n\t\t\treturn isWindows ? extpath.toSlashes(relativePath) : relativePath;\n\t\t}\n\t\tlet fromPath = from.path || '/';\n\t\tconst toPath = to.path || '/';\n\t\tif (this._ignorePathCasing(from)) {\n\t\t\t// make casing of fromPath match toPath\n\t\t\tlet i = 0;\n\t\t\tfor (const len = Math.min(fromPath.length, toPath.length); i < len; i++) {\n\t\t\t\tif (fromPath.charCodeAt(i) !== toPath.charCodeAt(i)) {\n\t\t\t\t\tif (fromPath.charAt(i).toLowerCase() !== toPath.charAt(i).toLowerCase()) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfromPath = toPath.substr(0, i) + fromPath.substr(i);\n\t\t}\n\t\treturn paths.posix.relative(fromPath, toPath);\n\t}\n\n\tresolvePath(base: URI, path: string): URI {\n\t\tif (base.scheme === Schemas.file) {\n\t\t\tconst newURI = URI.file(paths.resolve(originalFSPath(base), path));\n\t\t\treturn base.with({\n\t\t\t\tauthority: newURI.authority,\n\t\t\t\tpath: newURI.path\n\t\t\t});\n\t\t}\n\t\tpath = extpath.toPosixPath(path); // we allow path to be a windows path\n\t\treturn base.with({\n\t\t\tpath: paths.posix.resolve(base.path, path)\n\t\t});\n\t}\n\n\t// --- misc\n\n\tisAbsolutePath(resource: URI): boolean {\n\t\treturn !!resource.path && resource.path[0] === '/';\n\t}\n\n\tisEqualAuthority(a1: string | undefined, a2: string | undefined) {\n\t\treturn a1 === a2 || (a1 !== undefined && a2 !== undefined && equalsIgnoreCase(a1, a2));\n\t}\n\n\thasTrailingPathSeparator(resource: URI, sep: string = paths.sep): boolean {\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tconst fsp = originalFSPath(resource);\n\t\t\treturn fsp.length > extpath.getRoot(fsp).length && fsp[fsp.length - 1] === sep;\n\t\t} else {\n\t\t\tconst p = resource.path;\n\t\t\treturn (p.length > 1 && p.charCodeAt(p.length - 1) === CharCode.Slash) && !(/^[a-zA-Z]:(\\/$|\\\\$)/.test(resource.fsPath)); // ignore the slash at offset 0\n\t\t}\n\t}\n\n\tremoveTrailingPathSeparator(resource: URI, sep: string = paths.sep): URI {\n\t\t// Make sure that the path isn't a drive letter. A trailing separator there is not removable.\n\t\tif (hasTrailingPathSeparator(resource, sep)) {\n\t\t\treturn resource.with({ path: resource.path.substr(0, resource.path.length - 1) });\n\t\t}\n\t\treturn resource;\n\t}\n\n\taddTrailingPathSeparator(resource: URI, sep: string = paths.sep): URI {\n\t\tlet isRootSep: boolean = false;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tconst fsp = originalFSPath(resource);\n\t\t\tisRootSep = ((fsp !== undefined) && (fsp.length === extpath.getRoot(fsp).length) && (fsp[fsp.length - 1] === sep));\n\t\t} else {\n\t\t\tsep = '/';\n\t\t\tconst p = resource.path;\n\t\t\tisRootSep = p.length === 1 && p.charCodeAt(p.length - 1) === CharCode.Slash;\n\t\t}\n\t\tif (!isRootSep && !hasTrailingPathSeparator(resource, sep)) {\n\t\t\treturn resource.with({ path: resource.path + '/' });\n\t\t}\n\t\treturn resource;\n\t}\n}\n\n\n/**\n * Unbiased utility that takes uris \"as they are\". This means it can be interchanged with\n * uri#toString() usages. The following is true\n * ```\n * assertEqual(aUri.toString() === bUri.toString(), exturi.isEqual(aUri, bUri))\n * ```\n */\nexport const extUri = new ExtUri(() => false);\n\n/**\n * BIASED utility that _mostly_ ignored the case of urs paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriBiasedIgnorePathCase = new ExtUri(uri => {\n\t// A file scheme resource is in the same platform as code, so ignore case for non linux platforms\n\t// Resource can be from another platform. Lowering the case as an hack. Should come from File system provider\n\treturn uri.scheme === Schemas.file ? !isLinux : true;\n});\n\n\n/**\n * BIASED utility that always ignores the casing of uris paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriIgnorePathCase = new ExtUri(_ => true);\n\nexport const isEqual = extUri.isEqual.bind(extUri);\nexport const isEqualOrParent = extUri.isEqualOrParent.bind(extUri);\nexport const getComparisonKey = extUri.getComparisonKey.bind(extUri);\nexport const basenameOrAuthority = extUri.basenameOrAuthority.bind(extUri);\nexport const basename = extUri.basename.bind(extUri);\nexport const extname = extUri.extname.bind(extUri);\nexport const dirname = extUri.dirname.bind(extUri);\nexport const joinPath = extUri.joinPath.bind(extUri);\nexport const normalizePath = extUri.normalizePath.bind(extUri);\nexport const relativePath = extUri.relativePath.bind(extUri);\nexport const resolvePath = extUri.resolvePath.bind(extUri);\nexport const isAbsolutePath = extUri.isAbsolutePath.bind(extUri);\nexport const isEqualAuthority = extUri.isEqualAuthority.bind(extUri);\nexport const hasTrailingPathSeparator = extUri.hasTrailingPathSeparator.bind(extUri);\nexport const removeTrailingPathSeparator = extUri.removeTrailingPathSeparator.bind(extUri);\nexport const addTrailingPathSeparator = extUri.addTrailingPathSeparator.bind(extUri);\n\n//#endregion\n\nexport function distinctParents<T>(items: T[], resourceAccessor: (item: T) => URI): T[] {\n\tconst distinctParents: T[] = [];\n\tfor (let i = 0; i < items.length; i++) {\n\t\tconst candidateResource = resourceAccessor(items[i]);\n\t\tif (items.some((otherItem, index) => {\n\t\t\tif (index === i) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn isEqualOrParent(candidateResource, resourceAccessor(otherItem));\n\t\t})) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdistinctParents.push(items[i]);\n\t}\n\n\treturn distinctParents;\n}\n\n/**\n * Data URI related helpers.\n */\nexport namespace DataUri {\n\n\texport const META_DATA_LABEL = 'label';\n\texport const META_DATA_DESCRIPTION = 'description';\n\texport const META_DATA_SIZE = 'size';\n\texport const META_DATA_MIME = 'mime';\n\n\texport function parseMetaData(dataUri: URI): Map<string, string> {\n\t\tconst metadata = new Map<string, string>();\n\n\t\t// Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n\t\t// the metadata is: size:2313;label:SomeLabel;description:SomeDescription\n\t\tconst meta = dataUri.path.substring(dataUri.path.indexOf(';') + 1, dataUri.path.lastIndexOf(';'));\n\t\tmeta.split(';').forEach(property => {\n\t\t\tconst [key, value] = property.split(':');\n\t\t\tif (key && value) {\n\t\t\t\tmetadata.set(key, value);\n\t\t\t}\n\t\t});\n\n\t\t// Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n\t\t// the mime is: image/png\n\t\tconst mime = dataUri.path.substring(0, dataUri.path.indexOf(';'));\n\t\tif (mime) {\n\t\t\tmetadata.set(META_DATA_MIME, mime);\n\t\t}\n\n\t\treturn metadata;\n\t}\n}\n\nexport function toLocalResource(resource: URI, authority: string | undefined, localScheme: string): URI {\n\tif (authority) {\n\t\tlet path = resource.path;\n\t\tif (path && path[0] !== paths.posix.sep) {\n\t\t\tpath = paths.posix.sep + path;\n\t\t}\n\n\t\treturn resource.with({ scheme: localScheme, authority, path });\n\t}\n\n\treturn resource.with({ scheme: localScheme });\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken, CancellationTokenSource } from 'vs/base/common/cancellation';\nimport { BugIndicatingError, CancellationError } from 'vs/base/common/errors';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { Disposable, DisposableMap, DisposableStore, IDisposable, MutableDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { extUri as defaultExtUri, IExtUri } from 'vs/base/common/resources';\nimport { URI } from 'vs/base/common/uri';\nimport { setTimeout0 } from 'vs/base/common/platform';\nimport { MicrotaskDelay } from './symbols';\nimport { Lazy } from 'vs/base/common/lazy';\n\nexport function isThenable<T>(obj: unknown): obj is Promise<T> {\n\treturn !!obj && typeof (obj as unknown as Promise<T>).then === 'function';\n}\n\nexport interface CancelablePromise<T> extends Promise<T> {\n\tcancel(): void;\n}\n\nexport function createCancelablePromise<T>(callback: (token: CancellationToken) => Promise<T>): CancelablePromise<T> {\n\tconst source = new CancellationTokenSource();\n\n\tconst thenable = callback(source.token);\n\tconst promise = new Promise<T>((resolve, reject) => {\n\t\tconst subscription = source.token.onCancellationRequested(() => {\n\t\t\tsubscription.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t\tPromise.resolve(thenable).then(value => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\tresolve(value);\n\t\t}, err => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\treject(err);\n\t\t});\n\t});\n\n\treturn <CancelablePromise<T>>new class {\n\t\tcancel() {\n\t\t\tsource.cancel();\n\t\t\tsource.dispose();\n\t\t}\n\t\tthen<TResult1 = T, TResult2 = never>(resolve?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, reject?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2> {\n\t\t\treturn promise.then(resolve, reject);\n\t\t}\n\t\tcatch<TResult = never>(reject?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult> {\n\t\t\treturn this.then(undefined, reject);\n\t\t}\n\t\tfinally(onfinally?: (() => void) | undefined | null): Promise<T> {\n\t\t\treturn promise.finally(onfinally);\n\t\t}\n\t};\n}\n\n/**\n * Returns a promise that resolves with `undefined` as soon as the passed token is cancelled.\n * @see {@link raceCancellationError}\n */\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken): Promise<T | undefined>;\n\n/**\n * Returns a promise that resolves with `defaultValue` as soon as the passed token is cancelled.\n * @see {@link raceCancellationError}\n */\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue: T): Promise<T>;\n\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue?: T): Promise<T | undefined> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst ref = token.onCancellationRequested(() => {\n\t\t\tref.dispose();\n\t\t\tresolve(defaultValue);\n\t\t});\n\t\tpromise.then(resolve, reject).finally(() => ref.dispose());\n\t});\n}\n\n/**\n * Returns a promise that rejects with an {@CancellationError} as soon as the passed token is cancelled.\n * @see {@link raceCancellation}\n */\nexport function raceCancellationError<T>(promise: Promise<T>, token: CancellationToken): Promise<T> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst ref = token.onCancellationRequested(() => {\n\t\t\tref.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t\tpromise.then(resolve, reject).finally(() => ref.dispose());\n\t});\n}\n\n/**\n * Returns as soon as one of the promises resolves or rejects and cancels remaining promises\n */\nexport async function raceCancellablePromises<T>(cancellablePromises: CancelablePromise<T>[]): Promise<T> {\n\tlet resolvedPromiseIndex = -1;\n\tconst promises = cancellablePromises.map((promise, index) => promise.then(result => { resolvedPromiseIndex = index; return result; }));\n\ttry {\n\t\tconst result = await Promise.race(promises);\n\t\treturn result;\n\t} finally {\n\t\tcancellablePromises.forEach((cancellablePromise, index) => {\n\t\t\tif (index !== resolvedPromiseIndex) {\n\t\t\t\tcancellablePromise.cancel();\n\t\t\t}\n\t\t});\n\t}\n}\n\nexport function raceTimeout<T>(promise: Promise<T>, timeout: number, onTimeout?: () => void): Promise<T | undefined> {\n\tlet promiseResolve: ((value: T | undefined) => void) | undefined = undefined;\n\n\tconst timer = setTimeout(() => {\n\t\tpromiseResolve?.(undefined);\n\t\tonTimeout?.();\n\t}, timeout);\n\n\treturn Promise.race([\n\t\tpromise.finally(() => clearTimeout(timer)),\n\t\tnew Promise<T | undefined>(resolve => promiseResolve = resolve)\n\t]);\n}\n\nexport function asPromise<T>(callback: () => T | Thenable<T>): Promise<T> {\n\treturn new Promise<T>((resolve, reject) => {\n\t\tconst item = callback();\n\t\tif (isThenable<T>(item)) {\n\t\t\titem.then(resolve, reject);\n\t\t} else {\n\t\t\tresolve(item);\n\t\t}\n\t});\n}\n\n/**\n * Creates and returns a new promise, plus its `resolve` and `reject` callbacks.\n *\n * Replace with standardized [`Promise.withResolvers`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/withResolvers) once it is supported\n */\nexport function promiseWithResolvers<T>(): { promise: Promise<T>; resolve: (value: T | PromiseLike<T>) => void; reject: (err?: any) => void } {\n\tlet resolve: (value: T | PromiseLike<T>) => void;\n\tlet reject: (reason?: any) => void;\n\tconst promise = new Promise<T>((res, rej) => {\n\t\tresolve = res;\n\t\treject = rej;\n\t});\n\treturn { promise, resolve: resolve!, reject: reject! };\n}\n\nexport interface ITask<T> {\n\t(): T;\n}\n\n/**\n * A helper to prevent accumulation of sequential async tasks.\n *\n * Imagine a mail man with the sole task of delivering letters. As soon as\n * a letter submitted for delivery, he drives to the destination, delivers it\n * and returns to his base. Imagine that during the trip, N more letters were submitted.\n * When the mail man returns, he picks those N letters and delivers them all in a\n * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.\n *\n * The throttler implements this via the queue() method, by providing it a task\n * factory. Following the example:\n *\n * \t\tconst throttler = new Throttler();\n * \t\tconst letters = [];\n *\n * \t\tfunction deliver() {\n * \t\t\tconst lettersToDeliver = letters;\n * \t\t\tletters = [];\n * \t\t\treturn makeTheTrip(lettersToDeliver);\n * \t\t}\n *\n * \t\tfunction onLetterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tthrottler.queue(deliver);\n * \t\t}\n */\nexport class Throttler implements IDisposable {\n\n\tprivate activePromise: Promise<any> | null;\n\tprivate queuedPromise: Promise<any> | null;\n\tprivate queuedPromiseFactory: ITask<Promise<any>> | null;\n\n\tprivate isDisposed = false;\n\n\tconstructor() {\n\t\tthis.activePromise = null;\n\t\tthis.queuedPromise = null;\n\t\tthis.queuedPromiseFactory = null;\n\t}\n\n\tqueue<T>(promiseFactory: ITask<Promise<T>>): Promise<T> {\n\t\tif (this.isDisposed) {\n\t\t\treturn Promise.reject(new Error('Throttler is disposed'));\n\t\t}\n\n\t\tif (this.activePromise) {\n\t\t\tthis.queuedPromiseFactory = promiseFactory;\n\n\t\t\tif (!this.queuedPromise) {\n\t\t\t\tconst onComplete = () => {\n\t\t\t\t\tthis.queuedPromise = null;\n\n\t\t\t\t\tif (this.isDisposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst result = this.queue(this.queuedPromiseFactory!);\n\t\t\t\t\tthis.queuedPromiseFactory = null;\n\n\t\t\t\t\treturn result;\n\t\t\t\t};\n\n\t\t\t\tthis.queuedPromise = new Promise(resolve => {\n\t\t\t\t\tthis.activePromise!.then(onComplete, onComplete).then(resolve);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tthis.queuedPromise!.then(resolve, reject);\n\t\t\t});\n\t\t}\n\n\t\tthis.activePromise = promiseFactory();\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.activePromise!.then((result: T) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\tresolve(result);\n\t\t\t}, (err: unknown) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\treject(err);\n\t\t\t});\n\t\t});\n\t}\n\n\tdispose(): void {\n\t\tthis.isDisposed = true;\n\t}\n}\n\nexport class Sequencer {\n\n\tprivate current: Promise<unknown> = Promise.resolve(null);\n\n\tqueue<T>(promiseTask: ITask<Promise<T>>): Promise<T> {\n\t\treturn this.current = this.current.then(() => promiseTask(), () => promiseTask());\n\t}\n}\n\nexport class SequencerByKey<TKey> {\n\n\tprivate promiseMap = new Map<TKey, Promise<unknown>>();\n\n\tqueue<T>(key: TKey, promiseTask: ITask<Promise<T>>): Promise<T> {\n\t\tconst runningPromise = this.promiseMap.get(key) ?? Promise.resolve();\n\t\tconst newPromise = runningPromise\n\t\t\t.catch(() => { })\n\t\t\t.then(promiseTask)\n\t\t\t.finally(() => {\n\t\t\t\tif (this.promiseMap.get(key) === newPromise) {\n\t\t\t\t\tthis.promiseMap.delete(key);\n\t\t\t\t}\n\t\t\t});\n\t\tthis.promiseMap.set(key, newPromise);\n\t\treturn newPromise;\n\t}\n}\n\ninterface IScheduledLater extends IDisposable {\n\tisTriggered(): boolean;\n}\n\nconst timeoutDeferred = (timeout: number, fn: () => void): IScheduledLater => {\n\tlet scheduled = true;\n\tconst handle = setTimeout(() => {\n\t\tscheduled = false;\n\t\tfn();\n\t}, timeout);\n\treturn {\n\t\tisTriggered: () => scheduled,\n\t\tdispose: () => {\n\t\t\tclearTimeout(handle);\n\t\t\tscheduled = false;\n\t\t},\n\t};\n};\n\nconst microtaskDeferred = (fn: () => void): IScheduledLater => {\n\tlet scheduled = true;\n\tqueueMicrotask(() => {\n\t\tif (scheduled) {\n\t\t\tscheduled = false;\n\t\t\tfn();\n\t\t}\n\t});\n\n\treturn {\n\t\tisTriggered: () => scheduled,\n\t\tdispose: () => { scheduled = false; },\n\t};\n};\n\n/**\n * A helper to delay (debounce) execution of a task that is being requested often.\n *\n * Following the throttler, now imagine the mail man wants to optimize the number of\n * trips proactively. The trip itself can be long, so he decides not to make the trip\n * as soon as a letter is submitted. Instead he waits a while, in case more\n * letters are submitted. After said waiting period, if no letters were submitted, he\n * decides to make the trip. Imagine that N more letters were submitted after the first\n * one, all within a short period of time between each other. Even though N+1\n * submissions occurred, only 1 delivery was made.\n *\n * The delayer offers this behavior via the trigger() method, into which both the task\n * to be executed and the waiting period (delay) must be passed in as arguments. Following\n * the example:\n *\n * \t\tconst delayer = new Delayer(WAITING_PERIOD);\n * \t\tconst letters = [];\n *\n * \t\tfunction letterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tdelayer.trigger(() => { return makeTheTrip(); });\n * \t\t}\n */\nexport class Delayer<T> implements IDisposable {\n\n\tprivate deferred: IScheduledLater | null;\n\tprivate completionPromise: Promise<any> | null;\n\tprivate doResolve: ((value?: any | Promise<any>) => void) | null;\n\tprivate doReject: ((err: any) => void) | null;\n\tprivate task: ITask<T | Promise<T>> | null;\n\n\tconstructor(public defaultDelay: number | typeof MicrotaskDelay) {\n\t\tthis.deferred = null;\n\t\tthis.completionPromise = null;\n\t\tthis.doResolve = null;\n\t\tthis.doReject = null;\n\t\tthis.task = null;\n\t}\n\n\ttrigger(task: ITask<T | Promise<T>>, delay = this.defaultDelay): Promise<T> {\n\t\tthis.task = task;\n\t\tthis.cancelTimeout();\n\n\t\tif (!this.completionPromise) {\n\t\t\tthis.completionPromise = new Promise((resolve, reject) => {\n\t\t\t\tthis.doResolve = resolve;\n\t\t\t\tthis.doReject = reject;\n\t\t\t}).then(() => {\n\t\t\t\tthis.completionPromise = null;\n\t\t\t\tthis.doResolve = null;\n\t\t\t\tif (this.task) {\n\t\t\t\t\tconst task = this.task;\n\t\t\t\t\tthis.task = null;\n\t\t\t\t\treturn task();\n\t\t\t\t}\n\t\t\t\treturn undefined;\n\t\t\t});\n\t\t}\n\n\t\tconst fn = () => {\n\t\t\tthis.deferred = null;\n\t\t\tthis.doResolve?.(null);\n\t\t};\n\n\t\tthis.deferred = delay === MicrotaskDelay ? microtaskDeferred(fn) : timeoutDeferred(delay, fn);\n\n\t\treturn this.completionPromise;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn !!this.deferred?.isTriggered();\n\t}\n\n\tcancel(): void {\n\t\tthis.cancelTimeout();\n\n\t\tif (this.completionPromise) {\n\t\t\tthis.doReject?.(new CancellationError());\n\t\t\tthis.completionPromise = null;\n\t\t}\n\t}\n\n\tprivate cancelTimeout(): void {\n\t\tthis.deferred?.dispose();\n\t\tthis.deferred = null;\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n}\n\n/**\n * A helper to delay execution of a task that is being requested often, while\n * preventing accumulation of consecutive executions, while the task runs.\n *\n * The mail man is clever and waits for a certain amount of time, before going\n * out to deliver letters. While the mail man is going out, more letters arrive\n * and can only be delivered once he is back. Once he is back the mail man will\n * do one more trip to deliver the letters that have accumulated while he was out.\n */\nexport class ThrottledDelayer<T> {\n\n\tprivate delayer: Delayer<Promise<T>>;\n\tprivate throttler: Throttler;\n\n\tconstructor(defaultDelay: number) {\n\t\tthis.delayer = new Delayer(defaultDelay);\n\t\tthis.throttler = new Throttler();\n\t}\n\n\ttrigger(promiseFactory: ITask<Promise<T>>, delay?: number): Promise<T> {\n\t\treturn this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay) as unknown as Promise<T>;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn this.delayer.isTriggered();\n\t}\n\n\tcancel(): void {\n\t\tthis.delayer.cancel();\n\t}\n\n\tdispose(): void {\n\t\tthis.delayer.dispose();\n\t\tthis.throttler.dispose();\n\t}\n}\n\n/**\n * A barrier that is initially closed and then becomes opened permanently.\n */\nexport class Barrier {\n\tprivate _isOpen: boolean;\n\tprivate _promise: Promise<boolean>;\n\tprivate _completePromise!: (v: boolean) => void;\n\n\tconstructor() {\n\t\tthis._isOpen = false;\n\t\tthis._promise = new Promise<boolean>((c, e) => {\n\t\t\tthis._completePromise = c;\n\t\t});\n\t}\n\n\tisOpen(): boolean {\n\t\treturn this._isOpen;\n\t}\n\n\topen(): void {\n\t\tthis._isOpen = true;\n\t\tthis._completePromise(true);\n\t}\n\n\twait(): Promise<boolean> {\n\t\treturn this._promise;\n\t}\n}\n\n/**\n * A barrier that is initially closed and then becomes opened permanently after a certain period of\n * time or when open is called explicitly\n */\nexport class AutoOpenBarrier extends Barrier {\n\n\tprivate readonly _timeout: any;\n\n\tconstructor(autoOpenTimeMs: number) {\n\t\tsuper();\n\t\tthis._timeout = setTimeout(() => this.open(), autoOpenTimeMs);\n\t}\n\n\toverride open(): void {\n\t\tclearTimeout(this._timeout);\n\t\tsuper.open();\n\t}\n}\n\nexport function timeout(millis: number): CancelablePromise<void>;\nexport function timeout(millis: number, token: CancellationToken): Promise<void>;\nexport function timeout(millis: number, token?: CancellationToken): CancelablePromise<void> | Promise<void> {\n\tif (!token) {\n\t\treturn createCancelablePromise(token => timeout(millis, token));\n\t}\n\n\treturn new Promise((resolve, reject) => {\n\t\tconst handle = setTimeout(() => {\n\t\t\tdisposable.dispose();\n\t\t\tresolve();\n\t\t}, millis);\n\t\tconst disposable = token.onCancellationRequested(() => {\n\t\t\tclearTimeout(handle);\n\t\t\tdisposable.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t});\n}\n\n/**\n * Creates a timeout that can be disposed using its returned value.\n * @param handler The timeout handler.\n * @param timeout An optional timeout in milliseconds.\n * @param store An optional {@link DisposableStore} that will have the timeout disposable managed automatically.\n *\n * @example\n * const store = new DisposableStore;\n * // Call the timeout after 1000ms at which point it will be automatically\n * // evicted from the store.\n * const timeoutDisposable = disposableTimeout(() => {}, 1000, store);\n *\n * if (foo) {\n *   // Cancel the timeout and evict it from store.\n *   timeoutDisposable.dispose();\n * }\n */\nexport function disposableTimeout(handler: () => void, timeout = 0, store?: DisposableStore): IDisposable {\n\tconst timer = setTimeout(() => {\n\t\thandler();\n\t\tif (store) {\n\t\t\tdisposable.dispose();\n\t\t}\n\t}, timeout);\n\tconst disposable = toDisposable(() => {\n\t\tclearTimeout(timer);\n\t\tstore?.deleteAndLeak(disposable);\n\t});\n\tstore?.add(disposable);\n\treturn disposable;\n}\n\n/**\n * Runs the provided list of promise factories in sequential order. The returned\n * promise will complete to an array of results from each promise.\n */\n\nexport function sequence<T>(promiseFactories: ITask<Promise<T>>[]): Promise<T[]> {\n\tconst results: T[] = [];\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tfunction next(): Promise<T> | null {\n\t\treturn index < len ? promiseFactories[index++]() : null;\n\t}\n\n\tfunction thenHandler(result: any): Promise<any> {\n\t\tif (result !== undefined && result !== null) {\n\t\t\tresults.push(result);\n\t\t}\n\n\t\tconst n = next();\n\t\tif (n) {\n\t\t\treturn n.then(thenHandler);\n\t\t}\n\n\t\treturn Promise.resolve(results);\n\t}\n\n\treturn Promise.resolve(null).then(thenHandler);\n}\n\nexport function first<T>(promiseFactories: ITask<Promise<T>>[], shouldStop: (t: T) => boolean = t => !!t, defaultValue: T | null = null): Promise<T | null> {\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tconst loop: () => Promise<T | null> = () => {\n\t\tif (index >= len) {\n\t\t\treturn Promise.resolve(defaultValue);\n\t\t}\n\n\t\tconst factory = promiseFactories[index++];\n\t\tconst promise = Promise.resolve(factory());\n\n\t\treturn promise.then(result => {\n\t\t\tif (shouldStop(result)) {\n\t\t\t\treturn Promise.resolve(result);\n\t\t\t}\n\n\t\t\treturn loop();\n\t\t});\n\t};\n\n\treturn loop();\n}\n\n/**\n * Returns the result of the first promise that matches the \"shouldStop\",\n * running all promises in parallel. Supports cancelable promises.\n */\nexport function firstParallel<T>(promiseList: Promise<T>[], shouldStop?: (t: T) => boolean, defaultValue?: T | null): Promise<T | null>;\nexport function firstParallel<T, R extends T>(promiseList: Promise<T>[], shouldStop: (t: T) => t is R, defaultValue?: R | null): Promise<R | null>;\nexport function firstParallel<T>(promiseList: Promise<T>[], shouldStop: (t: T) => boolean = t => !!t, defaultValue: T | null = null) {\n\tif (promiseList.length === 0) {\n\t\treturn Promise.resolve(defaultValue);\n\t}\n\n\tlet todo = promiseList.length;\n\tconst finish = () => {\n\t\ttodo = -1;\n\t\tfor (const promise of promiseList) {\n\t\t\t(promise as Partial<CancelablePromise<T>>).cancel?.();\n\t\t}\n\t};\n\n\treturn new Promise<T | null>((resolve, reject) => {\n\t\tfor (const promise of promiseList) {\n\t\t\tpromise.then(result => {\n\t\t\t\tif (--todo >= 0 && shouldStop(result)) {\n\t\t\t\t\tfinish();\n\t\t\t\t\tresolve(result);\n\t\t\t\t} else if (todo === 0) {\n\t\t\t\t\tresolve(defaultValue);\n\t\t\t\t}\n\t\t\t})\n\t\t\t\t.catch(err => {\n\t\t\t\t\tif (--todo >= 0) {\n\t\t\t\t\t\tfinish();\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t}\n\t});\n}\n\ninterface ILimitedTaskFactory<T> {\n\tfactory: ITask<Promise<T>>;\n\tc: (value: T | Promise<T>) => void;\n\te: (error?: unknown) => void;\n}\n\nexport interface ILimiter<T> {\n\n\treadonly size: number;\n\n\tqueue(factory: ITask<Promise<T>>): Promise<T>;\n\n\tclear(): void;\n}\n\n/**\n * A helper to queue N promises and run them all with a max degree of parallelism. The helper\n * ensures that at any time no more than M promises are running at the same time.\n */\nexport class Limiter<T> implements ILimiter<T> {\n\n\tprivate _size = 0;\n\tprivate _isDisposed = false;\n\tprivate runningPromises: number;\n\tprivate readonly maxDegreeOfParalellism: number;\n\tprivate readonly outstandingPromises: ILimitedTaskFactory<T>[];\n\tprivate readonly _onDrained: Emitter<void>;\n\n\tconstructor(maxDegreeOfParalellism: number) {\n\t\tthis.maxDegreeOfParalellism = maxDegreeOfParalellism;\n\t\tthis.outstandingPromises = [];\n\t\tthis.runningPromises = 0;\n\t\tthis._onDrained = new Emitter<void>();\n\t}\n\n\t/**\n\t *\n\t * @returns A promise that resolved when all work is done (onDrained) or when\n\t * there is nothing to do\n\t */\n\twhenIdle(): Promise<void> {\n\t\treturn this.size > 0\n\t\t\t? Event.toPromise(this.onDrained)\n\t\t\t: Promise.resolve();\n\t}\n\n\tget onDrained(): Event<void> {\n\t\treturn this._onDrained.event;\n\t}\n\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\tqueue(factory: ITask<Promise<T>>): Promise<T> {\n\t\tif (this._isDisposed) {\n\t\t\tthrow new Error('Object has been disposed');\n\t\t}\n\t\tthis._size++;\n\n\t\treturn new Promise<T>((c, e) => {\n\t\t\tthis.outstandingPromises.push({ factory, c, e });\n\t\t\tthis.consume();\n\t\t});\n\t}\n\n\tprivate consume(): void {\n\t\twhile (this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism) {\n\t\t\tconst iLimitedTask = this.outstandingPromises.shift()!;\n\t\t\tthis.runningPromises++;\n\n\t\t\tconst promise = iLimitedTask.factory();\n\t\t\tpromise.then(iLimitedTask.c, iLimitedTask.e);\n\t\t\tpromise.then(() => this.consumed(), () => this.consumed());\n\t\t}\n\t}\n\n\tprivate consumed(): void {\n\t\tif (this._isDisposed) {\n\t\t\treturn;\n\t\t}\n\t\tthis.runningPromises--;\n\t\tif (--this._size === 0) {\n\t\t\tthis._onDrained.fire();\n\t\t}\n\n\t\tif (this.outstandingPromises.length > 0) {\n\t\t\tthis.consume();\n\t\t}\n\t}\n\n\tclear(): void {\n\t\tif (this._isDisposed) {\n\t\t\tthrow new Error('Object has been disposed');\n\t\t}\n\t\tthis.outstandingPromises.length = 0;\n\t\tthis._size = this.runningPromises;\n\t}\n\n\tdispose(): void {\n\t\tthis._isDisposed = true;\n\t\tthis.outstandingPromises.length = 0; // stop further processing\n\t\tthis._size = 0;\n\t\tthis._onDrained.dispose();\n\t}\n}\n\n/**\n * A queue is handles one promise at a time and guarantees that at any time only one promise is executing.\n */\nexport class Queue<T> extends Limiter<T> {\n\n\tconstructor() {\n\t\tsuper(1);\n\t}\n}\n\n/**\n * Same as `Queue`, ensures that only 1 task is executed at the same time. The difference to `Queue` is that\n * there is only 1 task about to be scheduled next. As such, calling `queue` while a task is executing will\n * replace the currently queued task until it executes.\n *\n * As such, the returned promise may not be from the factory that is passed in but from the next factory that\n * is running after having called `queue`.\n */\nexport class LimitedQueue {\n\n\tprivate readonly sequentializer = new TaskSequentializer();\n\n\tprivate tasks = 0;\n\n\tqueue(factory: ITask<Promise<void>>): Promise<void> {\n\t\tif (!this.sequentializer.isRunning()) {\n\t\t\treturn this.sequentializer.run(this.tasks++, factory());\n\t\t}\n\n\t\treturn this.sequentializer.queue(() => {\n\t\t\treturn this.sequentializer.run(this.tasks++, factory());\n\t\t});\n\t}\n}\n\n/**\n * A helper to organize queues per resource. The ResourceQueue makes sure to manage queues per resource\n * by disposing them once the queue is empty.\n */\nexport class ResourceQueue implements IDisposable {\n\n\tprivate readonly queues = new Map<string, Queue<void>>();\n\n\tprivate readonly drainers = new Set<DeferredPromise<void>>();\n\n\tprivate drainListeners: DisposableMap<number> | undefined = undefined;\n\tprivate drainListenerCount = 0;\n\n\tasync whenDrained(): Promise<void> {\n\t\tif (this.isDrained()) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst promise = new DeferredPromise<void>();\n\t\tthis.drainers.add(promise);\n\n\t\treturn promise.p;\n\t}\n\n\tprivate isDrained(): boolean {\n\t\tfor (const [, queue] of this.queues) {\n\t\t\tif (queue.size > 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tqueueSize(resource: URI, extUri: IExtUri = defaultExtUri): number {\n\t\tconst key = extUri.getComparisonKey(resource);\n\n\t\treturn this.queues.get(key)?.size ?? 0;\n\t}\n\n\tqueueFor(resource: URI, factory: ITask<Promise<void>>, extUri: IExtUri = defaultExtUri): Promise<void> {\n\t\tconst key = extUri.getComparisonKey(resource);\n\n\t\tlet queue = this.queues.get(key);\n\t\tif (!queue) {\n\t\t\tqueue = new Queue<void>();\n\t\t\tconst drainListenerId = this.drainListenerCount++;\n\t\t\tconst drainListener = Event.once(queue.onDrained)(() => {\n\t\t\t\tqueue?.dispose();\n\t\t\t\tthis.queues.delete(key);\n\t\t\t\tthis.onDidQueueDrain();\n\n\t\t\t\tthis.drainListeners?.deleteAndDispose(drainListenerId);\n\n\t\t\t\tif (this.drainListeners?.size === 0) {\n\t\t\t\t\tthis.drainListeners.dispose();\n\t\t\t\t\tthis.drainListeners = undefined;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (!this.drainListeners) {\n\t\t\t\tthis.drainListeners = new DisposableMap();\n\t\t\t}\n\t\t\tthis.drainListeners.set(drainListenerId, drainListener);\n\n\t\t\tthis.queues.set(key, queue);\n\t\t}\n\n\t\treturn queue.queue(factory);\n\t}\n\n\tprivate onDidQueueDrain(): void {\n\t\tif (!this.isDrained()) {\n\t\t\treturn; // not done yet\n\t\t}\n\n\t\tthis.releaseDrainers();\n\t}\n\n\tprivate releaseDrainers(): void {\n\t\tfor (const drainer of this.drainers) {\n\t\t\tdrainer.complete();\n\t\t}\n\n\t\tthis.drainers.clear();\n\t}\n\n\tdispose(): void {\n\t\tfor (const [, queue] of this.queues) {\n\t\t\tqueue.dispose();\n\t\t}\n\n\t\tthis.queues.clear();\n\n\t\t// Even though we might still have pending\n\t\t// tasks queued, after the queues have been\n\t\t// disposed, we can no longer track them, so\n\t\t// we release drainers to prevent hanging\n\t\t// promises when the resource queue is being\n\t\t// disposed.\n\t\tthis.releaseDrainers();\n\n\t\tthis.drainListeners?.dispose();\n\t}\n}\n\nexport class TimeoutTimer implements IDisposable {\n\tprivate _token: any;\n\n\tconstructor();\n\tconstructor(runner: () => void, timeout: number);\n\tconstructor(runner?: () => void, timeout?: number) {\n\t\tthis._token = -1;\n\n\t\tif (typeof runner === 'function' && typeof timeout === 'number') {\n\t\t\tthis.setIfNotSet(runner, timeout);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n\n\tcancel(): void {\n\t\tif (this._token !== -1) {\n\t\t\tclearTimeout(this._token);\n\t\t\tthis._token = -1;\n\t\t}\n\t}\n\n\tcancelAndSet(runner: () => void, timeout: number): void {\n\t\tthis.cancel();\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = -1;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n\n\tsetIfNotSet(runner: () => void, timeout: number): void {\n\t\tif (this._token !== -1) {\n\t\t\t// timer is already set\n\t\t\treturn;\n\t\t}\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = -1;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n}\n\nexport class IntervalTimer implements IDisposable {\n\n\tprivate disposable: IDisposable | undefined = undefined;\n\n\tcancel(): void {\n\t\tthis.disposable?.dispose();\n\t\tthis.disposable = undefined;\n\t}\n\n\tcancelAndSet(runner: () => void, interval: number, context = globalThis): void {\n\t\tthis.cancel();\n\t\tconst handle = context.setInterval(() => {\n\t\t\trunner();\n\t\t}, interval);\n\n\t\tthis.disposable = toDisposable(() => {\n\t\t\tcontext.clearInterval(handle);\n\t\t\tthis.disposable = undefined;\n\t\t});\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n}\n\nexport class RunOnceScheduler implements IDisposable {\n\n\tprotected runner: ((...args: unknown[]) => void) | null;\n\n\tprivate timeoutToken: any;\n\tprivate timeout: number;\n\tprivate timeoutHandler: () => void;\n\n\tconstructor(runner: (...args: any[]) => void, delay: number) {\n\t\tthis.timeoutToken = -1;\n\t\tthis.runner = runner;\n\t\tthis.timeout = delay;\n\t\tthis.timeoutHandler = this.onTimeout.bind(this);\n\t}\n\n\t/**\n\t * Dispose RunOnceScheduler\n\t */\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.runner = null;\n\t}\n\n\t/**\n\t * Cancel current scheduled runner (if any).\n\t */\n\tcancel(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tclearTimeout(this.timeoutToken);\n\t\t\tthis.timeoutToken = -1;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel previous runner (if any) & schedule a new runner.\n\t */\n\tschedule(delay = this.timeout): void {\n\t\tthis.cancel();\n\t\tthis.timeoutToken = setTimeout(this.timeoutHandler, delay);\n\t}\n\n\tget delay(): number {\n\t\treturn this.timeout;\n\t}\n\n\tset delay(value: number) {\n\t\tthis.timeout = value;\n\t}\n\n\t/**\n\t * Returns true if scheduled.\n\t */\n\tisScheduled(): boolean {\n\t\treturn this.timeoutToken !== -1;\n\t}\n\n\tflush(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tthis.cancel();\n\t\t\tthis.doRun();\n\t\t}\n\t}\n\n\tprivate onTimeout() {\n\t\tthis.timeoutToken = -1;\n\t\tif (this.runner) {\n\t\t\tthis.doRun();\n\t\t}\n\t}\n\n\tprotected doRun(): void {\n\t\tthis.runner?.();\n\t}\n}\n\n/**\n * Same as `RunOnceScheduler`, but doesn't count the time spent in sleep mode.\n * > **NOTE**: Only offers 1s resolution.\n *\n * When calling `setTimeout` with 3hrs, and putting the computer immediately to sleep\n * for 8hrs, `setTimeout` will fire **as soon as the computer wakes from sleep**. But\n * this scheduler will execute 3hrs **after waking the computer from sleep**.\n */\nexport class ProcessTimeRunOnceScheduler {\n\n\tprivate runner: (() => void) | null;\n\tprivate timeout: number;\n\n\tprivate counter: number;\n\tprivate intervalToken: any;\n\tprivate intervalHandler: () => void;\n\n\tconstructor(runner: () => void, delay: number) {\n\t\tif (delay % 1000 !== 0) {\n\t\t\tconsole.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${delay}ms is not a multiple of 1000ms.`);\n\t\t}\n\t\tthis.runner = runner;\n\t\tthis.timeout = delay;\n\t\tthis.counter = 0;\n\t\tthis.intervalToken = -1;\n\t\tthis.intervalHandler = this.onInterval.bind(this);\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.runner = null;\n\t}\n\n\tcancel(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tclearInterval(this.intervalToken);\n\t\t\tthis.intervalToken = -1;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel previous runner (if any) & schedule a new runner.\n\t */\n\tschedule(delay = this.timeout): void {\n\t\tif (delay % 1000 !== 0) {\n\t\t\tconsole.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${delay}ms is not a multiple of 1000ms.`);\n\t\t}\n\t\tthis.cancel();\n\t\tthis.counter = Math.ceil(delay / 1000);\n\t\tthis.intervalToken = setInterval(this.intervalHandler, 1000);\n\t}\n\n\t/**\n\t * Returns true if scheduled.\n\t */\n\tisScheduled(): boolean {\n\t\treturn this.intervalToken !== -1;\n\t}\n\n\tprivate onInterval() {\n\t\tthis.counter--;\n\t\tif (this.counter > 0) {\n\t\t\t// still need to wait\n\t\t\treturn;\n\t\t}\n\n\t\t// time elapsed\n\t\tclearInterval(this.intervalToken);\n\t\tthis.intervalToken = -1;\n\t\tthis.runner?.();\n\t}\n}\n\nexport class RunOnceWorker<T> extends RunOnceScheduler {\n\n\tprivate units: T[] = [];\n\n\tconstructor(runner: (units: T[]) => void, timeout: number) {\n\t\tsuper(runner, timeout);\n\t}\n\n\twork(unit: T): void {\n\t\tthis.units.push(unit);\n\n\t\tif (!this.isScheduled()) {\n\t\t\tthis.schedule();\n\t\t}\n\t}\n\n\tprotected override doRun(): void {\n\t\tconst units = this.units;\n\t\tthis.units = [];\n\n\t\tthis.runner?.(units);\n\t}\n\n\toverride dispose(): void {\n\t\tthis.units = [];\n\n\t\tsuper.dispose();\n\t}\n}\n\nexport interface IThrottledWorkerOptions {\n\n\t/**\n\t * maximum of units the worker will pass onto handler at once\n\t */\n\tmaxWorkChunkSize: number;\n\n\t/**\n\t * maximum of units the worker will keep in memory for processing\n\t */\n\tmaxBufferedWork: number | undefined;\n\n\t/**\n\t * delay before processing the next round of chunks when chunk size exceeds limits\n\t */\n\tthrottleDelay: number;\n}\n\n/**\n * The `ThrottledWorker` will accept units of work `T`\n * to handle. The contract is:\n * * there is a maximum of units the worker can handle at once (via `maxWorkChunkSize`)\n * * there is a maximum of units the worker will keep in memory for processing (via `maxBufferedWork`)\n * * after having handled `maxWorkChunkSize` units, the worker needs to rest (via `throttleDelay`)\n */\nexport class ThrottledWorker<T> extends Disposable {\n\n\tprivate readonly pendingWork: T[] = [];\n\n\tprivate readonly throttler = this._register(new MutableDisposable<RunOnceScheduler>());\n\tprivate disposed = false;\n\n\tconstructor(\n\t\tprivate options: IThrottledWorkerOptions,\n\t\tprivate readonly handler: (units: T[]) => void\n\t) {\n\t\tsuper();\n\t}\n\n\t/**\n\t * The number of work units that are pending to be processed.\n\t */\n\tget pending(): number { return this.pendingWork.length; }\n\n\t/**\n\t * Add units to be worked on. Use `pending` to figure out\n\t * how many units are not yet processed after this method\n\t * was called.\n\t *\n\t * @returns whether the work was accepted or not. If the\n\t * worker is disposed, it will not accept any more work.\n\t * If the number of pending units would become larger\n\t * than `maxPendingWork`, more work will also not be accepted.\n\t */\n\twork(units: readonly T[]): boolean {\n\t\tif (this.disposed) {\n\t\t\treturn false; // work not accepted: disposed\n\t\t}\n\n\t\t// Check for reaching maximum of pending work\n\t\tif (typeof this.options.maxBufferedWork === 'number') {\n\n\t\t\t// Throttled: simple check if pending + units exceeds max pending\n\t\t\tif (this.throttler.value) {\n\t\t\t\tif (this.pending + units.length > this.options.maxBufferedWork) {\n\t\t\t\t\treturn false; // work not accepted: too much pending work\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Unthrottled: same as throttled, but account for max chunk getting\n\t\t\t// worked on directly without being pending\n\t\t\telse {\n\t\t\t\tif (this.pending + units.length - this.options.maxWorkChunkSize > this.options.maxBufferedWork) {\n\t\t\t\t\treturn false; // work not accepted: too much pending work\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add to pending units first\n\t\tfor (const unit of units) {\n\t\t\tthis.pendingWork.push(unit);\n\t\t}\n\n\t\t// If not throttled, start working directly\n\t\t// Otherwise, when the throttle delay has\n\t\t// past, pending work will be worked again.\n\t\tif (!this.throttler.value) {\n\t\t\tthis.doWork();\n\t\t}\n\n\t\treturn true; // work accepted\n\t}\n\n\tprivate doWork(): void {\n\n\t\t// Extract chunk to handle and handle it\n\t\tthis.handler(this.pendingWork.splice(0, this.options.maxWorkChunkSize));\n\n\t\t// If we have remaining work, schedule it after a delay\n\t\tif (this.pendingWork.length > 0) {\n\t\t\tthis.throttler.value = new RunOnceScheduler(() => {\n\t\t\t\tthis.throttler.clear();\n\n\t\t\t\tthis.doWork();\n\t\t\t}, this.options.throttleDelay);\n\t\t\tthis.throttler.value.schedule();\n\t\t}\n\t}\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\n\t\tthis.disposed = true;\n\t}\n}\n\n//#region -- run on idle tricks ------------\n\nexport interface IdleDeadline {\n\treadonly didTimeout: boolean;\n\ttimeRemaining(): number;\n}\n\ntype IdleApi = Pick<typeof globalThis, 'requestIdleCallback' | 'cancelIdleCallback'>;\n\n\n/**\n * Execute the callback the next time the browser is idle, returning an\n * {@link IDisposable} that will cancel the callback when disposed. This wraps\n * [requestIdleCallback] so it will fallback to [setTimeout] if the environment\n * doesn't support it.\n *\n * @param callback The callback to run when idle, this includes an\n * [IdleDeadline] that provides the time alloted for the idle callback by the\n * browser. Not respecting this deadline will result in a degraded user\n * experience.\n * @param timeout A timeout at which point to queue no longer wait for an idle\n * callback but queue it on the regular event loop (like setTimeout). Typically\n * this should not be used.\n *\n * [IdleDeadline]: https://developer.mozilla.org/en-US/docs/Web/API/IdleDeadline\n * [requestIdleCallback]: https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback\n * [setTimeout]: https://developer.mozilla.org/en-US/docs/Web/API/Window/setTimeout\n *\n * **Note** that there is `dom.ts#runWhenWindowIdle` which is better suited when running inside a browser\n * context\n */\nexport let runWhenGlobalIdle: (callback: (idle: IdleDeadline) => void, timeout?: number) => IDisposable;\n\nexport let _runWhenIdle: (targetWindow: IdleApi, callback: (idle: IdleDeadline) => void, timeout?: number) => IDisposable;\n\n(function () {\n\tif (typeof globalThis.requestIdleCallback !== 'function' || typeof globalThis.cancelIdleCallback !== 'function') {\n\t\t_runWhenIdle = (_targetWindow, runner) => {\n\t\t\tsetTimeout0(() => {\n\t\t\t\tif (disposed) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst end = Date.now() + 15; // one frame at 64fps\n\t\t\t\tconst deadline: IdleDeadline = {\n\t\t\t\t\tdidTimeout: true,\n\t\t\t\t\ttimeRemaining() {\n\t\t\t\t\t\treturn Math.max(0, end - Date.now());\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\trunner(Object.freeze(deadline));\n\t\t\t});\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t} else {\n\t\t_runWhenIdle = (targetWindow: IdleApi, runner, timeout?) => {\n\t\t\tconst handle: number = targetWindow.requestIdleCallback(runner, typeof timeout === 'number' ? { timeout } : undefined);\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t\ttargetWindow.cancelIdleCallback(handle);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t}\n\trunWhenGlobalIdle = (runner) => _runWhenIdle(globalThis, runner);\n})();\n\nexport abstract class AbstractIdleValue<T> {\n\n\tprivate readonly _executor: () => void;\n\tprivate readonly _handle: IDisposable;\n\n\tprivate _didRun: boolean = false;\n\tprivate _value?: T;\n\tprivate _error: unknown;\n\n\tconstructor(targetWindow: IdleApi, executor: () => T) {\n\t\tthis._executor = () => {\n\t\t\ttry {\n\t\t\t\tthis._value = executor();\n\t\t\t} catch (err) {\n\t\t\t\tthis._error = err;\n\t\t\t} finally {\n\t\t\t\tthis._didRun = true;\n\t\t\t}\n\t\t};\n\t\tthis._handle = _runWhenIdle(targetWindow, () => this._executor());\n\t}\n\n\tdispose(): void {\n\t\tthis._handle.dispose();\n\t}\n\n\tget value(): T {\n\t\tif (!this._didRun) {\n\t\t\tthis._handle.dispose();\n\t\t\tthis._executor();\n\t\t}\n\t\tif (this._error) {\n\t\t\tthrow this._error;\n\t\t}\n\t\treturn this._value!;\n\t}\n\n\tget isInitialized(): boolean {\n\t\treturn this._didRun;\n\t}\n}\n\n/**\n * An `IdleValue` that always uses the current window (which might be throttled or inactive)\n *\n * **Note** that there is `dom.ts#WindowIdleValue` which is better suited when running inside a browser\n * context\n */\nexport class GlobalIdleValue<T> extends AbstractIdleValue<T> {\n\n\tconstructor(executor: () => T) {\n\t\tsuper(globalThis, executor);\n\t}\n}\n\n//#endregion\n\nexport async function retry<T>(task: ITask<Promise<T>>, delay: number, retries: number): Promise<T> {\n\tlet lastError: Error | undefined;\n\n\tfor (let i = 0; i < retries; i++) {\n\t\ttry {\n\t\t\treturn await task();\n\t\t} catch (error) {\n\t\t\tlastError = error;\n\n\t\t\tawait timeout(delay);\n\t\t}\n\t}\n\n\tthrow lastError;\n}\n\n//#region Task Sequentializer\n\ninterface IRunningTask {\n\treadonly taskId: number;\n\treadonly cancel: () => void;\n\treadonly promise: Promise<void>;\n}\n\ninterface IQueuedTask {\n\treadonly promise: Promise<void>;\n\treadonly promiseResolve: () => void;\n\treadonly promiseReject: (error: Error) => void;\n\trun: ITask<Promise<void>>;\n}\n\nexport interface ITaskSequentializerWithRunningTask {\n\treadonly running: Promise<void>;\n}\n\nexport interface ITaskSequentializerWithQueuedTask {\n\treadonly queued: IQueuedTask;\n}\n\n/**\n * @deprecated use `LimitedQueue` instead for an easier to use API\n */\nexport class TaskSequentializer {\n\n\tprivate _running?: IRunningTask;\n\tprivate _queued?: IQueuedTask;\n\n\tisRunning(taskId?: number): this is ITaskSequentializerWithRunningTask {\n\t\tif (typeof taskId === 'number') {\n\t\t\treturn this._running?.taskId === taskId;\n\t\t}\n\n\t\treturn !!this._running;\n\t}\n\n\tget running(): Promise<void> | undefined {\n\t\treturn this._running?.promise;\n\t}\n\n\tcancelRunning(): void {\n\t\tthis._running?.cancel();\n\t}\n\n\trun(taskId: number, promise: Promise<void>, onCancel?: () => void,): Promise<void> {\n\t\tthis._running = { taskId, cancel: () => onCancel?.(), promise };\n\n\t\tpromise.then(() => this.doneRunning(taskId), () => this.doneRunning(taskId));\n\n\t\treturn promise;\n\t}\n\n\tprivate doneRunning(taskId: number): void {\n\t\tif (this._running && taskId === this._running.taskId) {\n\n\t\t\t// only set running to done if the promise finished that is associated with that taskId\n\t\t\tthis._running = undefined;\n\n\t\t\t// schedule the queued task now that we are free if we have any\n\t\t\tthis.runQueued();\n\t\t}\n\t}\n\n\tprivate runQueued(): void {\n\t\tif (this._queued) {\n\t\t\tconst queued = this._queued;\n\t\t\tthis._queued = undefined;\n\n\t\t\t// Run queued task and complete on the associated promise\n\t\t\tqueued.run().then(queued.promiseResolve, queued.promiseReject);\n\t\t}\n\t}\n\n\t/**\n\t * Note: the promise to schedule as next run MUST itself call `run`.\n\t *       Otherwise, this sequentializer will report `false` for `isRunning`\n\t *       even when this task is running. Missing this detail means that\n\t *       suddenly multiple tasks will run in parallel.\n\t */\n\tqueue(run: ITask<Promise<void>>): Promise<void> {\n\n\t\t// this is our first queued task, so we create associated promise with it\n\t\t// so that we can return a promise that completes when the task has\n\t\t// completed.\n\t\tif (!this._queued) {\n\t\t\tconst { promise, resolve: promiseResolve, reject: promiseReject } = promiseWithResolvers<void>();\n\t\t\tthis._queued = {\n\t\t\t\trun,\n\t\t\t\tpromise,\n\t\t\t\tpromiseResolve: promiseResolve!,\n\t\t\t\tpromiseReject: promiseReject!\n\t\t\t};\n\t\t}\n\n\t\t// we have a previous queued task, just overwrite it\n\t\telse {\n\t\t\tthis._queued.run = run;\n\t\t}\n\n\t\treturn this._queued.promise;\n\t}\n\n\thasQueued(): this is ITaskSequentializerWithQueuedTask {\n\t\treturn !!this._queued;\n\t}\n\n\tasync join(): Promise<void> {\n\t\treturn this._queued?.promise ?? this._running?.promise;\n\t}\n}\n\n//#endregion\n\n//#region\n\n/**\n * The `IntervalCounter` allows to count the number\n * of calls to `increment()` over a duration of\n * `interval`. This utility can be used to conditionally\n * throttle a frequent task when a certain threshold\n * is reached.\n */\nexport class IntervalCounter {\n\n\tprivate lastIncrementTime = 0;\n\n\tprivate value = 0;\n\n\tconstructor(private readonly interval: number, private readonly nowFn = () => Date.now()) { }\n\n\tincrement(): number {\n\t\tconst now = this.nowFn();\n\n\t\t// We are outside of the range of `interval` and as such\n\t\t// start counting from 0 and remember the time\n\t\tif (now - this.lastIncrementTime > this.interval) {\n\t\t\tthis.lastIncrementTime = now;\n\t\t\tthis.value = 0;\n\t\t}\n\n\t\tthis.value++;\n\n\t\treturn this.value;\n\t}\n}\n\n//#endregion\n\n//#region\n\nexport type ValueCallback<T = unknown> = (value: T | Promise<T>) => void;\n\nconst enum DeferredOutcome {\n\tResolved,\n\tRejected\n}\n\n/**\n * Creates a promise whose resolution or rejection can be controlled imperatively.\n */\nexport class DeferredPromise<T> {\n\n\tprivate completeCallback!: ValueCallback<T>;\n\tprivate errorCallback!: (err: unknown) => void;\n\tprivate outcome?: { outcome: DeferredOutcome.Rejected; value: any } | { outcome: DeferredOutcome.Resolved; value: T };\n\n\tpublic get isRejected() {\n\t\treturn this.outcome?.outcome === DeferredOutcome.Rejected;\n\t}\n\n\tpublic get isResolved() {\n\t\treturn this.outcome?.outcome === DeferredOutcome.Resolved;\n\t}\n\n\tpublic get isSettled() {\n\t\treturn !!this.outcome;\n\t}\n\n\tpublic get value() {\n\t\treturn this.outcome?.outcome === DeferredOutcome.Resolved ? this.outcome?.value : undefined;\n\t}\n\n\tpublic readonly p: Promise<T>;\n\n\tconstructor() {\n\t\tthis.p = new Promise<T>((c, e) => {\n\t\t\tthis.completeCallback = c;\n\t\t\tthis.errorCallback = e;\n\t\t});\n\t}\n\n\tpublic complete(value: T) {\n\t\treturn new Promise<void>(resolve => {\n\t\t\tthis.completeCallback(value);\n\t\t\tthis.outcome = { outcome: DeferredOutcome.Resolved, value };\n\t\t\tresolve();\n\t\t});\n\t}\n\n\tpublic error(err: unknown) {\n\t\treturn new Promise<void>(resolve => {\n\t\t\tthis.errorCallback(err);\n\t\t\tthis.outcome = { outcome: DeferredOutcome.Rejected, value: err };\n\t\t\tresolve();\n\t\t});\n\t}\n\n\tpublic cancel() {\n\t\treturn this.error(new CancellationError());\n\t}\n}\n\n//#endregion\n\n//#region Promises\n\nexport namespace Promises {\n\n\t/**\n\t * A drop-in replacement for `Promise.all` with the only difference\n\t * that the method awaits every promise to either fulfill or reject.\n\t *\n\t * Similar to `Promise.all`, only the first error will be returned\n\t * if any.\n\t */\n\texport async function settled<T>(promises: Promise<T>[]): Promise<T[]> {\n\t\tlet firstError: Error | undefined = undefined;\n\n\t\tconst result = await Promise.all(promises.map(promise => promise.then(value => value, error => {\n\t\t\tif (!firstError) {\n\t\t\t\tfirstError = error;\n\t\t\t}\n\n\t\t\treturn undefined; // do not rethrow so that other promises can settle\n\t\t})));\n\n\t\tif (typeof firstError !== 'undefined') {\n\t\t\tthrow firstError;\n\t\t}\n\n\t\treturn result as unknown as T[]; // cast is needed and protected by the `throw` above\n\t}\n\n\t/**\n\t * A helper to create a new `Promise<T>` with a body that is a promise\n\t * itself. By default, an error that raises from the async body will\n\t * end up as a unhandled rejection, so this utility properly awaits the\n\t * body and rejects the promise as a normal promise does without async\n\t * body.\n\t *\n\t * This method should only be used in rare cases where otherwise `async`\n\t * cannot be used (e.g. when callbacks are involved that require this).\n\t */\n\texport function withAsyncBody<T, E = Error>(bodyFn: (resolve: (value: T) => unknown, reject: (error: E) => unknown) => Promise<unknown>): Promise<T> {\n\t\t// eslint-disable-next-line no-async-promise-executor\n\t\treturn new Promise<T>(async (resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tawait bodyFn(resolve, reject);\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t}\n\t\t});\n\t}\n}\n\nexport class StatefulPromise<T> {\n\tprivate _value: T | undefined = undefined;\n\tget value(): T | undefined { return this._value; }\n\n\tprivate _error: unknown = undefined;\n\tget error(): unknown { return this._error; }\n\n\tprivate _isResolved = false;\n\tget isResolved() { return this._isResolved; }\n\n\tpublic readonly promise: Promise<T>;\n\n\tconstructor(promise: Promise<T>) {\n\t\tthis.promise = promise.then(\n\t\t\tvalue => {\n\t\t\t\tthis._value = value;\n\t\t\t\tthis._isResolved = true;\n\t\t\t\treturn value;\n\t\t\t},\n\t\t\terror => {\n\t\t\t\tthis._error = error;\n\t\t\t\tthis._isResolved = true;\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t * Returns the resolved value.\n\t * Throws if the promise is not resolved yet.\n\t */\n\tpublic requireValue(): T {\n\t\tif (!this._isResolved) {\n\t\t\tthrow new BugIndicatingError('Promise is not resolved yet');\n\t\t}\n\t\tif (this._error) {\n\t\t\tthrow this._error;\n\t\t}\n\t\treturn this._value!;\n\t}\n}\n\nexport class LazyStatefulPromise<T> {\n\tprivate readonly _promise = new Lazy(() => new StatefulPromise(this._compute()));\n\n\tconstructor(\n\t\tprivate readonly _compute: () => Promise<T>,\n\t) { }\n\n\t/**\n\t * Returns the resolved value.\n\t * Throws if the promise is not resolved yet.\n\t */\n\tpublic requireValue(): T {\n\t\treturn this._promise.value.requireValue();\n\t}\n\n\t/**\n\t * Returns the promise (and triggers a computation of the promise if not yet done so).\n\t */\n\tpublic getPromise(): Promise<T> {\n\t\treturn this._promise.value.promise;\n\t}\n\n\t/**\n\t * Reads the current value without triggering a computation of the promise.\n\t */\n\tpublic get currentValue(): T | undefined {\n\t\treturn this._promise.rawValue?.value;\n\t}\n}\n\n//#endregion\n\n//#region\n\nconst enum AsyncIterableSourceState {\n\tInitial,\n\tDoneOK,\n\tDoneError,\n}\n\n/**\n * An object that allows to emit async values asynchronously or bring the iterable to an error state using `reject()`.\n * This emitter is valid only for the duration of the executor (until the promise returned by the executor settles).\n */\nexport interface AsyncIterableEmitter<T> {\n\t/**\n\t * The value will be appended at the end.\n\t *\n\t * **NOTE** If `reject()` has already been called, this method has no effect.\n\t */\n\temitOne(value: T): void;\n\t/**\n\t * The values will be appended at the end.\n\t *\n\t * **NOTE** If `reject()` has already been called, this method has no effect.\n\t */\n\temitMany(values: T[]): void;\n\t/**\n\t * Writing an error will permanently invalidate this iterable.\n\t * The current users will receive an error thrown, as will all future users.\n\t *\n\t * **NOTE** If `reject()` have already been called, this method has no effect.\n\t */\n\treject(error: Error): void;\n}\n\n/**\n * An executor for the `AsyncIterableObject` that has access to an emitter.\n */\nexport interface AsyncIterableExecutor<T> {\n\t/**\n\t * @param emitter An object that allows to emit async values valid only for the duration of the executor.\n\t */\n\t(emitter: AsyncIterableEmitter<T>): void | Promise<void>;\n}\n\n/**\n * A rich implementation for an `AsyncIterable<T>`.\n */\nexport class AsyncIterableObject<T> implements AsyncIterable<T> {\n\n\tpublic static fromArray<T>(items: T[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>((writer) => {\n\t\t\twriter.emitMany(items);\n\t\t});\n\t}\n\n\tpublic static fromPromise<T>(promise: Promise<T[]>): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\temitter.emitMany(await promise);\n\t\t});\n\t}\n\n\tpublic static fromPromises<T>(promises: Promise<T>[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\tawait Promise.all(promises.map(async (p) => emitter.emitOne(await p)));\n\t\t});\n\t}\n\n\tpublic static merge<T>(iterables: AsyncIterable<T>[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject(async (emitter) => {\n\t\t\tawait Promise.all(iterables.map(async (iterable) => {\n\t\t\t\tfor await (const item of iterable) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}));\n\t\t});\n\t}\n\n\tpublic static EMPTY = AsyncIterableObject.fromArray<any>([]);\n\n\tprivate _state: AsyncIterableSourceState;\n\tprivate _results: T[];\n\tprivate _error: Error | null;\n\tprivate readonly _onStateChanged: Emitter<void>;\n\n\tconstructor(executor: AsyncIterableExecutor<T>) {\n\t\tthis._state = AsyncIterableSourceState.Initial;\n\t\tthis._results = [];\n\t\tthis._error = null;\n\t\tthis._onStateChanged = new Emitter<void>();\n\n\t\tqueueMicrotask(async () => {\n\t\t\tconst writer: AsyncIterableEmitter<T> = {\n\t\t\t\temitOne: (item) => this.emitOne(item),\n\t\t\t\temitMany: (items) => this.emitMany(items),\n\t\t\t\treject: (error) => this.reject(error)\n\t\t\t};\n\t\t\ttry {\n\t\t\t\tawait Promise.resolve(executor(writer));\n\t\t\t\tthis.resolve();\n\t\t\t} catch (err) {\n\t\t\t\tthis.reject(err);\n\t\t\t} finally {\n\t\t\t\twriter.emitOne = undefined!;\n\t\t\t\twriter.emitMany = undefined!;\n\t\t\t\twriter.reject = undefined!;\n\t\t\t}\n\t\t});\n\t}\n\n\t[Symbol.asyncIterator](): AsyncIterator<T, undefined, undefined> {\n\t\tlet i = 0;\n\t\treturn {\n\t\t\tnext: async () => {\n\t\t\t\tdo {\n\t\t\t\t\tif (this._state === AsyncIterableSourceState.DoneError) {\n\t\t\t\t\t\tthrow this._error;\n\t\t\t\t\t}\n\t\t\t\t\tif (i < this._results.length) {\n\t\t\t\t\t\treturn { done: false, value: this._results[i++] };\n\t\t\t\t\t}\n\t\t\t\t\tif (this._state === AsyncIterableSourceState.DoneOK) {\n\t\t\t\t\t\treturn { done: true, value: undefined };\n\t\t\t\t\t}\n\t\t\t\t\tawait Event.toPromise(this._onStateChanged.event);\n\t\t\t\t} while (true);\n\t\t\t}\n\t\t};\n\t}\n\n\tpublic static map<T, R>(iterable: AsyncIterable<T>, mapFn: (item: T) => R): AsyncIterableObject<R> {\n\t\treturn new AsyncIterableObject<R>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\temitter.emitOne(mapFn(item));\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic map<R>(mapFn: (item: T) => R): AsyncIterableObject<R> {\n\t\treturn AsyncIterableObject.map(this, mapFn);\n\t}\n\n\tpublic static filter<T>(iterable: AsyncIterable<T>, filterFn: (item: T) => boolean): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\tif (filterFn(item)) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic filter(filterFn: (item: T) => boolean): AsyncIterableObject<T> {\n\t\treturn AsyncIterableObject.filter(this, filterFn);\n\t}\n\n\tpublic static coalesce<T>(iterable: AsyncIterable<T | undefined | null>): AsyncIterableObject<T> {\n\t\treturn <AsyncIterableObject<T>>AsyncIterableObject.filter(iterable, item => !!item);\n\t}\n\n\tpublic coalesce(): AsyncIterableObject<NonNullable<T>> {\n\t\treturn AsyncIterableObject.coalesce(this) as AsyncIterableObject<NonNullable<T>>;\n\t}\n\n\tpublic static async toPromise<T>(iterable: AsyncIterable<T>): Promise<T[]> {\n\t\tconst result: T[] = [];\n\t\tfor await (const item of iterable) {\n\t\t\tresult.push(item);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic toPromise(): Promise<T[]> {\n\t\treturn AsyncIterableObject.toPromise(this);\n\t}\n\n\t/**\n\t * The value will be appended at the end.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate emitOne(value: T): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\t// it is important to add new values at the end,\n\t\t// as we may have iterators already running on the array\n\t\tthis._results.push(value);\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * The values will be appended at the end.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate emitMany(values: T[]): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\t// it is important to add new values at the end,\n\t\t// as we may have iterators already running on the array\n\t\tthis._results = this._results.concat(values);\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * Calling `resolve()` will mark the result array as complete.\n\t *\n\t * **NOTE** `resolve()` must be called, otherwise all consumers of this iterable will hang indefinitely, similar to a non-resolved promise.\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate resolve(): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\tthis._state = AsyncIterableSourceState.DoneOK;\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * Writing an error will permanently invalidate this iterable.\n\t * The current users will receive an error thrown, as will all future users.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate reject(error: Error) {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\tthis._state = AsyncIterableSourceState.DoneError;\n\t\tthis._error = error;\n\t\tthis._onStateChanged.fire();\n\t}\n}\n\nexport class CancelableAsyncIterableObject<T> extends AsyncIterableObject<T> {\n\tconstructor(\n\t\tprivate readonly _source: CancellationTokenSource,\n\t\texecutor: AsyncIterableExecutor<T>\n\t) {\n\t\tsuper(executor);\n\t}\n\n\tcancel(): void {\n\t\tthis._source.cancel();\n\t}\n}\n\nexport function createCancelableAsyncIterable<T>(callback: (token: CancellationToken) => AsyncIterable<T>): CancelableAsyncIterableObject<T> {\n\tconst source = new CancellationTokenSource();\n\tconst innerIterable = callback(source.token);\n\n\treturn new CancelableAsyncIterableObject<T>(source, async (emitter) => {\n\t\tconst subscription = source.token.onCancellationRequested(() => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\temitter.reject(new CancellationError());\n\t\t});\n\t\ttry {\n\t\t\tfor await (const item of innerIterable) {\n\t\t\t\tif (source.token.isCancellationRequested) {\n\t\t\t\t\t// canceled in the meantime\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\temitter.emitOne(item);\n\t\t\t}\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t} catch (err) {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\temitter.reject(err);\n\t\t}\n\t});\n}\n\nexport class AsyncIterableSource<T> {\n\n\tprivate readonly _deferred = new DeferredPromise<void>();\n\tprivate readonly _asyncIterable: AsyncIterableObject<T>;\n\n\tprivate _errorFn: (error: Error) => void;\n\tprivate _emitFn: (item: T) => void;\n\n\tconstructor() {\n\t\tthis._asyncIterable = new AsyncIterableObject(emitter => {\n\n\t\t\tif (earlyError) {\n\t\t\t\temitter.reject(earlyError);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (earlyItems) {\n\t\t\t\temitter.emitMany(earlyItems);\n\t\t\t}\n\t\t\tthis._errorFn = (error: Error) => emitter.reject(error);\n\t\t\tthis._emitFn = (item: T) => emitter.emitOne(item);\n\t\t\treturn this._deferred.p;\n\t\t});\n\n\t\tlet earlyError: Error | undefined;\n\t\tlet earlyItems: T[] | undefined;\n\n\t\tthis._emitFn = (item: T) => {\n\t\t\tif (!earlyItems) {\n\t\t\t\tearlyItems = [];\n\t\t\t}\n\t\t\tearlyItems.push(item);\n\t\t};\n\t\tthis._errorFn = (error: Error) => {\n\t\t\tif (!earlyError) {\n\t\t\t\tearlyError = error;\n\t\t\t}\n\t\t};\n\t}\n\n\tget asyncIterable(): AsyncIterableObject<T> {\n\t\treturn this._asyncIterable;\n\t}\n\n\tresolve(): void {\n\t\tthis._deferred.complete();\n\t}\n\n\treject(error: Error): void {\n\t\tthis._errorFn(error);\n\t\tthis._deferred.complete();\n\t}\n\n\temitOne(item: T): void {\n\t\tthis._emitFn(item);\n\t}\n}\n\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Token, TokenizationResult, EncodedTokenizationResult, IState } from 'vs/editor/common/languages';\nimport { LanguageId, FontStyle, ColorId, StandardTokenType, MetadataConsts } from 'vs/editor/common/encodedTokenAttributes';\n\nexport const NullState: IState = new class implements IState {\n\tpublic clone(): IState {\n\t\treturn this;\n\t}\n\tpublic equals(other: IState): boolean {\n\t\treturn (this === other);\n\t}\n};\n\nexport function nullTokenize(languageId: string, state: IState): TokenizationResult {\n\treturn new TokenizationResult([new Token(0, '', languageId)], state);\n}\n\nexport function nullTokenizeEncoded(languageId: LanguageId, state: IState | null): EncodedTokenizationResult {\n\tconst tokens = new Uint32Array(2);\n\ttokens[0] = 0;\n\ttokens[1] = (\n\t\t(languageId << MetadataConsts.LANGUAGEID_OFFSET)\n\t\t| (StandardTokenType.Other << MetadataConsts.TOKEN_TYPE_OFFSET)\n\t\t| (FontStyle.None << MetadataConsts.FONT_STYLE_OFFSET)\n\t\t| (ColorId.DefaultForeground << MetadataConsts.FOREGROUND_OFFSET)\n\t\t| (ColorId.DefaultBackground << MetadataConsts.BACKGROUND_OFFSET)\n\t) >>> 0;\n\n\treturn new EncodedTokenizationResult(tokens, state === null ? NullState : state);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IdleDeadline, runWhenGlobalIdle } from 'vs/base/common/async';\nimport { BugIndicatingError, onUnexpectedError } from 'vs/base/common/errors';\nimport { setTimeout0 } from 'vs/base/common/platform';\nimport { StopWatch } from 'vs/base/common/stopwatch';\nimport { countEOL } from 'vs/editor/common/core/eolCounter';\nimport { LineRange } from 'vs/editor/common/core/lineRange';\nimport { OffsetRange } from 'vs/editor/common/core/offsetRange';\nimport { Position } from 'vs/editor/common/core/position';\nimport { StandardTokenType } from 'vs/editor/common/encodedTokenAttributes';\nimport { EncodedTokenizationResult, IBackgroundTokenizationStore, IBackgroundTokenizer, ILanguageIdCodec, IState, ITokenizationSupport } from 'vs/editor/common/languages';\nimport { nullTokenizeEncoded } from 'vs/editor/common/languages/nullTokenize';\nimport { ITextModel } from 'vs/editor/common/model';\nimport { FixedArray } from 'vs/editor/common/model/fixedArray';\nimport { IModelContentChange } from 'vs/editor/common/textModelEvents';\nimport { ContiguousMultilineTokensBuilder } from 'vs/editor/common/tokens/contiguousMultilineTokensBuilder';\nimport { LineTokens } from 'vs/editor/common/tokens/lineTokens';\n\nconst enum Constants {\n\tCHEAP_TOKENIZATION_LENGTH_LIMIT = 2048\n}\n\nexport class TokenizerWithStateStore<TState extends IState = IState> {\n\tprivate readonly initialState = this.tokenizationSupport.getInitialState() as TState;\n\n\tpublic readonly store: TrackingTokenizationStateStore<TState>;\n\n\tconstructor(\n\t\tlineCount: number,\n\t\tpublic readonly tokenizationSupport: ITokenizationSupport\n\t) {\n\t\tthis.store = new TrackingTokenizationStateStore<TState>(lineCount);\n\t}\n\n\tpublic getStartState(lineNumber: number): TState | null {\n\t\treturn this.store.getStartState(lineNumber, this.initialState);\n\t}\n\n\tpublic getFirstInvalidLine(): { lineNumber: number; startState: TState } | null {\n\t\treturn this.store.getFirstInvalidLine(this.initialState);\n\t}\n}\n\nexport class TokenizerWithStateStoreAndTextModel<TState extends IState = IState> extends TokenizerWithStateStore<TState> {\n\tconstructor(\n\t\tlineCount: number,\n\t\ttokenizationSupport: ITokenizationSupport,\n\t\tpublic readonly _textModel: ITextModel,\n\t\tpublic readonly _languageIdCodec: ILanguageIdCodec\n\t) {\n\t\tsuper(lineCount, tokenizationSupport);\n\t}\n\n\tpublic updateTokensUntilLine(builder: ContiguousMultilineTokensBuilder, lineNumber: number): void {\n\t\tconst languageId = this._textModel.getLanguageId();\n\n\t\twhile (true) {\n\t\t\tconst lineToTokenize = this.getFirstInvalidLine();\n\t\t\tif (!lineToTokenize || lineToTokenize.lineNumber > lineNumber) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst text = this._textModel.getLineContent(lineToTokenize.lineNumber);\n\n\t\t\tconst r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, lineToTokenize.startState);\n\t\t\tbuilder.add(lineToTokenize.lineNumber, r.tokens);\n\t\t\tthis.store.setEndState(lineToTokenize.lineNumber, r.endState as TState);\n\t\t}\n\t}\n\n\t/** assumes state is up to date */\n\tpublic getTokenTypeIfInsertingCharacter(position: Position, character: string): StandardTokenType {\n\t\t// TODO@hediet: use tokenizeLineWithEdit\n\t\tconst lineStartState = this.getStartState(position.lineNumber);\n\t\tif (!lineStartState) {\n\t\t\treturn StandardTokenType.Other;\n\t\t}\n\n\t\tconst languageId = this._textModel.getLanguageId();\n\t\tconst lineContent = this._textModel.getLineContent(position.lineNumber);\n\n\t\t// Create the text as if `character` was inserted\n\t\tconst text = (\n\t\t\tlineContent.substring(0, position.column - 1)\n\t\t\t+ character\n\t\t\t+ lineContent.substring(position.column - 1)\n\t\t);\n\n\t\tconst r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, lineStartState);\n\t\tconst lineTokens = new LineTokens(r.tokens, text, this._languageIdCodec);\n\t\tif (lineTokens.getCount() === 0) {\n\t\t\treturn StandardTokenType.Other;\n\t\t}\n\n\t\tconst tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n\t\treturn lineTokens.getStandardTokenType(tokenIndex);\n\t}\n\n\t/** assumes state is up to date */\n\tpublic tokenizeLineWithEdit(position: Position, length: number, newText: string): LineTokens | null {\n\t\tconst lineNumber = position.lineNumber;\n\t\tconst column = position.column;\n\n\t\tconst lineStartState = this.getStartState(lineNumber);\n\t\tif (!lineStartState) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst curLineContent = this._textModel.getLineContent(lineNumber);\n\t\tconst newLineContent = curLineContent.substring(0, column - 1)\n\t\t\t+ newText + curLineContent.substring(column - 1 + length);\n\n\t\tconst languageId = this._textModel.getLanguageIdAtPosition(lineNumber, 0);\n\t\tconst result = safeTokenize(\n\t\t\tthis._languageIdCodec,\n\t\t\tlanguageId,\n\t\t\tthis.tokenizationSupport,\n\t\t\tnewLineContent,\n\t\t\ttrue,\n\t\t\tlineStartState\n\t\t);\n\n\t\tconst lineTokens = new LineTokens(result.tokens, newLineContent, this._languageIdCodec);\n\t\treturn lineTokens;\n\t}\n\n\tpublic hasAccurateTokensForLine(lineNumber: number): boolean {\n\t\tconst firstInvalidLineNumber = this.store.getFirstInvalidEndStateLineNumberOrMax();\n\t\treturn (lineNumber < firstInvalidLineNumber);\n\t}\n\n\tpublic isCheapToTokenize(lineNumber: number): boolean {\n\t\tconst firstInvalidLineNumber = this.store.getFirstInvalidEndStateLineNumberOrMax();\n\t\tif (lineNumber < firstInvalidLineNumber) {\n\t\t\treturn true;\n\t\t}\n\t\tif (lineNumber === firstInvalidLineNumber\n\t\t\t&& this._textModel.getLineLength(lineNumber) < Constants.CHEAP_TOKENIZATION_LENGTH_LIMIT) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * The result is not cached.\n\t */\n\tpublic tokenizeHeuristically(builder: ContiguousMultilineTokensBuilder, startLineNumber: number, endLineNumber: number): { heuristicTokens: boolean } {\n\t\tif (endLineNumber <= this.store.getFirstInvalidEndStateLineNumberOrMax()) {\n\t\t\t// nothing to do\n\t\t\treturn { heuristicTokens: false };\n\t\t}\n\n\t\tif (startLineNumber <= this.store.getFirstInvalidEndStateLineNumberOrMax()) {\n\t\t\t// tokenization has reached the viewport start...\n\t\t\tthis.updateTokensUntilLine(builder, endLineNumber);\n\t\t\treturn { heuristicTokens: false };\n\t\t}\n\n\t\tlet state = this.guessStartState(startLineNumber);\n\t\tconst languageId = this._textModel.getLanguageId();\n\n\t\tfor (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n\t\t\tconst text = this._textModel.getLineContent(lineNumber);\n\t\t\tconst r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, state);\n\t\t\tbuilder.add(lineNumber, r.tokens);\n\t\t\tstate = r.endState;\n\t\t}\n\n\t\treturn { heuristicTokens: true };\n\t}\n\n\tprivate guessStartState(lineNumber: number): IState {\n\t\tlet nonWhitespaceColumn = this._textModel.getLineFirstNonWhitespaceColumn(lineNumber);\n\t\tconst likelyRelevantLines: string[] = [];\n\t\tlet initialState: IState | null = null;\n\t\tfor (let i = lineNumber - 1; nonWhitespaceColumn > 1 && i >= 1; i--) {\n\t\t\tconst newNonWhitespaceIndex = this._textModel.getLineFirstNonWhitespaceColumn(i);\n\t\t\t// Ignore lines full of whitespace\n\t\t\tif (newNonWhitespaceIndex === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (newNonWhitespaceIndex < nonWhitespaceColumn) {\n\t\t\t\tlikelyRelevantLines.push(this._textModel.getLineContent(i));\n\t\t\t\tnonWhitespaceColumn = newNonWhitespaceIndex;\n\t\t\t\tinitialState = this.getStartState(i);\n\t\t\t\tif (initialState) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!initialState) {\n\t\t\tinitialState = this.tokenizationSupport.getInitialState();\n\t\t}\n\t\tlikelyRelevantLines.reverse();\n\n\t\tconst languageId = this._textModel.getLanguageId();\n\t\tlet state = initialState;\n\t\tfor (const line of likelyRelevantLines) {\n\t\t\tconst r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, line, false, state);\n\t\t\tstate = r.endState;\n\t\t}\n\t\treturn state;\n\t}\n}\n\n/**\n * **Invariant:**\n * If the text model is retokenized from line 1 to {@link getFirstInvalidEndStateLineNumber}() - 1,\n * then the recomputed end state for line l will be equal to {@link getEndState}(l).\n */\nexport class TrackingTokenizationStateStore<TState extends IState> {\n\tprivate readonly _tokenizationStateStore = new TokenizationStateStore<TState>();\n\tprivate readonly _invalidEndStatesLineNumbers = new RangePriorityQueueImpl();\n\n\tconstructor(private lineCount: number) {\n\t\tthis._invalidEndStatesLineNumbers.addRange(new OffsetRange(1, lineCount + 1));\n\t}\n\n\tpublic getEndState(lineNumber: number): TState | null {\n\t\treturn this._tokenizationStateStore.getEndState(lineNumber);\n\t}\n\n\t/**\n\t * @returns if the end state has changed.\n\t */\n\tpublic setEndState(lineNumber: number, state: TState): boolean {\n\t\tif (!state) {\n\t\t\tthrow new BugIndicatingError('Cannot set null/undefined state');\n\t\t}\n\n\t\tthis._invalidEndStatesLineNumbers.delete(lineNumber);\n\t\tconst r = this._tokenizationStateStore.setEndState(lineNumber, state);\n\t\tif (r && lineNumber < this.lineCount) {\n\t\t\t// because the state changed, we cannot trust the next state anymore and have to invalidate it.\n\t\t\tthis._invalidEndStatesLineNumbers.addRange(new OffsetRange(lineNumber + 1, lineNumber + 2));\n\t\t}\n\n\t\treturn r;\n\t}\n\n\tpublic acceptChange(range: LineRange, newLineCount: number): void {\n\t\tthis.lineCount += newLineCount - range.length;\n\t\tthis._tokenizationStateStore.acceptChange(range, newLineCount);\n\t\tthis._invalidEndStatesLineNumbers.addRangeAndResize(new OffsetRange(range.startLineNumber, range.endLineNumberExclusive), newLineCount);\n\t}\n\n\tpublic acceptChanges(changes: IModelContentChange[]) {\n\t\tfor (const c of changes) {\n\t\t\tconst [eolCount] = countEOL(c.text);\n\t\t\tthis.acceptChange(new LineRange(c.range.startLineNumber, c.range.endLineNumber + 1), eolCount + 1);\n\t\t}\n\t}\n\n\tpublic invalidateEndStateRange(range: LineRange): void {\n\t\tthis._invalidEndStatesLineNumbers.addRange(new OffsetRange(range.startLineNumber, range.endLineNumberExclusive));\n\t}\n\n\tpublic getFirstInvalidEndStateLineNumber(): number | null { return this._invalidEndStatesLineNumbers.min; }\n\n\tpublic getFirstInvalidEndStateLineNumberOrMax(): number {\n\t\treturn this.getFirstInvalidEndStateLineNumber() || Number.MAX_SAFE_INTEGER;\n\t}\n\n\tpublic allStatesValid(): boolean { return this._invalidEndStatesLineNumbers.min === null; }\n\n\tpublic getStartState(lineNumber: number, initialState: TState): TState | null {\n\t\tif (lineNumber === 1) { return initialState; }\n\t\treturn this.getEndState(lineNumber - 1);\n\t}\n\n\tpublic getFirstInvalidLine(initialState: TState): { lineNumber: number; startState: TState } | null {\n\t\tconst lineNumber = this.getFirstInvalidEndStateLineNumber();\n\t\tif (lineNumber === null) {\n\t\t\treturn null;\n\t\t}\n\t\tconst startState = this.getStartState(lineNumber, initialState);\n\t\tif (!startState) {\n\t\t\tthrow new BugIndicatingError('Start state must be defined');\n\t\t}\n\n\t\treturn { lineNumber, startState };\n\t}\n}\n\nexport class TokenizationStateStore<TState extends IState> {\n\tprivate readonly _lineEndStates = new FixedArray<TState | null>(null);\n\n\tpublic getEndState(lineNumber: number): TState | null {\n\t\treturn this._lineEndStates.get(lineNumber);\n\t}\n\n\tpublic setEndState(lineNumber: number, state: TState): boolean {\n\t\tconst oldState = this._lineEndStates.get(lineNumber);\n\t\tif (oldState && oldState.equals(state)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis._lineEndStates.set(lineNumber, state);\n\t\treturn true;\n\t}\n\n\tpublic acceptChange(range: LineRange, newLineCount: number): void {\n\t\tlet length = range.length;\n\t\tif (newLineCount > 0 && length > 0) {\n\t\t\t// Keep the last state, even though it is unrelated.\n\t\t\t// But if the new state happens to agree with this last state, then we know we can stop tokenizing.\n\t\t\tlength--;\n\t\t\tnewLineCount--;\n\t\t}\n\n\t\tthis._lineEndStates.replace(range.startLineNumber, length, newLineCount);\n\t}\n\n\tpublic acceptChanges(changes: IModelContentChange[]) {\n\t\tfor (const c of changes) {\n\t\t\tconst [eolCount] = countEOL(c.text);\n\t\t\tthis.acceptChange(new LineRange(c.range.startLineNumber, c.range.endLineNumber + 1), eolCount + 1);\n\t\t}\n\t}\n}\n\ninterface RangePriorityQueue {\n\tget min(): number | null;\n\tremoveMin(): number | null;\n\n\taddRange(range: OffsetRange): void;\n\n\taddRangeAndResize(range: OffsetRange, newLength: number): void;\n}\n\nexport class RangePriorityQueueImpl implements RangePriorityQueue {\n\tprivate readonly _ranges: OffsetRange[] = [];\n\n\tpublic getRanges(): OffsetRange[] {\n\t\treturn this._ranges;\n\t}\n\n\tpublic get min(): number | null {\n\t\tif (this._ranges.length === 0) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this._ranges[0].start;\n\t}\n\n\tpublic removeMin(): number | null {\n\t\tif (this._ranges.length === 0) {\n\t\t\treturn null;\n\t\t}\n\t\tconst range = this._ranges[0];\n\t\tif (range.start + 1 === range.endExclusive) {\n\t\t\tthis._ranges.shift();\n\t\t} else {\n\t\t\tthis._ranges[0] = new OffsetRange(range.start + 1, range.endExclusive);\n\t\t}\n\t\treturn range.start;\n\t}\n\n\tpublic delete(value: number): void {\n\t\tconst idx = this._ranges.findIndex(r => r.contains(value));\n\t\tif (idx !== -1) {\n\t\t\tconst range = this._ranges[idx];\n\t\t\tif (range.start === value) {\n\t\t\t\tif (range.endExclusive === value + 1) {\n\t\t\t\t\tthis._ranges.splice(idx, 1);\n\t\t\t\t} else {\n\t\t\t\t\tthis._ranges[idx] = new OffsetRange(value + 1, range.endExclusive);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (range.endExclusive === value + 1) {\n\t\t\t\t\tthis._ranges[idx] = new OffsetRange(range.start, value);\n\t\t\t\t} else {\n\t\t\t\t\tthis._ranges.splice(idx, 1, new OffsetRange(range.start, value), new OffsetRange(value + 1, range.endExclusive));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic addRange(range: OffsetRange): void {\n\t\tOffsetRange.addRange(range, this._ranges);\n\t}\n\n\tpublic addRangeAndResize(range: OffsetRange, newLength: number): void {\n\t\tlet idxFirstMightBeIntersecting = 0;\n\t\twhile (!(idxFirstMightBeIntersecting >= this._ranges.length || range.start <= this._ranges[idxFirstMightBeIntersecting].endExclusive)) {\n\t\t\tidxFirstMightBeIntersecting++;\n\t\t}\n\t\tlet idxFirstIsAfter = idxFirstMightBeIntersecting;\n\t\twhile (!(idxFirstIsAfter >= this._ranges.length || range.endExclusive < this._ranges[idxFirstIsAfter].start)) {\n\t\t\tidxFirstIsAfter++;\n\t\t}\n\t\tconst delta = newLength - range.length;\n\n\t\tfor (let i = idxFirstIsAfter; i < this._ranges.length; i++) {\n\t\t\tthis._ranges[i] = this._ranges[i].delta(delta);\n\t\t}\n\n\t\tif (idxFirstMightBeIntersecting === idxFirstIsAfter) {\n\t\t\tconst newRange = new OffsetRange(range.start, range.start + newLength);\n\t\t\tif (!newRange.isEmpty) {\n\t\t\t\tthis._ranges.splice(idxFirstMightBeIntersecting, 0, newRange);\n\t\t\t}\n\t\t} else {\n\t\t\tconst start = Math.min(range.start, this._ranges[idxFirstMightBeIntersecting].start);\n\t\t\tconst endEx = Math.max(range.endExclusive, this._ranges[idxFirstIsAfter - 1].endExclusive);\n\n\t\t\tconst newRange = new OffsetRange(start, endEx + delta);\n\t\t\tif (!newRange.isEmpty) {\n\t\t\t\tthis._ranges.splice(idxFirstMightBeIntersecting, idxFirstIsAfter - idxFirstMightBeIntersecting, newRange);\n\t\t\t} else {\n\t\t\t\tthis._ranges.splice(idxFirstMightBeIntersecting, idxFirstIsAfter - idxFirstMightBeIntersecting);\n\t\t\t}\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn this._ranges.map(r => r.toString()).join(' + ');\n\t}\n}\n\n\nfunction safeTokenize(languageIdCodec: ILanguageIdCodec, languageId: string, tokenizationSupport: ITokenizationSupport | null, text: string, hasEOL: boolean, state: IState): EncodedTokenizationResult {\n\tlet r: EncodedTokenizationResult | null = null;\n\n\tif (tokenizationSupport) {\n\t\ttry {\n\t\t\tr = tokenizationSupport.tokenizeEncoded(text, hasEOL, state.clone());\n\t\t} catch (e) {\n\t\t\tonUnexpectedError(e);\n\t\t}\n\t}\n\n\tif (!r) {\n\t\tr = nullTokenizeEncoded(languageIdCodec.encodeLanguageId(languageId), state);\n\t}\n\n\tLineTokens.convertToEndOffset(r.tokens, text.length);\n\treturn r;\n}\n\nexport class DefaultBackgroundTokenizer implements IBackgroundTokenizer {\n\tprivate _isDisposed = false;\n\n\tconstructor(\n\t\tprivate readonly _tokenizerWithStateStore: TokenizerWithStateStoreAndTextModel,\n\t\tprivate readonly _backgroundTokenStore: IBackgroundTokenizationStore,\n\t) {\n\t}\n\n\tpublic dispose(): void {\n\t\tthis._isDisposed = true;\n\t}\n\n\tpublic handleChanges(): void {\n\t\tthis._beginBackgroundTokenization();\n\t}\n\n\tprivate _isScheduled = false;\n\tprivate _beginBackgroundTokenization(): void {\n\t\tif (this._isScheduled || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._isScheduled = true;\n\t\trunWhenGlobalIdle((deadline) => {\n\t\t\tthis._isScheduled = false;\n\n\t\t\tthis._backgroundTokenizeWithDeadline(deadline);\n\t\t});\n\t}\n\n\t/**\n\t * Tokenize until the deadline occurs, but try to yield every 1-2ms.\n\t */\n\tprivate _backgroundTokenizeWithDeadline(deadline: IdleDeadline): void {\n\t\t// Read the time remaining from the `deadline` immediately because it is unclear\n\t\t// if the `deadline` object will be valid after execution leaves this function.\n\t\tconst endTime = Date.now() + deadline.timeRemaining();\n\n\t\tconst execute = () => {\n\t\t\tif (this._isDisposed || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {\n\t\t\t\t// disposed in the meantime or detached or finished\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._backgroundTokenizeForAtLeast1ms();\n\n\t\t\tif (Date.now() < endTime) {\n\t\t\t\t// There is still time before reaching the deadline, so yield to the browser and then\n\t\t\t\t// continue execution\n\t\t\t\tsetTimeout0(execute);\n\t\t\t} else {\n\t\t\t\t// The deadline has been reached, so schedule a new idle callback if necessary\n\t\t\t\tthis._beginBackgroundTokenization();\n\t\t\t}\n\t\t};\n\t\texecute();\n\t}\n\n\t/**\n\t * Tokenize for at least 1ms.\n\t */\n\tprivate _backgroundTokenizeForAtLeast1ms(): void {\n\t\tconst lineCount = this._tokenizerWithStateStore._textModel.getLineCount();\n\t\tconst builder = new ContiguousMultilineTokensBuilder();\n\t\tconst sw = StopWatch.create(false);\n\n\t\tdo {\n\t\t\tif (sw.elapsed() > 1) {\n\t\t\t\t// the comparison is intentionally > 1 and not >= 1 to ensure that\n\t\t\t\t// a full millisecond has elapsed, given how microseconds are rounded\n\t\t\t\t// to milliseconds\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst tokenizedLineNumber = this._tokenizeOneInvalidLine(builder);\n\n\t\t\tif (tokenizedLineNumber >= lineCount) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (this._hasLinesToTokenize());\n\n\t\tthis._backgroundTokenStore.setTokens(builder.finalize());\n\t\tthis.checkFinished();\n\t}\n\n\tprivate _hasLinesToTokenize(): boolean {\n\t\tif (!this._tokenizerWithStateStore) {\n\t\t\treturn false;\n\t\t}\n\t\treturn !this._tokenizerWithStateStore.store.allStatesValid();\n\t}\n\n\tprivate _tokenizeOneInvalidLine(builder: ContiguousMultilineTokensBuilder): number {\n\t\tconst firstInvalidLine = this._tokenizerWithStateStore?.getFirstInvalidLine();\n\t\tif (!firstInvalidLine) {\n\t\t\treturn this._tokenizerWithStateStore._textModel.getLineCount() + 1;\n\t\t}\n\t\tthis._tokenizerWithStateStore.updateTokensUntilLine(builder, firstInvalidLine.lineNumber);\n\t\treturn firstInvalidLine.lineNumber;\n\t}\n\n\tpublic checkFinished(): void {\n\t\tif (this._isDisposed) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._tokenizerWithStateStore.store.allStatesValid()) {\n\t\t\tthis._backgroundTokenStore.backgroundTokenizationFinished();\n\t\t}\n\t}\n\n\tpublic requestTokens(startLineNumber: number, endLineNumberExclusive: number): void {\n\t\tthis._tokenizerWithStateStore.store.invalidateEndStateRange(new LineRange(startLineNumber, endLineNumberExclusive));\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { Disposable } from 'vs/base/common/lifecycle';\nimport { StopWatch } from 'vs/base/common/stopwatch';\nimport { LanguageId, TokenMetadata } from 'vs/editor/common/encodedTokenAttributes';\nimport { EncodedTokenizationResult, IBackgroundTokenizationStore, IBackgroundTokenizer, IState, ITokenizationSupport, TokenizationResult } from 'vs/editor/common/languages';\nimport { ITextModel } from 'vs/editor/common/model';\nimport type { IGrammar, StateStack } from 'vscode-textmate';\n\nexport class TextMateTokenizationSupport extends Disposable implements ITokenizationSupport {\n\tprivate readonly _seenLanguages: boolean[] = [];\n\tprivate readonly _onDidEncounterLanguage: Emitter<LanguageId> = this._register(new Emitter<LanguageId>());\n\tpublic readonly onDidEncounterLanguage: Event<LanguageId> = this._onDidEncounterLanguage.event;\n\n\tconstructor(\n\t\tprivate readonly _grammar: IGrammar,\n\t\tprivate readonly _initialState: StateStack,\n\t\tprivate readonly _containsEmbeddedLanguages: boolean,\n\t\tprivate readonly _createBackgroundTokenizer: ((textModel: ITextModel, tokenStore: IBackgroundTokenizationStore) => IBackgroundTokenizer | undefined) | undefined,\n\t\tprivate readonly _backgroundTokenizerShouldOnlyVerifyTokens: () => boolean,\n\t\tprivate readonly _reportTokenizationTime: (timeMs: number, lineLength: number, isRandomSample: boolean) => void,\n\t\tprivate readonly _reportSlowTokenization: boolean,\n\t) {\n\t\tsuper();\n\t}\n\n\tpublic get backgroundTokenizerShouldOnlyVerifyTokens(): boolean | undefined {\n\t\treturn this._backgroundTokenizerShouldOnlyVerifyTokens();\n\t}\n\n\tpublic getInitialState(): IState {\n\t\treturn this._initialState;\n\t}\n\n\tpublic tokenize(line: string, hasEOL: boolean, state: IState): TokenizationResult {\n\t\tthrow new Error('Not supported!');\n\t}\n\n\tpublic createBackgroundTokenizer(textModel: ITextModel, store: IBackgroundTokenizationStore): IBackgroundTokenizer | undefined {\n\t\tif (this._createBackgroundTokenizer) {\n\t\t\treturn this._createBackgroundTokenizer(textModel, store);\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tpublic tokenizeEncoded(line: string, hasEOL: boolean, state: StateStack): EncodedTokenizationResult {\n\t\tconst isRandomSample = Math.random() * 10_000 < 1;\n\t\tconst shouldMeasure = this._reportSlowTokenization || isRandomSample;\n\t\tconst sw = shouldMeasure ? new StopWatch(true) : undefined;\n\t\tconst textMateResult = this._grammar.tokenizeLine2(line, state, 500);\n\t\tif (shouldMeasure) {\n\t\t\tconst timeMS = sw!.elapsed();\n\t\t\tif (isRandomSample || timeMS > 32) {\n\t\t\t\tthis._reportTokenizationTime(timeMS, line.length, isRandomSample);\n\t\t\t}\n\t\t}\n\n\t\tif (textMateResult.stoppedEarly) {\n\t\t\tconsole.warn(`Time limit reached when tokenizing line: ${line.substring(0, 100)}`);\n\t\t\t// return the state at the beginning of the line\n\t\t\treturn new EncodedTokenizationResult(textMateResult.tokens, state);\n\t\t}\n\n\t\tif (this._containsEmbeddedLanguages) {\n\t\t\tconst seenLanguages = this._seenLanguages;\n\t\t\tconst tokens = textMateResult.tokens;\n\n\t\t\t// Must check if any of the embedded languages was hit\n\t\t\tfor (let i = 0, len = (tokens.length >>> 1); i < len; i++) {\n\t\t\t\tconst metadata = tokens[(i << 1) + 1];\n\t\t\t\tconst languageId = TokenMetadata.getLanguageId(metadata);\n\n\t\t\t\tif (!seenLanguages[languageId]) {\n\t\t\t\t\tseenLanguages[languageId] = true;\n\t\t\t\t\tthis._onDidEncounterLanguage.fire(languageId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet endState: StateStack;\n\t\t// try to save an object if possible\n\t\tif (state.equals(textMateResult.ruleStack)) {\n\t\t\tendState = state;\n\t\t} else {\n\t\t\tendState = textMateResult.ruleStack;\n\t\t}\n\n\t\treturn new EncodedTokenizationResult(textMateResult.tokens, endState);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { LanguageId } from 'vs/editor/common/encodedTokenAttributes';\nimport { EncodedTokenizationResult, IBackgroundTokenizationStore, IBackgroundTokenizer, IState, ITokenizationSupport, TokenizationResult } from 'vs/editor/common/languages';\nimport { nullTokenizeEncoded } from 'vs/editor/common/languages/nullTokenize';\nimport { ITextModel } from 'vs/editor/common/model';\nimport { Disposable } from 'vs/base/common/lifecycle';\nimport { IObservable, keepObserved } from 'vs/base/common/observable';\n\nexport class TokenizationSupportWithLineLimit extends Disposable implements ITokenizationSupport {\n\tget backgroundTokenizerShouldOnlyVerifyTokens(): boolean | undefined {\n\t\treturn this._actual.backgroundTokenizerShouldOnlyVerifyTokens;\n\t}\n\n\tconstructor(\n\t\tprivate readonly _encodedLanguageId: LanguageId,\n\t\tprivate readonly _actual: ITokenizationSupport,\n\t\tprivate readonly _maxTokenizationLineLength: IObservable<number>,\n\t) {\n\t\tsuper();\n\n\t\tthis._register(keepObserved(this._maxTokenizationLineLength));\n\t}\n\n\tgetInitialState(): IState {\n\t\treturn this._actual.getInitialState();\n\t}\n\n\ttokenize(line: string, hasEOL: boolean, state: IState): TokenizationResult {\n\t\tthrow new Error('Not supported!');\n\t}\n\n\ttokenizeEncoded(line: string, hasEOL: boolean, state: IState): EncodedTokenizationResult {\n\t\t// Do not attempt to tokenize if a line is too long\n\t\tif (line.length >= this._maxTokenizationLineLength.get()) {\n\t\t\treturn nullTokenizeEncoded(this._encodedLanguageId, state);\n\t\t}\n\n\t\treturn this._actual.tokenizeEncoded(line, hasEOL, state);\n\t}\n\n\tcreateBackgroundTokenizer(textModel: ITextModel, store: IBackgroundTokenizationStore): IBackgroundTokenizer | undefined {\n\t\tif (this._actual.createBackgroundTokenizer) {\n\t\t\treturn this._actual.createBackgroundTokenizer(textModel, store);\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { importAMDNodeModule } from 'vs/amdX';\nimport { RunOnceScheduler } from 'vs/base/common/async';\nimport { observableValue } from 'vs/base/common/observable';\nimport { setTimeout0 } from 'vs/base/common/platform';\nimport { URI } from 'vs/base/common/uri';\nimport { LineRange } from 'vs/editor/common/core/lineRange';\nimport { LanguageId } from 'vs/editor/common/encodedTokenAttributes';\nimport { IModelChangedEvent, MirrorTextModel } from 'vs/editor/common/model/mirrorTextModel';\nimport { TokenizerWithStateStore } from 'vs/editor/common/model/textModelTokens';\nimport { ContiguousMultilineTokensBuilder } from 'vs/editor/common/tokens/contiguousMultilineTokensBuilder';\nimport { LineTokens } from 'vs/editor/common/tokens/lineTokens';\nimport { TextMateTokenizationSupport } from 'vs/workbench/services/textMate/browser/tokenizationSupport/textMateTokenizationSupport';\nimport { TokenizationSupportWithLineLimit } from 'vs/workbench/services/textMate/browser/tokenizationSupport/tokenizationSupportWithLineLimit';\nimport type { StackDiff, StateStack, diffStateStacksRefEq } from 'vscode-textmate';\nimport { ICreateGrammarResult } from 'vs/workbench/services/textMate/common/TMGrammarFactory';\nimport { StateDeltas } from 'vs/workbench/services/textMate/browser/backgroundTokenization/worker/textMateTokenizationWorker.worker';\n\nexport interface TextMateModelTokenizerHost {\n\tgetOrCreateGrammar(languageId: string, encodedLanguageId: LanguageId): Promise<ICreateGrammarResult | null>;\n\tsetTokensAndStates(versionId: number, tokens: Uint8Array, stateDeltas: StateDeltas[]): void;\n\treportTokenizationTime(timeMs: number, languageId: string, sourceExtensionId: string | undefined, lineLength: number, isRandomSample: boolean): void;\n}\n\nexport class TextMateWorkerTokenizer extends MirrorTextModel {\n\tprivate _tokenizerWithStateStore: TokenizerWithStateStore<StateStack> | null = null;\n\tprivate _isDisposed: boolean = false;\n\tprivate readonly _maxTokenizationLineLength = observableValue(this, -1);\n\tprivate _diffStateStacksRefEqFn?: typeof diffStateStacksRefEq;\n\tprivate readonly _tokenizeDebouncer = new RunOnceScheduler(() => this._tokenize(), 10);\n\n\tconstructor(\n\t\turi: URI,\n\t\tlines: string[],\n\t\teol: string,\n\t\tversionId: number,\n\t\tprivate readonly _host: TextMateModelTokenizerHost,\n\t\tprivate _languageId: string,\n\t\tprivate _encodedLanguageId: LanguageId,\n\t\tmaxTokenizationLineLength: number,\n\t) {\n\t\tsuper(uri, lines, eol, versionId);\n\t\tthis._maxTokenizationLineLength.set(maxTokenizationLineLength, undefined);\n\t\tthis._resetTokenization();\n\t}\n\n\tpublic override dispose(): void {\n\t\tthis._isDisposed = true;\n\t\tsuper.dispose();\n\t}\n\n\tpublic onLanguageId(languageId: string, encodedLanguageId: LanguageId): void {\n\t\tthis._languageId = languageId;\n\t\tthis._encodedLanguageId = encodedLanguageId;\n\t\tthis._resetTokenization();\n\t}\n\n\toverride onEvents(e: IModelChangedEvent): void {\n\t\tsuper.onEvents(e);\n\n\t\tthis._tokenizerWithStateStore?.store.acceptChanges(e.changes);\n\t\tthis._tokenizeDebouncer.schedule();\n\t}\n\n\tpublic acceptMaxTokenizationLineLength(maxTokenizationLineLength: number): void {\n\t\tthis._maxTokenizationLineLength.set(maxTokenizationLineLength, undefined);\n\t}\n\n\tpublic retokenize(startLineNumber: number, endLineNumberExclusive: number) {\n\t\tif (this._tokenizerWithStateStore) {\n\t\t\tthis._tokenizerWithStateStore.store.invalidateEndStateRange(new LineRange(startLineNumber, endLineNumberExclusive));\n\t\t\tthis._tokenizeDebouncer.schedule();\n\t\t}\n\t}\n\n\tprivate async _resetTokenization() {\n\t\tthis._tokenizerWithStateStore = null;\n\n\t\tconst languageId = this._languageId;\n\t\tconst encodedLanguageId = this._encodedLanguageId;\n\n\t\tconst r = await this._host.getOrCreateGrammar(languageId, encodedLanguageId);\n\n\t\tif (this._isDisposed || languageId !== this._languageId || encodedLanguageId !== this._encodedLanguageId || !r) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (r.grammar) {\n\t\t\tconst tokenizationSupport = new TokenizationSupportWithLineLimit(\n\t\t\t\tthis._encodedLanguageId,\n\t\t\t\tnew TextMateTokenizationSupport(r.grammar, r.initialState, false, undefined, () => false,\n\t\t\t\t\t(timeMs, lineLength, isRandomSample) => {\n\t\t\t\t\t\tthis._host.reportTokenizationTime(timeMs, languageId, r.sourceExtensionId, lineLength, isRandomSample);\n\t\t\t\t\t},\n\t\t\t\t\tfalse\n\t\t\t\t),\n\t\t\t\tthis._maxTokenizationLineLength\n\t\t\t);\n\t\t\tthis._tokenizerWithStateStore = new TokenizerWithStateStore(this._lines.length, tokenizationSupport);\n\t\t} else {\n\t\t\tthis._tokenizerWithStateStore = null;\n\t\t}\n\t\tthis._tokenize();\n\t}\n\n\tprivate async _tokenize(): Promise<void> {\n\t\tif (this._isDisposed || !this._tokenizerWithStateStore) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this._diffStateStacksRefEqFn) {\n\t\t\tconst { diffStateStacksRefEq } = await importAMDNodeModule<typeof import('vscode-textmate')>('vscode-textmate', 'release/main.js');\n\t\t\tthis._diffStateStacksRefEqFn = diffStateStacksRefEq;\n\t\t}\n\n\t\tconst startTime = new Date().getTime();\n\n\t\twhile (true) {\n\t\t\tlet tokenizedLines = 0;\n\t\t\tconst tokenBuilder = new ContiguousMultilineTokensBuilder();\n\t\t\tconst stateDeltaBuilder = new StateDeltaBuilder();\n\n\t\t\twhile (true) {\n\t\t\t\tconst lineToTokenize = this._tokenizerWithStateStore.getFirstInvalidLine();\n\t\t\t\tif (lineToTokenize === null || tokenizedLines > 200) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\ttokenizedLines++;\n\n\t\t\t\tconst text = this._lines[lineToTokenize.lineNumber - 1];\n\t\t\t\tconst r = this._tokenizerWithStateStore.tokenizationSupport.tokenizeEncoded(text, true, lineToTokenize.startState);\n\t\t\t\tif (this._tokenizerWithStateStore.store.setEndState(lineToTokenize.lineNumber, r.endState as StateStack)) {\n\t\t\t\t\tconst delta = this._diffStateStacksRefEqFn(lineToTokenize.startState, r.endState as StateStack);\n\t\t\t\t\tstateDeltaBuilder.setState(lineToTokenize.lineNumber, delta);\n\t\t\t\t} else {\n\t\t\t\t\tstateDeltaBuilder.setState(lineToTokenize.lineNumber, null);\n\t\t\t\t}\n\n\t\t\t\tLineTokens.convertToEndOffset(r.tokens, text.length);\n\t\t\t\ttokenBuilder.add(lineToTokenize.lineNumber, r.tokens);\n\n\t\t\t\tconst deltaMs = new Date().getTime() - startTime;\n\t\t\t\tif (deltaMs > 20) {\n\t\t\t\t\t// yield to check for changes\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tokenizedLines === 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst stateDeltas = stateDeltaBuilder.getStateDeltas();\n\t\t\tthis._host.setTokensAndStates(\n\t\t\t\tthis._versionId,\n\t\t\t\ttokenBuilder.serialize(),\n\t\t\t\tstateDeltas\n\t\t\t);\n\n\t\t\tconst deltaMs = new Date().getTime() - startTime;\n\t\t\tif (deltaMs > 20) {\n\t\t\t\t// yield to check for changes\n\t\t\t\tsetTimeout0(() => this._tokenize());\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass StateDeltaBuilder {\n\tprivate _lastStartLineNumber: number = -1;\n\tprivate _stateDeltas: StateDeltas[] = [];\n\n\tpublic setState(lineNumber: number, stackDiff: StackDiff | null): void {\n\t\tif (lineNumber === this._lastStartLineNumber + 1) {\n\t\t\tthis._stateDeltas[this._stateDeltas.length - 1].stateDeltas.push(stackDiff);\n\t\t} else {\n\t\t\tthis._stateDeltas.push({ startLineNumber: lineNumber, stateDeltas: [stackDiff] });\n\t\t}\n\t\tthis._lastStartLineNumber = lineNumber;\n\t}\n\n\tpublic getStateDeltas(): StateDeltas[] {\n\t\treturn this._stateDeltas;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as resources from 'vs/base/common/resources';\nimport { URI } from 'vs/base/common/uri';\nimport { LanguageId, StandardTokenType } from 'vs/editor/common/encodedTokenAttributes';\n\nexport interface IValidGrammarDefinition {\n\tlocation: URI;\n\tlanguage?: string;\n\tscopeName: string;\n\tembeddedLanguages: IValidEmbeddedLanguagesMap;\n\ttokenTypes: IValidTokenTypeMap;\n\tinjectTo?: string[];\n\tbalancedBracketSelectors: string[];\n\tunbalancedBracketSelectors: string[];\n\tsourceExtensionId?: string;\n}\n\nexport interface IValidTokenTypeMap {\n\t[selector: string]: StandardTokenType;\n}\n\nexport interface IValidEmbeddedLanguagesMap {\n\t[scopeName: string]: LanguageId;\n}\n\nexport class TMScopeRegistry {\n\n\tprivate _scopeNameToLanguageRegistration: { [scopeName: string]: IValidGrammarDefinition };\n\n\tconstructor() {\n\t\tthis._scopeNameToLanguageRegistration = Object.create(null);\n\t}\n\n\tpublic reset(): void {\n\t\tthis._scopeNameToLanguageRegistration = Object.create(null);\n\t}\n\n\tpublic register(def: IValidGrammarDefinition): void {\n\t\tif (this._scopeNameToLanguageRegistration[def.scopeName]) {\n\t\t\tconst existingRegistration = this._scopeNameToLanguageRegistration[def.scopeName];\n\t\t\tif (!resources.isEqual(existingRegistration.location, def.location)) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`Overwriting grammar scope name to file mapping for scope ${def.scopeName}.\\n` +\n\t\t\t\t\t`Old grammar file: ${existingRegistration.location.toString()}.\\n` +\n\t\t\t\t\t`New grammar file: ${def.location.toString()}`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tthis._scopeNameToLanguageRegistration[def.scopeName] = def;\n\t}\n\n\tpublic getGrammarDefinition(scopeName: string): IValidGrammarDefinition | null {\n\t\treturn this._scopeNameToLanguageRegistration[scopeName] || null;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Disposable } from 'vs/base/common/lifecycle';\nimport { URI } from 'vs/base/common/uri';\nimport { IValidEmbeddedLanguagesMap, IValidGrammarDefinition, TMScopeRegistry } from 'vs/workbench/services/textMate/common/TMScopeRegistry';\nimport type { IGrammar, IOnigLib, IRawTheme, Registry, StateStack } from 'vscode-textmate';\n\ninterface ITMGrammarFactoryHost {\n\tlogTrace(msg: string): void;\n\tlogError(msg: string, err: any): void;\n\treadFile(resource: URI): Promise<string>;\n}\n\nexport interface ICreateGrammarResult {\n\tlanguageId: string;\n\tgrammar: IGrammar | null;\n\tinitialState: StateStack;\n\tcontainsEmbeddedLanguages: boolean;\n\tsourceExtensionId?: string;\n}\n\nexport const missingTMGrammarErrorMessage = 'No TM Grammar registered for this language.';\n\nexport class TMGrammarFactory extends Disposable {\n\n\tprivate readonly _host: ITMGrammarFactoryHost;\n\tprivate readonly _initialState: StateStack;\n\tprivate readonly _scopeRegistry: TMScopeRegistry;\n\tprivate readonly _injections: { [scopeName: string]: string[] };\n\tprivate readonly _injectedEmbeddedLanguages: { [scopeName: string]: IValidEmbeddedLanguagesMap[] };\n\tprivate readonly _languageToScope: Map<string, string>;\n\tprivate readonly _grammarRegistry: Registry;\n\n\tconstructor(host: ITMGrammarFactoryHost, grammarDefinitions: IValidGrammarDefinition[], vscodeTextmate: typeof import('vscode-textmate'), onigLib: Promise<IOnigLib>) {\n\t\tsuper();\n\t\tthis._host = host;\n\t\tthis._initialState = vscodeTextmate.INITIAL;\n\t\tthis._scopeRegistry = new TMScopeRegistry();\n\t\tthis._injections = {};\n\t\tthis._injectedEmbeddedLanguages = {};\n\t\tthis._languageToScope = new Map<string, string>();\n\t\tthis._grammarRegistry = this._register(new vscodeTextmate.Registry({\n\t\t\tonigLib: onigLib,\n\t\t\tloadGrammar: async (scopeName: string) => {\n\t\t\t\tconst grammarDefinition = this._scopeRegistry.getGrammarDefinition(scopeName);\n\t\t\t\tif (!grammarDefinition) {\n\t\t\t\t\tthis._host.logTrace(`No grammar found for scope ${scopeName}`);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tconst location = grammarDefinition.location;\n\t\t\t\ttry {\n\t\t\t\t\tconst content = await this._host.readFile(location);\n\t\t\t\t\treturn vscodeTextmate.parseRawGrammar(content, location.path);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthis._host.logError(`Unable to load and parse grammar for scope ${scopeName} from ${location}`, e);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t},\n\t\t\tgetInjections: (scopeName: string) => {\n\t\t\t\tconst scopeParts = scopeName.split('.');\n\t\t\t\tlet injections: string[] = [];\n\t\t\t\tfor (let i = 1; i <= scopeParts.length; i++) {\n\t\t\t\t\tconst subScopeName = scopeParts.slice(0, i).join('.');\n\t\t\t\t\tinjections = [...injections, ...(this._injections[subScopeName] || [])];\n\t\t\t\t}\n\t\t\t\treturn injections;\n\t\t\t}\n\t\t}));\n\n\t\tfor (const validGrammar of grammarDefinitions) {\n\t\t\tthis._scopeRegistry.register(validGrammar);\n\n\t\t\tif (validGrammar.injectTo) {\n\t\t\t\tfor (const injectScope of validGrammar.injectTo) {\n\t\t\t\t\tlet injections = this._injections[injectScope];\n\t\t\t\t\tif (!injections) {\n\t\t\t\t\t\tthis._injections[injectScope] = injections = [];\n\t\t\t\t\t}\n\t\t\t\t\tinjections.push(validGrammar.scopeName);\n\t\t\t\t}\n\n\t\t\t\tif (validGrammar.embeddedLanguages) {\n\t\t\t\t\tfor (const injectScope of validGrammar.injectTo) {\n\t\t\t\t\t\tlet injectedEmbeddedLanguages = this._injectedEmbeddedLanguages[injectScope];\n\t\t\t\t\t\tif (!injectedEmbeddedLanguages) {\n\t\t\t\t\t\t\tthis._injectedEmbeddedLanguages[injectScope] = injectedEmbeddedLanguages = [];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinjectedEmbeddedLanguages.push(validGrammar.embeddedLanguages);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (validGrammar.language) {\n\t\t\t\tthis._languageToScope.set(validGrammar.language, validGrammar.scopeName);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic has(languageId: string): boolean {\n\t\treturn this._languageToScope.has(languageId);\n\t}\n\n\tpublic setTheme(theme: IRawTheme, colorMap: string[]): void {\n\t\tthis._grammarRegistry.setTheme(theme, colorMap);\n\t}\n\n\tpublic getColorMap(): string[] {\n\t\treturn this._grammarRegistry.getColorMap();\n\t}\n\n\tpublic async createGrammar(languageId: string, encodedLanguageId: number): Promise<ICreateGrammarResult> {\n\t\tconst scopeName = this._languageToScope.get(languageId);\n\t\tif (typeof scopeName !== 'string') {\n\t\t\t// No TM grammar defined\n\t\t\tthrow new Error(missingTMGrammarErrorMessage);\n\t\t}\n\n\t\tconst grammarDefinition = this._scopeRegistry.getGrammarDefinition(scopeName);\n\t\tif (!grammarDefinition) {\n\t\t\t// No TM grammar defined\n\t\t\tthrow new Error(missingTMGrammarErrorMessage);\n\t\t}\n\n\t\tconst embeddedLanguages = grammarDefinition.embeddedLanguages;\n\t\tif (this._injectedEmbeddedLanguages[scopeName]) {\n\t\t\tconst injectedEmbeddedLanguages = this._injectedEmbeddedLanguages[scopeName];\n\t\t\tfor (const injected of injectedEmbeddedLanguages) {\n\t\t\t\tfor (const scope of Object.keys(injected)) {\n\t\t\t\t\tembeddedLanguages[scope] = injected[scope];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst containsEmbeddedLanguages = (Object.keys(embeddedLanguages).length > 0);\n\n\t\tlet grammar: IGrammar | null;\n\n\t\ttry {\n\t\t\tgrammar = await this._grammarRegistry.loadGrammarWithConfiguration(\n\t\t\t\tscopeName,\n\t\t\t\tencodedLanguageId,\n\t\t\t\t{\n\t\t\t\t\tembeddedLanguages,\n\t\t\t\t\ttokenTypes: <any>grammarDefinition.tokenTypes,\n\t\t\t\t\tbalancedBracketSelectors: grammarDefinition.balancedBracketSelectors,\n\t\t\t\t\tunbalancedBracketSelectors: grammarDefinition.unbalancedBracketSelectors,\n\t\t\t\t}\n\t\t\t);\n\t\t} catch (err) {\n\t\t\tif (err.message && err.message.startsWith('No grammar provided for')) {\n\t\t\t\t// No TM grammar defined\n\t\t\t\tthrow new Error(missingTMGrammarErrorMessage);\n\t\t\t}\n\t\t\tthrow err;\n\t\t}\n\n\t\treturn {\n\t\t\tlanguageId: languageId,\n\t\t\tgrammar: grammar,\n\t\t\tinitialState: this._initialState,\n\t\t\tcontainsEmbeddedLanguages: containsEmbeddedLanguages,\n\t\t\tsourceExtensionId: grammarDefinition.sourceExtensionId,\n\t\t};\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI, UriComponents } from 'vs/base/common/uri';\nimport { LanguageId } from 'vs/editor/common/encodedTokenAttributes';\nimport { IModelChangedEvent } from 'vs/editor/common/model/mirrorTextModel';\nimport { IWorkerContext } from 'vs/editor/common/services/editorSimpleWorker';\nimport { ICreateGrammarResult, TMGrammarFactory } from 'vs/workbench/services/textMate/common/TMGrammarFactory';\nimport { IValidEmbeddedLanguagesMap, IValidGrammarDefinition, IValidTokenTypeMap } from 'vs/workbench/services/textMate/common/TMScopeRegistry';\nimport type { IOnigLib, IRawTheme, StackDiff } from 'vscode-textmate';\nimport { TextMateWorkerTokenizer } from './textMateWorkerTokenizer';\n\n/**\n * Defines the worker entry point. Must be exported and named `create`.\n */\nexport function create(ctx: IWorkerContext<ITextMateWorkerHost>, createData: ICreateData): TextMateTokenizationWorker {\n\treturn new TextMateTokenizationWorker(ctx, createData);\n}\n\nexport interface ITextMateWorkerHost {\n\treadFile(_resource: UriComponents): Promise<string>;\n\tsetTokensAndStates(controllerId: number, versionId: number, tokens: Uint8Array, lineEndStateDeltas: StateDeltas[]): Promise<void>;\n\treportTokenizationTime(timeMs: number, languageId: string, sourceExtensionId: string | undefined, lineLength: number, isRandomSample: boolean): void;\n}\n\nexport interface ICreateData {\n\tgrammarDefinitions: IValidGrammarDefinitionDTO[];\n\ttextmateMainUri: string;\n\tonigurumaMainUri: string;\n\tonigurumaWASMUri: string;\n}\n\nexport interface IValidGrammarDefinitionDTO {\n\tlocation: UriComponents;\n\tlanguage?: string;\n\tscopeName: string;\n\tembeddedLanguages: IValidEmbeddedLanguagesMap;\n\ttokenTypes: IValidTokenTypeMap;\n\tinjectTo?: string[];\n\tbalancedBracketSelectors: string[];\n\tunbalancedBracketSelectors: string[];\n\tsourceExtensionId?: string;\n}\n\nexport interface StateDeltas {\n\tstartLineNumber: number;\n\t// null means the state for that line did not change\n\tstateDeltas: (StackDiff | null)[];\n}\n\nexport class TextMateTokenizationWorker {\n\tprivate readonly _host: ITextMateWorkerHost;\n\tprivate readonly _models = new Map</* controllerId */ number, TextMateWorkerTokenizer>();\n\tprivate readonly _grammarCache: Promise<ICreateGrammarResult>[] = [];\n\tprivate readonly _grammarFactory: Promise<TMGrammarFactory | null>;\n\n\tconstructor(\n\t\tctx: IWorkerContext<ITextMateWorkerHost>,\n\t\tprivate readonly _createData: ICreateData\n\t) {\n\t\tthis._host = ctx.host;\n\t\tconst grammarDefinitions = _createData.grammarDefinitions.map<IValidGrammarDefinition>((def) => {\n\t\t\treturn {\n\t\t\t\tlocation: URI.revive(def.location),\n\t\t\t\tlanguage: def.language,\n\t\t\t\tscopeName: def.scopeName,\n\t\t\t\tembeddedLanguages: def.embeddedLanguages,\n\t\t\t\ttokenTypes: def.tokenTypes,\n\t\t\t\tinjectTo: def.injectTo,\n\t\t\t\tbalancedBracketSelectors: def.balancedBracketSelectors,\n\t\t\t\tunbalancedBracketSelectors: def.unbalancedBracketSelectors,\n\t\t\t\tsourceExtensionId: def.sourceExtensionId,\n\t\t\t};\n\t\t});\n\t\tthis._grammarFactory = this._loadTMGrammarFactory(grammarDefinitions);\n\t}\n\n\tprivate async _loadTMGrammarFactory(grammarDefinitions: IValidGrammarDefinition[]): Promise<TMGrammarFactory> {\n\t\tconst uri = this._createData.textmateMainUri;\n\t\tconst vscodeTextmate = await import(uri);\n\t\tconst vscodeOniguruma = await import(this._createData.onigurumaMainUri);\n\t\tconst response = await fetch(this._createData.onigurumaWASMUri);\n\n\t\t// Using the response directly only works if the server sets the MIME type 'application/wasm'.\n\t\t// Otherwise, a TypeError is thrown when using the streaming compiler.\n\t\t// We therefore use the non-streaming compiler :(.\n\t\tconst bytes = await response.arrayBuffer();\n\t\tawait vscodeOniguruma.loadWASM(bytes);\n\n\t\tconst onigLib: Promise<IOnigLib> = Promise.resolve({\n\t\t\tcreateOnigScanner: (sources) => vscodeOniguruma.createOnigScanner(sources),\n\t\t\tcreateOnigString: (str) => vscodeOniguruma.createOnigString(str)\n\t\t});\n\n\t\treturn new TMGrammarFactory({\n\t\t\tlogTrace: (msg: string) => {/* console.log(msg) */ },\n\t\t\tlogError: (msg: string, err: any) => console.error(msg, err),\n\t\t\treadFile: (resource: URI) => this._host.readFile(resource)\n\t\t}, grammarDefinitions, vscodeTextmate, onigLib);\n\t}\n\n\t// These methods are called by the renderer\n\n\tpublic acceptNewModel(data: IRawModelData): void {\n\t\tconst uri = URI.revive(data.uri);\n\t\tconst that = this;\n\t\tthis._models.set(data.controllerId, new TextMateWorkerTokenizer(uri, data.lines, data.EOL, data.versionId, {\n\t\t\tasync getOrCreateGrammar(languageId: string, encodedLanguageId: LanguageId): Promise<ICreateGrammarResult | null> {\n\t\t\t\tconst grammarFactory = await that._grammarFactory;\n\t\t\t\tif (!grammarFactory) {\n\t\t\t\t\treturn Promise.resolve(null);\n\t\t\t\t}\n\t\t\t\tif (!that._grammarCache[encodedLanguageId]) {\n\t\t\t\t\tthat._grammarCache[encodedLanguageId] = grammarFactory.createGrammar(languageId, encodedLanguageId);\n\t\t\t\t}\n\t\t\t\treturn that._grammarCache[encodedLanguageId];\n\t\t\t},\n\t\t\tsetTokensAndStates(versionId: number, tokens: Uint8Array, stateDeltas: StateDeltas[]): void {\n\t\t\t\tthat._host.setTokensAndStates(data.controllerId, versionId, tokens, stateDeltas);\n\t\t\t},\n\t\t\treportTokenizationTime(timeMs: number, languageId: string, sourceExtensionId: string | undefined, lineLength: number, isRandomSample: boolean): void {\n\t\t\t\tthat._host.reportTokenizationTime(timeMs, languageId, sourceExtensionId, lineLength, isRandomSample);\n\t\t\t},\n\t\t}, data.languageId, data.encodedLanguageId, data.maxTokenizationLineLength));\n\t}\n\n\tpublic acceptModelChanged(controllerId: number, e: IModelChangedEvent): void {\n\t\tthis._models.get(controllerId)!.onEvents(e);\n\t}\n\n\tpublic retokenize(controllerId: number, startLineNumber: number, endLineNumberExclusive: number): void {\n\t\tthis._models.get(controllerId)!.retokenize(startLineNumber, endLineNumberExclusive);\n\t}\n\n\tpublic acceptModelLanguageChanged(controllerId: number, newLanguageId: string, newEncodedLanguageId: LanguageId): void {\n\t\tthis._models.get(controllerId)!.onLanguageId(newLanguageId, newEncodedLanguageId);\n\t}\n\n\tpublic acceptRemovedModel(controllerId: number): void {\n\t\tconst model = this._models.get(controllerId);\n\t\tif (model) {\n\t\t\tmodel.dispose();\n\t\t\tthis._models.delete(controllerId);\n\t\t}\n\t}\n\n\tpublic async acceptTheme(theme: IRawTheme, colorMap: string[]): Promise<void> {\n\t\tconst grammarFactory = await this._grammarFactory;\n\t\tgrammarFactory?.setTheme(theme, colorMap);\n\t}\n\n\tpublic acceptMaxTokenizationLineLength(controllerId: number, value: number): void {\n\t\tthis._models.get(controllerId)!.acceptMaxTokenizationLineLength(value);\n\t}\n}\n\nexport interface IRawModelData {\n\turi: UriComponents;\n\tversionId: number;\n\tlines: string[];\n\tEOL: string;\n\tlanguageId: string;\n\tencodedLanguageId: LanguageId;\n\tmaxTokenizationLineLength: number;\n\tcontrollerId: number;\n}\n"],"mappings":"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","names":["__m","__M","deps","result","i","len","exports","$U","amdLoadScript","amdInvokeFactory","nodeRequire","nodeEval","mark","map","stat","diff","duration","stats","require","a","b","nodeRequireTotal","value","to2dArray","res","index","header","rows","lengths","cell","ci","row","_cell","$7c","$8c","$6c","owner","debugNameSource","referenceFn","target","countPerName","cachedDebugName","data","cached","dbgName","computeDebugName","count","self","ownerStr","formatOwner","key","findKey","obj","countPerClassName","ownerId","id","className","getClassName","ctor","fn","fnSrc","match","$yd","$zd","globalObservableLogger","logger","$Ad","text","consoleTextToArgs","normalText","repeat","info","styled","formatValue","observable","formatKind","changes","o","derived","existingHandleChange","change","changedObservables","autorun","transaction","transactionName","styles","firstArg","process","t","item","kind","padStr","options","objToCss","styleObj","styleString","propName","propValue","style","availableLen","formatArray","formatObject","first","val","str","length","$cd","$dd","$ed","$fd","$gd","$hd","$id","debugName_1","store","lifecycle_1","disposable","reader","changeSummary","handler","_lastValue","newValue","lastValue","AutorunState","h","_runFn","j","logging_1","emptySet","isDisposed","d","assert_1","$Id","$Jd","$Kd","$Nd","$Od","$Pd","$Qd","$Sd","$Ud","_recomputeInitiallyAndOnChange","recomputeInitiallyAndOnChange","_keepObserved","keepObserved","_derived","$Ld","fnOrOwner","fnOrUndefined","name","handleValue","$Md","observer","getDebugName","tx","$Rd","_globalTransaction","_fn","updatingObservers","nameOrOwner","initialValue","$Td","_tx","oldValue","$Vd","$Cd","$Dd","$Ed","$Fd","$Gd","$Bd","computeFnOrOwner","computeFn","$Hd","base_1","computeFnOrUndefined","r","DerivedState","n","_computeFn","p","q","s","hadValue","didChange","_observable","propagateBeginUpdate","observers","shouldReact","wasUpToDate","shouldCallBeginUpdate","shouldCallEndUpdate","$jd","$kd","$ld","$nd","$od","$pd","$qd","$rd","$sd","$td","$vd","$wd","$xd","ConstObservable","promise","event","getValue","$md","_getValue","args","didRunTransaction","batchEventsGlobally","didSet","debugName","FromEventObservableSignal","debugNameOrOwner","ObservableSignal","debounceMs","disposableStore","debouncedObservable","timeout","autorun_1","hasValue","cb","timeoutMs","$ud","c","derived_1","counter","items","keySelector","m","ArrayMap","e","entry","newItems","itemsToRemove","$1d","$2d","$Wd","v","$Xd","$Yd","error","$Zd","predicate","isError","resolve","reject","isImmediateRun","shouldDispose","stateObs","state","isFinished","cancellationTokenSource","cancellation_1","utils_1","promise_1","$fe","$ge","$he","$ie","$je","$ke","$le","$me","$ne","$oe","$pe","$qe","$re","$se","$te","candidate","reducer","WriteableStreamImpl","f","listener","errors_1","callback","listeners","fullDataBuffer","pendingWritePromises","pendingWritePromise","readable","chunks","chunk","maxChunks","lastReadChunk","stream","token","streamListeners","buffer","dataListener","errorListener","endListener","consumed","transformer","prefix","prefixHandled","$ve","$we","$xe","$ye","$ze","$Ae","$Be","$Ce","$De","$Ee","$Fe","$Ge","$He","$Ie","$Je","$Ke","$Le","$Me","$Ne","$Oe","hasBuffer","indexOfTable","lazy_1","textEncoder","textDecoder","$ue","byteLength","actual","source","buffers","totalLength","ret","offset","element","start","end","array","subarray","haystack","needle","needleLen","haystackLen","table","destination","streams","bufferedStream","encoded","building","remainder","bufi","append","code","unpadded","base64Alphabet","base64UrlSafeAlphabet","padded","urlSafe","dictionary","output","$Ot","StringEOL","eolCount","firstLineLength","lastLineStart","eol","chr","LanguageId","FontStyle","ColorId","StandardTokenType","MetadataConsts","$Mt","metadata","fontStyle","colorMap","foreground","textDecoration","$IC","oldLength","newLength","before","after","insertArr","arrayFill","deleteIndex","deleteCount","insertIndex","insertCount","arr","arrays_1","$Pt","lineContent","decoder","defaultMetadata","tokens","other","sliceFromTokenIndex","sliceTokenCount","from","to","tokenIndex","languageId","encodedTokenAttributes_1","startOffset","endOffset","deltaOffset","SliceLineTokens","lineTextLength","lastTokenIndex","desiredIndex","low","high","mid","insertTokens","nextOriginalTokenIdx","nextInsertTokenIdx","newTokens","originalEndOffset","nextOriginalTokenEndOffset","nextInsertToken","tokenEndOffset","$St","$Rt","lineTokens","toChIndex","fromChIndex","tokensCount","fromTokenIndex","lineTokens_1","fromTokenStartOffset","fromTokenEndOffset","delta","dest","lastEnd","tmp","_otherTokens","myTokens","otherTokens","otherTokensCount","chIndex","textLength","$Tt","buff","view32","startLineNumber","buffer_1","byteCount","lineRange_1","lineNumber","range","eolCounter_1","position_1","firstLineIndex","lastLineIndex","deletedLinesCount","contiguousTokensEditing_1","lastLineTokens","deletedBefore","position","lineIndex","arrays","$JC","contiguousMultilineTokens_1","last","size","$bg","$cg","$dg","$eg","$fg","$gg","$hg","$ig","$jg","$kg","$lg","$mg","$ng","$og","$pg","$qg","osPath","path_1","path","sep","firstLetter","pos","platform_1","WINDOWS_INVALID_FILE_CHARS","UNIX_INVALID_FILE_CHARS","WINDOWS_FORBIDDEN_NAMES","isWindowsOS","invalidFileChars","pathA","pathB","ignoreCase","identityEquals","strings_1","base","parentCandidate","separator","sepOffset","char0","cwd","pathNormalized","rawPath","segments","line","column","segment","segmentAsNumber","types_1","pathChars","windowsSafePathFirstChars","parent","randomLength","suffix","pathCharsTouse","randomFileName","$rg","$sg","$wg","Schemas","scheme","uri_1","schemes","RemoteAuthoritiesImpl","schema","delegate","product","serverBasePath","paths","authority","host","port","connectionToken","uri","err","errors","query","platform","basePath","FileAccessImpl","resourcePath","uriOrModule","moduleIdToUrl","COI","coiHeaders","coiSearchParamName","getHeadersFromQuery","url","params","addSearchParam","urlOrSearch","coop","coep","$JD","DefineCall","dependencies","AMDModuleImporter","scriptSrc","defineCall","scriptElement","unbind","loadEventListener","errorEventListener","fs","vm","module","filePath","content","scriptSource","cache","_paths","nodeModuleName","pathInsideNodeModule","isBuilt","amd_1","nodeModulePath","network_1","resolve_1","reject_1","$Jg","$5g","$6g","$Kg","uri1","uri2","ignoreFragment","extpath","resource","pathFragment","dirname","normalizedPath","relativePath","fromPath","toPath","newURI","a1","a2","fsp","isRootSep","_","resourceAccessor","distinctParents","candidateResource","otherItem","DataUri","parseMetaData","dataUri","property","mime","localScheme","$7g","$8g","$9g","$0g","$$g","$_g","$ah","$bh","$jh","$kh","$lh","$mh","$nh","$Ch","$Kh","thenable","subscription","onfinally","defaultValue","ref","cancellablePromises","resolvedPromiseIndex","promises","cancellablePromise","onTimeout","promiseResolve","timer","rej","$ch","promiseFactory","onComplete","$dh","promiseTask","$eh","newPromise","timeoutDeferred","scheduled","handle","microtaskDeferred","$fh","defaultDelay","task","delay","symbols_1","$gh","$hh","$ih","autoOpenTimeMs","millis","promiseFactories","results","next","thenHandler","shouldStop","loop","factory","promiseList","todo","finish","$oh","maxDegreeOfParalellism","event_1","iLimitedTask","$ph","$qh","$Dh","$rh","$Fh","queue","extUri","resources_1","drainListenerId","drainListener","drainer","$sh","runner","$th","interval","context","$uh","$vh","$wh","unit","units","$xh","g","_targetWindow","disposed","targetWindow","$Ah","executor","$Bh","retries","lastError","taskId","onCancel","queued","run","promiseReject","$Eh","now","DeferredOutcome","Promises","settled","firstError","withAsyncBody","bodyFn","$Gh","$Hh","AsyncIterableSourceState","$Ih","writer","emitter","iterables","iterable","mapFn","filterFn","values","$Jh","l","innerIterable","$Lh","earlyError","earlyItems","$GC","$HC","languages_1","Constants","$KC","lineCount","tokenizationSupport","$MC","$LC","_textModel","_languageIdCodec","builder","lineToTokenize","safeTokenize","character","lineStartState","newText","curLineContent","newLineContent","firstInvalidLineNumber","endLineNumber","nonWhitespaceColumn","likelyRelevantLines","initialState","newNonWhitespaceIndex","$NC","$OC","offsetRange_1","newLineCount","startState","fixedArray_1","oldState","idx","idxFirstMightBeIntersecting","idxFirstIsAfter","newRange","endEx","languageIdCodec","hasEOL","nullTokenize_1","$PC","async_1","deadline","endTime","execute","contiguousMultilineTokensBuilder_1","sw","stopwatch_1","firstInvalidLine","endLineNumberExclusive","$PKb","textModel","isRandomSample","shouldMeasure","textMateResult","timeMS","seenLanguages","endState","$QKb","observable_1","$VKb","mirrorTextModel_1","lines","versionId","u","maxTokenizationLineLength","encodedLanguageId","tokenizationSupportWithLineLimit_1","textMateTokenizationSupport_1","timeMs","lineLength","textModelTokens_1","diffStateStacksRefEq","amdX_1","startTime","tokenizedLines","tokenBuilder","stateDeltaBuilder","StateDeltaBuilder","stateDeltas","stackDiff","$SKb","def","existingRegistration","resources","scopeName","$UKb","grammarDefinitions","vscodeTextmate","onigLib","TMScopeRegistry_1","grammarDefinition","location","scopeParts","injections","subScopeName","validGrammar","injectScope","injectedEmbeddedLanguages","theme","embeddedLanguages","injected","scope","containsEmbeddedLanguages","grammar","create","ctx","createData","TextMateTokenizationWorker","vscodeOniguruma","resolve_2","reject_2","bytes","sources","TMGrammarFactory_1","msg","that","textMateWorkerTokenizer_1","grammarFactory","sourceExtensionId","controllerId","newLanguageId","newEncodedLanguageId","model"],"file":"textMateTokenizationWorker.worker.js"}