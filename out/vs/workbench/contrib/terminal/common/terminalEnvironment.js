/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(["require", "exports", "vs/base/common/path", "vs/base/common/uri", "vs/base/common/processes", "vs/base/common/platform", "vs/platform/terminal/common/terminalEnvironment", "vs/base/common/types"], function (require, exports, path, uri_1, processes_1, platform_1, terminalEnvironment_1, types_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeEnvironments = mergeEnvironments;
    exports.addTerminalEnvironmentKeys = addTerminalEnvironmentKeys;
    exports.shouldSetLangEnvVariable = shouldSetLangEnvVariable;
    exports.getLangEnvVariable = getLangEnvVariable;
    exports.getCwd = getCwd;
    exports.createVariableResolver = createVariableResolver;
    exports.createTerminalEnvironment = createTerminalEnvironment;
    exports.preparePathForShell = preparePathForShell;
    exports.getWorkspaceForTerminal = getWorkspaceForTerminal;
    function mergeEnvironments(parent, other) {
        if (!other) {
            return;
        }
        // On Windows apply the new values ignoring case, while still retaining
        // the case of the original key.
        if (platform_1.isWindows) {
            for (const configKey in other) {
                let actualKey = configKey;
                for (const envKey in parent) {
                    if (configKey.toLowerCase() === envKey.toLowerCase()) {
                        actualKey = envKey;
                        break;
                    }
                }
                const value = other[configKey];
                if (value !== undefined) {
                    _mergeEnvironmentValue(parent, actualKey, value);
                }
            }
        }
        else {
            Object.keys(other).forEach((key) => {
                const value = other[key];
                if (value !== undefined) {
                    _mergeEnvironmentValue(parent, key, value);
                }
            });
        }
    }
    function _mergeEnvironmentValue(env, key, value) {
        if (typeof value === 'string') {
            env[key] = value;
        }
        else {
            delete env[key];
        }
    }
    function addTerminalEnvironmentKeys(env, version, locale, detectLocale) {
        env['TERM_PROGRAM'] = 'vscode';
        if (version) {
            env['TERM_PROGRAM_VERSION'] = version;
        }
        if (shouldSetLangEnvVariable(env, detectLocale)) {
            env['LANG'] = getLangEnvVariable(locale);
        }
        env['COLORTERM'] = 'truecolor';
    }
    function mergeNonNullKeys(env, other) {
        if (!other) {
            return;
        }
        for (const key of Object.keys(other)) {
            const value = other[key];
            if (value !== undefined && value !== null) {
                env[key] = value;
            }
        }
    }
    async function resolveConfigurationVariables(variableResolver, env) {
        await Promise.all(Object.entries(env).map(async ([key, value]) => {
            if (typeof value === 'string') {
                try {
                    env[key] = await variableResolver(value);
                }
                catch (e) {
                    env[key] = value;
                }
            }
        }));
        return env;
    }
    function shouldSetLangEnvVariable(env, detectLocale) {
        if (detectLocale === 'on') {
            return true;
        }
        if (detectLocale === 'auto') {
            const lang = env['LANG'];
            return !lang || (lang.search(/\.UTF\-8$/) === -1 && lang.search(/\.utf8$/) === -1 && lang.search(/\.euc.+/) === -1);
        }
        return false; // 'off'
    }
    function getLangEnvVariable(locale) {
        const parts = locale ? locale.split('-') : [];
        const n = parts.length;
        if (n === 0) {
            // Fallback to en_US if the locale is unknown
            return 'en_US.UTF-8';
        }
        if (n === 1) {
            // The local may only contain the language, not the variant, if this is the case guess the
            // variant such that it can be used as a valid $LANG variable. The language variant chosen
            // is the original and/or most prominent with help from
            // https://stackoverflow.com/a/2502675/1156119
            // The list of locales was generated by running `locale -a` on macOS
            const languageVariants = {
                af: 'ZA',
                am: 'ET',
                be: 'BY',
                bg: 'BG',
                ca: 'ES',
                cs: 'CZ',
                da: 'DK',
                // de: 'AT',
                // de: 'CH',
                de: 'DE',
                el: 'GR',
                // en: 'AU',
                // en: 'CA',
                // en: 'GB',
                // en: 'IE',
                // en: 'NZ',
                en: 'US',
                es: 'ES',
                et: 'EE',
                eu: 'ES',
                fi: 'FI',
                // fr: 'BE',
                // fr: 'CA',
                // fr: 'CH',
                fr: 'FR',
                he: 'IL',
                hr: 'HR',
                hu: 'HU',
                hy: 'AM',
                is: 'IS',
                // it: 'CH',
                it: 'IT',
                ja: 'JP',
                kk: 'KZ',
                ko: 'KR',
                lt: 'LT',
                // nl: 'BE',
                nl: 'NL',
                no: 'NO',
                pl: 'PL',
                pt: 'BR',
                // pt: 'PT',
                ro: 'RO',
                ru: 'RU',
                sk: 'SK',
                sl: 'SI',
                sr: 'YU',
                sv: 'SE',
                tr: 'TR',
                uk: 'UA',
                zh: 'CN',
            };
            if (parts[0] in languageVariants) {
                parts.push(languageVariants[parts[0]]);
            }
        }
        else {
            // Ensure the variant is uppercase to be a valid $LANG
            parts[1] = parts[1].toUpperCase();
        }
        return parts.join('_') + '.UTF-8';
    }
    async function getCwd(shell, userHome, variableResolver, root, customCwd, logService) {
        if (shell.cwd) {
            const unresolved = (typeof shell.cwd === 'object') ? shell.cwd.fsPath : shell.cwd;
            const resolved = await _resolveCwd(unresolved, variableResolver);
            return (0, terminalEnvironment_1.sanitizeCwd)(resolved || unresolved);
        }
        let cwd;
        if (!shell.ignoreConfigurationCwd && customCwd) {
            if (variableResolver) {
                customCwd = await _resolveCwd(customCwd, variableResolver, logService);
            }
            if (customCwd) {
                if (path.isAbsolute(customCwd)) {
                    cwd = customCwd;
                }
                else if (root) {
                    cwd = path.join(root.fsPath, customCwd);
                }
            }
        }
        // If there was no custom cwd or it was relative with no workspace
        if (!cwd) {
            cwd = root ? root.fsPath : userHome || '';
        }
        return (0, terminalEnvironment_1.sanitizeCwd)(cwd);
    }
    async function _resolveCwd(cwd, variableResolver, logService) {
        if (variableResolver) {
            try {
                return await variableResolver(cwd);
            }
            catch (e) {
                logService?.error('Could not resolve terminal cwd', e);
                return undefined;
            }
        }
        return cwd;
    }
    function createVariableResolver(lastActiveWorkspace, env, configurationResolverService) {
        if (!configurationResolverService) {
            return undefined;
        }
        return (str) => configurationResolverService.resolveWithEnvironment(env, lastActiveWorkspace, str);
    }
    async function createTerminalEnvironment(shellLaunchConfig, envFromConfig, variableResolver, version, detectLocale, baseEnv) {
        // Create a terminal environment based on settings, launch config and permissions
        const env = {};
        if (shellLaunchConfig.strictEnv) {
            // strictEnv is true, only use the requested env (ignoring null entries)
            mergeNonNullKeys(env, shellLaunchConfig.env);
        }
        else {
            // Merge process env with the env from config and from shellLaunchConfig
            mergeNonNullKeys(env, baseEnv);
            const allowedEnvFromConfig = { ...envFromConfig };
            // Resolve env vars from config and shell
            if (variableResolver) {
                if (allowedEnvFromConfig) {
                    await resolveConfigurationVariables(variableResolver, allowedEnvFromConfig);
                }
                if (shellLaunchConfig.env) {
                    await resolveConfigurationVariables(variableResolver, shellLaunchConfig.env);
                }
            }
            // Workaround for https://github.com/microsoft/vscode/issues/204005
            // We should restore the following environment variables when a user
            // launches the application using the CLI so that integrated terminal
            // can still inherit these variables.
            // We are not bypassing the restrictions implied in https://github.com/electron/electron/pull/40770
            // since this only affects integrated terminal and not the application itself.
            if (platform_1.isMacintosh) {
                // Restore NODE_OPTIONS if it was set
                if (env['VSCODE_NODE_OPTIONS']) {
                    env['NODE_OPTIONS'] = env['VSCODE_NODE_OPTIONS'];
                    delete env['VSCODE_NODE_OPTIONS'];
                }
                // Restore NODE_REPL_EXTERNAL_MODULE if it was set
                if (env['VSCODE_NODE_REPL_EXTERNAL_MODULE']) {
                    env['NODE_REPL_EXTERNAL_MODULE'] = env['VSCODE_NODE_REPL_EXTERNAL_MODULE'];
                    delete env['VSCODE_NODE_REPL_EXTERNAL_MODULE'];
                }
            }
            // Sanitize the environment, removing any undesirable VS Code and Electron environment
            // variables
            (0, processes_1.sanitizeProcessEnvironment)(env, 'VSCODE_IPC_HOOK_CLI');
            // Merge config (settings) and ShellLaunchConfig environments
            mergeEnvironments(env, allowedEnvFromConfig);
            mergeEnvironments(env, shellLaunchConfig.env);
            // Adding other env keys necessary to create the process
            addTerminalEnvironmentKeys(env, version, platform_1.language, detectLocale);
        }
        return env;
    }
    /**
     * Takes a path and returns the properly escaped path to send to a given shell. On Windows, this
     * included trying to prepare the path for WSL if needed.
     *
     * @param originalPath The path to be escaped and formatted.
     * @param executable The executable off the shellLaunchConfig.
     * @param title The terminal's title.
     * @param shellType The type of shell the path is being sent to.
     * @param backend The backend for the terminal.
     * @param isWindowsFrontend Whether the frontend is Windows, this is only exposed for injection via
     * tests.
     * @returns An escaped version of the path to be execuded in the terminal.
     */
    async function preparePathForShell(resource, executable, title, shellType, backend, os, isWindowsFrontend = platform_1.isWindows) {
        let originalPath;
        if ((0, types_1.isString)(resource)) {
            originalPath = resource;
        }
        else {
            originalPath = resource.fsPath;
            // Apply backend OS-specific formatting to the path since URI.fsPath uses the frontend's OS
            if (isWindowsFrontend && os !== 1 /* OperatingSystem.Windows */) {
                originalPath = originalPath.replace(/\\/g, '\/');
            }
            else if (!isWindowsFrontend && os === 1 /* OperatingSystem.Windows */) {
                originalPath = originalPath.replace(/\//g, '\\');
            }
        }
        if (!executable) {
            return originalPath;
        }
        const hasSpace = originalPath.includes(' ');
        const hasParens = originalPath.includes('(') || originalPath.includes(')');
        const pathBasename = path.basename(executable, '.exe');
        const isPowerShell = pathBasename === 'pwsh' ||
            title === 'pwsh' ||
            pathBasename === 'powershell' ||
            title === 'powershell';
        if (isPowerShell && (hasSpace || originalPath.includes('\''))) {
            return `& '${originalPath.replace(/'/g, '\'\'')}'`;
        }
        if (hasParens && isPowerShell) {
            return `& '${originalPath}'`;
        }
        if (os === 1 /* OperatingSystem.Windows */) {
            // 17063 is the build number where wsl path was introduced.
            // Update Windows uriPath to be executed in WSL.
            if (shellType !== undefined) {
                if (shellType === "gitbash" /* WindowsShellType.GitBash */) {
                    return (0, terminalEnvironment_1.escapeNonWindowsPath)(originalPath.replace(/\\/g, '/'));
                }
                else if (shellType === "wsl" /* WindowsShellType.Wsl */) {
                    return backend?.getWslPath(originalPath, 'win-to-unix') || originalPath;
                }
                else if (hasSpace) {
                    return `"${originalPath}"`;
                }
                return originalPath;
            }
            const lowerExecutable = executable.toLowerCase();
            if (lowerExecutable.includes('wsl') || (lowerExecutable.includes('bash.exe') && !lowerExecutable.toLowerCase().includes('git'))) {
                return backend?.getWslPath(originalPath, 'win-to-unix') || originalPath;
            }
            else if (hasSpace) {
                return `"${originalPath}"`;
            }
            return originalPath;
        }
        return (0, terminalEnvironment_1.escapeNonWindowsPath)(originalPath);
    }
    function getWorkspaceForTerminal(cwd, workspaceContextService, historyService) {
        const cwdUri = typeof cwd === 'string' ? uri_1.URI.parse(cwd) : cwd;
        let workspaceFolder = cwdUri ? workspaceContextService.getWorkspaceFolder(cwdUri) ?? undefined : undefined;
        if (!workspaceFolder) {
            // fallback to last active workspace if cwd is not available or it is not in workspace
            // TOOD: last active workspace is known to be unreliable, we should remove this fallback eventually
            const activeWorkspaceRootUri = historyService.getLastActiveWorkspaceRoot();
            workspaceFolder = activeWorkspaceRootUri ? workspaceContextService.getWorkspaceFolder(activeWorkspaceRootUri) ?? undefined : undefined;
        }
        return workspaceFolder;
    }
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVybWluYWxFbnZpcm9ubWVudC5qcyIsInNvdXJjZVJvb3QiOiJmaWxlOi8vL2hvbWUvcnVubmVyL3dvcmsvbW9kL21vZC9idWlsZHZzY29kZS92c2NvZGUvc3JjLyIsInNvdXJjZXMiOlsidnMvd29ya2JlbmNoL2NvbnRyaWIvdGVybWluYWwvY29tbW9uL3Rlcm1pbmFsRW52aXJvbm1lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztnR0FHZ0c7Ozs7SUFrQmhHLDhDQTZCQztJQVVELGdFQVNDO0lBNEJELDREQVNDO0lBRUQsZ0RBMEVDO0lBRUQsd0JBbUNDO0lBZ0JELHdEQUtDO0lBRUQsOERBNkRDO0lBZUQsa0RBNkRDO0lBRUQsMERBVUM7SUFsWEQsU0FBZ0IsaUJBQWlCLENBQUMsTUFBMkIsRUFBRSxLQUF1QztRQUNyRyxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7WUFDWixPQUFPO1FBQ1IsQ0FBQztRQUVELHVFQUF1RTtRQUN2RSxnQ0FBZ0M7UUFDaEMsSUFBSSxvQkFBUyxFQUFFLENBQUM7WUFDZixLQUFLLE1BQU0sU0FBUyxJQUFJLEtBQUssRUFBRSxDQUFDO2dCQUMvQixJQUFJLFNBQVMsR0FBRyxTQUFTLENBQUM7Z0JBQzFCLEtBQUssTUFBTSxNQUFNLElBQUksTUFBTSxFQUFFLENBQUM7b0JBQzdCLElBQUksU0FBUyxDQUFDLFdBQVcsRUFBRSxLQUFLLE1BQU0sQ0FBQyxXQUFXLEVBQUUsRUFBRSxDQUFDO3dCQUN0RCxTQUFTLEdBQUcsTUFBTSxDQUFDO3dCQUNuQixNQUFNO29CQUNQLENBQUM7Z0JBQ0YsQ0FBQztnQkFDRCxNQUFNLEtBQUssR0FBRyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUM7Z0JBQy9CLElBQUksS0FBSyxLQUFLLFNBQVMsRUFBRSxDQUFDO29CQUN6QixzQkFBc0IsQ0FBQyxNQUFNLEVBQUUsU0FBUyxFQUFFLEtBQUssQ0FBQyxDQUFDO2dCQUNsRCxDQUFDO1lBQ0YsQ0FBQztRQUNGLENBQUM7YUFBTSxD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