{"version":3,"file":"unwrapFunction.js","sourceRoot":"","sources":["../../src/internal/unwrapFunction.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAE,OAAO,EAAE,MAAM,wBAAwB,CAAC;AACjD,OAAO,EAAE,cAAc,EAAE,MAAM,kBAAkB,CAAC;AAClD,OAAO,EAAE,QAAQ,EAAE,MAAM,qBAAqB,CAAC;AAC/C,OAAO,EAAE,QAAQ,EAAE,KAAK,EAAE,MAAM,aAAa,CAAC;AAE9C,MAAM,SAAS,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC;AAElC,MAAM,qBAAqB,GAAG,CAAI,QAAkB,EAAE,OAAU,EAAS,EAAE;IACvE,cAAc,CAAC,GAAG,GAAG,QAAQ,CAAC,QAAQ,CAAC,GAAG,oBAAoB,GAAG,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC;AACvF,CAAC,CAAA;AAED;;;;;;;;;GASG;AACH,MAAM,CAAC,MAAM,mBAAmB,GAAG,CAAO,QAAiB,EAAE,EAAE;IAC3D,OAAO,UAAS,OAAY;QACxB,OAAQ,OAAO,CAAC,QAAQ,CAAc,CAAC,KAAK,CAAC,OAAO,EAAE,SAAS,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC,CAAC;IACxF,CAAC,CAAC;AACN,CAAC,CAAA;AAED;;;;;;;GAOG;AACH,MAAM,CAAC,MAAM,eAAe,GAAG,CAAO,QAAiB,EAAE,QAAW,EAAE,EAAE;IACpE,IAAI,KAAK,GAAG,QAAQ,IAAI,QAAQ,CAAC,QAAQ,CAAC,CAAC;IAE3C,OAAO,UAAS,OAAY;QACxB,IAAI,OAAO,GAAG,CAAC,OAAO,IAAI,OAAO,CAAC,QAAQ,CAAC,CAAC,IAAI,KAAK,CAAC;QACtD,IAAI,OAAO,EAAE;YACT,OAAQ,OAAoB,CAAC,KAAK,CAAC,OAAO,EAAE,SAAS,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC,CAAC;SAC7E;QAED,qBAAqB,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;IAC7C,CAAC,CAAC;AACN,CAAC,CAAA;AAED;;;;;;;;GAQG;AACH,MAAM,CAAC,MAAM,uBAAuB,GAAG,CAAqC,QAAiB,EAAE,QAAW,EAAE,QAAW,EAAE,EAAE;IACvH,IAAI,KAAK,GAAG,QAAQ,IAAI,QAAQ,CAAC,QAAQ,CAAC,CAAC;IAE3C,OAAO,UAAS,OAAY;QACxB,IAAI,OAAO,GAAG,CAAC,OAAO,IAAI,OAAO,CAAC,QAAQ,CAAC,CAAC,IAAI,KAAK,CAAC;QACtD,IAAI,OAAO,IAAI,QAAQ,EAAE;YACrB,IAAI,OAAO,GAAG,SAAS,CAAC;YACxB,OAAQ,CAAC,OAAO,IAAI,QAAQ,CAAc,CAAC,KAAK,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC,CAAC,SAAS,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC;SAC7G;QAED,qBAAqB,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;IAC7C,CAAC,CAAC;AACN,CAAC,CAAA;AAED;;;;;;;;;GASG;AACH,MAAM,UAAU,WAAW,CAAI,QAAiB;IAC5C,OAAO,UAAU,OAAU;QACvB,OAAO,OAAO,CAAC,QAAQ,CAAC,CAAC;IAC7B,CAAC,CAAC;AACN,CAAC","sourcesContent":["/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { dumpObj } from \"../helpers/diagnostics\";\r\nimport { throwTypeError } from \"../helpers/throw\";\r\nimport { asString } from \"../string/as_string\";\r\nimport { ArrProto, SLICE } from \"./constants\";\r\n\r\nconst _arrSlice = ArrProto[SLICE];\r\n\r\nconst _throwMissingFunction = <T>(funcName:  keyof T, thisArg: T): never => {\r\n    throwTypeError(\"'\" + asString(funcName) + \"' not defined for \" + dumpObj(thisArg));\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Internal helper to run the named function on the passed first argument, this does not support polyfill\r\n * or prototype fallback, so the function must exist on the provided first argument.\r\n * If the first argument is null, undefined or the function does not exist an exception will be thrown\r\n * by the runtime\r\n * @param funcName - The function name to call on the first argument passed to the wrapped function\r\n * @returns A function which will call the funcName against the first passed argument and pass on the remaining arguments\r\n */\r\nexport const _unwrapInstFunction = <R, T>(funcName: keyof T) => {\r\n    return function(thisArg: any): R {\r\n        return (thisArg[funcName] as Function).apply(thisArg, _arrSlice.call(arguments, 1));\r\n    };\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Internal helper to convert an expanded function back into an instance `this` function call\r\n * @param funcName - The function name to call on the first argument passed to the wrapped function\r\n * @param clsProto - The Class or class prototype to fallback to if the instance doesn't have the function.\r\n * @returns A function which will call the funcName against the first passed argument and pass on the remaining arguments\r\n */\r\nexport const _unwrapFunction = <R, T>(funcName: keyof T, clsProto: T) => {\r\n    let clsFn = clsProto && clsProto[funcName];\r\n\r\n    return function(thisArg: any): R {\r\n        let theFunc = (thisArg && thisArg[funcName]) || clsFn;\r\n        if (theFunc) {\r\n            return (theFunc as Function).apply(thisArg, _arrSlice.call(arguments, 1));\r\n        }\r\n\r\n        _throwMissingFunction(funcName, thisArg);\r\n    };\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Internal helper to convert an expanded function back into an instance `this` function call\r\n * @param funcName - The function name to call on the first argument passed to the wrapped function\r\n * @param clsProto - The Class or class prototype to fallback to if the instance doesn't have the function.\r\n * @param polyFunc - The function to call if not available on the thisArg, act like the polyfill\r\n * @returns A function which will call the funcName against the first passed argument and pass on the remaining arguments\r\n */\r\nexport const _unwrapFunctionWithPoly = <T, P extends (...args: any) => any>(funcName: keyof T, clsProto: T, polyFunc: P) => {\r\n    let clsFn = clsProto && clsProto[funcName];\r\n\r\n    return function(thisArg: any): ReturnType<P> {\r\n        let theFunc = (thisArg && thisArg[funcName]) || clsFn;\r\n        if (theFunc || polyFunc) {\r\n            let theArgs = arguments;\r\n            return ((theFunc || polyFunc) as Function).apply(thisArg, theFunc ? _arrSlice.call(theArgs, 1) : theArgs);\r\n        }\r\n\r\n        _throwMissingFunction(funcName, thisArg);\r\n    };\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Internal helper to lookup and return the named property from the first argument (which becomes the this)\r\n *\r\n * @since 0.4.2\r\n * @typeParam T - The type of the object which contains the propName\r\n * @param propName - The property name\r\n * @returns The value of the property\r\n */\r\nexport function _unwrapProp<T>(propName: keyof T) {\r\n    return function (thisArg: T) {\r\n        return thisArg[propName];\r\n    };\r\n}"]}