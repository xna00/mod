/*! https://github.com/nevware21/ts-utils v0.10.1 */
/*
 * Copyright (c) NevWare21 and contributors. All rights reserved.
 * Licensed under the MIT license.
 */
System.register('nevware21.ts-utils', [], (function (exports) {
    'use strict';
    return {
        execute: (function () {

            exports({
                arrAppend: arrAppend,
                arrForEach: arrForEach,
                arrayDeepCopyHandler: arrayDeepCopyHandler,
                createArrayIterator: createArrayIterator,
                createCustomError: createCustomError,
                createEnum: createEnum,
                createEnumKeyMap: createEnumKeyMap,
                createEnumValueMap: createEnumValueMap,
                createFilenameRegex: createFilenameRegex,
                createIterable: createIterable,
                createIterator: createIterator,
                createRangeIterator: createRangeIterator,
                createSimpleMap: createSimpleMap,
                createTimeout: createTimeout,
                createTimeoutWith: createTimeoutWith,
                createTypeMap: createTypeMap,
                createWildcardRegex: createWildcardRegex,
                dateDeepCopyHandler: dateDeepCopyHandler,
                deepExtend: deepExtend,
                dumpObj: dumpObj,
                elapsedTime: elapsedTime,
                encodeAsHtml: encodeAsHtml,
                encodeAsJson: encodeAsJson,
                functionDeepCopyHandler: functionDeepCopyHandler,
                getIntValue: getIntValue,
                getKnownSymbol: getKnownSymbol,
                getLazy: getLazy,
                getPerformance: getPerformance,
                getSymbol: getSymbol,
                getValueByIter: getValueByIter,
                getValueByKey: getValueByKey,
                hasIdleCallback: hasIdleCallback,
                hasPerformance: hasPerformance,
                hasSymbol: hasSymbol,
                hasValue: hasValue,
                isDefined: isDefined,
                isIterable: isIterable,
                isIterator: isIterator,
                isNotTruthy: isNotTruthy,
                isNullOrUndefined: isNullOrUndefined,
                isObject: isObject,
                isPlainObject: isPlainObject,
                isPromise: isPromise,
                isPromiseLike: isPromiseLike,
                isStrictNullOrUndefined: isStrictNullOrUndefined,
                isStrictUndefined: isStrictUndefined,
                isTruthy: isTruthy,
                isTypeof: isTypeof,
                isUndefined: isUndefined,
                iterForOf: iterForOf,
                makeGlobRegex: makeGlobRegex,
                makeIterable: makeIterable,
                mathToInt: mathToInt,
                newSymbol: newSymbol,
                normalizeJsName: normalizeJsName,
                objCopyProps: objCopyProps,
                objDeepCopy: objDeepCopy,
                objDeepFreeze: objDeepFreeze,
                objDefine: objDefine,
                objDefineAccessors: objDefineAccessors,
                objDefineGet: objDefineGet,
                objDefineProps: objDefineProps,
                objExtend: objExtend,
                objForEachKey: objForEachKey,
                objHasOwnProperty: objHasOwnProperty,
                objKeys: objKeys,
                objSetPrototypeOf: objSetPrototypeOf,
                objToString: objToString,
                perfNow: perfNow,
                plainObjDeepCopyHandler: plainObjDeepCopyHandler,
                polyArrFind: polyArrFind,
                polyArrFindIndex: polyArrFindIndex,
                polyArrFindLast: polyArrFindLast,
                polyArrFindLastIndex: polyArrFindLastIndex,
                polyArrFrom: polyArrFrom,
                polyArrIncludes: polyArrIncludes,
                polyGetKnownSymbol: polyGetKnownSymbol,
                polyIsArray: polyIsArray,
                polyNewSymbol: polyNewSymbol,
                polyObjEntries: polyObjEntries,
                polyObjHasOwn: polyObjHasOwn,
                polyObjKeys: polyObjKeys,
                polyStrIncludes: polyStrIncludes,
                polyStrSubstr: polyStrSubstr,
                polyStrSymSplit: polyStrSymSplit,
                polySymbolFor: polySymbolFor,
                polySymbolKeyFor: polySymbolKeyFor,
                polyUtcNow: polyUtcNow,
                safeGet: safeGet,
                safeGetLazy: safeGetLazy,
                scheduleIdleCallback: scheduleIdleCallback,
                scheduleInterval: scheduleInterval,
                scheduleTimeout: scheduleTimeout,
                scheduleTimeoutWith: scheduleTimeoutWith,
                setBypassLazyCache: setBypassLazyCache,
                setDefaultIdleTimeout: setDefaultIdleTimeout,
                setDefaultMaxExecutionTime: setDefaultMaxExecutionTime,
                setValueByIter: setValueByIter,
                setValueByKey: setValueByKey,
                strCamelCase: strCamelCase,
                strIsNullOrEmpty: strIsNullOrEmpty,
                strIsNullOrWhiteSpace: strIsNullOrWhiteSpace,
                strKebabCase: strKebabCase,
                strLeft: strLeft,
                strLetterCase: strLetterCase,
                strRight: strRight,
                strSnakeCase: strSnakeCase,
                symbolFor: symbolFor,
                symbolKeyFor: symbolKeyFor,
                throwError: throwError,
                throwRangeError: throwRangeError,
                throwTypeError: throwTypeError,
                throwUnsupported: throwUnsupported,
                utcNow: utcNow
            });

            var UNDEF_VALUE = undefined;
            var NULL_VALUE = null;
            var EMPTY = "";
            var BOOLEAN = "boolean";
            var FUNCTION = "function";
            var NUMBER = "number";
            var OBJECT = "object";
            var PROTOTYPE = "prototype";
            var __PROTO__ = "__proto__";
            var STRING = "string";
            var UNDEFINED = "undefined";
            var CONSTRUCTOR = "constructor";
            var SYMBOL = "Symbol";
            var POLYFILL_TAG = "_polyfill";
            var INDEX_OF = "indexOf";
            var LAST_INDEX_OF = "lastIndexOf";
            var LENGTH = "length";
            var DONE = "done";
            var VALUE = "value";
            var NAME = "name";
            var SLICE = "slice";
            var ObjClass = Object;
            var ObjProto = ObjClass[PROTOTYPE];
            var StrCls = String;
            var StrProto = StrCls[PROTOTYPE];
            var MathCls = Math;
            var ArrCls = Array;
            var ArrProto = ArrCls[PROTOTYPE];

            function safeGet(cb, defValue) {
                var result = defValue;
                try {
                    result = cb();
                }
                catch (e) {
                }
                return result;
            }

            var PRIMITIVE_TYPES = [STRING, NUMBER, BOOLEAN, UNDEFINED, "symbol", "bigint"];
            function _createIs(theType) {
                return function (value) {
                    return typeof value === theType;
                };
            }
            function _createObjIs(theName) {
                var theType = "[object " + theName + "]";
                return function (value) {
                    return !!(value && objToString(value) === theType);
                };
            }
            function objToString(value) {
                return ObjProto.toString.call(value);
            }
            function isTypeof(value, theType) {
                return typeof value === theType;
            }
            function isUndefined(value) {
                return typeof value === UNDEFINED || value === UNDEFINED;
            }
            function isStrictUndefined(arg) {
                return !isDefined(arg);
            }
            function isNullOrUndefined(value) {
                return value === NULL_VALUE || isUndefined(value);
            }
            function isStrictNullOrUndefined(value) {
                return value === NULL_VALUE || !isDefined(value);
            }
            function isDefined(arg) {
                return !!arg || arg !== UNDEF_VALUE;
            }
            var isPrimitive = exports('isPrimitive', function (value) {
                return value === NULL_VALUE || isPrimitiveType(typeof value);
            });
            var isPrimitiveType = exports('isPrimitiveType', function (theType) {
                return theType !== OBJECT && PRIMITIVE_TYPES.indexOf(theType) !== -1;
            });
            var isString = exports('isString', _createIs(STRING));
            var isFunction = exports('isFunction', _createIs(FUNCTION));
            function isObject(value) {
                if (!value && isNullOrUndefined(value)) {
                    return false;
                }
                return !!value && typeof value === OBJECT;
            }
            var isArray = exports('isArray', ArrCls.isArray);
            var isDate = exports('isDate', _createObjIs("Date"));
            var isNumber = exports('isNumber', _createIs(NUMBER));
            var isBoolean = exports('isBoolean', _createIs(BOOLEAN));
            var isRegExp = exports('isRegExp', _createObjIs("RegExp"));
            var isFile = exports('isFile', _createObjIs("File"));
            var isFormData = exports('isFormData', _createObjIs("FormData"));
            var isBlob = exports('isBlob', _createObjIs("Blob"));
            var isArrayBuffer = exports('isArrayBuffer', _createObjIs("ArrayBuffer"));
            var isError = exports('isError', _createObjIs("Error"));
            function isPromiseLike(value) {
                return !!value && isFunction(value.then);
            }
            var isThenable = exports('isThenable', isPromiseLike);
            function isPromise(value) {
                return isPromiseLike(value) && isFunction(value.catch);
            }
            function isNotTruthy(value) {
                return !value || !safeGet(function () { return (value && (0 + value)); }, value);
            }
            function isTruthy(value) {
                return !(!value || safeGet(function () { return !(value && (0 + value)); }, !value));
            }

            var objGetOwnPropertyDescriptor = exports('objGetOwnPropertyDescriptor', ObjClass.getOwnPropertyDescriptor);

            function objHasOwnProperty(obj, prop) {
                return obj && ObjProto.hasOwnProperty.call(obj, prop);
            }

            var objHasOwn = exports('objHasOwn', ObjClass["hasOwn"] || polyObjHasOwn);
            function polyObjHasOwn(obj, prop) {
                return objHasOwnProperty(obj, prop) || !!objGetOwnPropertyDescriptor(obj, prop);
            }

            function objForEachKey(theObject, callbackfn, thisArg) {
                if (theObject && isObject(theObject)) {
                    for (var prop in theObject) {
                        if (objHasOwn(theObject, prop)) {
                            if (callbackfn.call(thisArg || theObject, prop, theObject[prop]) === -1) {
                                break;
                            }
                        }
                    }
                }
            }

            function _createKeyValueMap(values, keyType, valueType, completeFn) {
                var theMap = {};
                objForEachKey(values, function (key, value) {
                    theMap[key] = keyType ? value : key;
                    theMap[value] = valueType ? value : key;
                });
                return completeFn(theMap);
            }

            function throwError(message) {
                throw new Error(message);
            }
            function throwTypeError(message) {
                throw new TypeError(message);
            }
            function throwRangeError(message) {
                throw new RangeError(message);
            }

            function polyObjKeys(obj) {
                if (!isObject(obj) || obj === NULL_VALUE) {
                    throw new TypeError("polyObjKeys called on non-object");
                }
                var result = [];
                for (var prop in obj) {
                    if (objHasOwn(obj, prop)) {
                        result.push(prop);
                    }
                }
                return result;
            }
            function polyObjEntries(value) {
                var result = [];
                objForEachKey(value, function (key, value) {
                    result.push([key, value]);
                });
                return result;
            }

            var _objFreeze = ObjClass["freeze"];
            var _doNothing = function (value) { return value; };
            var _getProto = function (value) { return value[__PROTO__] || NULL_VALUE; };
            var objAssign = exports('objAssign', ObjClass["assign"]);
            function objKeys(value) {
                if (!isObject(value) || value === NULL_VALUE) {
                    throwTypeError("objKeys called on non-object");
                }
                return ObjClass.keys(value);
            }
            function objDeepFreeze(value) {
                if (_objFreeze) {
                    objForEachKey(value, function (key, value) {
                        if (isArray(value) || isObject(value)) {
                            _objFreeze(value);
                        }
                    });
                }
                return objFreeze(value);
            }
            var objFreeze = exports('objFreeze', _objFreeze || _doNothing);
            var objSeal = exports('objSeal', ObjClass["seal"] || _doNothing);
            var objGetPrototypeOf = exports('objGetPrototypeOf', ObjClass["getPrototypeOf"] || _getProto);
            var objEntries = exports('objEntries', ObjClass.entries || polyObjEntries);

            function createEnum(values) {
                return _createKeyValueMap(values, 1 , 0 , objDeepFreeze);
            }
            function createEnumKeyMap(values) {
                return _createKeyValueMap(values, 0 , 0 , objDeepFreeze);
            }
            function createEnumValueMap(values) {
                return _createKeyValueMap(values, 1 , 1 , objDeepFreeze);
            }
            function createSimpleMap(values) {
                var mapClass = {};
                objForEachKey(values, function (key, value) {
                    mapClass[key] = value[1];
                    mapClass[value[0]] = value[1];
                });
                return objDeepFreeze(mapClass);
            }
            function createTypeMap(values) {
                return createSimpleMap(values);
            }

            var _wellKnownSymbolMap = createEnumKeyMap({
                asyncIterator: 0 ,
                hasInstance: 1 ,
                isConcatSpreadable: 2 ,
                iterator: 3 ,
                match: 4 ,
                matchAll: 5 ,
                replace: 6 ,
                search: 7 ,
                species: 8 ,
                split: 9 ,
                toPrimitive: 10 ,
                toStringTag: 11 ,
                unscopables: 12
            });

            var asString = exports('asString', StrCls);

            var GLOBAL_CONFIG_KEY = "__tsUtils$gblCfg";
            var _globalCfg;
            function _getGlobalValue() {
                var result;
                if (typeof globalThis !== UNDEFINED) {
                    result = globalThis;
                }
                if (!result && typeof self !== UNDEFINED) {
                    result = self;
                }
                if (!result && typeof window !== UNDEFINED) {
                    result = window;
                }
                if (!result && typeof global !== UNDEFINED) {
                    result = global;
                }
                return result;
            }
            function _getGlobalConfig() {
                if (!_globalCfg) {
                    var gbl = _getGlobalValue() || {};
                    _globalCfg = gbl[GLOBAL_CONFIG_KEY] = gbl[GLOBAL_CONFIG_KEY] || {};
                }
                return _globalCfg;
            }

            function dumpObj(object, format) {
                var propertyValueDump = EMPTY;
                if (isError(object)) {
                    propertyValueDump = "{ stack: '" + object.stack + "', message: '" + object.message + "', name: '" + object.name + "'";
                }
                else {
                    try {
                        propertyValueDump = JSON.stringify(object, NULL_VALUE, format ? (isNumber(format) ? format : 4) : UNDEF_VALUE);
                    }
                    catch (e) {
                        propertyValueDump = " - " + dumpObj(e, format);
                    }
                }
                return objToString(object) + ": " + propertyValueDump;
            }

            var _arrSlice = ArrProto[SLICE];
            var _throwMissingFunction = function (funcName, thisArg) {
                throwTypeError("'" + asString(funcName) + "' not defined for " + dumpObj(thisArg));
            };
            var _unwrapInstFunction = function (funcName) {
                return function (thisArg) {
                    return thisArg[funcName].apply(thisArg, _arrSlice.call(arguments, 1));
                };
            };
            var _unwrapFunction = function (funcName, clsProto) {
                var clsFn = clsProto && clsProto[funcName];
                return function (thisArg) {
                    var theFunc = (thisArg && thisArg[funcName]) || clsFn;
                    if (theFunc) {
                        return theFunc.apply(thisArg, _arrSlice.call(arguments, 1));
                    }
                    _throwMissingFunction(funcName, thisArg);
                };
            };
            var _unwrapFunctionWithPoly = function (funcName, clsProto, polyFunc) {
                var clsFn = clsProto && clsProto[funcName];
                return function (thisArg) {
                    var theFunc = (thisArg && thisArg[funcName]) || clsFn;
                    if (theFunc || polyFunc) {
                        var theArgs = arguments;
                        return (theFunc || polyFunc).apply(thisArg, theFunc ? _arrSlice.call(theArgs, 1) : theArgs);
                    }
                    _throwMissingFunction(funcName, thisArg);
                };
            };
            function _unwrapProp(propName) {
                return function (thisArg) {
                    return thisArg[propName];
                };
            }

            var mathMin = exports('mathMin', MathCls.min);
            var mathMax = exports('mathMax', MathCls.max);

            var strSlice = exports('strSlice', _unwrapFunction(SLICE, StrProto));

            var strSubstring = exports('strSubstring', _unwrapFunction("substring", StrProto));
            var strSubstr = exports('strSubstr', _unwrapFunctionWithPoly("substr", StrProto, polyStrSubstr));
            function polyStrSubstr(value, start, length) {
                if (isNullOrUndefined(value)) {
                    throwTypeError("'polyStrSubstr called with invalid " + dumpObj(value));
                }
                if (length < 0) {
                    return EMPTY;
                }
                start = start || 0;
                if (start < 0) {
                    start = mathMax(start + value[LENGTH], 0);
                }
                if (isUndefined(length)) {
                    return strSlice(value, start);
                }
                return strSlice(value, start, start + length);
            }
            function strLeft(value, count) {
                return strSubstring(value, 0, count);
            }
            function strRight(value, count) {
                var len = value[LENGTH];
                if (count <= 0) {
                    return EMPTY;
                }
                return len > count ? strSubstring(value, len - count) : value;
            }

            var strStartsWith = exports('strStartsWith', _unwrapFunctionWithPoly("startsWith", StrProto, polyStrStartsWith));
            function polyStrStartsWith(value, searchString, position) {
                if (!isString(value)) {
                    throwTypeError("'" + dumpObj(value) + "' is not a string");
                }
                var searchValue = isString(searchString) ? searchString : asString(searchString);
                var chkLen = searchValue[LENGTH];
                var pos = position > 0 ? position : 0;
                return strSubstring(value, pos, pos + chkLen) === searchValue;
            }

            var UNIQUE_REGISTRY_ID = "_urid";
            var _polySymbols;
            function _globalSymbolRegistry() {
                if (!_polySymbols) {
                    var gblCfg = _getGlobalConfig();
                    _polySymbols = gblCfg.gblSym = gblCfg.gblSym || { k: {}, s: {} };
                }
                return _polySymbols;
            }
            var _wellKnownSymbolCache = {};
            function polyNewSymbol(description) {
                var theSymbol = {
                    description: asString(description),
                    toString: function () { return SYMBOL + "(" + description + ")"; }
                };
                theSymbol[POLYFILL_TAG] = true;
                return theSymbol;
            }
            function polySymbolFor(key) {
                var registry = _globalSymbolRegistry();
                if (!objHasOwn(registry.k, key)) {
                    var newSymbol_1 = polyNewSymbol(key);
                    var regId_1 = objKeys(registry.s).length;
                    newSymbol_1[UNIQUE_REGISTRY_ID] = function () { return regId_1 + "_" + newSymbol_1.toString(); };
                    registry.k[key] = newSymbol_1;
                    registry.s[newSymbol_1[UNIQUE_REGISTRY_ID]()] = asString(key);
                }
                return registry.k[key];
            }
            function polySymbolKeyFor(sym) {
                if (!sym || !sym.toString || !strStartsWith(sym.toString(), SYMBOL)) {
                    throwTypeError(sym + " is not a symbol");
                }
                var regId = sym[POLYFILL_TAG] && sym[UNIQUE_REGISTRY_ID] && sym[UNIQUE_REGISTRY_ID]();
                return regId ? _globalSymbolRegistry().s[regId] : undefined;
            }
            function polyGetKnownSymbol(name) {
                var result;
                var knownName = _wellKnownSymbolMap[name];
                if (knownName) {
                    result = _wellKnownSymbolCache[knownName] = _wellKnownSymbolCache[knownName] || polyNewSymbol(SYMBOL + "." + knownName);
                }
                return result;
            }

            var propMap = {
                e: "enumerable",
                c: "configurable",
                v: VALUE,
                w: "writable",
                g: "get",
                s: "set"
            };
            function _createProp(value) {
                var prop = {};
                prop[propMap["c"]] = true;
                prop[propMap["e"]] = true;
                if (value.l) {
                    prop.get = function () { return value.l.v; };
                    var desc = objGetOwnPropertyDescriptor(value.l, "v");
                    if (desc && desc.set) {
                        prop.set = function (newValue) {
                            value.l.v = newValue;
                        };
                    }
                }
                objForEachKey(value, function (key, value) {
                    prop[propMap[key]] = isUndefined(value) ? prop[propMap[key]] : value;
                });
                return prop;
            }
            var objDefineProp = exports('objDefineProp', ObjClass["defineProperty"]);
            var objDefineProperties = exports('objDefineProperties', ObjClass["defineProperties"]);
            function objDefineGet(target, key, value, configurable, enumerable) {
                var _a;
                return objDefineProp(target, key, _createProp((_a = {
                        e: enumerable,
                        c: configurable
                    },
                    _a[isFunction(value) ? "g" : "v"] = value,
                    _a)));
            }
            function objDefineAccessors(target, prop, getProp, setProp, configurable, enumerable) {
                var desc = {
                    e: enumerable,
                    c: configurable
                };
                if (getProp) {
                    desc.g = getProp;
                }
                if (setProp) {
                    desc.s = setProp;
                }
                return objDefineProp(target, prop, _createProp(desc));
            }
            function objDefine(target, key, propDesc) {
                return objDefineProp(target, key, _createProp(propDesc));
            }
            function objDefineProps(target, propDescMap) {
                var props = {};
                objForEachKey(propDescMap, function (key, value) {
                    props[key] = _createProp(value);
                });
                return objDefineProperties(target, props);
            }

            var _globalLazyTestHooks;
            var _fetchLazyTestHooks = function () {
                _globalLazyTestHooks = _getGlobalConfig();
                _fetchLazyTestHooks = NULL_VALUE;
            };
            function getLazy(cb) {
                var lazyValue = {};
                _fetchLazyTestHooks && _fetchLazyTestHooks();
                lazyValue.b = _globalLazyTestHooks.lzy;
                objDefineProp(lazyValue, "v", {
                    configurable: true,
                    get: function () {
                        var result = cb();
                        if (!_globalLazyTestHooks.lzy) {
                            objDefineProp(lazyValue, "v", {
                                value: result
                            });
                            if (lazyValue.b) {
                                delete lazyValue.b;
                            }
                        }
                        if (_globalLazyTestHooks.lzy && lazyValue.b !== _globalLazyTestHooks.lzy) {
                            lazyValue.b = _globalLazyTestHooks.lzy;
                        }
                        return result;
                    }
                });
                return lazyValue;
            }
            function setBypassLazyCache(newValue) {
                _fetchLazyTestHooks && _fetchLazyTestHooks();
                _globalLazyTestHooks.lzy = newValue;
            }

            function safeGetLazy(cb, defValue) {
                return getLazy(function () { return safeGet(cb, defValue); });
            }

            var WINDOW = "window";
            var _cachedGlobal;
            var _cachedWindow;
            var _cachedDocument;
            var _cachedNavigator;
            var _cachedHistory;
            var _isWebWorker;
            var _isNode;
            var lazySafeGetInst = exports('lazySafeGetInst', function (name) { return safeGetLazy(function () { return getInst(name) || UNDEF_VALUE; }, UNDEF_VALUE); });
            var getGlobal = exports('getGlobal', function (useCached) {
                (!_cachedGlobal || useCached === false || (_globalLazyTestHooks && _globalLazyTestHooks.lzy && !_cachedGlobal.b)) && (_cachedGlobal = safeGetLazy(_getGlobalValue, NULL_VALUE));
                return _cachedGlobal.v;
            });
            var getInst = exports('getInst', function (name, useCached) {
                var gbl = (!_cachedGlobal || useCached === false) ? getGlobal(useCached) : _cachedGlobal.v;
                if (gbl && gbl[name]) {
                    return gbl[name];
                }
                if (name === WINDOW && _cachedWindow) {
                    return _cachedWindow.v;
                }
                return NULL_VALUE;
            });
            var hasDocument = exports('hasDocument', function () { return !!getDocument(); });
            var getDocument = exports('getDocument', function () {
                (!_cachedDocument || (_globalLazyTestHooks && _globalLazyTestHooks.lzy && !_cachedDocument.b)) && (_cachedDocument = lazySafeGetInst("document"));
                return _cachedDocument.v;
            });
            var hasWindow = exports('hasWindow', function () { return !!getWindow(); });
            var getWindow = exports('getWindow', function () {
                (!_cachedWindow || (_globalLazyTestHooks && _globalLazyTestHooks.lzy && !_cachedWindow.b)) && (_cachedWindow = lazySafeGetInst(WINDOW));
                return _cachedWindow.v;
            });
            var hasNavigator = exports('hasNavigator', function () { return !!getNavigator(); });
            var getNavigator = exports('getNavigator', function () {
                (!_cachedNavigator || (_globalLazyTestHooks && _globalLazyTestHooks.lzy && !_cachedNavigator.b)) && (_cachedNavigator = lazySafeGetInst("navigator"));
                return _cachedNavigator.v;
            });
            var hasHistory = exports('hasHistory', function () { return !!getHistory(); });
            var getHistory = exports('getHistory', function () {
                (!_cachedHistory || (_globalLazyTestHooks && _globalLazyTestHooks.lzy && !_cachedHistory.b)) && (_cachedHistory = lazySafeGetInst("history"));
                return _cachedHistory.v;
            });
            var isNode = exports('isNode', function () {
                !_isNode && (_isNode = safeGetLazy(function () { return !!(process && (process.versions || {}).node); }, false));
                return _isNode.v;
            });
            var isWebWorker = exports('isWebWorker', function () {
                !_isWebWorker && (_isWebWorker = safeGetLazy(function () { return !!(self && self instanceof WorkerGlobalScope); }, false));
                return _isWebWorker.v;
            });

            var _symbol;
            var _symbolFor;
            var _symbolKeyFor;
            function _getSymbolValue(name) {
                return safeGetLazy(function () {
                    return (_symbol.v ? _symbol.v[name] : UNDEF_VALUE);
                }, UNDEF_VALUE);
            }
            var isSymbol = exports('isSymbol', _createIs("symbol"));
            function hasSymbol() {
                return !!getSymbol();
            }
            function getSymbol() {
                var resetCache = !_symbol || (_globalLazyTestHooks && _globalLazyTestHooks.lzy && !_symbol.b);
                resetCache && (_symbol = lazySafeGetInst(SYMBOL));
                (!_symbolFor || resetCache) && (_symbolFor = _getSymbolValue("for"));
                (!_symbolKeyFor || resetCache) && (_symbolKeyFor = _getSymbolValue("keyFor"));
                return _symbol.v;
            }
            function getKnownSymbol(name, noPoly) {
                var knownName = _wellKnownSymbolMap[name];
                (!_symbol || (_globalLazyTestHooks.lzy && !_symbol.b)) && getSymbol();
                return _symbol.v ? _symbol.v[knownName || name] : (!noPoly ? polyGetKnownSymbol(name) : UNDEF_VALUE);
            }
            function newSymbol(description, noPoly) {
                (!_symbol || (_globalLazyTestHooks.lzy && !_symbol.b)) && getSymbol();
                return _symbol.v ? _symbol.v(description) : (!noPoly ? polyNewSymbol(description) : NULL_VALUE);
            }
            function symbolFor(key) {
                (!_symbolFor || (_globalLazyTestHooks.lzy && !_symbol.b)) && getSymbol();
                return (_symbolFor.v || polySymbolFor)(key);
            }
            function symbolKeyFor(sym) {
                (!_symbolKeyFor || (_globalLazyTestHooks.lzy && !_symbol.b)) && getSymbol();
                return (_symbolKeyFor.v || polySymbolKeyFor)(sym);
            }

            function isIterator(value) {
                return !!value && isFunction(value.next);
            }
            function isIterable(value) {
                return !isStrictNullOrUndefined(value) && isFunction(value[getKnownSymbol(3 )]);
            }

            var _iterSymbol$1;
            function iterForOf(iter, callbackfn, thisArg) {
                if (iter) {
                    if (!isIterator(iter)) {
                        !_iterSymbol$1 && (_iterSymbol$1 = getLazy(function () { return getKnownSymbol(3 ); }));
                        iter = iter[_iterSymbol$1.v] ? iter[_iterSymbol$1.v]() : null;
                    }
                    if (isIterator(iter)) {
                        var err = void 0;
                        var iterResult = void 0;
                        try {
                            var count = 0;
                            while (!(iterResult = iter.next())[DONE]) {
                                if (callbackfn.call(thisArg || iter, iterResult[VALUE], count, iter) === -1) {
                                    break;
                                }
                                count++;
                            }
                        }
                        catch (failed) {
                            err = { e: failed };
                            if (iter.throw) {
                                iterResult = null;
                                iter.throw(err);
                            }
                        }
                        finally {
                            try {
                                if (iterResult && !iterResult[DONE]) {
                                    iter.return && iter.return(iterResult);
                                }
                            }
                            finally {
                                if (err) {
                                    throw err.e;
                                }
                            }
                        }
                    }
                }
            }

            var fnApply = exports('fnApply', _unwrapInstFunction("apply"));

            function arrAppend(target, elms) {
                if (!isUndefined(elms) && target) {
                    if (isArray(elms)) {
                        fnApply(target.push, target, elms);
                    }
                    else if (isIterator(elms) || isIterable(elms)) {
                        iterForOf(elms, function (elm) {
                            target.push(elm);
                        });
                    }
                    else {
                        target.push(elms);
                    }
                }
                return target;
            }

            var arrEvery = exports('arrEvery', _unwrapFunction("every", ArrProto));
            var arrFilter = exports('arrFilter', _unwrapFunction("filter", ArrProto));

            function arrForEach(theArray, callbackfn, thisArg) {
                if (theArray) {
                    var len = theArray[LENGTH] >>> 0;
                    for (var idx = 0; idx < len; idx++) {
                        if (idx in theArray) {
                            if (callbackfn.call(thisArg || theArray, theArray[idx], idx, theArray) === -1) {
                                break;
                            }
                        }
                    }
                }
            }

            var arrIndexOf = exports('arrIndexOf', _unwrapFunction(INDEX_OF, ArrProto));
            var arrLastIndexOf = exports('arrLastIndexOf', _unwrapFunction(LAST_INDEX_OF, ArrProto));

            var arrMap = exports('arrMap', _unwrapFunction("map", ArrProto));

            var arrSlice = exports('arrSlice', _unwrapFunction(SLICE, ArrProto));

            var fnCall = exports('fnCall', _unwrapInstFunction("call"));

            function polyIsArray(value) {
                if (isNullOrUndefined(value)) {
                    return false;
                }
                return objToString(value) === "[object Array]";
            }
            function polyArrIncludes(theArray, searchElement, fromIndex) {
                return arrIndexOf(theArray, searchElement, fromIndex) !== -1;
            }
            function polyArrFind(theArray, callbackFn, thisArg) {
                var result;
                var idx = polyArrFindIndex(theArray, callbackFn, thisArg);
                return idx !== -1 ? theArray[idx] : result;
            }
            function polyArrFindIndex(theArray, callbackFn, thisArg) {
                var result = -1;
                arrForEach(theArray, function (value, index) {
                    if (fnCall(callbackFn, thisArg | theArray, value, index, theArray)) {
                        result = index;
                        return -1;
                    }
                });
                return result;
            }
            function polyArrFindLast(theArray, callbackFn, thisArg) {
                var result;
                var idx = polyArrFindLastIndex(theArray, callbackFn, thisArg);
                return idx !== -1 ? theArray[idx] : result;
            }
            function polyArrFindLastIndex(theArray, callbackFn, thisArg) {
                var result = -1;
                var len = theArray[LENGTH] >>> 0;
                for (var idx = len - 1; idx >= 0; idx--) {
                    if (idx in theArray && fnCall(callbackFn, thisArg | theArray, theArray[idx], idx, theArray)) {
                        result = idx;
                        break;
                    }
                }
                return result;
            }
            function polyArrFrom(theValue, mapFn, thisArg) {
                if (isArray(theValue)) {
                    var result_1 = arrSlice(theValue);
                    return mapFn ? arrMap(result_1, mapFn, thisArg) : result_1;
                }
                var result = [];
                iterForOf(theValue, function (value, cnt) {
                    return result.push(mapFn ? fnCall(mapFn, thisArg, value, cnt) : value);
                });
                return result;
            }

            var arrFind = exports('arrFind', _unwrapFunctionWithPoly("find", ArrProto, polyArrFind));
            var arrFindIndex = exports('arrFindIndex', _unwrapFunctionWithPoly("findIndex", ArrProto, polyArrFindIndex));
            var arrFindLast = exports('arrFindLast', _unwrapFunctionWithPoly("findLast", ArrProto, polyArrFindLast));
            var arrFindLastIndex = exports('arrFindLastIndex', _unwrapFunctionWithPoly("findLastIndex", ArrProto, polyArrFindLastIndex));

            var arrFrom = exports('arrFrom', ArrCls.from || polyArrFrom);

            var arrIncludes = exports('arrIncludes', _unwrapFunctionWithPoly("includes", ArrProto, polyArrIncludes));
            var arrContains = exports('arrContains', arrIncludes);

            var arrReduce = exports('arrReduce', _unwrapFunction("reduce", ArrProto));

            var arrSome = exports('arrSome', _unwrapFunction("some", ArrProto));

            var fnBind = exports('fnBind', _unwrapInstFunction("bind"));

            var createFnDeferredProxy = exports('createFnDeferredProxy', function (hostFn, funcName) {
                return function () {
                    var theArgs = arrSlice(arguments);
                    var theHost = hostFn();
                    return fnApply(theHost[funcName], theHost, theArgs);
                };
            });
            var createProxyFuncs = exports('createProxyFuncs', function (target, host, funcDefs) {
                if (target && host && isArray(funcDefs)) {
                    var isDeferred_1 = isFunction(host);
                    arrForEach(funcDefs, function (funcDef) {
                        var targetName = (funcDef.as || funcDef.n);
                        if (funcDef.rp === false && target[targetName]) {
                            return;
                        }
                        target[targetName] = isDeferred_1 ?
                            createFnDeferredProxy(host, funcDef.n) :
                            fnBind(host[funcDef.n], host);
                    });
                }
                return target;
            });

            var _iterSymbol;
            var readArgs = exports('readArgs', function (theArgs, start, end) {
                if (!_iterSymbol) {
                    _iterSymbol = getLazy(function () { return hasSymbol() && getKnownSymbol(3 ); });
                }
                if (!objHasOwn(theArgs, LENGTH)) {
                    var iterFn = _iterSymbol.v && theArgs[_iterSymbol.v];
                    if (iterFn) {
                        var values_1 = [];
                        var from_1 = (start === UNDEF_VALUE || start < 0) ? 0 : start;
                        var to_1 = end < 0 || start < 0 ? UNDEF_VALUE : end;
                        iterForOf(iterFn.call(theArgs), function (value, cnt) {
                            if (to_1 !== UNDEF_VALUE && cnt >= to_1) {
                                return -1;
                            }
                            if (cnt >= from_1) {
                                values_1.push(value);
                            }
                        });
                        if ((start === UNDEF_VALUE || start >= 0) && (end === UNDEF_VALUE || end >= 0)) {
                            return values_1;
                        }
                        theArgs = values_1;
                    }
                }
                return arrSlice(theArgs, start, end);
            });

            var _objCreate = ObjClass["create"];
            var objCreate = exports('objCreate', _objCreate || polyObjCreate);
            function polyObjCreate(obj) {
                if (!obj) {
                    return {};
                }
                var type = typeof obj;
                if (type !== OBJECT && type !== FUNCTION) {
                    throw new TypeError("Prototype must be an Object or function: " + dumpObj(obj));
                }
                function tempFunc() { }
                tempFunc[PROTOTYPE] = obj;
                return new tempFunc();
            }

            var _isProtoArray;
            function objSetPrototypeOf(obj, proto) {
                var fn = ObjClass["setPrototypeOf"] ||
                    function (d, b) {
                        !_isProtoArray && (_isProtoArray = getLazy(function () {
                            var _a;
                            return ((_a = {}, _a[__PROTO__] = [], _a) instanceof Array);
                        }));
                        _isProtoArray.v ? d[__PROTO__] = b : objForEachKey(b, function (key, value) { return d[key] = value; });
                    };
                return fn(obj, proto);
            }

            var _createCustomError = function (name, d, b) {
                _safeDefineName(d, name);
                d = objSetPrototypeOf(d, b);
                function __() {
                    this.constructor = d;
                    _safeDefineName(this, name);
                }
                d[PROTOTYPE] = b === NULL_VALUE ? objCreate(b) : (__[PROTOTYPE] = b[PROTOTYPE], new __());
                return d;
            };
            var _safeSetName = function (baseClass, name) {
                try {
                    name && (baseClass[NAME] = name);
                }
                catch (e) {
                }
            };
            var _safeDefineName = function (target, name) {
                try {
                    objDefine(target, NAME, { v: name, c: true, e: false });
                }
                catch (e) {
                }
            };
            function createCustomError(name, constructCb, errorBase) {
                var theBaseClass = errorBase || Error;
                var orgName = theBaseClass[PROTOTYPE][NAME];
                var captureFn = Error.captureStackTrace;
                return _createCustomError(name, function () {
                    var _this = this;
                    try {
                        _safeSetName(theBaseClass, name);
                        var _self = fnApply(theBaseClass, _this, arrSlice(arguments)) || _this;
                        if (_self !== _this) {
                            var orgProto = objGetPrototypeOf(_this);
                            if (orgProto !== objGetPrototypeOf(_self)) {
                                objSetPrototypeOf(_self, orgProto);
                            }
                        }
                        captureFn && captureFn(_self, _this[CONSTRUCTOR]);
                        constructCb && constructCb(_self, arguments);
                        return _self;
                    }
                    finally {
                        _safeSetName(theBaseClass, orgName);
                    }
                }, theBaseClass);
            }
            var _unsupportedError;
            function throwUnsupported(message) {
                if (!_unsupportedError) {
                    _unsupportedError = createCustomError("UnsupportedError");
                }
                throw new _unsupportedError(message);
            }

            function utcNow() {
                return (Date.now || polyUtcNow)();
            }
            function polyUtcNow() {
                return new Date().getTime();
            }

            function _createTrimFn(exp) {
                return function _doTrim(value) {
                    if (isNullOrUndefined(value)) {
                        throwTypeError("strTrim called [" + dumpObj(value) + "]");
                    }
                    if (value && value.replace) {
                        value = value.replace(exp, EMPTY);
                    }
                    return value;
                };
            }
            var polyStrTrim = exports('polyStrTrim', _createTrimFn(/^\s+|(?=\s)\s+$/g));
            var polyStrTrimStart = exports('polyStrTrimStart', _createTrimFn(/^\s+/g));
            var polyStrTrimEnd = exports('polyStrTrimEnd', _createTrimFn(/(?=\s)\s+$/g));

            var strTrim = exports('strTrim', _unwrapFunctionWithPoly("trim", StrProto, polyStrTrim));
            var strTrimStart = exports('strTrimStart', _unwrapFunctionWithPoly("trimStart", StrProto, polyStrTrimStart));
            var strTrimLeft = exports('strTrimLeft', strTrimStart);
            var strTrimEnd = exports('strTrimEnd', _unwrapFunctionWithPoly("trimEnd", StrProto, polyStrTrimEnd));
            var strTrimRight = exports('strTrimRight', strTrimEnd);

            var strUpper = exports('strUpper', _unwrapFunction("toUpperCase", StrProto));
            var strLower = exports('strLower', _unwrapFunction("toLowerCase", StrProto));

            function _convertCase(value, newPrefix, upperWord) {
                return strTrim(asString(value)).replace(/((_|\W)+(\w){0,1}|([a-z])([A-Z]))/g, function (_match, _g1, _g2, wordStart, upperPrefix, upperLetter) {
                    var convertMatch = wordStart || upperLetter || EMPTY;
                    if (upperWord) {
                        convertMatch = strUpper(convertMatch);
                    }
                    return (upperPrefix || EMPTY) + newPrefix + convertMatch;
                });
            }
            function strLetterCase(value) {
                return asString(value).replace(/(_|\b)\w/g, strUpper);
            }
            function strCamelCase(value, upperFirst) {
                var result = _convertCase(value, "", true);
                return result.replace(/^\w/, upperFirst ? strUpper : strLower);
            }
            function strKebabCase(value, scream) {
                var result = _convertCase(value, "-");
                return (scream ? strUpper : strLower)(result);
            }
            function strSnakeCase(value, scream) {
                var result = _convertCase(value, "_");
                return (scream ? strUpper : strLower)(result);
            }

            var mathFloor = exports('mathFloor', MathCls.floor);
            var mathCeil = exports('mathCeil', MathCls.ceil);

            var _mathTrunc = MathCls.trunc;
            var mathTrunc = exports('mathTrunc', _mathTrunc ? _mathTrunc : polyMathTrunc);
            function polyMathTrunc(value) {
                var theValue = +value;
                return (theValue > 0 ? mathFloor : mathCeil)(theValue);
            }

            function mathToInt(value, throwInfinity) {
                var result = +value;
                if (result == Infinity && throwInfinity) {
                    throwRangeError("invalid value [" + dumpObj(value) + "]");
                }
                return result !== result || result === 0 ? 0 : mathTrunc(result);
            }

            var strRepeat = exports('strRepeat', _unwrapFunctionWithPoly("repeat", StrProto, polyStrRepeat));
            function polyStrRepeat(value, count) {
                if (isNullOrUndefined(value)) {
                    throwTypeError("can't convert [" + dumpObj(value) + "]");
                }
                count = mathToInt(count, true);
                if (count < 0) {
                    throwRangeError("invalid count must be >= 0 && < Infinity");
                }
                var pad = isString(value) ? value : asString(value);
                var result = EMPTY;
                for (; count > 0; (count >>>= 1) && (pad += pad)) {
                    if (count & 1) {
                        result += pad;
                    }
                }
                return result;
            }

            function _padValue(value, targetLength, padString) {
                var result = EMPTY;
                targetLength = mathToInt(targetLength, true);
                targetLength >>= 0;
                var len = value[LENGTH];
                if (len < targetLength) {
                    result = isNullOrUndefined(padString) ? " " : asString(padString);
                    targetLength = targetLength - len;
                    if (targetLength > result[LENGTH]) {
                        result = strRepeat(result, mathCeil(targetLength / result[LENGTH]));
                    }
                    if (result[LENGTH] > targetLength) {
                        result = strSubstring(result, 0, targetLength);
                    }
                }
                return result;
            }
            var strPadStart = exports('strPadStart', _unwrapFunctionWithPoly("padStart", StrProto, polyStrPadStart));
            var strPadEnd = exports('strPadEnd', _unwrapFunctionWithPoly("padEnd", StrProto, polyStrPadEnd));
            function polyStrPadStart(value, targetLength, padString) {
                return _padValue(value, targetLength, padString) + value;
            }
            function polyStrPadEnd(value, targetLength, padString) {
                return value + _padValue(value, targetLength, padString);
            }

            var DBL_QUOTE = "\"";
            var INVALID_JS_NAME = /([^\w\d_$])/g;
            var _htmlEntityCache;
            function normalizeJsName(jsName, camelCase) {
                var result = asString(jsName).replace(INVALID_JS_NAME, "_");
                return !isUndefined(camelCase) ? strCamelCase(result, !camelCase) : result;
            }
            function encodeAsJson(value, format) {
                var result;
                if (isString(value)) {
                    result = DBL_QUOTE + value.replace(/[^\w .,\-!@#$%\^&*\(\)_+={}\[\]:;|<>?]/g, function (match) {
                        if (match === DBL_QUOTE || match === "\\") {
                            return "\\" + match;
                        }
                        var hex = match.charCodeAt(0).toString(16);
                        return "\\u" + strPadStart(strUpper(hex), 4, "0");
                    }) + DBL_QUOTE;
                }
                else {
                    try {
                        result = JSON.stringify(value, NULL_VALUE, format ? (isNumber(format) ? format : 4) : UNDEF_VALUE);
                    }
                    catch (e) {
                        result = DBL_QUOTE + dumpObj(e) + DBL_QUOTE;
                    }
                }
                return result;
            }
            function encodeAsHtml(value) {
                !_htmlEntityCache && (_htmlEntityCache = getLazy(function () {
                    var _a;
                    return _a = {
                            "&": "amp",
                            "<": "lt",
                            ">": "gt"
                        },
                        _a[DBL_QUOTE] = "quot",
                        _a["'"] = "#39",
                        _a;
                }));
                return asString(value).replace(/[&<>"']/g, function (match) { return "&" + _htmlEntityCache.v[match] + ";"; });
            }

            var _fnToString;
            var _objCtrFnString;
            var _gblWindow;
            function isPlainObject(value) {
                if (!value || typeof value !== OBJECT) {
                    return false;
                }
                if (!_gblWindow) {
                    _gblWindow = hasWindow() ? getWindow() : true;
                }
                var result = false;
                if (value !== _gblWindow) {
                    if (!_objCtrFnString) {
                        _fnToString = Function[PROTOTYPE].toString;
                        _objCtrFnString = fnCall(_fnToString, ObjClass);
                    }
                    try {
                        var proto = objGetPrototypeOf(value);
                        result = !proto;
                        if (!result) {
                            if (objHasOwnProperty(proto, CONSTRUCTOR)) {
                                proto = proto[CONSTRUCTOR];
                            }
                            result = proto && typeof proto === FUNCTION && _fnToString.call(proto) === _objCtrFnString;
                        }
                    }
                    catch (ex) {
                    }
                }
                return result;
            }

            var _defaultDeepCopyHandler = function (details) {
                details.value && plainObjDeepCopyHandler(details);
                return true;
            };
            var defaultDeepCopyHandlers = [
                arrayDeepCopyHandler,
                plainObjDeepCopyHandler,
                functionDeepCopyHandler,
                dateDeepCopyHandler
            ];
            function _getSetVisited(visitMap, source, newPath, cb) {
                var theEntry;
                arrForEach(visitMap, function (entry) {
                    if (entry.k === source) {
                        theEntry = entry;
                        return -1;
                    }
                });
                if (!theEntry) {
                    theEntry = { k: source, v: source };
                    visitMap.push(theEntry);
                    cb(theEntry);
                }
                return theEntry.v;
            }
            function _deepCopy(visitMap, value, ctx, key) {
                var userHandler = ctx.handler;
                var newPath = ctx.path ? (key ? ctx.path.concat(key) : ctx.path) : [];
                var newCtx = {
                    handler: ctx.handler,
                    src: ctx.src,
                    path: newPath
                };
                var theType = typeof value;
                var isPlain = false;
                var isPrim = false;
                if (value && theType === OBJECT) {
                    isPlain = isPlainObject(value);
                }
                else {
                    isPrim = value === NULL_VALUE || isPrimitiveType(theType);
                }
                var details = {
                    type: theType,
                    isPrim: isPrim,
                    isPlain: isPlain,
                    value: value,
                    result: value,
                    path: newPath,
                    origin: ctx.src,
                    copy: function (source, newKey) {
                        return _deepCopy(visitMap, source, newKey ? newCtx : ctx, newKey);
                    },
                    copyTo: function (target, source) {
                        return _copyProps(visitMap, target, source, newCtx);
                    }
                };
                if (!details.isPrim) {
                    return _getSetVisited(visitMap, value, newPath, function (newEntry) {
                        objDefine(details, "result", {
                            g: function () {
                                return newEntry.v;
                            },
                            s: function (newValue) {
                                newEntry.v = newValue;
                            }
                        });
                        var idx = 0;
                        var handler = userHandler;
                        while (!fnCall(handler || (idx < defaultDeepCopyHandlers.length ? defaultDeepCopyHandlers[idx++] : _defaultDeepCopyHandler), ctx, details)) {
                            handler = NULL_VALUE;
                        }
                    });
                }
                if (userHandler && fnCall(userHandler, ctx, details)) {
                    return details.result;
                }
                return value;
            }
            function _copyProps(visitMap, target, source, ctx) {
                if (!isNullOrUndefined(source)) {
                    for (var key in source) {
                        target[key] = _deepCopy(visitMap, source[key], ctx, key);
                    }
                }
                return target;
            }
            function objCopyProps(target, source, handler) {
                var ctx = {
                    handler: handler,
                    src: source,
                    path: []
                };
                return _copyProps([], target, source, ctx);
            }
            function objDeepCopy(source, handler) {
                var ctx = {
                    handler: handler,
                    src: source
                };
                return _deepCopy([], source, ctx);
            }
            function arrayDeepCopyHandler(details) {
                var value = details.value;
                if (isArray(value)) {
                    var target = details.result = [];
                    target.length = value.length;
                    details.copyTo(target, value);
                    return true;
                }
                return false;
            }
            function dateDeepCopyHandler(details) {
                var value = details.value;
                if (isDate(value)) {
                    details.result = new Date(value.getTime());
                    return true;
                }
                return false;
            }
            function functionDeepCopyHandler(details) {
                if (details.type === FUNCTION) {
                    return true;
                }
                return false;
            }
            function plainObjDeepCopyHandler(details) {
                var value = details.value;
                if (value && details.isPlain) {
                    var target = details.result = {};
                    details.copyTo(target, value);
                    return true;
                }
                return false;
            }

            function _doExtend(target, theArgs) {
                arrForEach(theArgs, function (theArg) {
                    objCopyProps(target, theArg);
                });
                return target;
            }
            function deepExtend(target, obj1, obj2, obj3, obj4, obj5, obj6) {
                return _doExtend(objDeepCopy(target) || {}, arrSlice(arguments));
            }
            function objExtend(target, obj1, obj2, obj3, obj4, obj5, obj6) {
                return _doExtend(target || {}, arrSlice(arguments));
            }

            var getLength = exports('getLength', _unwrapProp(LENGTH));

            function getIntValue(value, defValue) {
                if (!isNullOrUndefined(value)) {
                    if (isNumber(value)) {
                        return value;
                    }
                    var theValue = parseInt(value, 10);
                    return isNaN(theValue) ? defValue : theValue;
                }
                return defValue;
            }

            var _perf;
            function hasPerformance() {
                return !!getPerformance();
            }
            function getPerformance() {
                (!_perf || (!_perf.b && _globalLazyTestHooks && _globalLazyTestHooks.lzy)) && (_perf = lazySafeGetInst("performance"));
                return _perf.v;
            }
            function perfNow() {
                var perf = getPerformance();
                if (perf && perf.now) {
                    return perf.now();
                }
                return utcNow();
            }
            function elapsedTime(startTime) {
                return perfNow() - startTime;
            }

            var MATCH_ANY = "(.*)";
            var MATCH_SINGLE = "(.)";
            function _createRegExp(value, escapeRgx, replaceFn, ignoreCase, fullMatch) {
                return new RegExp((fullMatch ? "^" : EMPTY) + replaceFn(value.replace(escapeRgx, "\\$1")) + (fullMatch ? "$" : EMPTY), ignoreCase ? "i" : "");
            }
            function createWildcardRegex(value, ignoreCase, fullMatch) {
                return _createRegExp(asString(value), /([-+|^$#.\?{}()\[\]\\/\"\'])/g, function (value) {
                    return value.replace(/\*/g, MATCH_ANY);
                }, !!ignoreCase, fullMatch);
            }
            function createFilenameRegex(value, ignoreCase, fullMatch) {
                return _createRegExp(asString(value), /([-+|^$#.{}()\\\/\[\]\"\'])/g, function (value) {
                    return value.replace(/(\\\\|\\\/|\*|\?)/g, function (_all, g1) {
                        if (g1 == "\\/" || g1 == "\\\\") {
                            return "[\\\\\\/]{1}";
                        }
                        return g1 == "*" ? MATCH_ANY : MATCH_SINGLE;
                    });
                }, !!ignoreCase, fullMatch);
            }
            function makeGlobRegex(value, ignoreCase, fullMatch) {
                return _createRegExp(asString(value), /([-+|^$#.{}()\\\/\[\]\"\'])/g, function (value) {
                    return value.replace(/(\*\*\\[\\\/]|\\\\|\\\/|\*\*|\*|\?)/g, function (_all, g1) {
                        if (g1 == "**\\/" || g1 == "**\\\\") {
                            return "(.*[\\\\\\/])*";
                        }
                        if (g1 === "\\/" || g1 == "\\\\") {
                            return "[\\\\\\/]{1}";
                        }
                        if (g1 === "**") {
                            return MATCH_ANY;
                        }
                        return g1 === "*" ? "([^\\\\\\/]*)" : "([^\\\\\\/]{1})";
                    });
                }, !!ignoreCase, fullMatch);
            }

            function _checkLength(value, props) {
                var result;
                arrForEach(props, function (prop) {
                    if (prop in value) {
                        var propValue = value[prop];
                        result = (isFunction(propValue) ? propValue() : propValue) > 0;
                        return -1;
                    }
                });
                return result;
            }
            function _hasValue(value, depth) {
                var result = value === false || value === 0;
                if (!result && !isNullOrUndefined(value)) {
                    if (isArray(value)) {
                        result = value[LENGTH] > 0;
                    }
                    else if (isDate(value)) {
                        result = !isNaN(value.getTime());
                    }
                    else if (isBoolean(value)) {
                        return true;
                    }
                    else if (isObject(value)) {
                        try {
                            var chkValue = _checkLength(value, [LENGTH, "byteLength", "size", "count"]);
                            if (isBoolean(chkValue)) {
                                return chkValue;
                            }
                            if (isFunction(value.valueOf) && depth < 5) {
                                return _hasValue(value.valueOf(), ++depth);
                            }
                        }
                        catch (e) {
                        }
                        return !!objKeys(value)[LENGTH];
                    }
                    else {
                        result = isTruthy(value);
                    }
                }
                return result;
            }
            function hasValue(value) {
                return _hasValue(value, 0);
            }

            function createIterable(ctx) {
                return makeIterable({}, ctx);
            }
            function makeIterable(target, ctx) {
                var itSymbol = getKnownSymbol(3 );
                function _createIterator() {
                    return createIterator(ctx);
                }
                target[itSymbol] = _createIterator;
                return target;
            }
            function createIterator(ctx) {
                var isDone = false;
                function _value() {
                    return ctx.v;
                }
                function _next() {
                    var _a;
                    isDone = isDone || (ctx.n ? ctx.n(arguments) : true);
                    var result = (_a = {},
                        _a[DONE] = isDone,
                        _a);
                    if (!isDone) {
                        objDefine(result, VALUE, { g: _value });
                    }
                    return result;
                }
                function _return(value) {
                    var _a;
                    isDone = true;
                    return _a = {},
                        _a[DONE] = true,
                        _a[VALUE] = ctx.r && ctx.r(value),
                        _a;
                }
                function _throw(e) {
                    var _a;
                    isDone = true;
                    return _a = {},
                        _a[DONE] = true,
                        _a[VALUE] = ctx.t && ctx.t(e),
                        _a;
                }
                var theIterator = {
                    next: _next
                };
                if (ctx.r) {
                    theIterator.return = _return;
                }
                if (ctx.t) {
                    theIterator.throw = _throw;
                }
                return theIterator;
            }

            function createArrayIterator(values) {
                var idx = -1;
                var theValues = values ? values.slice() : [];
                var len = theValues[LENGTH];
                function _value() {
                    if (idx >= 0 && idx < len) {
                        return theValues[idx];
                    }
                }
                function _getNext() {
                    idx++;
                    return idx >= len;
                }
                var ctx = {
                    n: _getNext
                };
                objDefine(ctx, "v", { g: _value });
                return createIterator(ctx);
            }

            function createRangeIterator(start, end, step) {
                var nextValue = start;
                var theValue = UNDEF_VALUE;
                if (isNullOrUndefined(end)) {
                    end = start;
                }
                var theStep = step || ((start <= end) ? 1 : -1);
                function _value() {
                    return theValue;
                }
                function _getNext() {
                    var isDone = false;
                    if (theStep > 0) {
                        isDone = nextValue > end;
                    }
                    else {
                        isDone = nextValue < end;
                    }
                    if (!isDone) {
                        theValue = nextValue;
                        nextValue += theStep;
                    }
                    return isDone;
                }
                var ctx = {
                    n: _getNext
                };
                objDefine(ctx, "v", { g: _value });
                return createIterator(ctx);
            }

            function polyStrSymSplit(value, splitter, limit) {
                var splitFn = splitter && splitter[getKnownSymbol(9 )];
                return splitFn ? splitFn(value, limit) : [value];
            }

            var strSplit = exports('strSplit', _unwrapFunction("split", StrProto));
            var strSymSplit = exports('strSymSplit', hasSymbol() ? _unwrapFunction("split", StrProto) : polyStrSymSplit);

            function getValueByKey(target, path, defValue) {
                if (!path || !target) {
                    return defValue;
                }
                var parts = strSplit(path, ".");
                var cnt = parts.length;
                for (var lp = 0; lp < cnt && !isNullOrUndefined(target); lp++) {
                    target = target[parts[lp]];
                }
                return (!isNullOrUndefined(target) ? target : defValue);
            }
            function getValueByIter(target, iter, defValue) {
                if (!iter || !target) {
                    return defValue;
                }
                iterForOf(iter, function (value) {
                    if (isNullOrUndefined(target)) {
                        return -1;
                    }
                    target = target[value];
                });
                return (!isNullOrUndefined(target) ? target : defValue);
            }
            function setValueByKey(target, path, value) {
                if (target && path) {
                    var parts = strSplit(path, ".");
                    var lastKey = parts.pop();
                    arrForEach(parts, function (key) {
                        if (isNullOrUndefined(target[key])) {
                            target[key] = {};
                        }
                        target = target[key];
                    });
                    target[lastKey] = value;
                }
            }
            function setValueByIter(target, iter, value) {
                if (target && iter) {
                    var lastKey_1;
                    iterForOf(iter, function (key) {
                        if (lastKey_1) {
                            if (isNullOrUndefined(target[lastKey_1])) {
                                target[lastKey_1] = {};
                            }
                            target = target[lastKey_1];
                        }
                        lastKey_1 = key;
                    });
                    target[lastKey_1] = value;
                }
            }

            var strEndsWith = exports('strEndsWith', _unwrapFunctionWithPoly("endsWith", StrProto, polyStrEndsWith));
            function polyStrEndsWith(value, searchString, length) {
                if (!isString(value)) {
                    throwTypeError("'" + dumpObj(value) + "' is not a string");
                }
                var searchValue = isString(searchString) ? searchString : asString(searchString);
                var chkLen = searchValue[LENGTH];
                var len = value[LENGTH];
                var end = !isUndefined(length) && length < len ? length : len;
                return strSubstring(value, end - chkLen, end) === searchValue;
            }

            var strIndexOf = exports('strIndexOf', _unwrapFunction(INDEX_OF, StrProto));
            var strLastIndexOf = exports('strLastIndexOf', _unwrapFunction(LAST_INDEX_OF, StrProto));

            var strIncludes = exports('strIncludes', _unwrapFunctionWithPoly("includes", StrProto, polyStrIncludes));
            var strContains = exports('strContains', strIncludes);
            function polyStrIncludes(value, searchString, position) {
                if (isRegExp(searchString)) {
                    throwTypeError("'searchString' must not be a regular expression" + dumpObj(searchString));
                }
                return strIndexOf(value, asString(searchString), position) !== -1;
            }

            function strIsNullOrWhiteSpace(value) {
                if (isString(value)) {
                    return value.replace(/[\s\t\r\n\f]+/g, EMPTY) === EMPTY;
                }
                return isNullOrUndefined(value);
            }
            function strIsNullOrEmpty(value) {
                if (isString(value)) {
                    return value === EMPTY;
                }
                return isNullOrUndefined(value);
            }

            var REF = "ref";
            var UNREF = "un" + REF;
            var HAS_REF = "hasRef";
            var ENABLED = "enabled";
            function _createTimerHandler(startTimer, refreshFn, cancelFn) {
                var _a;
                var ref = true;
                var timerId = startTimer ? refreshFn(NULL_VALUE) : NULL_VALUE;
                var theTimerHandler;
                var _unref = function () {
                    ref = false;
                    timerId && timerId[UNREF] && timerId[UNREF]();
                    return theTimerHandler;
                };
                var _ref = function () {
                    ref = true;
                    timerId && timerId[REF] && timerId[REF]();
                    return theTimerHandler;
                };
                var _hasRef = function () {
                    if (timerId && timerId[HAS_REF]) {
                        return timerId[HAS_REF]();
                    }
                    return ref;
                };
                var _refresh = function () {
                    timerId = refreshFn(timerId);
                    if (!ref) {
                        _unref();
                    }
                    return theTimerHandler;
                };
                var _cancel = function () {
                    timerId && cancelFn(timerId);
                    timerId = NULL_VALUE;
                };
                var _setEnabled = function (value) {
                    !value && timerId && _cancel();
                    value && !timerId && _refresh();
                };
                theTimerHandler = (_a = {
                        cancel: _cancel,
                        refresh: _refresh
                    },
                    _a[HAS_REF] = _hasRef,
                    _a[REF] = _ref,
                    _a[UNREF] = _unref,
                    _a[ENABLED] = false,
                    _a);
                objDefineProp(theTimerHandler, ENABLED, {
                    get: function () { return !!timerId; },
                    set: _setEnabled
                });
                return {
                    h: theTimerHandler,
                    dn: function () {
                        timerId = NULL_VALUE;
                    }
                };
            }

            function _createTimeoutWith(self, startTimer, overrideFn, theArgs) {
                var isArr = isArray(overrideFn);
                var len = isArr ? overrideFn.length : 0;
                var setFn = (len > 0 ? overrideFn[0] : (!isArr ? overrideFn : UNDEF_VALUE)) || setTimeout;
                var clearFn = (len > 1 ? overrideFn[1] : UNDEF_VALUE) || clearTimeout;
                var timerFn = theArgs[0];
                theArgs[0] = function () {
                    handler.dn();
                    fnApply(timerFn, self, arrSlice(arguments));
                };
                var handler = _createTimerHandler(startTimer, function (timerId) {
                    if (timerId) {
                        if (timerId.refresh) {
                            timerId.refresh();
                            return timerId;
                        }
                        fnApply(clearFn, self, [timerId]);
                    }
                    return fnApply(setFn, self, theArgs);
                }, function (timerId) {
                    fnApply(clearFn, self, [timerId]);
                });
                return handler.h;
            }
            function scheduleTimeout(callback, timeout) {
                return _createTimeoutWith(this, true, UNDEF_VALUE, arrSlice(arguments));
            }
            function scheduleTimeoutWith(overrideFn, callback, timeout) {
                return _createTimeoutWith(this, true, overrideFn, arrSlice(arguments, 1));
            }
            function createTimeout(callback, timeout) {
                return _createTimeoutWith(this, false, UNDEF_VALUE, arrSlice(arguments));
            }
            function createTimeoutWith(overrideFn, callback, timeout) {
                return _createTimeoutWith(this, false, overrideFn, arrSlice(arguments, 1));
            }

            var _hasIdleCallback;
            var _defaultIdleTimeout = 100;
            var _maxExecutionTime = 50;
            function hasIdleCallback() {
                !_hasIdleCallback && (_hasIdleCallback = safeGetLazy(function () { return isDefined(requestIdleCallback); }, false));
                return !!(_hasIdleCallback.v ? requestIdleCallback : false);
            }
            function setDefaultIdleTimeout(timeout) {
                _defaultIdleTimeout = timeout;
            }
            function setDefaultMaxExecutionTime(maxTime) {
                _maxExecutionTime = maxTime;
            }
            function scheduleIdleCallback(callback, options) {
                function _createDeadline(timedOut) {
                    var startTime = perfNow();
                    return {
                        didTimeout: timedOut,
                        timeRemaining: function () {
                            return _maxExecutionTime - elapsedTime(startTime);
                        }
                    };
                }
                if (hasIdleCallback()) {
                    var handler_1 = _createTimerHandler(true, function (idleId) {
                        idleId && cancelIdleCallback(idleId);
                        return requestIdleCallback(function (deadline) {
                            handler_1.dn();
                            callback(deadline || _createDeadline(false));
                        }, options);
                    }, function (idleId) {
                        cancelIdleCallback(idleId);
                    });
                    return handler_1.h;
                }
                var timeout = (options || {}).timeout;
                if (isUndefined(timeout)) {
                    timeout = _defaultIdleTimeout;
                }
                return scheduleTimeout(function () {
                    callback(_createDeadline(true));
                }, timeout);
            }

            function scheduleInterval(callback, timeout) {
                var self = this;
                var theArguments = arrSlice(arguments);
                var handler = _createTimerHandler(true, function (intervalId) {
                    intervalId && clearInterval(intervalId);
                    return fnApply(setInterval, self, theArguments);
                }, function (intervalId) {
                    fnApply(clearInterval, self, [intervalId]);
                });
                return handler.h;
            }

        })
    };
}));
//# sourceMappingURL=ts-utils.js.map
