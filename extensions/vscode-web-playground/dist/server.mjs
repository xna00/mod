var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x2) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x2, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x2)(function(x2) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x2 + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/vscode-jsonrpc/lib/common/is.js
var require_is = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/is.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports2.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports2.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports2.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports2.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports2.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports2.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports2.stringArray = stringArray;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messages.js
var require_messages = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Message = exports2.NotificationType9 = exports2.NotificationType8 = exports2.NotificationType7 = exports2.NotificationType6 = exports2.NotificationType5 = exports2.NotificationType4 = exports2.NotificationType3 = exports2.NotificationType2 = exports2.NotificationType1 = exports2.NotificationType0 = exports2.NotificationType = exports2.RequestType9 = exports2.RequestType8 = exports2.RequestType7 = exports2.RequestType6 = exports2.RequestType5 = exports2.RequestType4 = exports2.RequestType3 = exports2.RequestType2 = exports2.RequestType1 = exports2.RequestType = exports2.RequestType0 = exports2.AbstractMessageSignature = exports2.ParameterStructures = exports2.ResponseError = exports2.ErrorCodes = void 0;
    var is = require_is();
    var ErrorCodes;
    (function(ErrorCodes2) {
      ErrorCodes2.ParseError = -32700;
      ErrorCodes2.InvalidRequest = -32600;
      ErrorCodes2.MethodNotFound = -32601;
      ErrorCodes2.InvalidParams = -32602;
      ErrorCodes2.InternalError = -32603;
      ErrorCodes2.jsonrpcReservedErrorRangeStart = -32099;
      ErrorCodes2.serverErrorStart = -32099;
      ErrorCodes2.MessageWriteError = -32099;
      ErrorCodes2.MessageReadError = -32098;
      ErrorCodes2.PendingResponseRejected = -32097;
      ErrorCodes2.ConnectionInactive = -32096;
      ErrorCodes2.ServerNotInitialized = -32002;
      ErrorCodes2.UnknownErrorCode = -32001;
      ErrorCodes2.jsonrpcReservedErrorRangeEnd = -32e3;
      ErrorCodes2.serverErrorEnd = -32e3;
    })(ErrorCodes || (exports2.ErrorCodes = ErrorCodes = {}));
    var ResponseError = class _ResponseError extends Error {
      constructor(code, message, data) {
        super(message);
        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
        this.data = data;
        Object.setPrototypeOf(this, _ResponseError.prototype);
      }
      toJson() {
        const result = {
          code: this.code,
          message: this.message
        };
        if (this.data !== void 0) {
          result.data = this.data;
        }
        return result;
      }
    };
    exports2.ResponseError = ResponseError;
    var ParameterStructures = class _ParameterStructures {
      constructor(kind) {
        this.kind = kind;
      }
      static is(value) {
        return value === _ParameterStructures.auto || value === _ParameterStructures.byName || value === _ParameterStructures.byPosition;
      }
      toString() {
        return this.kind;
      }
    };
    exports2.ParameterStructures = ParameterStructures;
    ParameterStructures.auto = new ParameterStructures("auto");
    ParameterStructures.byPosition = new ParameterStructures("byPosition");
    ParameterStructures.byName = new ParameterStructures("byName");
    var AbstractMessageSignature = class {
      constructor(method, numberOfParams) {
        this.method = method;
        this.numberOfParams = numberOfParams;
      }
      get parameterStructures() {
        return ParameterStructures.auto;
      }
    };
    exports2.AbstractMessageSignature = AbstractMessageSignature;
    var RequestType0 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    };
    exports2.RequestType0 = RequestType0;
    var RequestType = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.RequestType = RequestType;
    var RequestType1 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.RequestType1 = RequestType1;
    var RequestType2 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    };
    exports2.RequestType2 = RequestType2;
    var RequestType3 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    };
    exports2.RequestType3 = RequestType3;
    var RequestType4 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    };
    exports2.RequestType4 = RequestType4;
    var RequestType5 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    };
    exports2.RequestType5 = RequestType5;
    var RequestType6 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    };
    exports2.RequestType6 = RequestType6;
    var RequestType7 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    };
    exports2.RequestType7 = RequestType7;
    var RequestType8 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    };
    exports2.RequestType8 = RequestType8;
    var RequestType9 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    };
    exports2.RequestType9 = RequestType9;
    var NotificationType = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.NotificationType = NotificationType;
    var NotificationType0 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    };
    exports2.NotificationType0 = NotificationType0;
    var NotificationType1 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.NotificationType1 = NotificationType1;
    var NotificationType2 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    };
    exports2.NotificationType2 = NotificationType2;
    var NotificationType3 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    };
    exports2.NotificationType3 = NotificationType3;
    var NotificationType4 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    };
    exports2.NotificationType4 = NotificationType4;
    var NotificationType5 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    };
    exports2.NotificationType5 = NotificationType5;
    var NotificationType6 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    };
    exports2.NotificationType6 = NotificationType6;
    var NotificationType7 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    };
    exports2.NotificationType7 = NotificationType7;
    var NotificationType8 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    };
    exports2.NotificationType8 = NotificationType8;
    var NotificationType9 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    };
    exports2.NotificationType9 = NotificationType9;
    var Message;
    (function(Message2) {
      function isRequest(message) {
        const candidate = message;
        return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
      }
      Message2.isRequest = isRequest;
      function isNotification(message) {
        const candidate = message;
        return candidate && is.string(candidate.method) && message.id === void 0;
      }
      Message2.isNotification = isNotification;
      function isResponse(message) {
        const candidate = message;
        return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
      }
      Message2.isResponse = isResponse;
    })(Message || (exports2.Message = Message = {}));
  }
});

// node_modules/vscode-jsonrpc/lib/common/linkedMap.js
var require_linkedMap = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/linkedMap.js"(exports2) {
    "use strict";
    var _a;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LRUCache = exports2.LinkedMap = exports2.Touch = void 0;
    var Touch;
    (function(Touch2) {
      Touch2.None = 0;
      Touch2.First = 1;
      Touch2.AsOld = Touch2.First;
      Touch2.Last = 2;
      Touch2.AsNew = Touch2.Last;
    })(Touch || (exports2.Touch = Touch = {}));
    var LinkedMap = class {
      constructor() {
        this[_a] = "LinkedMap";
        this._map = /* @__PURE__ */ new Map();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state = 0;
      }
      clear() {
        this._map.clear();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state++;
      }
      isEmpty() {
        return !this._head && !this._tail;
      }
      get size() {
        return this._size;
      }
      get first() {
        return this._head?.value;
      }
      get last() {
        return this._tail?.value;
      }
      has(key) {
        return this._map.has(key);
      }
      get(key, touch = Touch.None) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        if (touch !== Touch.None) {
          this.touch(item, touch);
        }
        return item.value;
      }
      set(key, value, touch = Touch.None) {
        let item = this._map.get(key);
        if (item) {
          item.value = value;
          if (touch !== Touch.None) {
            this.touch(item, touch);
          }
        } else {
          item = { key, value, next: void 0, previous: void 0 };
          switch (touch) {
            case Touch.None:
              this.addItemLast(item);
              break;
            case Touch.First:
              this.addItemFirst(item);
              break;
            case Touch.Last:
              this.addItemLast(item);
              break;
            default:
              this.addItemLast(item);
              break;
          }
          this._map.set(key, item);
          this._size++;
        }
        return this;
      }
      delete(key) {
        return !!this.remove(key);
      }
      remove(key) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      shift() {
        if (!this._head && !this._tail) {
          return void 0;
        }
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      forEach(callbackfn, thisArg) {
        const state = this._state;
        let current = this._head;
        while (current) {
          if (thisArg) {
            callbackfn.bind(thisArg)(current.value, current.key, this);
          } else {
            callbackfn(current.value, current.key, this);
          }
          if (this._state !== state) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          current = current.next;
        }
      }
      keys() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.key, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      values() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.value, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      entries() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: [current.key, current.value], done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      [(_a = Symbol.toStringTag, Symbol.iterator)]() {
        return this.entries();
      }
      trimOld(newSize) {
        if (newSize >= this.size) {
          return;
        }
        if (newSize === 0) {
          this.clear();
          return;
        }
        let current = this._head;
        let currentSize = this.size;
        while (current && currentSize > newSize) {
          this._map.delete(current.key);
          current = current.next;
          currentSize--;
        }
        this._head = current;
        this._size = currentSize;
        if (current) {
          current.previous = void 0;
        }
        this._state++;
      }
      addItemFirst(item) {
        if (!this._head && !this._tail) {
          this._tail = item;
        } else if (!this._head) {
          throw new Error("Invalid list");
        } else {
          item.next = this._head;
          this._head.previous = item;
        }
        this._head = item;
        this._state++;
      }
      addItemLast(item) {
        if (!this._head && !this._tail) {
          this._head = item;
        } else if (!this._tail) {
          throw new Error("Invalid list");
        } else {
          item.previous = this._tail;
          this._tail.next = item;
        }
        this._tail = item;
        this._state++;
      }
      removeItem(item) {
        if (item === this._head && item === this._tail) {
          this._head = void 0;
          this._tail = void 0;
        } else if (item === this._head) {
          if (!item.next) {
            throw new Error("Invalid list");
          }
          item.next.previous = void 0;
          this._head = item.next;
        } else if (item === this._tail) {
          if (!item.previous) {
            throw new Error("Invalid list");
          }
          item.previous.next = void 0;
          this._tail = item.previous;
        } else {
          const next = item.next;
          const previous = item.previous;
          if (!next || !previous) {
            throw new Error("Invalid list");
          }
          next.previous = previous;
          previous.next = next;
        }
        item.next = void 0;
        item.previous = void 0;
        this._state++;
      }
      touch(item, touch) {
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        if (touch !== Touch.First && touch !== Touch.Last) {
          return;
        }
        if (touch === Touch.First) {
          if (item === this._head) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._tail) {
            previous.next = void 0;
            this._tail = previous;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.previous = void 0;
          item.next = this._head;
          this._head.previous = item;
          this._head = item;
          this._state++;
        } else if (touch === Touch.Last) {
          if (item === this._tail) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._head) {
            next.previous = void 0;
            this._head = next;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.next = void 0;
          item.previous = this._tail;
          this._tail.next = item;
          this._tail = item;
          this._state++;
        }
      }
      toJSON() {
        const data = [];
        this.forEach((value, key) => {
          data.push([key, value]);
        });
        return data;
      }
      fromJSON(data) {
        this.clear();
        for (const [key, value] of data) {
          this.set(key, value);
        }
      }
    };
    exports2.LinkedMap = LinkedMap;
    var LRUCache = class extends LinkedMap {
      constructor(limit, ratio = 1) {
        super();
        this._limit = limit;
        this._ratio = Math.min(Math.max(0, ratio), 1);
      }
      get limit() {
        return this._limit;
      }
      set limit(limit) {
        this._limit = limit;
        this.checkTrim();
      }
      get ratio() {
        return this._ratio;
      }
      set ratio(ratio) {
        this._ratio = Math.min(Math.max(0, ratio), 1);
        this.checkTrim();
      }
      get(key, touch = Touch.AsNew) {
        return super.get(key, touch);
      }
      peek(key) {
        return super.get(key, Touch.None);
      }
      set(key, value) {
        super.set(key, value, Touch.Last);
        this.checkTrim();
        return this;
      }
      checkTrim() {
        if (this.size > this._limit) {
          this.trimOld(Math.round(this._limit * this._ratio));
        }
      }
    };
    exports2.LRUCache = LRUCache;
  }
});

// node_modules/vscode-jsonrpc/lib/common/disposable.js
var require_disposable = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/disposable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Disposable = void 0;
    var Disposable;
    (function(Disposable2) {
      function create(func) {
        return {
          dispose: func
        };
      }
      Disposable2.create = create;
    })(Disposable || (exports2.Disposable = Disposable = {}));
  }
});

// node_modules/vscode-jsonrpc/lib/common/ral.js
var require_ral = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/ral.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var _ral;
    function RAL() {
      if (_ral === void 0) {
        throw new Error(`No runtime abstraction layer installed`);
      }
      return _ral;
    }
    (function(RAL2) {
      function install(ral) {
        if (ral === void 0) {
          throw new Error(`No runtime abstraction layer provided`);
        }
        _ral = ral;
      }
      RAL2.install = install;
    })(RAL || (RAL = {}));
    exports2.default = RAL;
  }
});

// node_modules/vscode-jsonrpc/lib/common/events.js
var require_events = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/events.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Emitter = exports2.Event = void 0;
    var ral_1 = require_ral();
    var Event;
    (function(Event2) {
      const _disposable = { dispose() {
      } };
      Event2.None = function() {
        return _disposable;
      };
    })(Event || (exports2.Event = Event = {}));
    var CallbackList = class {
      add(callback, context = null, bucket) {
        if (!this._callbacks) {
          this._callbacks = [];
          this._contexts = [];
        }
        this._callbacks.push(callback);
        this._contexts.push(context);
        if (Array.isArray(bucket)) {
          bucket.push({ dispose: () => this.remove(callback, context) });
        }
      }
      remove(callback, context = null) {
        if (!this._callbacks) {
          return;
        }
        let foundCallbackWithDifferentContext = false;
        for (let i = 0, len = this._callbacks.length; i < len; i++) {
          if (this._callbacks[i] === callback) {
            if (this._contexts[i] === context) {
              this._callbacks.splice(i, 1);
              this._contexts.splice(i, 1);
              return;
            } else {
              foundCallbackWithDifferentContext = true;
            }
          }
        }
        if (foundCallbackWithDifferentContext) {
          throw new Error("When adding a listener with a context, you should remove it with the same context");
        }
      }
      invoke(...args) {
        if (!this._callbacks) {
          return [];
        }
        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
        for (let i = 0, len = callbacks.length; i < len; i++) {
          try {
            ret.push(callbacks[i].apply(contexts[i], args));
          } catch (e) {
            (0, ral_1.default)().console.error(e);
          }
        }
        return ret;
      }
      isEmpty() {
        return !this._callbacks || this._callbacks.length === 0;
      }
      dispose() {
        this._callbacks = void 0;
        this._contexts = void 0;
      }
    };
    var Emitter = class _Emitter {
      constructor(_options) {
        this._options = _options;
      }
      /**
       * For the public to allow to subscribe
       * to events from this Emitter
       */
      get event() {
        if (!this._event) {
          this._event = (listener, thisArgs, disposables) => {
            if (!this._callbacks) {
              this._callbacks = new CallbackList();
            }
            if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
              this._options.onFirstListenerAdd(this);
            }
            this._callbacks.add(listener, thisArgs);
            const result = {
              dispose: () => {
                if (!this._callbacks) {
                  return;
                }
                this._callbacks.remove(listener, thisArgs);
                result.dispose = _Emitter._noop;
                if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                  this._options.onLastListenerRemove(this);
                }
              }
            };
            if (Array.isArray(disposables)) {
              disposables.push(result);
            }
            return result;
          };
        }
        return this._event;
      }
      /**
       * To be kept private to fire an event to
       * subscribers
       */
      fire(event) {
        if (this._callbacks) {
          this._callbacks.invoke.call(this._callbacks, event);
        }
      }
      dispose() {
        if (this._callbacks) {
          this._callbacks.dispose();
          this._callbacks = void 0;
        }
      }
    };
    exports2.Emitter = Emitter;
    Emitter._noop = function() {
    };
  }
});

// node_modules/vscode-jsonrpc/lib/common/cancellation.js
var require_cancellation = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/cancellation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CancellationTokenSource = exports2.CancellationToken = void 0;
    var ral_1 = require_ral();
    var Is2 = require_is();
    var events_1 = require_events();
    var CancellationToken;
    (function(CancellationToken2) {
      CancellationToken2.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: events_1.Event.None
      });
      CancellationToken2.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: events_1.Event.None
      });
      function is(value) {
        const candidate = value;
        return candidate && (candidate === CancellationToken2.None || candidate === CancellationToken2.Cancelled || Is2.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
      }
      CancellationToken2.is = is;
    })(CancellationToken || (exports2.CancellationToken = CancellationToken = {}));
    var shortcutEvent = Object.freeze(function(callback, context) {
      const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
      return { dispose() {
        handle.dispose();
      } };
    });
    var MutableToken = class {
      constructor() {
        this._isCancelled = false;
      }
      cancel() {
        if (!this._isCancelled) {
          this._isCancelled = true;
          if (this._emitter) {
            this._emitter.fire(void 0);
            this.dispose();
          }
        }
      }
      get isCancellationRequested() {
        return this._isCancelled;
      }
      get onCancellationRequested() {
        if (this._isCancelled) {
          return shortcutEvent;
        }
        if (!this._emitter) {
          this._emitter = new events_1.Emitter();
        }
        return this._emitter.event;
      }
      dispose() {
        if (this._emitter) {
          this._emitter.dispose();
          this._emitter = void 0;
        }
      }
    };
    var CancellationTokenSource = class {
      get token() {
        if (!this._token) {
          this._token = new MutableToken();
        }
        return this._token;
      }
      cancel() {
        if (!this._token) {
          this._token = CancellationToken.Cancelled;
        } else {
          this._token.cancel();
        }
      }
      dispose() {
        if (!this._token) {
          this._token = CancellationToken.None;
        } else if (this._token instanceof MutableToken) {
          this._token.dispose();
        }
      }
    };
    exports2.CancellationTokenSource = CancellationTokenSource;
  }
});

// node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js
var require_sharedArrayCancellation = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SharedArrayReceiverStrategy = exports2.SharedArraySenderStrategy = void 0;
    var cancellation_1 = require_cancellation();
    var CancellationState;
    (function(CancellationState2) {
      CancellationState2.Continue = 0;
      CancellationState2.Cancelled = 1;
    })(CancellationState || (CancellationState = {}));
    var SharedArraySenderStrategy = class {
      constructor() {
        this.buffers = /* @__PURE__ */ new Map();
      }
      enableCancellation(request) {
        if (request.id === null) {
          return;
        }
        const buffer = new SharedArrayBuffer(4);
        const data = new Int32Array(buffer, 0, 1);
        data[0] = CancellationState.Continue;
        this.buffers.set(request.id, buffer);
        request.$cancellationData = buffer;
      }
      async sendCancellation(_conn, id) {
        const buffer = this.buffers.get(id);
        if (buffer === void 0) {
          return;
        }
        const data = new Int32Array(buffer, 0, 1);
        Atomics.store(data, 0, CancellationState.Cancelled);
      }
      cleanup(id) {
        this.buffers.delete(id);
      }
      dispose() {
        this.buffers.clear();
      }
    };
    exports2.SharedArraySenderStrategy = SharedArraySenderStrategy;
    var SharedArrayBufferCancellationToken = class {
      constructor(buffer) {
        this.data = new Int32Array(buffer, 0, 1);
      }
      get isCancellationRequested() {
        return Atomics.load(this.data, 0) === CancellationState.Cancelled;
      }
      get onCancellationRequested() {
        throw new Error(`Cancellation over SharedArrayBuffer doesn't support cancellation events`);
      }
    };
    var SharedArrayBufferCancellationTokenSource = class {
      constructor(buffer) {
        this.token = new SharedArrayBufferCancellationToken(buffer);
      }
      cancel() {
      }
      dispose() {
      }
    };
    var SharedArrayReceiverStrategy = class {
      constructor() {
        this.kind = "request";
      }
      createCancellationTokenSource(request) {
        const buffer = request.$cancellationData;
        if (buffer === void 0) {
          return new cancellation_1.CancellationTokenSource();
        }
        return new SharedArrayBufferCancellationTokenSource(buffer);
      }
    };
    exports2.SharedArrayReceiverStrategy = SharedArrayReceiverStrategy;
  }
});

// node_modules/vscode-jsonrpc/lib/common/semaphore.js
var require_semaphore = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/semaphore.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Semaphore = void 0;
    var ral_1 = require_ral();
    var Semaphore = class {
      constructor(capacity = 1) {
        if (capacity <= 0) {
          throw new Error("Capacity must be greater than 0");
        }
        this._capacity = capacity;
        this._active = 0;
        this._waiting = [];
      }
      lock(thunk) {
        return new Promise((resolve, reject) => {
          this._waiting.push({ thunk, resolve, reject });
          this.runNext();
        });
      }
      get active() {
        return this._active;
      }
      runNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        (0, ral_1.default)().timer.setImmediate(() => this.doRunNext());
      }
      doRunNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        const next = this._waiting.shift();
        this._active++;
        if (this._active > this._capacity) {
          throw new Error(`To many thunks active`);
        }
        try {
          const result = next.thunk();
          if (result instanceof Promise) {
            result.then((value) => {
              this._active--;
              next.resolve(value);
              this.runNext();
            }, (err) => {
              this._active--;
              next.reject(err);
              this.runNext();
            });
          } else {
            this._active--;
            next.resolve(result);
            this.runNext();
          }
        } catch (err) {
          this._active--;
          next.reject(err);
          this.runNext();
        }
      }
    };
    exports2.Semaphore = Semaphore;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messageReader.js
var require_messageReader = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messageReader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReadableStreamMessageReader = exports2.AbstractMessageReader = exports2.MessageReader = void 0;
    var ral_1 = require_ral();
    var Is2 = require_is();
    var events_1 = require_events();
    var semaphore_1 = require_semaphore();
    var MessageReader;
    (function(MessageReader2) {
      function is(value) {
        let candidate = value;
        return candidate && Is2.func(candidate.listen) && Is2.func(candidate.dispose) && Is2.func(candidate.onError) && Is2.func(candidate.onClose) && Is2.func(candidate.onPartialMessage);
      }
      MessageReader2.is = is;
    })(MessageReader || (exports2.MessageReader = MessageReader = {}));
    var AbstractMessageReader = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
        this.partialMessageEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error) {
        this.errorEmitter.fire(this.asError(error));
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      get onPartialMessage() {
        return this.partialMessageEmitter.event;
      }
      firePartialMessage(info) {
        this.partialMessageEmitter.fire(info);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Reader received error. Reason: ${Is2.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports2.AbstractMessageReader = AbstractMessageReader;
    var ResolvedMessageReaderOptions;
    (function(ResolvedMessageReaderOptions2) {
      function fromOptions(options) {
        let charset;
        let result;
        let contentDecoder;
        const contentDecoders = /* @__PURE__ */ new Map();
        let contentTypeDecoder;
        const contentTypeDecoders = /* @__PURE__ */ new Map();
        if (options === void 0 || typeof options === "string") {
          charset = options ?? "utf-8";
        } else {
          charset = options.charset ?? "utf-8";
          if (options.contentDecoder !== void 0) {
            contentDecoder = options.contentDecoder;
            contentDecoders.set(contentDecoder.name, contentDecoder);
          }
          if (options.contentDecoders !== void 0) {
            for (const decoder of options.contentDecoders) {
              contentDecoders.set(decoder.name, decoder);
            }
          }
          if (options.contentTypeDecoder !== void 0) {
            contentTypeDecoder = options.contentTypeDecoder;
            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
          }
          if (options.contentTypeDecoders !== void 0) {
            for (const decoder of options.contentTypeDecoders) {
              contentTypeDecoders.set(decoder.name, decoder);
            }
          }
        }
        if (contentTypeDecoder === void 0) {
          contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
          contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
        }
        return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
      }
      ResolvedMessageReaderOptions2.fromOptions = fromOptions;
    })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
    var ReadableStreamMessageReader = class extends AbstractMessageReader {
      constructor(readable, options) {
        super();
        this.readable = readable;
        this.options = ResolvedMessageReaderOptions.fromOptions(options);
        this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
        this._partialMessageTimeout = 1e4;
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.readSemaphore = new semaphore_1.Semaphore(1);
      }
      set partialMessageTimeout(timeout) {
        this._partialMessageTimeout = timeout;
      }
      get partialMessageTimeout() {
        return this._partialMessageTimeout;
      }
      listen(callback) {
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.partialMessageTimer = void 0;
        this.callback = callback;
        const result = this.readable.onData((data) => {
          this.onData(data);
        });
        this.readable.onError((error) => this.fireError(error));
        this.readable.onClose(() => this.fireClose());
        return result;
      }
      onData(data) {
        try {
          this.buffer.append(data);
          while (true) {
            if (this.nextMessageLength === -1) {
              const headers = this.buffer.tryReadHeaders(true);
              if (!headers) {
                return;
              }
              const contentLength = headers.get("content-length");
              if (!contentLength) {
                this.fireError(new Error(`Header must provide a Content-Length property.
${JSON.stringify(Object.fromEntries(headers))}`));
                return;
              }
              const length = parseInt(contentLength);
              if (isNaN(length)) {
                this.fireError(new Error(`Content-Length value must be a number. Got ${contentLength}`));
                return;
              }
              this.nextMessageLength = length;
            }
            const body = this.buffer.tryReadBody(this.nextMessageLength);
            if (body === void 0) {
              this.setPartialMessageTimer();
              return;
            }
            this.clearPartialMessageTimer();
            this.nextMessageLength = -1;
            this.readSemaphore.lock(async () => {
              const bytes = this.options.contentDecoder !== void 0 ? await this.options.contentDecoder.decode(body) : body;
              const message = await this.options.contentTypeDecoder.decode(bytes, this.options);
              this.callback(message);
            }).catch((error) => {
              this.fireError(error);
            });
          }
        } catch (error) {
          this.fireError(error);
        }
      }
      clearPartialMessageTimer() {
        if (this.partialMessageTimer) {
          this.partialMessageTimer.dispose();
          this.partialMessageTimer = void 0;
        }
      }
      setPartialMessageTimer() {
        this.clearPartialMessageTimer();
        if (this._partialMessageTimeout <= 0) {
          return;
        }
        this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout) => {
          this.partialMessageTimer = void 0;
          if (token === this.messageToken) {
            this.firePartialMessage({ messageToken: token, waitingTime: timeout });
            this.setPartialMessageTimer();
          }
        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
      }
    };
    exports2.ReadableStreamMessageReader = ReadableStreamMessageReader;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messageWriter.js
var require_messageWriter = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messageWriter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WriteableStreamMessageWriter = exports2.AbstractMessageWriter = exports2.MessageWriter = void 0;
    var ral_1 = require_ral();
    var Is2 = require_is();
    var semaphore_1 = require_semaphore();
    var events_1 = require_events();
    var ContentLength = "Content-Length: ";
    var CRLF = "\r\n";
    var MessageWriter;
    (function(MessageWriter2) {
      function is(value) {
        let candidate = value;
        return candidate && Is2.func(candidate.dispose) && Is2.func(candidate.onClose) && Is2.func(candidate.onError) && Is2.func(candidate.write);
      }
      MessageWriter2.is = is;
    })(MessageWriter || (exports2.MessageWriter = MessageWriter = {}));
    var AbstractMessageWriter = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error, message, count) {
        this.errorEmitter.fire([this.asError(error), message, count]);
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Writer received error. Reason: ${Is2.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports2.AbstractMessageWriter = AbstractMessageWriter;
    var ResolvedMessageWriterOptions;
    (function(ResolvedMessageWriterOptions2) {
      function fromOptions(options) {
        if (options === void 0 || typeof options === "string") {
          return { charset: options ?? "utf-8", contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder };
        } else {
          return { charset: options.charset ?? "utf-8", contentEncoder: options.contentEncoder, contentTypeEncoder: options.contentTypeEncoder ?? (0, ral_1.default)().applicationJson.encoder };
        }
      }
      ResolvedMessageWriterOptions2.fromOptions = fromOptions;
    })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
    var WriteableStreamMessageWriter = class extends AbstractMessageWriter {
      constructor(writable, options) {
        super();
        this.writable = writable;
        this.options = ResolvedMessageWriterOptions.fromOptions(options);
        this.errorCount = 0;
        this.writeSemaphore = new semaphore_1.Semaphore(1);
        this.writable.onError((error) => this.fireError(error));
        this.writable.onClose(() => this.fireClose());
      }
      async write(msg) {
        return this.writeSemaphore.lock(async () => {
          const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
            if (this.options.contentEncoder !== void 0) {
              return this.options.contentEncoder.encode(buffer);
            } else {
              return buffer;
            }
          });
          return payload.then((buffer) => {
            const headers = [];
            headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
            headers.push(CRLF);
            return this.doWrite(msg, headers, buffer);
          }, (error) => {
            this.fireError(error);
            throw error;
          });
        });
      }
      async doWrite(msg, headers, data) {
        try {
          await this.writable.write(headers.join(""), "ascii");
          return this.writable.write(data);
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
        this.writable.end();
      }
    };
    exports2.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messageBuffer.js
var require_messageBuffer = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messageBuffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AbstractMessageBuffer = void 0;
    var CR = 13;
    var LF = 10;
    var CRLF = "\r\n";
    var AbstractMessageBuffer = class {
      constructor(encoding = "utf-8") {
        this._encoding = encoding;
        this._chunks = [];
        this._totalLength = 0;
      }
      get encoding() {
        return this._encoding;
      }
      append(chunk) {
        const toAppend = typeof chunk === "string" ? this.fromString(chunk, this._encoding) : chunk;
        this._chunks.push(toAppend);
        this._totalLength += toAppend.byteLength;
      }
      tryReadHeaders(lowerCaseKeys = false) {
        if (this._chunks.length === 0) {
          return void 0;
        }
        let state = 0;
        let chunkIndex = 0;
        let offset = 0;
        let chunkBytesRead = 0;
        row:
          while (chunkIndex < this._chunks.length) {
            const chunk = this._chunks[chunkIndex];
            offset = 0;
            column:
              while (offset < chunk.length) {
                const value = chunk[offset];
                switch (value) {
                  case CR:
                    switch (state) {
                      case 0:
                        state = 1;
                        break;
                      case 2:
                        state = 3;
                        break;
                      default:
                        state = 0;
                    }
                    break;
                  case LF:
                    switch (state) {
                      case 1:
                        state = 2;
                        break;
                      case 3:
                        state = 4;
                        offset++;
                        break row;
                      default:
                        state = 0;
                    }
                    break;
                  default:
                    state = 0;
                }
                offset++;
              }
            chunkBytesRead += chunk.byteLength;
            chunkIndex++;
          }
        if (state !== 4) {
          return void 0;
        }
        const buffer = this._read(chunkBytesRead + offset);
        const result = /* @__PURE__ */ new Map();
        const headers = this.toString(buffer, "ascii").split(CRLF);
        if (headers.length < 2) {
          return result;
        }
        for (let i = 0; i < headers.length - 2; i++) {
          const header = headers[i];
          const index = header.indexOf(":");
          if (index === -1) {
            throw new Error(`Message header must separate key and value using ':'
${header}`);
          }
          const key = header.substr(0, index);
          const value = header.substr(index + 1).trim();
          result.set(lowerCaseKeys ? key.toLowerCase() : key, value);
        }
        return result;
      }
      tryReadBody(length) {
        if (this._totalLength < length) {
          return void 0;
        }
        return this._read(length);
      }
      get numberOfBytes() {
        return this._totalLength;
      }
      _read(byteCount) {
        if (byteCount === 0) {
          return this.emptyBuffer();
        }
        if (byteCount > this._totalLength) {
          throw new Error(`Cannot read so many bytes!`);
        }
        if (this._chunks[0].byteLength === byteCount) {
          const chunk = this._chunks[0];
          this._chunks.shift();
          this._totalLength -= byteCount;
          return this.asNative(chunk);
        }
        if (this._chunks[0].byteLength > byteCount) {
          const chunk = this._chunks[0];
          const result2 = this.asNative(chunk, byteCount);
          this._chunks[0] = chunk.slice(byteCount);
          this._totalLength -= byteCount;
          return result2;
        }
        const result = this.allocNative(byteCount);
        let resultOffset = 0;
        let chunkIndex = 0;
        while (byteCount > 0) {
          const chunk = this._chunks[chunkIndex];
          if (chunk.byteLength > byteCount) {
            const chunkPart = chunk.slice(0, byteCount);
            result.set(chunkPart, resultOffset);
            resultOffset += byteCount;
            this._chunks[chunkIndex] = chunk.slice(byteCount);
            this._totalLength -= byteCount;
            byteCount -= byteCount;
          } else {
            result.set(chunk, resultOffset);
            resultOffset += chunk.byteLength;
            this._chunks.shift();
            this._totalLength -= chunk.byteLength;
            byteCount -= chunk.byteLength;
          }
        }
        return result;
      }
    };
    exports2.AbstractMessageBuffer = AbstractMessageBuffer;
  }
});

// node_modules/vscode-jsonrpc/lib/common/connection.js
var require_connection = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/connection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMessageConnection = exports2.ConnectionOptions = exports2.MessageStrategy = exports2.CancellationStrategy = exports2.CancellationSenderStrategy = exports2.CancellationReceiverStrategy = exports2.RequestCancellationReceiverStrategy = exports2.IdCancellationReceiverStrategy = exports2.ConnectionStrategy = exports2.ConnectionError = exports2.ConnectionErrors = exports2.LogTraceNotification = exports2.SetTraceNotification = exports2.TraceFormat = exports2.TraceValues = exports2.Trace = exports2.NullLogger = exports2.ProgressType = exports2.ProgressToken = void 0;
    var ral_1 = require_ral();
    var Is2 = require_is();
    var messages_1 = require_messages();
    var linkedMap_1 = require_linkedMap();
    var events_1 = require_events();
    var cancellation_1 = require_cancellation();
    var CancelNotification;
    (function(CancelNotification2) {
      CancelNotification2.type = new messages_1.NotificationType("$/cancelRequest");
    })(CancelNotification || (CancelNotification = {}));
    var ProgressToken;
    (function(ProgressToken2) {
      function is(value) {
        return typeof value === "string" || typeof value === "number";
      }
      ProgressToken2.is = is;
    })(ProgressToken || (exports2.ProgressToken = ProgressToken = {}));
    var ProgressNotification;
    (function(ProgressNotification2) {
      ProgressNotification2.type = new messages_1.NotificationType("$/progress");
    })(ProgressNotification || (ProgressNotification = {}));
    var ProgressType = class {
      constructor() {
      }
    };
    exports2.ProgressType = ProgressType;
    var StarRequestHandler;
    (function(StarRequestHandler2) {
      function is(value) {
        return Is2.func(value);
      }
      StarRequestHandler2.is = is;
    })(StarRequestHandler || (StarRequestHandler = {}));
    exports2.NullLogger = Object.freeze({
      error: () => {
      },
      warn: () => {
      },
      info: () => {
      },
      log: () => {
      }
    });
    var Trace;
    (function(Trace2) {
      Trace2[Trace2["Off"] = 0] = "Off";
      Trace2[Trace2["Messages"] = 1] = "Messages";
      Trace2[Trace2["Compact"] = 2] = "Compact";
      Trace2[Trace2["Verbose"] = 3] = "Verbose";
    })(Trace || (exports2.Trace = Trace = {}));
    var TraceValues;
    (function(TraceValues2) {
      TraceValues2.Off = "off";
      TraceValues2.Messages = "messages";
      TraceValues2.Compact = "compact";
      TraceValues2.Verbose = "verbose";
    })(TraceValues || (exports2.TraceValues = TraceValues = {}));
    (function(Trace2) {
      function fromString(value) {
        if (!Is2.string(value)) {
          return Trace2.Off;
        }
        value = value.toLowerCase();
        switch (value) {
          case "off":
            return Trace2.Off;
          case "messages":
            return Trace2.Messages;
          case "compact":
            return Trace2.Compact;
          case "verbose":
            return Trace2.Verbose;
          default:
            return Trace2.Off;
        }
      }
      Trace2.fromString = fromString;
      function toString(value) {
        switch (value) {
          case Trace2.Off:
            return "off";
          case Trace2.Messages:
            return "messages";
          case Trace2.Compact:
            return "compact";
          case Trace2.Verbose:
            return "verbose";
          default:
            return "off";
        }
      }
      Trace2.toString = toString;
    })(Trace || (exports2.Trace = Trace = {}));
    var TraceFormat;
    (function(TraceFormat2) {
      TraceFormat2["Text"] = "text";
      TraceFormat2["JSON"] = "json";
    })(TraceFormat || (exports2.TraceFormat = TraceFormat = {}));
    (function(TraceFormat2) {
      function fromString(value) {
        if (!Is2.string(value)) {
          return TraceFormat2.Text;
        }
        value = value.toLowerCase();
        if (value === "json") {
          return TraceFormat2.JSON;
        } else {
          return TraceFormat2.Text;
        }
      }
      TraceFormat2.fromString = fromString;
    })(TraceFormat || (exports2.TraceFormat = TraceFormat = {}));
    var SetTraceNotification;
    (function(SetTraceNotification2) {
      SetTraceNotification2.type = new messages_1.NotificationType("$/setTrace");
    })(SetTraceNotification || (exports2.SetTraceNotification = SetTraceNotification = {}));
    var LogTraceNotification;
    (function(LogTraceNotification2) {
      LogTraceNotification2.type = new messages_1.NotificationType("$/logTrace");
    })(LogTraceNotification || (exports2.LogTraceNotification = LogTraceNotification = {}));
    var ConnectionErrors;
    (function(ConnectionErrors2) {
      ConnectionErrors2[ConnectionErrors2["Closed"] = 1] = "Closed";
      ConnectionErrors2[ConnectionErrors2["Disposed"] = 2] = "Disposed";
      ConnectionErrors2[ConnectionErrors2["AlreadyListening"] = 3] = "AlreadyListening";
    })(ConnectionErrors || (exports2.ConnectionErrors = ConnectionErrors = {}));
    var ConnectionError = class _ConnectionError extends Error {
      constructor(code, message) {
        super(message);
        this.code = code;
        Object.setPrototypeOf(this, _ConnectionError.prototype);
      }
    };
    exports2.ConnectionError = ConnectionError;
    var ConnectionStrategy;
    (function(ConnectionStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && Is2.func(candidate.cancelUndispatched);
      }
      ConnectionStrategy2.is = is;
    })(ConnectionStrategy || (exports2.ConnectionStrategy = ConnectionStrategy = {}));
    var IdCancellationReceiverStrategy;
    (function(IdCancellationReceiverStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && (candidate.kind === void 0 || candidate.kind === "id") && Is2.func(candidate.createCancellationTokenSource) && (candidate.dispose === void 0 || Is2.func(candidate.dispose));
      }
      IdCancellationReceiverStrategy2.is = is;
    })(IdCancellationReceiverStrategy || (exports2.IdCancellationReceiverStrategy = IdCancellationReceiverStrategy = {}));
    var RequestCancellationReceiverStrategy;
    (function(RequestCancellationReceiverStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && candidate.kind === "request" && Is2.func(candidate.createCancellationTokenSource) && (candidate.dispose === void 0 || Is2.func(candidate.dispose));
      }
      RequestCancellationReceiverStrategy2.is = is;
    })(RequestCancellationReceiverStrategy || (exports2.RequestCancellationReceiverStrategy = RequestCancellationReceiverStrategy = {}));
    var CancellationReceiverStrategy;
    (function(CancellationReceiverStrategy2) {
      CancellationReceiverStrategy2.Message = Object.freeze({
        createCancellationTokenSource(_) {
          return new cancellation_1.CancellationTokenSource();
        }
      });
      function is(value) {
        return IdCancellationReceiverStrategy.is(value) || RequestCancellationReceiverStrategy.is(value);
      }
      CancellationReceiverStrategy2.is = is;
    })(CancellationReceiverStrategy || (exports2.CancellationReceiverStrategy = CancellationReceiverStrategy = {}));
    var CancellationSenderStrategy;
    (function(CancellationSenderStrategy2) {
      CancellationSenderStrategy2.Message = Object.freeze({
        sendCancellation(conn, id) {
          return conn.sendNotification(CancelNotification.type, { id });
        },
        cleanup(_) {
        }
      });
      function is(value) {
        const candidate = value;
        return candidate && Is2.func(candidate.sendCancellation) && Is2.func(candidate.cleanup);
      }
      CancellationSenderStrategy2.is = is;
    })(CancellationSenderStrategy || (exports2.CancellationSenderStrategy = CancellationSenderStrategy = {}));
    var CancellationStrategy;
    (function(CancellationStrategy2) {
      CancellationStrategy2.Message = Object.freeze({
        receiver: CancellationReceiverStrategy.Message,
        sender: CancellationSenderStrategy.Message
      });
      function is(value) {
        const candidate = value;
        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
      }
      CancellationStrategy2.is = is;
    })(CancellationStrategy || (exports2.CancellationStrategy = CancellationStrategy = {}));
    var MessageStrategy;
    (function(MessageStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && Is2.func(candidate.handleMessage);
      }
      MessageStrategy2.is = is;
    })(MessageStrategy || (exports2.MessageStrategy = MessageStrategy = {}));
    var ConnectionOptions;
    (function(ConnectionOptions2) {
      function is(value) {
        const candidate = value;
        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy) || MessageStrategy.is(candidate.messageStrategy));
      }
      ConnectionOptions2.is = is;
    })(ConnectionOptions || (exports2.ConnectionOptions = ConnectionOptions = {}));
    var ConnectionState;
    (function(ConnectionState2) {
      ConnectionState2[ConnectionState2["New"] = 1] = "New";
      ConnectionState2[ConnectionState2["Listening"] = 2] = "Listening";
      ConnectionState2[ConnectionState2["Closed"] = 3] = "Closed";
      ConnectionState2[ConnectionState2["Disposed"] = 4] = "Disposed";
    })(ConnectionState || (ConnectionState = {}));
    function createMessageConnection(messageReader2, messageWriter2, _logger, options) {
      const logger = _logger !== void 0 ? _logger : exports2.NullLogger;
      let sequenceNumber = 0;
      let notificationSequenceNumber = 0;
      let unknownResponseSequenceNumber = 0;
      const version = "2.0";
      let starRequestHandler = void 0;
      const requestHandlers = /* @__PURE__ */ new Map();
      let starNotificationHandler = void 0;
      const notificationHandlers = /* @__PURE__ */ new Map();
      const progressHandlers = /* @__PURE__ */ new Map();
      let timer;
      let messageQueue = new linkedMap_1.LinkedMap();
      let responsePromises = /* @__PURE__ */ new Map();
      let knownCanceledRequests = /* @__PURE__ */ new Set();
      let requestTokens = /* @__PURE__ */ new Map();
      let trace = Trace.Off;
      let traceFormat = TraceFormat.Text;
      let tracer;
      let state = ConnectionState.New;
      const errorEmitter = new events_1.Emitter();
      const closeEmitter = new events_1.Emitter();
      const unhandledNotificationEmitter = new events_1.Emitter();
      const unhandledProgressEmitter = new events_1.Emitter();
      const disposeEmitter = new events_1.Emitter();
      const cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy.Message;
      function createRequestQueueKey(id) {
        if (id === null) {
          throw new Error(`Can't send requests with id null since the response can't be correlated.`);
        }
        return "req-" + id.toString();
      }
      function createResponseQueueKey(id) {
        if (id === null) {
          return "res-unknown-" + (++unknownResponseSequenceNumber).toString();
        } else {
          return "res-" + id.toString();
        }
      }
      function createNotificationQueueKey() {
        return "not-" + (++notificationSequenceNumber).toString();
      }
      function addMessageToQueue(queue, message) {
        if (messages_1.Message.isRequest(message)) {
          queue.set(createRequestQueueKey(message.id), message);
        } else if (messages_1.Message.isResponse(message)) {
          queue.set(createResponseQueueKey(message.id), message);
        } else {
          queue.set(createNotificationQueueKey(), message);
        }
      }
      function cancelUndispatched(_message) {
        return void 0;
      }
      function isListening() {
        return state === ConnectionState.Listening;
      }
      function isClosed() {
        return state === ConnectionState.Closed;
      }
      function isDisposed() {
        return state === ConnectionState.Disposed;
      }
      function closeHandler() {
        if (state === ConnectionState.New || state === ConnectionState.Listening) {
          state = ConnectionState.Closed;
          closeEmitter.fire(void 0);
        }
      }
      function readErrorHandler(error) {
        errorEmitter.fire([error, void 0, void 0]);
      }
      function writeErrorHandler(data) {
        errorEmitter.fire(data);
      }
      messageReader2.onClose(closeHandler);
      messageReader2.onError(readErrorHandler);
      messageWriter2.onClose(closeHandler);
      messageWriter2.onError(writeErrorHandler);
      function triggerMessageQueue() {
        if (timer || messageQueue.size === 0) {
          return;
        }
        timer = (0, ral_1.default)().timer.setImmediate(() => {
          timer = void 0;
          processMessageQueue();
        });
      }
      function handleMessage(message) {
        if (messages_1.Message.isRequest(message)) {
          handleRequest(message);
        } else if (messages_1.Message.isNotification(message)) {
          handleNotification(message);
        } else if (messages_1.Message.isResponse(message)) {
          handleResponse(message);
        } else {
          handleInvalidMessage(message);
        }
      }
      function processMessageQueue() {
        if (messageQueue.size === 0) {
          return;
        }
        const message = messageQueue.shift();
        try {
          const messageStrategy = options?.messageStrategy;
          if (MessageStrategy.is(messageStrategy)) {
            messageStrategy.handleMessage(message, handleMessage);
          } else {
            handleMessage(message);
          }
        } finally {
          triggerMessageQueue();
        }
      }
      const callback = (message) => {
        try {
          if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
            const cancelId = message.params.id;
            const key = createRequestQueueKey(cancelId);
            const toCancel = messageQueue.get(key);
            if (messages_1.Message.isRequest(toCancel)) {
              const strategy = options?.connectionStrategy;
              const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
              if (response && (response.error !== void 0 || response.result !== void 0)) {
                messageQueue.delete(key);
                requestTokens.delete(cancelId);
                response.id = toCancel.id;
                traceSendingResponse(response, message.method, Date.now());
                messageWriter2.write(response).catch(() => logger.error(`Sending response for canceled message failed.`));
                return;
              }
            }
            const cancellationToken = requestTokens.get(cancelId);
            if (cancellationToken !== void 0) {
              cancellationToken.cancel();
              traceReceivedNotification(message);
              return;
            } else {
              knownCanceledRequests.add(cancelId);
            }
          }
          addMessageToQueue(messageQueue, message);
        } finally {
          triggerMessageQueue();
        }
      };
      function handleRequest(requestMessage) {
        if (isDisposed()) {
          return;
        }
        function reply(resultOrError, method, startTime2) {
          const message = {
            jsonrpc: version,
            id: requestMessage.id
          };
          if (resultOrError instanceof messages_1.ResponseError) {
            message.error = resultOrError.toJson();
          } else {
            message.result = resultOrError === void 0 ? null : resultOrError;
          }
          traceSendingResponse(message, method, startTime2);
          messageWriter2.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        function replyError(error, method, startTime2) {
          const message = {
            jsonrpc: version,
            id: requestMessage.id,
            error: error.toJson()
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter2.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        function replySuccess(result, method, startTime2) {
          if (result === void 0) {
            result = null;
          }
          const message = {
            jsonrpc: version,
            id: requestMessage.id,
            result
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter2.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        traceReceivedRequest(requestMessage);
        const element = requestHandlers.get(requestMessage.method);
        let type;
        let requestHandler;
        if (element) {
          type = element.type;
          requestHandler = element.handler;
        }
        const startTime = Date.now();
        if (requestHandler || starRequestHandler) {
          const tokenKey = requestMessage.id ?? String(Date.now());
          const cancellationSource = IdCancellationReceiverStrategy.is(cancellationStrategy.receiver) ? cancellationStrategy.receiver.createCancellationTokenSource(tokenKey) : cancellationStrategy.receiver.createCancellationTokenSource(requestMessage);
          if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
            cancellationSource.cancel();
          }
          if (requestMessage.id !== null) {
            requestTokens.set(tokenKey, cancellationSource);
          }
          try {
            let handlerResult;
            if (requestHandler) {
              if (requestMessage.params === void 0) {
                if (type !== void 0 && type.numberOfParams !== 0) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(cancellationSource.token);
              } else if (Array.isArray(requestMessage.params)) {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byName) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
              } else {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
              }
            } else if (starRequestHandler) {
              handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
            }
            const promise = handlerResult;
            if (!handlerResult) {
              requestTokens.delete(tokenKey);
              replySuccess(handlerResult, requestMessage.method, startTime);
            } else if (promise.then) {
              promise.then((resultOrError) => {
                requestTokens.delete(tokenKey);
                reply(resultOrError, requestMessage.method, startTime);
              }, (error) => {
                requestTokens.delete(tokenKey);
                if (error instanceof messages_1.ResponseError) {
                  replyError(error, requestMessage.method, startTime);
                } else if (error && Is2.string(error.message)) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                } else {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                }
              });
            } else {
              requestTokens.delete(tokenKey);
              reply(handlerResult, requestMessage.method, startTime);
            }
          } catch (error) {
            requestTokens.delete(tokenKey);
            if (error instanceof messages_1.ResponseError) {
              reply(error, requestMessage.method, startTime);
            } else if (error && Is2.string(error.message)) {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
            } else {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
            }
          }
        } else {
          replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
        }
      }
      function handleResponse(responseMessage) {
        if (isDisposed()) {
          return;
        }
        if (responseMessage.id === null) {
          if (responseMessage.error) {
            logger.error(`Received response message without id: Error is: 
${JSON.stringify(responseMessage.error, void 0, 4)}`);
          } else {
            logger.error(`Received response message without id. No further error information provided.`);
          }
        } else {
          const key = responseMessage.id;
          const responsePromise = responsePromises.get(key);
          traceReceivedResponse(responseMessage, responsePromise);
          if (responsePromise !== void 0) {
            responsePromises.delete(key);
            try {
              if (responseMessage.error) {
                const error = responseMessage.error;
                responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
              } else if (responseMessage.result !== void 0) {
                responsePromise.resolve(responseMessage.result);
              } else {
                throw new Error("Should never happen.");
              }
            } catch (error) {
              if (error.message) {
                logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
              } else {
                logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
              }
            }
          }
        }
      }
      function handleNotification(message) {
        if (isDisposed()) {
          return;
        }
        let type = void 0;
        let notificationHandler;
        if (message.method === CancelNotification.type.method) {
          const cancelId = message.params.id;
          knownCanceledRequests.delete(cancelId);
          traceReceivedNotification(message);
          return;
        } else {
          const element = notificationHandlers.get(message.method);
          if (element) {
            notificationHandler = element.handler;
            type = element.type;
          }
        }
        if (notificationHandler || starNotificationHandler) {
          try {
            traceReceivedNotification(message);
            if (notificationHandler) {
              if (message.params === void 0) {
                if (type !== void 0) {
                  if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                    logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                  }
                }
                notificationHandler();
              } else if (Array.isArray(message.params)) {
                const params = message.params;
                if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {
                  notificationHandler({ token: params[0], value: params[1] });
                } else {
                  if (type !== void 0) {
                    if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                      logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                    }
                    if (type.numberOfParams !== message.params.length) {
                      logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
                    }
                  }
                  notificationHandler(...params);
                }
              } else {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                }
                notificationHandler(message.params);
              }
            } else if (starNotificationHandler) {
              starNotificationHandler(message.method, message.params);
            }
          } catch (error) {
            if (error.message) {
              logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
            } else {
              logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
            }
          }
        } else {
          unhandledNotificationEmitter.fire(message);
        }
      }
      function handleInvalidMessage(message) {
        if (!message) {
          logger.error("Received empty message.");
          return;
        }
        logger.error(`Received message which is neither a response nor a notification message:
${JSON.stringify(message, null, 4)}`);
        const responseMessage = message;
        if (Is2.string(responseMessage.id) || Is2.number(responseMessage.id)) {
          const key = responseMessage.id;
          const responseHandler = responsePromises.get(key);
          if (responseHandler) {
            responseHandler.reject(new Error("The received response has neither a result nor an error property."));
          }
        }
      }
      function stringifyTrace(params) {
        if (params === void 0 || params === null) {
          return void 0;
        }
        switch (trace) {
          case Trace.Verbose:
            return JSON.stringify(params, null, 4);
          case Trace.Compact:
            return JSON.stringify(params);
          default:
            return void 0;
        }
      }
      function traceSendingRequest(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
            data = `Params: ${stringifyTrace(message.params)}

`;
          }
          tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("send-request", message);
        }
      }
      function traceSendingNotification(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Sending notification '${message.method}'.`, data);
        } else {
          logLSPMessage("send-notification", message);
        }
      }
      function traceSendingResponse(message, method, startTime) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.error && message.error.data) {
              data = `Error data: ${stringifyTrace(message.error.data)}

`;
            } else {
              if (message.result) {
                data = `Result: ${stringifyTrace(message.result)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
        } else {
          logLSPMessage("send-response", message);
        }
      }
      function traceReceivedRequest(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
            data = `Params: ${stringifyTrace(message.params)}

`;
          }
          tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("receive-request", message);
        }
      }
      function traceReceivedNotification(message) {
        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Received notification '${message.method}'.`, data);
        } else {
          logLSPMessage("receive-notification", message);
        }
      }
      function traceReceivedResponse(message, responsePromise) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.error && message.error.data) {
              data = `Error data: ${stringifyTrace(message.error.data)}

`;
            } else {
              if (message.result) {
                data = `Result: ${stringifyTrace(message.result)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          if (responsePromise) {
            const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : "";
            tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
          } else {
            tracer.log(`Received response ${message.id} without active response promise.`, data);
          }
        } else {
          logLSPMessage("receive-response", message);
        }
      }
      function logLSPMessage(type, message) {
        if (!tracer || trace === Trace.Off) {
          return;
        }
        const lspMessage = {
          isLSPMessage: true,
          type,
          message,
          timestamp: Date.now()
        };
        tracer.log(lspMessage);
      }
      function throwIfClosedOrDisposed() {
        if (isClosed()) {
          throw new ConnectionError(ConnectionErrors.Closed, "Connection is closed.");
        }
        if (isDisposed()) {
          throw new ConnectionError(ConnectionErrors.Disposed, "Connection is disposed.");
        }
      }
      function throwIfListening() {
        if (isListening()) {
          throw new ConnectionError(ConnectionErrors.AlreadyListening, "Connection is already listening");
        }
      }
      function throwIfNotListening() {
        if (!isListening()) {
          throw new Error("Call listen() first.");
        }
      }
      function undefinedToNull(param) {
        if (param === void 0) {
          return null;
        } else {
          return param;
        }
      }
      function nullToUndefined(param) {
        if (param === null) {
          return void 0;
        } else {
          return param;
        }
      }
      function isNamedParam(param) {
        return param !== void 0 && param !== null && !Array.isArray(param) && typeof param === "object";
      }
      function computeSingleParam(parameterStructures, param) {
        switch (parameterStructures) {
          case messages_1.ParameterStructures.auto:
            if (isNamedParam(param)) {
              return nullToUndefined(param);
            } else {
              return [undefinedToNull(param)];
            }
          case messages_1.ParameterStructures.byName:
            if (!isNamedParam(param)) {
              throw new Error(`Received parameters by name but param is not an object literal.`);
            }
            return nullToUndefined(param);
          case messages_1.ParameterStructures.byPosition:
            return [undefinedToNull(param)];
          default:
            throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
        }
      }
      function computeMessageParams(type, params) {
        let result;
        const numberOfParams = type.numberOfParams;
        switch (numberOfParams) {
          case 0:
            result = void 0;
            break;
          case 1:
            result = computeSingleParam(type.parameterStructures, params[0]);
            break;
          default:
            result = [];
            for (let i = 0; i < params.length && i < numberOfParams; i++) {
              result.push(undefinedToNull(params[i]));
            }
            if (params.length < numberOfParams) {
              for (let i = params.length; i < numberOfParams; i++) {
                result.push(null);
              }
            }
            break;
        }
        return result;
      }
      const connection2 = {
        sendNotification: (type, ...args) => {
          throwIfClosedOrDisposed();
          let method;
          let messageParams;
          if (Is2.string(type)) {
            method = type;
            const first = args[0];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first)) {
              paramStart = 1;
              parameterStructures = first;
            }
            let paramEnd = args.length;
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                break;
            }
          } else {
            const params = args;
            method = type.method;
            messageParams = computeMessageParams(type, params);
          }
          const notificationMessage = {
            jsonrpc: version,
            method,
            params: messageParams
          };
          traceSendingNotification(notificationMessage);
          return messageWriter2.write(notificationMessage).catch((error) => {
            logger.error(`Sending notification failed.`);
            throw error;
          });
        },
        onNotification: (type, handler) => {
          throwIfClosedOrDisposed();
          let method;
          if (Is2.func(type)) {
            starNotificationHandler = type;
          } else if (handler) {
            if (Is2.string(type)) {
              method = type;
              notificationHandlers.set(type, { type: void 0, handler });
            } else {
              method = type.method;
              notificationHandlers.set(type.method, { type, handler });
            }
          }
          return {
            dispose: () => {
              if (method !== void 0) {
                notificationHandlers.delete(method);
              } else {
                starNotificationHandler = void 0;
              }
            }
          };
        },
        onProgress: (_type, token, handler) => {
          if (progressHandlers.has(token)) {
            throw new Error(`Progress handler for token ${token} already registered`);
          }
          progressHandlers.set(token, handler);
          return {
            dispose: () => {
              progressHandlers.delete(token);
            }
          };
        },
        sendProgress: (_type, token, value) => {
          return connection2.sendNotification(ProgressNotification.type, { token, value });
        },
        onUnhandledProgress: unhandledProgressEmitter.event,
        sendRequest: (type, ...args) => {
          throwIfClosedOrDisposed();
          throwIfNotListening();
          let method;
          let messageParams;
          let token = void 0;
          if (Is2.string(type)) {
            method = type;
            const first = args[0];
            const last = args[args.length - 1];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first)) {
              paramStart = 1;
              parameterStructures = first;
            }
            let paramEnd = args.length;
            if (cancellation_1.CancellationToken.is(last)) {
              paramEnd = paramEnd - 1;
              token = last;
            }
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                break;
            }
          } else {
            const params = args;
            method = type.method;
            messageParams = computeMessageParams(type, params);
            const numberOfParams = type.numberOfParams;
            token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : void 0;
          }
          const id = sequenceNumber++;
          let disposable;
          if (token) {
            disposable = token.onCancellationRequested(() => {
              const p = cancellationStrategy.sender.sendCancellation(connection2, id);
              if (p === void 0) {
                logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
                return Promise.resolve();
              } else {
                return p.catch(() => {
                  logger.log(`Sending cancellation messages for id ${id} failed`);
                });
              }
            });
          }
          const requestMessage = {
            jsonrpc: version,
            id,
            method,
            params: messageParams
          };
          traceSendingRequest(requestMessage);
          if (typeof cancellationStrategy.sender.enableCancellation === "function") {
            cancellationStrategy.sender.enableCancellation(requestMessage);
          }
          return new Promise(async (resolve, reject) => {
            const resolveWithCleanup = (r) => {
              resolve(r);
              cancellationStrategy.sender.cleanup(id);
              disposable?.dispose();
            };
            const rejectWithCleanup = (r) => {
              reject(r);
              cancellationStrategy.sender.cleanup(id);
              disposable?.dispose();
            };
            const responsePromise = { method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
            try {
              await messageWriter2.write(requestMessage);
              responsePromises.set(id, responsePromise);
            } catch (error) {
              logger.error(`Sending request failed.`);
              responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, error.message ? error.message : "Unknown reason"));
              throw error;
            }
          });
        },
        onRequest: (type, handler) => {
          throwIfClosedOrDisposed();
          let method = null;
          if (StarRequestHandler.is(type)) {
            method = void 0;
            starRequestHandler = type;
          } else if (Is2.string(type)) {
            method = null;
            if (handler !== void 0) {
              method = type;
              requestHandlers.set(type, { handler, type: void 0 });
            }
          } else {
            if (handler !== void 0) {
              method = type.method;
              requestHandlers.set(type.method, { type, handler });
            }
          }
          return {
            dispose: () => {
              if (method === null) {
                return;
              }
              if (method !== void 0) {
                requestHandlers.delete(method);
              } else {
                starRequestHandler = void 0;
              }
            }
          };
        },
        hasPendingResponse: () => {
          return responsePromises.size > 0;
        },
        trace: async (_value, _tracer, sendNotificationOrTraceOptions) => {
          let _sendNotification = false;
          let _traceFormat = TraceFormat.Text;
          if (sendNotificationOrTraceOptions !== void 0) {
            if (Is2.boolean(sendNotificationOrTraceOptions)) {
              _sendNotification = sendNotificationOrTraceOptions;
            } else {
              _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
              _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
            }
          }
          trace = _value;
          traceFormat = _traceFormat;
          if (trace === Trace.Off) {
            tracer = void 0;
          } else {
            tracer = _tracer;
          }
          if (_sendNotification && !isClosed() && !isDisposed()) {
            await connection2.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
          }
        },
        onError: errorEmitter.event,
        onClose: closeEmitter.event,
        onUnhandledNotification: unhandledNotificationEmitter.event,
        onDispose: disposeEmitter.event,
        end: () => {
          messageWriter2.end();
        },
        dispose: () => {
          if (isDisposed()) {
            return;
          }
          state = ConnectionState.Disposed;
          disposeEmitter.fire(void 0);
          const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, "Pending response rejected since connection got disposed");
          for (const promise of responsePromises.values()) {
            promise.reject(error);
          }
          responsePromises = /* @__PURE__ */ new Map();
          requestTokens = /* @__PURE__ */ new Map();
          knownCanceledRequests = /* @__PURE__ */ new Set();
          messageQueue = new linkedMap_1.LinkedMap();
          if (Is2.func(messageWriter2.dispose)) {
            messageWriter2.dispose();
          }
          if (Is2.func(messageReader2.dispose)) {
            messageReader2.dispose();
          }
        },
        listen: () => {
          throwIfClosedOrDisposed();
          throwIfListening();
          state = ConnectionState.Listening;
          messageReader2.listen(callback);
        },
        inspect: () => {
          (0, ral_1.default)().console.log("inspect");
        }
      };
      connection2.onNotification(LogTraceNotification.type, (params) => {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        const verbose = trace === Trace.Verbose || trace === Trace.Compact;
        tracer.log(params.message, verbose ? params.verbose : void 0);
      });
      connection2.onNotification(ProgressNotification.type, (params) => {
        const handler = progressHandlers.get(params.token);
        if (handler) {
          handler(params.value);
        } else {
          unhandledProgressEmitter.fire(params);
        }
      });
      return connection2;
    }
    exports2.createMessageConnection = createMessageConnection;
  }
});

// node_modules/vscode-jsonrpc/lib/common/api.js
var require_api = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/api.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProgressType = exports2.ProgressToken = exports2.createMessageConnection = exports2.NullLogger = exports2.ConnectionOptions = exports2.ConnectionStrategy = exports2.AbstractMessageBuffer = exports2.WriteableStreamMessageWriter = exports2.AbstractMessageWriter = exports2.MessageWriter = exports2.ReadableStreamMessageReader = exports2.AbstractMessageReader = exports2.MessageReader = exports2.SharedArrayReceiverStrategy = exports2.SharedArraySenderStrategy = exports2.CancellationToken = exports2.CancellationTokenSource = exports2.Emitter = exports2.Event = exports2.Disposable = exports2.LRUCache = exports2.Touch = exports2.LinkedMap = exports2.ParameterStructures = exports2.NotificationType9 = exports2.NotificationType8 = exports2.NotificationType7 = exports2.NotificationType6 = exports2.NotificationType5 = exports2.NotificationType4 = exports2.NotificationType3 = exports2.NotificationType2 = exports2.NotificationType1 = exports2.NotificationType0 = exports2.NotificationType = exports2.ErrorCodes = exports2.ResponseError = exports2.RequestType9 = exports2.RequestType8 = exports2.RequestType7 = exports2.RequestType6 = exports2.RequestType5 = exports2.RequestType4 = exports2.RequestType3 = exports2.RequestType2 = exports2.RequestType1 = exports2.RequestType0 = exports2.RequestType = exports2.Message = exports2.RAL = void 0;
    exports2.MessageStrategy = exports2.CancellationStrategy = exports2.CancellationSenderStrategy = exports2.CancellationReceiverStrategy = exports2.ConnectionError = exports2.ConnectionErrors = exports2.LogTraceNotification = exports2.SetTraceNotification = exports2.TraceFormat = exports2.TraceValues = exports2.Trace = void 0;
    var messages_1 = require_messages();
    Object.defineProperty(exports2, "Message", { enumerable: true, get: function() {
      return messages_1.Message;
    } });
    Object.defineProperty(exports2, "RequestType", { enumerable: true, get: function() {
      return messages_1.RequestType;
    } });
    Object.defineProperty(exports2, "RequestType0", { enumerable: true, get: function() {
      return messages_1.RequestType0;
    } });
    Object.defineProperty(exports2, "RequestType1", { enumerable: true, get: function() {
      return messages_1.RequestType1;
    } });
    Object.defineProperty(exports2, "RequestType2", { enumerable: true, get: function() {
      return messages_1.RequestType2;
    } });
    Object.defineProperty(exports2, "RequestType3", { enumerable: true, get: function() {
      return messages_1.RequestType3;
    } });
    Object.defineProperty(exports2, "RequestType4", { enumerable: true, get: function() {
      return messages_1.RequestType4;
    } });
    Object.defineProperty(exports2, "RequestType5", { enumerable: true, get: function() {
      return messages_1.RequestType5;
    } });
    Object.defineProperty(exports2, "RequestType6", { enumerable: true, get: function() {
      return messages_1.RequestType6;
    } });
    Object.defineProperty(exports2, "RequestType7", { enumerable: true, get: function() {
      return messages_1.RequestType7;
    } });
    Object.defineProperty(exports2, "RequestType8", { enumerable: true, get: function() {
      return messages_1.RequestType8;
    } });
    Object.defineProperty(exports2, "RequestType9", { enumerable: true, get: function() {
      return messages_1.RequestType9;
    } });
    Object.defineProperty(exports2, "ResponseError", { enumerable: true, get: function() {
      return messages_1.ResponseError;
    } });
    Object.defineProperty(exports2, "ErrorCodes", { enumerable: true, get: function() {
      return messages_1.ErrorCodes;
    } });
    Object.defineProperty(exports2, "NotificationType", { enumerable: true, get: function() {
      return messages_1.NotificationType;
    } });
    Object.defineProperty(exports2, "NotificationType0", { enumerable: true, get: function() {
      return messages_1.NotificationType0;
    } });
    Object.defineProperty(exports2, "NotificationType1", { enumerable: true, get: function() {
      return messages_1.NotificationType1;
    } });
    Object.defineProperty(exports2, "NotificationType2", { enumerable: true, get: function() {
      return messages_1.NotificationType2;
    } });
    Object.defineProperty(exports2, "NotificationType3", { enumerable: true, get: function() {
      return messages_1.NotificationType3;
    } });
    Object.defineProperty(exports2, "NotificationType4", { enumerable: true, get: function() {
      return messages_1.NotificationType4;
    } });
    Object.defineProperty(exports2, "NotificationType5", { enumerable: true, get: function() {
      return messages_1.NotificationType5;
    } });
    Object.defineProperty(exports2, "NotificationType6", { enumerable: true, get: function() {
      return messages_1.NotificationType6;
    } });
    Object.defineProperty(exports2, "NotificationType7", { enumerable: true, get: function() {
      return messages_1.NotificationType7;
    } });
    Object.defineProperty(exports2, "NotificationType8", { enumerable: true, get: function() {
      return messages_1.NotificationType8;
    } });
    Object.defineProperty(exports2, "NotificationType9", { enumerable: true, get: function() {
      return messages_1.NotificationType9;
    } });
    Object.defineProperty(exports2, "ParameterStructures", { enumerable: true, get: function() {
      return messages_1.ParameterStructures;
    } });
    var linkedMap_1 = require_linkedMap();
    Object.defineProperty(exports2, "LinkedMap", { enumerable: true, get: function() {
      return linkedMap_1.LinkedMap;
    } });
    Object.defineProperty(exports2, "LRUCache", { enumerable: true, get: function() {
      return linkedMap_1.LRUCache;
    } });
    Object.defineProperty(exports2, "Touch", { enumerable: true, get: function() {
      return linkedMap_1.Touch;
    } });
    var disposable_1 = require_disposable();
    Object.defineProperty(exports2, "Disposable", { enumerable: true, get: function() {
      return disposable_1.Disposable;
    } });
    var events_1 = require_events();
    Object.defineProperty(exports2, "Event", { enumerable: true, get: function() {
      return events_1.Event;
    } });
    Object.defineProperty(exports2, "Emitter", { enumerable: true, get: function() {
      return events_1.Emitter;
    } });
    var cancellation_1 = require_cancellation();
    Object.defineProperty(exports2, "CancellationTokenSource", { enumerable: true, get: function() {
      return cancellation_1.CancellationTokenSource;
    } });
    Object.defineProperty(exports2, "CancellationToken", { enumerable: true, get: function() {
      return cancellation_1.CancellationToken;
    } });
    var sharedArrayCancellation_1 = require_sharedArrayCancellation();
    Object.defineProperty(exports2, "SharedArraySenderStrategy", { enumerable: true, get: function() {
      return sharedArrayCancellation_1.SharedArraySenderStrategy;
    } });
    Object.defineProperty(exports2, "SharedArrayReceiverStrategy", { enumerable: true, get: function() {
      return sharedArrayCancellation_1.SharedArrayReceiverStrategy;
    } });
    var messageReader_1 = require_messageReader();
    Object.defineProperty(exports2, "MessageReader", { enumerable: true, get: function() {
      return messageReader_1.MessageReader;
    } });
    Object.defineProperty(exports2, "AbstractMessageReader", { enumerable: true, get: function() {
      return messageReader_1.AbstractMessageReader;
    } });
    Object.defineProperty(exports2, "ReadableStreamMessageReader", { enumerable: true, get: function() {
      return messageReader_1.ReadableStreamMessageReader;
    } });
    var messageWriter_1 = require_messageWriter();
    Object.defineProperty(exports2, "MessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.MessageWriter;
    } });
    Object.defineProperty(exports2, "AbstractMessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.AbstractMessageWriter;
    } });
    Object.defineProperty(exports2, "WriteableStreamMessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.WriteableStreamMessageWriter;
    } });
    var messageBuffer_1 = require_messageBuffer();
    Object.defineProperty(exports2, "AbstractMessageBuffer", { enumerable: true, get: function() {
      return messageBuffer_1.AbstractMessageBuffer;
    } });
    var connection_1 = require_connection();
    Object.defineProperty(exports2, "ConnectionStrategy", { enumerable: true, get: function() {
      return connection_1.ConnectionStrategy;
    } });
    Object.defineProperty(exports2, "ConnectionOptions", { enumerable: true, get: function() {
      return connection_1.ConnectionOptions;
    } });
    Object.defineProperty(exports2, "NullLogger", { enumerable: true, get: function() {
      return connection_1.NullLogger;
    } });
    Object.defineProperty(exports2, "createMessageConnection", { enumerable: true, get: function() {
      return connection_1.createMessageConnection;
    } });
    Object.defineProperty(exports2, "ProgressToken", { enumerable: true, get: function() {
      return connection_1.ProgressToken;
    } });
    Object.defineProperty(exports2, "ProgressType", { enumerable: true, get: function() {
      return connection_1.ProgressType;
    } });
    Object.defineProperty(exports2, "Trace", { enumerable: true, get: function() {
      return connection_1.Trace;
    } });
    Object.defineProperty(exports2, "TraceValues", { enumerable: true, get: function() {
      return connection_1.TraceValues;
    } });
    Object.defineProperty(exports2, "TraceFormat", { enumerable: true, get: function() {
      return connection_1.TraceFormat;
    } });
    Object.defineProperty(exports2, "SetTraceNotification", { enumerable: true, get: function() {
      return connection_1.SetTraceNotification;
    } });
    Object.defineProperty(exports2, "LogTraceNotification", { enumerable: true, get: function() {
      return connection_1.LogTraceNotification;
    } });
    Object.defineProperty(exports2, "ConnectionErrors", { enumerable: true, get: function() {
      return connection_1.ConnectionErrors;
    } });
    Object.defineProperty(exports2, "ConnectionError", { enumerable: true, get: function() {
      return connection_1.ConnectionError;
    } });
    Object.defineProperty(exports2, "CancellationReceiverStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationReceiverStrategy;
    } });
    Object.defineProperty(exports2, "CancellationSenderStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationSenderStrategy;
    } });
    Object.defineProperty(exports2, "CancellationStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationStrategy;
    } });
    Object.defineProperty(exports2, "MessageStrategy", { enumerable: true, get: function() {
      return connection_1.MessageStrategy;
    } });
    var ral_1 = require_ral();
    exports2.RAL = ral_1.default;
  }
});

// node_modules/vscode-jsonrpc/lib/browser/ril.js
var require_ril = __commonJS({
  "node_modules/vscode-jsonrpc/lib/browser/ril.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var api_1 = require_api();
    var MessageBuffer = class _MessageBuffer extends api_1.AbstractMessageBuffer {
      constructor(encoding = "utf-8") {
        super(encoding);
        this.asciiDecoder = new TextDecoder("ascii");
      }
      emptyBuffer() {
        return _MessageBuffer.emptyBuffer;
      }
      fromString(value, _encoding) {
        return new TextEncoder().encode(value);
      }
      toString(value, encoding) {
        if (encoding === "ascii") {
          return this.asciiDecoder.decode(value);
        } else {
          return new TextDecoder(encoding).decode(value);
        }
      }
      asNative(buffer, length) {
        if (length === void 0) {
          return buffer;
        } else {
          return buffer.slice(0, length);
        }
      }
      allocNative(length) {
        return new Uint8Array(length);
      }
    };
    MessageBuffer.emptyBuffer = new Uint8Array(0);
    var ReadableStreamWrapper = class {
      constructor(socket) {
        this.socket = socket;
        this._onData = new api_1.Emitter();
        this._messageListener = (event) => {
          const blob = event.data;
          blob.arrayBuffer().then((buffer) => {
            this._onData.fire(new Uint8Array(buffer));
          }, () => {
            (0, api_1.RAL)().console.error(`Converting blob to array buffer failed.`);
          });
        };
        this.socket.addEventListener("message", this._messageListener);
      }
      onClose(listener) {
        this.socket.addEventListener("close", listener);
        return api_1.Disposable.create(() => this.socket.removeEventListener("close", listener));
      }
      onError(listener) {
        this.socket.addEventListener("error", listener);
        return api_1.Disposable.create(() => this.socket.removeEventListener("error", listener));
      }
      onEnd(listener) {
        this.socket.addEventListener("end", listener);
        return api_1.Disposable.create(() => this.socket.removeEventListener("end", listener));
      }
      onData(listener) {
        return this._onData.event(listener);
      }
    };
    var WritableStreamWrapper = class {
      constructor(socket) {
        this.socket = socket;
      }
      onClose(listener) {
        this.socket.addEventListener("close", listener);
        return api_1.Disposable.create(() => this.socket.removeEventListener("close", listener));
      }
      onError(listener) {
        this.socket.addEventListener("error", listener);
        return api_1.Disposable.create(() => this.socket.removeEventListener("error", listener));
      }
      onEnd(listener) {
        this.socket.addEventListener("end", listener);
        return api_1.Disposable.create(() => this.socket.removeEventListener("end", listener));
      }
      write(data, encoding) {
        if (typeof data === "string") {
          if (encoding !== void 0 && encoding !== "utf-8") {
            throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${encoding}`);
          }
          this.socket.send(data);
        } else {
          this.socket.send(data);
        }
        return Promise.resolve();
      }
      end() {
        this.socket.close();
      }
    };
    var _textEncoder = new TextEncoder();
    var _ril = Object.freeze({
      messageBuffer: Object.freeze({
        create: (encoding) => new MessageBuffer(encoding)
      }),
      applicationJson: Object.freeze({
        encoder: Object.freeze({
          name: "application/json",
          encode: (msg, options) => {
            if (options.charset !== "utf-8") {
              throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${options.charset}`);
            }
            return Promise.resolve(_textEncoder.encode(JSON.stringify(msg, void 0, 0)));
          }
        }),
        decoder: Object.freeze({
          name: "application/json",
          decode: (buffer, options) => {
            if (!(buffer instanceof Uint8Array)) {
              throw new Error(`In a Browser environments only Uint8Arrays are supported.`);
            }
            return Promise.resolve(JSON.parse(new TextDecoder(options.charset).decode(buffer)));
          }
        })
      }),
      stream: Object.freeze({
        asReadableStream: (socket) => new ReadableStreamWrapper(socket),
        asWritableStream: (socket) => new WritableStreamWrapper(socket)
      }),
      console,
      timer: Object.freeze({
        setTimeout(callback, ms, ...args) {
          const handle = setTimeout(callback, ms, ...args);
          return { dispose: () => clearTimeout(handle) };
        },
        setImmediate(callback, ...args) {
          const handle = setTimeout(callback, 0, ...args);
          return { dispose: () => clearTimeout(handle) };
        },
        setInterval(callback, ms, ...args) {
          const handle = setInterval(callback, ms, ...args);
          return { dispose: () => clearInterval(handle) };
        }
      })
    });
    function RIL() {
      return _ril;
    }
    (function(RIL2) {
      function install() {
        api_1.RAL.install(_ril);
      }
      RIL2.install = install;
    })(RIL || (RIL = {}));
    exports2.default = RIL;
  }
});

// node_modules/vscode-jsonrpc/lib/browser/main.js
var require_main = __commonJS({
  "node_modules/vscode-jsonrpc/lib/browser/main.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMessageConnection = exports2.BrowserMessageWriter = exports2.BrowserMessageReader = void 0;
    var ril_1 = require_ril();
    ril_1.default.install();
    var api_1 = require_api();
    __exportStar(require_api(), exports2);
    var BrowserMessageReader2 = class extends api_1.AbstractMessageReader {
      constructor(port) {
        super();
        this._onData = new api_1.Emitter();
        this._messageListener = (event) => {
          this._onData.fire(event.data);
        };
        port.addEventListener("error", (event) => this.fireError(event));
        port.onmessage = this._messageListener;
      }
      listen(callback) {
        return this._onData.event(callback);
      }
    };
    exports2.BrowserMessageReader = BrowserMessageReader2;
    var BrowserMessageWriter2 = class extends api_1.AbstractMessageWriter {
      constructor(port) {
        super();
        this.port = port;
        this.errorCount = 0;
        port.addEventListener("error", (event) => this.fireError(event));
      }
      write(msg) {
        try {
          this.port.postMessage(msg);
          return Promise.resolve();
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
      }
    };
    exports2.BrowserMessageWriter = BrowserMessageWriter2;
    function createMessageConnection(reader, writer, logger, options) {
      if (logger === void 0) {
        logger = api_1.NullLogger;
      }
      if (api_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
      }
      return (0, api_1.createMessageConnection)(reader, writer, logger, options);
    }
    exports2.createMessageConnection = createMessageConnection;
  }
});

// node_modules/vscode-jsonrpc/browser.js
var require_browser = __commonJS({
  "node_modules/vscode-jsonrpc/browser.js"(exports2, module2) {
    "use strict";
    module2.exports = require_main();
  }
});

// node_modules/vscode-languageserver-types/lib/esm/main.js
var main_exports = {};
__export(main_exports, {
  AnnotatedTextEdit: () => AnnotatedTextEdit,
  ChangeAnnotation: () => ChangeAnnotation,
  ChangeAnnotationIdentifier: () => ChangeAnnotationIdentifier,
  CodeAction: () => CodeAction,
  CodeActionContext: () => CodeActionContext,
  CodeActionKind: () => CodeActionKind,
  CodeActionTriggerKind: () => CodeActionTriggerKind,
  CodeDescription: () => CodeDescription,
  CodeLens: () => CodeLens,
  Color: () => Color,
  ColorInformation: () => ColorInformation,
  ColorPresentation: () => ColorPresentation,
  Command: () => Command,
  CompletionItem: () => CompletionItem,
  CompletionItemKind: () => CompletionItemKind,
  CompletionItemLabelDetails: () => CompletionItemLabelDetails,
  CompletionItemTag: () => CompletionItemTag,
  CompletionList: () => CompletionList,
  CreateFile: () => CreateFile,
  DeleteFile: () => DeleteFile,
  Diagnostic: () => Diagnostic,
  DiagnosticRelatedInformation: () => DiagnosticRelatedInformation,
  DiagnosticSeverity: () => DiagnosticSeverity,
  DiagnosticTag: () => DiagnosticTag,
  DocumentHighlight: () => DocumentHighlight,
  DocumentHighlightKind: () => DocumentHighlightKind,
  DocumentLink: () => DocumentLink,
  DocumentSymbol: () => DocumentSymbol,
  DocumentUri: () => DocumentUri,
  EOL: () => EOL,
  FoldingRange: () => FoldingRange,
  FoldingRangeKind: () => FoldingRangeKind,
  FormattingOptions: () => FormattingOptions,
  Hover: () => Hover,
  InlayHint: () => InlayHint,
  InlayHintKind: () => InlayHintKind,
  InlayHintLabelPart: () => InlayHintLabelPart,
  InlineCompletionContext: () => InlineCompletionContext,
  InlineCompletionItem: () => InlineCompletionItem,
  InlineCompletionList: () => InlineCompletionList,
  InlineCompletionTriggerKind: () => InlineCompletionTriggerKind,
  InlineValueContext: () => InlineValueContext,
  InlineValueEvaluatableExpression: () => InlineValueEvaluatableExpression,
  InlineValueText: () => InlineValueText,
  InlineValueVariableLookup: () => InlineValueVariableLookup,
  InsertReplaceEdit: () => InsertReplaceEdit,
  InsertTextFormat: () => InsertTextFormat,
  InsertTextMode: () => InsertTextMode,
  Location: () => Location,
  LocationLink: () => LocationLink,
  MarkedString: () => MarkedString,
  MarkupContent: () => MarkupContent,
  MarkupKind: () => MarkupKind,
  OptionalVersionedTextDocumentIdentifier: () => OptionalVersionedTextDocumentIdentifier,
  ParameterInformation: () => ParameterInformation,
  Position: () => Position,
  Range: () => Range,
  RenameFile: () => RenameFile,
  SelectedCompletionInfo: () => SelectedCompletionInfo,
  SelectionRange: () => SelectionRange,
  SemanticTokenModifiers: () => SemanticTokenModifiers,
  SemanticTokenTypes: () => SemanticTokenTypes,
  SemanticTokens: () => SemanticTokens,
  SignatureInformation: () => SignatureInformation,
  StringValue: () => StringValue,
  SymbolInformation: () => SymbolInformation,
  SymbolKind: () => SymbolKind,
  SymbolTag: () => SymbolTag,
  TextDocument: () => TextDocument,
  TextDocumentEdit: () => TextDocumentEdit,
  TextDocumentIdentifier: () => TextDocumentIdentifier,
  TextDocumentItem: () => TextDocumentItem,
  TextEdit: () => TextEdit,
  URI: () => URI,
  VersionedTextDocumentIdentifier: () => VersionedTextDocumentIdentifier,
  WorkspaceChange: () => WorkspaceChange,
  WorkspaceEdit: () => WorkspaceEdit,
  WorkspaceFolder: () => WorkspaceFolder,
  WorkspaceSymbol: () => WorkspaceSymbol,
  integer: () => integer,
  uinteger: () => uinteger
});
var DocumentUri, URI, integer, uinteger, Position, Range, Location, LocationLink, Color, ColorInformation, ColorPresentation, FoldingRangeKind, FoldingRange, DiagnosticRelatedInformation, DiagnosticSeverity, DiagnosticTag, CodeDescription, Diagnostic, Command, TextEdit, ChangeAnnotation, ChangeAnnotationIdentifier, AnnotatedTextEdit, TextDocumentEdit, CreateFile, RenameFile, DeleteFile, WorkspaceEdit, TextEditChangeImpl, ChangeAnnotations, WorkspaceChange, TextDocumentIdentifier, VersionedTextDocumentIdentifier, OptionalVersionedTextDocumentIdentifier, TextDocumentItem, MarkupKind, MarkupContent, CompletionItemKind, InsertTextFormat, CompletionItemTag, InsertReplaceEdit, InsertTextMode, CompletionItemLabelDetails, CompletionItem, CompletionList, MarkedString, Hover, ParameterInformation, SignatureInformation, DocumentHighlightKind, DocumentHighlight, SymbolKind, SymbolTag, SymbolInformation, WorkspaceSymbol, DocumentSymbol, CodeActionKind, CodeActionTriggerKind, CodeActionContext, CodeAction, CodeLens, FormattingOptions, DocumentLink, SelectionRange, SemanticTokenTypes, SemanticTokenModifiers, SemanticTokens, InlineValueText, InlineValueVariableLookup, InlineValueEvaluatableExpression, InlineValueContext, InlayHintKind, InlayHintLabelPart, InlayHint, StringValue, InlineCompletionItem, InlineCompletionList, InlineCompletionTriggerKind, SelectedCompletionInfo, InlineCompletionContext, WorkspaceFolder, EOL, TextDocument, FullTextDocument, Is;
var init_main = __esm({
  "node_modules/vscode-languageserver-types/lib/esm/main.js"() {
    "use strict";
    (function(DocumentUri2) {
      function is(value) {
        return typeof value === "string";
      }
      DocumentUri2.is = is;
    })(DocumentUri || (DocumentUri = {}));
    (function(URI2) {
      function is(value) {
        return typeof value === "string";
      }
      URI2.is = is;
    })(URI || (URI = {}));
    (function(integer2) {
      integer2.MIN_VALUE = -2147483648;
      integer2.MAX_VALUE = 2147483647;
      function is(value) {
        return typeof value === "number" && integer2.MIN_VALUE <= value && value <= integer2.MAX_VALUE;
      }
      integer2.is = is;
    })(integer || (integer = {}));
    (function(uinteger2) {
      uinteger2.MIN_VALUE = 0;
      uinteger2.MAX_VALUE = 2147483647;
      function is(value) {
        return typeof value === "number" && uinteger2.MIN_VALUE <= value && value <= uinteger2.MAX_VALUE;
      }
      uinteger2.is = is;
    })(uinteger || (uinteger = {}));
    (function(Position2) {
      function create(line, character) {
        if (line === Number.MAX_VALUE) {
          line = uinteger.MAX_VALUE;
        }
        if (character === Number.MAX_VALUE) {
          character = uinteger.MAX_VALUE;
        }
        return { line, character };
      }
      Position2.create = create;
      function is(value) {
        let candidate = value;
        return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
      }
      Position2.is = is;
    })(Position || (Position = {}));
    (function(Range2) {
      function create(one, two, three, four) {
        if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
          return { start: Position.create(one, two), end: Position.create(three, four) };
        } else if (Position.is(one) && Position.is(two)) {
          return { start: one, end: two };
        } else {
          throw new Error(`Range#create called with invalid arguments[${one}, ${two}, ${three}, ${four}]`);
        }
      }
      Range2.create = create;
      function is(value) {
        let candidate = value;
        return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
      }
      Range2.is = is;
    })(Range || (Range = {}));
    (function(Location2) {
      function create(uri, range) {
        return { uri, range };
      }
      Location2.create = create;
      function is(value) {
        let candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
      }
      Location2.is = is;
    })(Location || (Location = {}));
    (function(LocationLink2) {
      function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
        return { targetUri, targetRange, targetSelectionRange, originSelectionRange };
      }
      LocationLink2.create = create;
      function is(value) {
        let candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri) && Range.is(candidate.targetSelectionRange) && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
      }
      LocationLink2.is = is;
    })(LocationLink || (LocationLink = {}));
    (function(Color2) {
      function create(red, green, blue, alpha) {
        return {
          red,
          green,
          blue,
          alpha
        };
      }
      Color2.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);
      }
      Color2.is = is;
    })(Color || (Color = {}));
    (function(ColorInformation2) {
      function create(range, color) {
        return {
          range,
          color
        };
      }
      ColorInformation2.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);
      }
      ColorInformation2.is = is;
    })(ColorInformation || (ColorInformation = {}));
    (function(ColorPresentation2) {
      function create(label, textEdit, additionalTextEdits) {
        return {
          label,
          textEdit,
          additionalTextEdits
        };
      }
      ColorPresentation2.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
      }
      ColorPresentation2.is = is;
    })(ColorPresentation || (ColorPresentation = {}));
    (function(FoldingRangeKind2) {
      FoldingRangeKind2.Comment = "comment";
      FoldingRangeKind2.Imports = "imports";
      FoldingRangeKind2.Region = "region";
    })(FoldingRangeKind || (FoldingRangeKind = {}));
    (function(FoldingRange2) {
      function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
        const result = {
          startLine,
          endLine
        };
        if (Is.defined(startCharacter)) {
          result.startCharacter = startCharacter;
        }
        if (Is.defined(endCharacter)) {
          result.endCharacter = endCharacter;
        }
        if (Is.defined(kind)) {
          result.kind = kind;
        }
        if (Is.defined(collapsedText)) {
          result.collapsedText = collapsedText;
        }
        return result;
      }
      FoldingRange2.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
      }
      FoldingRange2.is = is;
    })(FoldingRange || (FoldingRange = {}));
    (function(DiagnosticRelatedInformation2) {
      function create(location, message) {
        return {
          location,
          message
        };
      }
      DiagnosticRelatedInformation2.create = create;
      function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
      }
      DiagnosticRelatedInformation2.is = is;
    })(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
    (function(DiagnosticSeverity3) {
      DiagnosticSeverity3.Error = 1;
      DiagnosticSeverity3.Warning = 2;
      DiagnosticSeverity3.Information = 3;
      DiagnosticSeverity3.Hint = 4;
    })(DiagnosticSeverity || (DiagnosticSeverity = {}));
    (function(DiagnosticTag2) {
      DiagnosticTag2.Unnecessary = 1;
      DiagnosticTag2.Deprecated = 2;
    })(DiagnosticTag || (DiagnosticTag = {}));
    (function(CodeDescription2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.href);
      }
      CodeDescription2.is = is;
    })(CodeDescription || (CodeDescription = {}));
    (function(Diagnostic3) {
      function create(range, message, severity, code, source, relatedInformation) {
        let result = { range, message };
        if (Is.defined(severity)) {
          result.severity = severity;
        }
        if (Is.defined(code)) {
          result.code = code;
        }
        if (Is.defined(source)) {
          result.source = source;
        }
        if (Is.defined(relatedInformation)) {
          result.relatedInformation = relatedInformation;
        }
        return result;
      }
      Diagnostic3.create = create;
      function is(value) {
        var _a;
        let candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
      }
      Diagnostic3.is = is;
    })(Diagnostic || (Diagnostic = {}));
    (function(Command2) {
      function create(title, command, ...args) {
        let result = { title, command };
        if (Is.defined(args) && args.length > 0) {
          result.arguments = args;
        }
        return result;
      }
      Command2.create = create;
      function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
      }
      Command2.is = is;
    })(Command || (Command = {}));
    (function(TextEdit2) {
      function replace(range, newText) {
        return { range, newText };
      }
      TextEdit2.replace = replace;
      function insert(position, newText) {
        return { range: { start: position, end: position }, newText };
      }
      TextEdit2.insert = insert;
      function del(range) {
        return { range, newText: "" };
      }
      TextEdit2.del = del;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range.is(candidate.range);
      }
      TextEdit2.is = is;
    })(TextEdit || (TextEdit = {}));
    (function(ChangeAnnotation2) {
      function create(label, needsConfirmation, description) {
        const result = { label };
        if (needsConfirmation !== void 0) {
          result.needsConfirmation = needsConfirmation;
        }
        if (description !== void 0) {
          result.description = description;
        }
        return result;
      }
      ChangeAnnotation2.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
      }
      ChangeAnnotation2.is = is;
    })(ChangeAnnotation || (ChangeAnnotation = {}));
    (function(ChangeAnnotationIdentifier2) {
      function is(value) {
        const candidate = value;
        return Is.string(candidate);
      }
      ChangeAnnotationIdentifier2.is = is;
    })(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));
    (function(AnnotatedTextEdit2) {
      function replace(range, newText, annotation) {
        return { range, newText, annotationId: annotation };
      }
      AnnotatedTextEdit2.replace = replace;
      function insert(position, newText, annotation) {
        return { range: { start: position, end: position }, newText, annotationId: annotation };
      }
      AnnotatedTextEdit2.insert = insert;
      function del(range, annotation) {
        return { range, newText: "", annotationId: annotation };
      }
      AnnotatedTextEdit2.del = del;
      function is(value) {
        const candidate = value;
        return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
      }
      AnnotatedTextEdit2.is = is;
    })(AnnotatedTextEdit || (AnnotatedTextEdit = {}));
    (function(TextDocumentEdit2) {
      function create(textDocument, edits) {
        return { textDocument, edits };
      }
      TextDocumentEdit2.create = create;
      function is(value) {
        let candidate = value;
        return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
      }
      TextDocumentEdit2.is = is;
    })(TextDocumentEdit || (TextDocumentEdit = {}));
    (function(CreateFile2) {
      function create(uri, options, annotation) {
        let result = {
          kind: "create",
          uri
        };
        if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
          result.options = options;
        }
        if (annotation !== void 0) {
          result.annotationId = annotation;
        }
        return result;
      }
      CreateFile2.create = create;
      function is(value) {
        let candidate = value;
        return candidate && candidate.kind === "create" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
      }
      CreateFile2.is = is;
    })(CreateFile || (CreateFile = {}));
    (function(RenameFile2) {
      function create(oldUri, newUri, options, annotation) {
        let result = {
          kind: "rename",
          oldUri,
          newUri
        };
        if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
          result.options = options;
        }
        if (annotation !== void 0) {
          result.annotationId = annotation;
        }
        return result;
      }
      RenameFile2.create = create;
      function is(value) {
        let candidate = value;
        return candidate && candidate.kind === "rename" && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
      }
      RenameFile2.is = is;
    })(RenameFile || (RenameFile = {}));
    (function(DeleteFile2) {
      function create(uri, options, annotation) {
        let result = {
          kind: "delete",
          uri
        };
        if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {
          result.options = options;
        }
        if (annotation !== void 0) {
          result.annotationId = annotation;
        }
        return result;
      }
      DeleteFile2.create = create;
      function is(value) {
        let candidate = value;
        return candidate && candidate.kind === "delete" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
      }
      DeleteFile2.is = is;
    })(DeleteFile || (DeleteFile = {}));
    (function(WorkspaceEdit2) {
      function is(value) {
        let candidate = value;
        return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every((change) => {
          if (Is.string(change.kind)) {
            return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
          } else {
            return TextDocumentEdit.is(change);
          }
        }));
      }
      WorkspaceEdit2.is = is;
    })(WorkspaceEdit || (WorkspaceEdit = {}));
    TextEditChangeImpl = class {
      constructor(edits, changeAnnotations) {
        this.edits = edits;
        this.changeAnnotations = changeAnnotations;
      }
      insert(position, newText, annotation) {
        let edit;
        let id;
        if (annotation === void 0) {
          edit = TextEdit.insert(position, newText);
        } else if (ChangeAnnotationIdentifier.is(annotation)) {
          id = annotation;
          edit = AnnotatedTextEdit.insert(position, newText, annotation);
        } else {
          this.assertChangeAnnotations(this.changeAnnotations);
          id = this.changeAnnotations.manage(annotation);
          edit = AnnotatedTextEdit.insert(position, newText, id);
        }
        this.edits.push(edit);
        if (id !== void 0) {
          return id;
        }
      }
      replace(range, newText, annotation) {
        let edit;
        let id;
        if (annotation === void 0) {
          edit = TextEdit.replace(range, newText);
        } else if (ChangeAnnotationIdentifier.is(annotation)) {
          id = annotation;
          edit = AnnotatedTextEdit.replace(range, newText, annotation);
        } else {
          this.assertChangeAnnotations(this.changeAnnotations);
          id = this.changeAnnotations.manage(annotation);
          edit = AnnotatedTextEdit.replace(range, newText, id);
        }
        this.edits.push(edit);
        if (id !== void 0) {
          return id;
        }
      }
      delete(range, annotation) {
        let edit;
        let id;
        if (annotation === void 0) {
          edit = TextEdit.del(range);
        } else if (ChangeAnnotationIdentifier.is(annotation)) {
          id = annotation;
          edit = AnnotatedTextEdit.del(range, annotation);
        } else {
          this.assertChangeAnnotations(this.changeAnnotations);
          id = this.changeAnnotations.manage(annotation);
          edit = AnnotatedTextEdit.del(range, id);
        }
        this.edits.push(edit);
        if (id !== void 0) {
          return id;
        }
      }
      add(edit) {
        this.edits.push(edit);
      }
      all() {
        return this.edits;
      }
      clear() {
        this.edits.splice(0, this.edits.length);
      }
      assertChangeAnnotations(value) {
        if (value === void 0) {
          throw new Error(`Text edit change is not configured to manage change annotations.`);
        }
      }
    };
    ChangeAnnotations = class {
      constructor(annotations) {
        this._annotations = annotations === void 0 ? /* @__PURE__ */ Object.create(null) : annotations;
        this._counter = 0;
        this._size = 0;
      }
      all() {
        return this._annotations;
      }
      get size() {
        return this._size;
      }
      manage(idOrAnnotation, annotation) {
        let id;
        if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
          id = idOrAnnotation;
        } else {
          id = this.nextId();
          annotation = idOrAnnotation;
        }
        if (this._annotations[id] !== void 0) {
          throw new Error(`Id ${id} is already in use.`);
        }
        if (annotation === void 0) {
          throw new Error(`No annotation provided for id ${id}`);
        }
        this._annotations[id] = annotation;
        this._size++;
        return id;
      }
      nextId() {
        this._counter++;
        return this._counter.toString();
      }
    };
    WorkspaceChange = class {
      constructor(workspaceEdit) {
        this._textEditChanges = /* @__PURE__ */ Object.create(null);
        if (workspaceEdit !== void 0) {
          this._workspaceEdit = workspaceEdit;
          if (workspaceEdit.documentChanges) {
            this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
            workspaceEdit.changeAnnotations = this._changeAnnotations.all();
            workspaceEdit.documentChanges.forEach((change) => {
              if (TextDocumentEdit.is(change)) {
                const textEditChange = new TextEditChangeImpl(change.edits, this._changeAnnotations);
                this._textEditChanges[change.textDocument.uri] = textEditChange;
              }
            });
          } else if (workspaceEdit.changes) {
            Object.keys(workspaceEdit.changes).forEach((key) => {
              const textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
              this._textEditChanges[key] = textEditChange;
            });
          }
        } else {
          this._workspaceEdit = {};
        }
      }
      /**
       * Returns the underlying {@link WorkspaceEdit} literal
       * use to be returned from a workspace edit operation like rename.
       */
      get edit() {
        this.initDocumentChanges();
        if (this._changeAnnotations !== void 0) {
          if (this._changeAnnotations.size === 0) {
            this._workspaceEdit.changeAnnotations = void 0;
          } else {
            this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
          }
        }
        return this._workspaceEdit;
      }
      getTextEditChange(key) {
        if (OptionalVersionedTextDocumentIdentifier.is(key)) {
          this.initDocumentChanges();
          if (this._workspaceEdit.documentChanges === void 0) {
            throw new Error("Workspace edit is not configured for document changes.");
          }
          const textDocument = { uri: key.uri, version: key.version };
          let result = this._textEditChanges[textDocument.uri];
          if (!result) {
            const edits = [];
            const textDocumentEdit = {
              textDocument,
              edits
            };
            this._workspaceEdit.documentChanges.push(textDocumentEdit);
            result = new TextEditChangeImpl(edits, this._changeAnnotations);
            this._textEditChanges[textDocument.uri] = result;
          }
          return result;
        } else {
          this.initChanges();
          if (this._workspaceEdit.changes === void 0) {
            throw new Error("Workspace edit is not configured for normal text edit changes.");
          }
          let result = this._textEditChanges[key];
          if (!result) {
            let edits = [];
            this._workspaceEdit.changes[key] = edits;
            result = new TextEditChangeImpl(edits);
            this._textEditChanges[key] = result;
          }
          return result;
        }
      }
      initDocumentChanges() {
        if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
          this._changeAnnotations = new ChangeAnnotations();
          this._workspaceEdit.documentChanges = [];
          this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
        }
      }
      initChanges() {
        if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
          this._workspaceEdit.changes = /* @__PURE__ */ Object.create(null);
        }
      }
      createFile(uri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === void 0) {
          throw new Error("Workspace edit is not configured for document changes.");
        }
        let annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
          annotation = optionsOrAnnotation;
        } else {
          options = optionsOrAnnotation;
        }
        let operation;
        let id;
        if (annotation === void 0) {
          operation = CreateFile.create(uri, options);
        } else {
          id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
          operation = CreateFile.create(uri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== void 0) {
          return id;
        }
      }
      renameFile(oldUri, newUri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === void 0) {
          throw new Error("Workspace edit is not configured for document changes.");
        }
        let annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
          annotation = optionsOrAnnotation;
        } else {
          options = optionsOrAnnotation;
        }
        let operation;
        let id;
        if (annotation === void 0) {
          operation = RenameFile.create(oldUri, newUri, options);
        } else {
          id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
          operation = RenameFile.create(oldUri, newUri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== void 0) {
          return id;
        }
      }
      deleteFile(uri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === void 0) {
          throw new Error("Workspace edit is not configured for document changes.");
        }
        let annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
          annotation = optionsOrAnnotation;
        } else {
          options = optionsOrAnnotation;
        }
        let operation;
        let id;
        if (annotation === void 0) {
          operation = DeleteFile.create(uri, options);
        } else {
          id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
          operation = DeleteFile.create(uri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== void 0) {
          return id;
        }
      }
    };
    (function(TextDocumentIdentifier2) {
      function create(uri) {
        return { uri };
      }
      TextDocumentIdentifier2.create = create;
      function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri);
      }
      TextDocumentIdentifier2.is = is;
    })(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
    (function(VersionedTextDocumentIdentifier2) {
      function create(uri, version) {
        return { uri, version };
      }
      VersionedTextDocumentIdentifier2.create = create;
      function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
      }
      VersionedTextDocumentIdentifier2.is = is;
    })(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
    (function(OptionalVersionedTextDocumentIdentifier2) {
      function create(uri, version) {
        return { uri, version };
      }
      OptionalVersionedTextDocumentIdentifier2.create = create;
      function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
      }
      OptionalVersionedTextDocumentIdentifier2.is = is;
    })(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));
    (function(TextDocumentItem2) {
      function create(uri, languageId, version, text) {
        return { uri, languageId, version, text };
      }
      TextDocumentItem2.create = create;
      function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
      }
      TextDocumentItem2.is = is;
    })(TextDocumentItem || (TextDocumentItem = {}));
    (function(MarkupKind2) {
      MarkupKind2.PlainText = "plaintext";
      MarkupKind2.Markdown = "markdown";
      function is(value) {
        const candidate = value;
        return candidate === MarkupKind2.PlainText || candidate === MarkupKind2.Markdown;
      }
      MarkupKind2.is = is;
    })(MarkupKind || (MarkupKind = {}));
    (function(MarkupContent2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
      }
      MarkupContent2.is = is;
    })(MarkupContent || (MarkupContent = {}));
    (function(CompletionItemKind3) {
      CompletionItemKind3.Text = 1;
      CompletionItemKind3.Method = 2;
      CompletionItemKind3.Function = 3;
      CompletionItemKind3.Constructor = 4;
      CompletionItemKind3.Field = 5;
      CompletionItemKind3.Variable = 6;
      CompletionItemKind3.Class = 7;
      CompletionItemKind3.Interface = 8;
      CompletionItemKind3.Module = 9;
      CompletionItemKind3.Property = 10;
      CompletionItemKind3.Unit = 11;
      CompletionItemKind3.Value = 12;
      CompletionItemKind3.Enum = 13;
      CompletionItemKind3.Keyword = 14;
      CompletionItemKind3.Snippet = 15;
      CompletionItemKind3.Color = 16;
      CompletionItemKind3.File = 17;
      CompletionItemKind3.Reference = 18;
      CompletionItemKind3.Folder = 19;
      CompletionItemKind3.EnumMember = 20;
      CompletionItemKind3.Constant = 21;
      CompletionItemKind3.Struct = 22;
      CompletionItemKind3.Event = 23;
      CompletionItemKind3.Operator = 24;
      CompletionItemKind3.TypeParameter = 25;
    })(CompletionItemKind || (CompletionItemKind = {}));
    (function(InsertTextFormat2) {
      InsertTextFormat2.PlainText = 1;
      InsertTextFormat2.Snippet = 2;
    })(InsertTextFormat || (InsertTextFormat = {}));
    (function(CompletionItemTag2) {
      CompletionItemTag2.Deprecated = 1;
    })(CompletionItemTag || (CompletionItemTag = {}));
    (function(InsertReplaceEdit2) {
      function create(newText, insert, replace) {
        return { newText, insert, replace };
      }
      InsertReplaceEdit2.create = create;
      function is(value) {
        const candidate = value;
        return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
      }
      InsertReplaceEdit2.is = is;
    })(InsertReplaceEdit || (InsertReplaceEdit = {}));
    (function(InsertTextMode2) {
      InsertTextMode2.asIs = 1;
      InsertTextMode2.adjustIndentation = 2;
    })(InsertTextMode || (InsertTextMode = {}));
    (function(CompletionItemLabelDetails2) {
      function is(value) {
        const candidate = value;
        return candidate && (Is.string(candidate.detail) || candidate.detail === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
      }
      CompletionItemLabelDetails2.is = is;
    })(CompletionItemLabelDetails || (CompletionItemLabelDetails = {}));
    (function(CompletionItem3) {
      function create(label) {
        return { label };
      }
      CompletionItem3.create = create;
    })(CompletionItem || (CompletionItem = {}));
    (function(CompletionList2) {
      function create(items, isIncomplete) {
        return { items: items ? items : [], isIncomplete: !!isIncomplete };
      }
      CompletionList2.create = create;
    })(CompletionList || (CompletionList = {}));
    (function(MarkedString2) {
      function fromPlainText(plainText) {
        return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
      }
      MarkedString2.fromPlainText = fromPlainText;
      function is(value) {
        const candidate = value;
        return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
      }
      MarkedString2.is = is;
    })(MarkedString || (MarkedString = {}));
    (function(Hover2) {
      function is(value) {
        let candidate = value;
        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range.is(value.range));
      }
      Hover2.is = is;
    })(Hover || (Hover = {}));
    (function(ParameterInformation2) {
      function create(label, documentation) {
        return documentation ? { label, documentation } : { label };
      }
      ParameterInformation2.create = create;
    })(ParameterInformation || (ParameterInformation = {}));
    (function(SignatureInformation2) {
      function create(label, documentation, ...parameters) {
        let result = { label };
        if (Is.defined(documentation)) {
          result.documentation = documentation;
        }
        if (Is.defined(parameters)) {
          result.parameters = parameters;
        } else {
          result.parameters = [];
        }
        return result;
      }
      SignatureInformation2.create = create;
    })(SignatureInformation || (SignatureInformation = {}));
    (function(DocumentHighlightKind2) {
      DocumentHighlightKind2.Text = 1;
      DocumentHighlightKind2.Read = 2;
      DocumentHighlightKind2.Write = 3;
    })(DocumentHighlightKind || (DocumentHighlightKind = {}));
    (function(DocumentHighlight2) {
      function create(range, kind) {
        let result = { range };
        if (Is.number(kind)) {
          result.kind = kind;
        }
        return result;
      }
      DocumentHighlight2.create = create;
    })(DocumentHighlight || (DocumentHighlight = {}));
    (function(SymbolKind2) {
      SymbolKind2.File = 1;
      SymbolKind2.Module = 2;
      SymbolKind2.Namespace = 3;
      SymbolKind2.Package = 4;
      SymbolKind2.Class = 5;
      SymbolKind2.Method = 6;
      SymbolKind2.Property = 7;
      SymbolKind2.Field = 8;
      SymbolKind2.Constructor = 9;
      SymbolKind2.Enum = 10;
      SymbolKind2.Interface = 11;
      SymbolKind2.Function = 12;
      SymbolKind2.Variable = 13;
      SymbolKind2.Constant = 14;
      SymbolKind2.String = 15;
      SymbolKind2.Number = 16;
      SymbolKind2.Boolean = 17;
      SymbolKind2.Array = 18;
      SymbolKind2.Object = 19;
      SymbolKind2.Key = 20;
      SymbolKind2.Null = 21;
      SymbolKind2.EnumMember = 22;
      SymbolKind2.Struct = 23;
      SymbolKind2.Event = 24;
      SymbolKind2.Operator = 25;
      SymbolKind2.TypeParameter = 26;
    })(SymbolKind || (SymbolKind = {}));
    (function(SymbolTag2) {
      SymbolTag2.Deprecated = 1;
    })(SymbolTag || (SymbolTag = {}));
    (function(SymbolInformation2) {
      function create(name, kind, range, uri, containerName) {
        let result = {
          name,
          kind,
          location: { uri, range }
        };
        if (containerName) {
          result.containerName = containerName;
        }
        return result;
      }
      SymbolInformation2.create = create;
    })(SymbolInformation || (SymbolInformation = {}));
    (function(WorkspaceSymbol2) {
      function create(name, kind, uri, range) {
        return range !== void 0 ? { name, kind, location: { uri, range } } : { name, kind, location: { uri } };
      }
      WorkspaceSymbol2.create = create;
    })(WorkspaceSymbol || (WorkspaceSymbol = {}));
    (function(DocumentSymbol2) {
      function create(name, detail, kind, range, selectionRange, children) {
        let result = {
          name,
          detail,
          kind,
          range,
          selectionRange
        };
        if (children !== void 0) {
          result.children = children;
        }
        return result;
      }
      DocumentSymbol2.create = create;
      function is(value) {
        let candidate = value;
        return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range.is(candidate.range) && Range.is(candidate.selectionRange) && (candidate.detail === void 0 || Is.string(candidate.detail)) && (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children)) && (candidate.tags === void 0 || Array.isArray(candidate.tags));
      }
      DocumentSymbol2.is = is;
    })(DocumentSymbol || (DocumentSymbol = {}));
    (function(CodeActionKind2) {
      CodeActionKind2.Empty = "";
      CodeActionKind2.QuickFix = "quickfix";
      CodeActionKind2.Refactor = "refactor";
      CodeActionKind2.RefactorExtract = "refactor.extract";
      CodeActionKind2.RefactorInline = "refactor.inline";
      CodeActionKind2.RefactorRewrite = "refactor.rewrite";
      CodeActionKind2.Source = "source";
      CodeActionKind2.SourceOrganizeImports = "source.organizeImports";
      CodeActionKind2.SourceFixAll = "source.fixAll";
    })(CodeActionKind || (CodeActionKind = {}));
    (function(CodeActionTriggerKind2) {
      CodeActionTriggerKind2.Invoked = 1;
      CodeActionTriggerKind2.Automatic = 2;
    })(CodeActionTriggerKind || (CodeActionTriggerKind = {}));
    (function(CodeActionContext2) {
      function create(diagnostics, only, triggerKind) {
        let result = { diagnostics };
        if (only !== void 0 && only !== null) {
          result.only = only;
        }
        if (triggerKind !== void 0 && triggerKind !== null) {
          result.triggerKind = triggerKind;
        }
        return result;
      }
      CodeActionContext2.create = create;
      function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string)) && (candidate.triggerKind === void 0 || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
      }
      CodeActionContext2.is = is;
    })(CodeActionContext || (CodeActionContext = {}));
    (function(CodeAction2) {
      function create(title, kindOrCommandOrEdit, kind) {
        let result = { title };
        let checkKind = true;
        if (typeof kindOrCommandOrEdit === "string") {
          checkKind = false;
          result.kind = kindOrCommandOrEdit;
        } else if (Command.is(kindOrCommandOrEdit)) {
          result.command = kindOrCommandOrEdit;
        } else {
          result.edit = kindOrCommandOrEdit;
        }
        if (checkKind && kind !== void 0) {
          result.kind = kind;
        }
        return result;
      }
      CodeAction2.create = create;
      function is(value) {
        let candidate = value;
        return candidate && Is.string(candidate.title) && (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === void 0 || Is.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command.is(candidate.command)) && (candidate.isPreferred === void 0 || Is.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));
      }
      CodeAction2.is = is;
    })(CodeAction || (CodeAction = {}));
    (function(CodeLens2) {
      function create(range, data) {
        let result = { range };
        if (Is.defined(data)) {
          result.data = data;
        }
        return result;
      }
      CodeLens2.create = create;
      function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
      }
      CodeLens2.is = is;
    })(CodeLens || (CodeLens = {}));
    (function(FormattingOptions2) {
      function create(tabSize, insertSpaces) {
        return { tabSize, insertSpaces };
      }
      FormattingOptions2.create = create;
      function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
      }
      FormattingOptions2.is = is;
    })(FormattingOptions || (FormattingOptions = {}));
    (function(DocumentLink2) {
      function create(range, target, data) {
        return { range, target, data };
      }
      DocumentLink2.create = create;
      function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
      }
      DocumentLink2.is = is;
    })(DocumentLink || (DocumentLink = {}));
    (function(SelectionRange2) {
      function create(range, parent) {
        return { range, parent };
      }
      SelectionRange2.create = create;
      function is(value) {
        let candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === void 0 || SelectionRange2.is(candidate.parent));
      }
      SelectionRange2.is = is;
    })(SelectionRange || (SelectionRange = {}));
    (function(SemanticTokenTypes3) {
      SemanticTokenTypes3["namespace"] = "namespace";
      SemanticTokenTypes3["type"] = "type";
      SemanticTokenTypes3["class"] = "class";
      SemanticTokenTypes3["enum"] = "enum";
      SemanticTokenTypes3["interface"] = "interface";
      SemanticTokenTypes3["struct"] = "struct";
      SemanticTokenTypes3["typeParameter"] = "typeParameter";
      SemanticTokenTypes3["parameter"] = "parameter";
      SemanticTokenTypes3["variable"] = "variable";
      SemanticTokenTypes3["property"] = "property";
      SemanticTokenTypes3["enumMember"] = "enumMember";
      SemanticTokenTypes3["event"] = "event";
      SemanticTokenTypes3["function"] = "function";
      SemanticTokenTypes3["method"] = "method";
      SemanticTokenTypes3["macro"] = "macro";
      SemanticTokenTypes3["keyword"] = "keyword";
      SemanticTokenTypes3["modifier"] = "modifier";
      SemanticTokenTypes3["comment"] = "comment";
      SemanticTokenTypes3["string"] = "string";
      SemanticTokenTypes3["number"] = "number";
      SemanticTokenTypes3["regexp"] = "regexp";
      SemanticTokenTypes3["operator"] = "operator";
      SemanticTokenTypes3["decorator"] = "decorator";
    })(SemanticTokenTypes || (SemanticTokenTypes = {}));
    (function(SemanticTokenModifiers3) {
      SemanticTokenModifiers3["declaration"] = "declaration";
      SemanticTokenModifiers3["definition"] = "definition";
      SemanticTokenModifiers3["readonly"] = "readonly";
      SemanticTokenModifiers3["static"] = "static";
      SemanticTokenModifiers3["deprecated"] = "deprecated";
      SemanticTokenModifiers3["abstract"] = "abstract";
      SemanticTokenModifiers3["async"] = "async";
      SemanticTokenModifiers3["modification"] = "modification";
      SemanticTokenModifiers3["documentation"] = "documentation";
      SemanticTokenModifiers3["defaultLibrary"] = "defaultLibrary";
    })(SemanticTokenModifiers || (SemanticTokenModifiers = {}));
    (function(SemanticTokens2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (candidate.resultId === void 0 || typeof candidate.resultId === "string") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === "number");
      }
      SemanticTokens2.is = is;
    })(SemanticTokens || (SemanticTokens = {}));
    (function(InlineValueText2) {
      function create(range, text) {
        return { range, text };
      }
      InlineValueText2.create = create;
      function is(value) {
        const candidate = value;
        return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);
      }
      InlineValueText2.is = is;
    })(InlineValueText || (InlineValueText = {}));
    (function(InlineValueVariableLookup2) {
      function create(range, variableName, caseSensitiveLookup) {
        return { range, variableName, caseSensitiveLookup };
      }
      InlineValueVariableLookup2.create = create;
      function is(value) {
        const candidate = value;
        return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup) && (Is.string(candidate.variableName) || candidate.variableName === void 0);
      }
      InlineValueVariableLookup2.is = is;
    })(InlineValueVariableLookup || (InlineValueVariableLookup = {}));
    (function(InlineValueEvaluatableExpression2) {
      function create(range, expression) {
        return { range, expression };
      }
      InlineValueEvaluatableExpression2.create = create;
      function is(value) {
        const candidate = value;
        return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && (Is.string(candidate.expression) || candidate.expression === void 0);
      }
      InlineValueEvaluatableExpression2.is = is;
    })(InlineValueEvaluatableExpression || (InlineValueEvaluatableExpression = {}));
    (function(InlineValueContext2) {
      function create(frameId, stoppedLocation) {
        return { frameId, stoppedLocation };
      }
      InlineValueContext2.create = create;
      function is(value) {
        const candidate = value;
        return Is.defined(candidate) && Range.is(value.stoppedLocation);
      }
      InlineValueContext2.is = is;
    })(InlineValueContext || (InlineValueContext = {}));
    (function(InlayHintKind2) {
      InlayHintKind2.Type = 1;
      InlayHintKind2.Parameter = 2;
      function is(value) {
        return value === 1 || value === 2;
      }
      InlayHintKind2.is = is;
    })(InlayHintKind || (InlayHintKind = {}));
    (function(InlayHintLabelPart2) {
      function create(value) {
        return { value };
      }
      InlayHintLabelPart2.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.location === void 0 || Location.is(candidate.location)) && (candidate.command === void 0 || Command.is(candidate.command));
      }
      InlayHintLabelPart2.is = is;
    })(InlayHintLabelPart || (InlayHintLabelPart = {}));
    (function(InlayHint2) {
      function create(position, label, kind) {
        const result = { position, label };
        if (kind !== void 0) {
          result.kind = kind;
        }
        return result;
      }
      InlayHint2.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Position.is(candidate.position) && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is)) && (candidate.kind === void 0 || InlayHintKind.is(candidate.kind)) && candidate.textEdits === void 0 || Is.typedArray(candidate.textEdits, TextEdit.is) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.paddingLeft === void 0 || Is.boolean(candidate.paddingLeft)) && (candidate.paddingRight === void 0 || Is.boolean(candidate.paddingRight));
      }
      InlayHint2.is = is;
    })(InlayHint || (InlayHint = {}));
    (function(StringValue2) {
      function createSnippet(value) {
        return { kind: "snippet", value };
      }
      StringValue2.createSnippet = createSnippet;
    })(StringValue || (StringValue = {}));
    (function(InlineCompletionItem2) {
      function create(insertText, filterText, range, command) {
        return { insertText, filterText, range, command };
      }
      InlineCompletionItem2.create = create;
    })(InlineCompletionItem || (InlineCompletionItem = {}));
    (function(InlineCompletionList2) {
      function create(items) {
        return { items };
      }
      InlineCompletionList2.create = create;
    })(InlineCompletionList || (InlineCompletionList = {}));
    (function(InlineCompletionTriggerKind2) {
      InlineCompletionTriggerKind2.Invoked = 0;
      InlineCompletionTriggerKind2.Automatic = 1;
    })(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));
    (function(SelectedCompletionInfo2) {
      function create(range, text) {
        return { range, text };
      }
      SelectedCompletionInfo2.create = create;
    })(SelectedCompletionInfo || (SelectedCompletionInfo = {}));
    (function(InlineCompletionContext2) {
      function create(triggerKind, selectedCompletionInfo) {
        return { triggerKind, selectedCompletionInfo };
      }
      InlineCompletionContext2.create = create;
    })(InlineCompletionContext || (InlineCompletionContext = {}));
    (function(WorkspaceFolder2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);
      }
      WorkspaceFolder2.is = is;
    })(WorkspaceFolder || (WorkspaceFolder = {}));
    EOL = ["\n", "\r\n", "\r"];
    (function(TextDocument3) {
      function create(uri, languageId, version, content) {
        return new FullTextDocument(uri, languageId, version, content);
      }
      TextDocument3.create = create;
      function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
      }
      TextDocument3.is = is;
      function applyEdits(document2, edits) {
        let text = document2.getText();
        let sortedEdits = mergeSort2(edits, (a, b) => {
          let diff = a.range.start.line - b.range.start.line;
          if (diff === 0) {
            return a.range.start.character - b.range.start.character;
          }
          return diff;
        });
        let lastModifiedOffset = text.length;
        for (let i = sortedEdits.length - 1; i >= 0; i--) {
          let e = sortedEdits[i];
          let startOffset = document2.offsetAt(e.range.start);
          let endOffset = document2.offsetAt(e.range.end);
          if (endOffset <= lastModifiedOffset) {
            text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
          } else {
            throw new Error("Overlapping edit");
          }
          lastModifiedOffset = startOffset;
        }
        return text;
      }
      TextDocument3.applyEdits = applyEdits;
      function mergeSort2(data, compare) {
        if (data.length <= 1) {
          return data;
        }
        const p = data.length / 2 | 0;
        const left = data.slice(0, p);
        const right = data.slice(p);
        mergeSort2(left, compare);
        mergeSort2(right, compare);
        let leftIdx = 0;
        let rightIdx = 0;
        let i = 0;
        while (leftIdx < left.length && rightIdx < right.length) {
          let ret = compare(left[leftIdx], right[rightIdx]);
          if (ret <= 0) {
            data[i++] = left[leftIdx++];
          } else {
            data[i++] = right[rightIdx++];
          }
        }
        while (leftIdx < left.length) {
          data[i++] = left[leftIdx++];
        }
        while (rightIdx < right.length) {
          data[i++] = right[rightIdx++];
        }
        return data;
      }
    })(TextDocument || (TextDocument = {}));
    FullTextDocument = class {
      constructor(uri, languageId, version, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._version = version;
        this._content = content;
        this._lineOffsets = void 0;
      }
      get uri() {
        return this._uri;
      }
      get languageId() {
        return this._languageId;
      }
      get version() {
        return this._version;
      }
      getText(range) {
        if (range) {
          let start = this.offsetAt(range.start);
          let end = this.offsetAt(range.end);
          return this._content.substring(start, end);
        }
        return this._content;
      }
      update(event, version) {
        this._content = event.text;
        this._version = version;
        this._lineOffsets = void 0;
      }
      getLineOffsets() {
        if (this._lineOffsets === void 0) {
          let lineOffsets = [];
          let text = this._content;
          let isLineStart = true;
          for (let i = 0; i < text.length; i++) {
            if (isLineStart) {
              lineOffsets.push(i);
              isLineStart = false;
            }
            let ch = text.charAt(i);
            isLineStart = ch === "\r" || ch === "\n";
            if (ch === "\r" && i + 1 < text.length && text.charAt(i + 1) === "\n") {
              i++;
            }
          }
          if (isLineStart && text.length > 0) {
            lineOffsets.push(text.length);
          }
          this._lineOffsets = lineOffsets;
        }
        return this._lineOffsets;
      }
      positionAt(offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        let lineOffsets = this.getLineOffsets();
        let low = 0, high = lineOffsets.length;
        if (high === 0) {
          return Position.create(0, offset);
        }
        while (low < high) {
          let mid = Math.floor((low + high) / 2);
          if (lineOffsets[mid] > offset) {
            high = mid;
          } else {
            low = mid + 1;
          }
        }
        let line = low - 1;
        return Position.create(line, offset - lineOffsets[line]);
      }
      offsetAt(position) {
        let lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
          return this._content.length;
        } else if (position.line < 0) {
          return 0;
        }
        let lineOffset = lineOffsets[position.line];
        let nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
      }
      get lineCount() {
        return this.getLineOffsets().length;
      }
    };
    (function(Is2) {
      const toString = Object.prototype.toString;
      function defined(value) {
        return typeof value !== "undefined";
      }
      Is2.defined = defined;
      function undefined2(value) {
        return typeof value === "undefined";
      }
      Is2.undefined = undefined2;
      function boolean(value) {
        return value === true || value === false;
      }
      Is2.boolean = boolean;
      function string(value) {
        return toString.call(value) === "[object String]";
      }
      Is2.string = string;
      function number(value) {
        return toString.call(value) === "[object Number]";
      }
      Is2.number = number;
      function numberRange(value, min, max) {
        return toString.call(value) === "[object Number]" && min <= value && value <= max;
      }
      Is2.numberRange = numberRange;
      function integer2(value) {
        return toString.call(value) === "[object Number]" && -2147483648 <= value && value <= 2147483647;
      }
      Is2.integer = integer2;
      function uinteger2(value) {
        return toString.call(value) === "[object Number]" && 0 <= value && value <= 2147483647;
      }
      Is2.uinteger = uinteger2;
      function func(value) {
        return toString.call(value) === "[object Function]";
      }
      Is2.func = func;
      function objectLiteral(value) {
        return value !== null && typeof value === "object";
      }
      Is2.objectLiteral = objectLiteral;
      function typedArray(value, check) {
        return Array.isArray(value) && value.every(check);
      }
      Is2.typedArray = typedArray;
    })(Is || (Is = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/messages.js
var require_messages2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/messages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProtocolNotificationType = exports2.ProtocolNotificationType0 = exports2.ProtocolRequestType = exports2.ProtocolRequestType0 = exports2.RegistrationType = exports2.MessageDirection = void 0;
    var vscode_jsonrpc_1 = require_main();
    var MessageDirection;
    (function(MessageDirection2) {
      MessageDirection2["clientToServer"] = "clientToServer";
      MessageDirection2["serverToClient"] = "serverToClient";
      MessageDirection2["both"] = "both";
    })(MessageDirection || (exports2.MessageDirection = MessageDirection = {}));
    var RegistrationType = class {
      constructor(method) {
        this.method = method;
      }
    };
    exports2.RegistrationType = RegistrationType;
    var ProtocolRequestType0 = class extends vscode_jsonrpc_1.RequestType0 {
      constructor(method) {
        super(method);
      }
    };
    exports2.ProtocolRequestType0 = ProtocolRequestType0;
    var ProtocolRequestType = class extends vscode_jsonrpc_1.RequestType {
      constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
      }
    };
    exports2.ProtocolRequestType = ProtocolRequestType;
    var ProtocolNotificationType0 = class extends vscode_jsonrpc_1.NotificationType0 {
      constructor(method) {
        super(method);
      }
    };
    exports2.ProtocolNotificationType0 = ProtocolNotificationType0;
    var ProtocolNotificationType = class extends vscode_jsonrpc_1.NotificationType {
      constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
      }
    };
    exports2.ProtocolNotificationType = ProtocolNotificationType;
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/utils/is.js
var require_is2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/utils/is.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.objectLiteral = exports2.typedArray = exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports2.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports2.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports2.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports2.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports2.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports2.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports2.stringArray = stringArray;
    function typedArray(value, check) {
      return Array.isArray(value) && value.every(check);
    }
    exports2.typedArray = typedArray;
    function objectLiteral(value) {
      return value !== null && typeof value === "object";
    }
    exports2.objectLiteral = objectLiteral;
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js
var require_protocol_implementation = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ImplementationRequest = void 0;
    var messages_1 = require_messages2();
    var ImplementationRequest;
    (function(ImplementationRequest2) {
      ImplementationRequest2.method = "textDocument/implementation";
      ImplementationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ImplementationRequest2.type = new messages_1.ProtocolRequestType(ImplementationRequest2.method);
    })(ImplementationRequest || (exports2.ImplementationRequest = ImplementationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js
var require_protocol_typeDefinition = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeDefinitionRequest = void 0;
    var messages_1 = require_messages2();
    var TypeDefinitionRequest;
    (function(TypeDefinitionRequest2) {
      TypeDefinitionRequest2.method = "textDocument/typeDefinition";
      TypeDefinitionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeDefinitionRequest2.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest2.method);
    })(TypeDefinitionRequest || (exports2.TypeDefinitionRequest = TypeDefinitionRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js
var require_protocol_workspaceFolder = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DidChangeWorkspaceFoldersNotification = exports2.WorkspaceFoldersRequest = void 0;
    var messages_1 = require_messages2();
    var WorkspaceFoldersRequest;
    (function(WorkspaceFoldersRequest2) {
      WorkspaceFoldersRequest2.method = "workspace/workspaceFolders";
      WorkspaceFoldersRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      WorkspaceFoldersRequest2.type = new messages_1.ProtocolRequestType0(WorkspaceFoldersRequest2.method);
    })(WorkspaceFoldersRequest || (exports2.WorkspaceFoldersRequest = WorkspaceFoldersRequest = {}));
    var DidChangeWorkspaceFoldersNotification;
    (function(DidChangeWorkspaceFoldersNotification2) {
      DidChangeWorkspaceFoldersNotification2.method = "workspace/didChangeWorkspaceFolders";
      DidChangeWorkspaceFoldersNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeWorkspaceFoldersNotification2.type = new messages_1.ProtocolNotificationType(DidChangeWorkspaceFoldersNotification2.method);
    })(DidChangeWorkspaceFoldersNotification || (exports2.DidChangeWorkspaceFoldersNotification = DidChangeWorkspaceFoldersNotification = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js
var require_protocol_configuration = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConfigurationRequest = void 0;
    var messages_1 = require_messages2();
    var ConfigurationRequest;
    (function(ConfigurationRequest2) {
      ConfigurationRequest2.method = "workspace/configuration";
      ConfigurationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ConfigurationRequest2.type = new messages_1.ProtocolRequestType(ConfigurationRequest2.method);
    })(ConfigurationRequest || (exports2.ConfigurationRequest = ConfigurationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js
var require_protocol_colorProvider = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ColorPresentationRequest = exports2.DocumentColorRequest = void 0;
    var messages_1 = require_messages2();
    var DocumentColorRequest;
    (function(DocumentColorRequest2) {
      DocumentColorRequest2.method = "textDocument/documentColor";
      DocumentColorRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentColorRequest2.type = new messages_1.ProtocolRequestType(DocumentColorRequest2.method);
    })(DocumentColorRequest || (exports2.DocumentColorRequest = DocumentColorRequest = {}));
    var ColorPresentationRequest;
    (function(ColorPresentationRequest2) {
      ColorPresentationRequest2.method = "textDocument/colorPresentation";
      ColorPresentationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ColorPresentationRequest2.type = new messages_1.ProtocolRequestType(ColorPresentationRequest2.method);
    })(ColorPresentationRequest || (exports2.ColorPresentationRequest = ColorPresentationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js
var require_protocol_foldingRange = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FoldingRangeRefreshRequest = exports2.FoldingRangeRequest = void 0;
    var messages_1 = require_messages2();
    var FoldingRangeRequest;
    (function(FoldingRangeRequest2) {
      FoldingRangeRequest2.method = "textDocument/foldingRange";
      FoldingRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      FoldingRangeRequest2.type = new messages_1.ProtocolRequestType(FoldingRangeRequest2.method);
    })(FoldingRangeRequest || (exports2.FoldingRangeRequest = FoldingRangeRequest = {}));
    var FoldingRangeRefreshRequest;
    (function(FoldingRangeRefreshRequest2) {
      FoldingRangeRefreshRequest2.method = `workspace/foldingRange/refresh`;
      FoldingRangeRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      FoldingRangeRefreshRequest2.type = new messages_1.ProtocolRequestType0(FoldingRangeRefreshRequest2.method);
    })(FoldingRangeRefreshRequest || (exports2.FoldingRangeRefreshRequest = FoldingRangeRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js
var require_protocol_declaration = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DeclarationRequest = void 0;
    var messages_1 = require_messages2();
    var DeclarationRequest;
    (function(DeclarationRequest2) {
      DeclarationRequest2.method = "textDocument/declaration";
      DeclarationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DeclarationRequest2.type = new messages_1.ProtocolRequestType(DeclarationRequest2.method);
    })(DeclarationRequest || (exports2.DeclarationRequest = DeclarationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js
var require_protocol_selectionRange = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SelectionRangeRequest = void 0;
    var messages_1 = require_messages2();
    var SelectionRangeRequest;
    (function(SelectionRangeRequest2) {
      SelectionRangeRequest2.method = "textDocument/selectionRange";
      SelectionRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SelectionRangeRequest2.type = new messages_1.ProtocolRequestType(SelectionRangeRequest2.method);
    })(SelectionRangeRequest || (exports2.SelectionRangeRequest = SelectionRangeRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js
var require_protocol_progress = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCreateRequest = exports2.WorkDoneProgress = void 0;
    var vscode_jsonrpc_1 = require_main();
    var messages_1 = require_messages2();
    var WorkDoneProgress;
    (function(WorkDoneProgress2) {
      WorkDoneProgress2.type = new vscode_jsonrpc_1.ProgressType();
      function is(value) {
        return value === WorkDoneProgress2.type;
      }
      WorkDoneProgress2.is = is;
    })(WorkDoneProgress || (exports2.WorkDoneProgress = WorkDoneProgress = {}));
    var WorkDoneProgressCreateRequest;
    (function(WorkDoneProgressCreateRequest2) {
      WorkDoneProgressCreateRequest2.method = "window/workDoneProgress/create";
      WorkDoneProgressCreateRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      WorkDoneProgressCreateRequest2.type = new messages_1.ProtocolRequestType(WorkDoneProgressCreateRequest2.method);
    })(WorkDoneProgressCreateRequest || (exports2.WorkDoneProgressCreateRequest = WorkDoneProgressCreateRequest = {}));
    var WorkDoneProgressCancelNotification;
    (function(WorkDoneProgressCancelNotification2) {
      WorkDoneProgressCancelNotification2.method = "window/workDoneProgress/cancel";
      WorkDoneProgressCancelNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkDoneProgressCancelNotification2.type = new messages_1.ProtocolNotificationType(WorkDoneProgressCancelNotification2.method);
    })(WorkDoneProgressCancelNotification || (exports2.WorkDoneProgressCancelNotification = WorkDoneProgressCancelNotification = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js
var require_protocol_callHierarchy = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyIncomingCallsRequest = exports2.CallHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var CallHierarchyPrepareRequest;
    (function(CallHierarchyPrepareRequest2) {
      CallHierarchyPrepareRequest2.method = "textDocument/prepareCallHierarchy";
      CallHierarchyPrepareRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest2.method);
    })(CallHierarchyPrepareRequest || (exports2.CallHierarchyPrepareRequest = CallHierarchyPrepareRequest = {}));
    var CallHierarchyIncomingCallsRequest;
    (function(CallHierarchyIncomingCallsRequest2) {
      CallHierarchyIncomingCallsRequest2.method = "callHierarchy/incomingCalls";
      CallHierarchyIncomingCallsRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyIncomingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest2.method);
    })(CallHierarchyIncomingCallsRequest || (exports2.CallHierarchyIncomingCallsRequest = CallHierarchyIncomingCallsRequest = {}));
    var CallHierarchyOutgoingCallsRequest;
    (function(CallHierarchyOutgoingCallsRequest2) {
      CallHierarchyOutgoingCallsRequest2.method = "callHierarchy/outgoingCalls";
      CallHierarchyOutgoingCallsRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyOutgoingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest2.method);
    })(CallHierarchyOutgoingCallsRequest || (exports2.CallHierarchyOutgoingCallsRequest = CallHierarchyOutgoingCallsRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js
var require_protocol_semanticTokens = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SemanticTokensRefreshRequest = exports2.SemanticTokensRangeRequest = exports2.SemanticTokensDeltaRequest = exports2.SemanticTokensRequest = exports2.SemanticTokensRegistrationType = exports2.TokenFormat = void 0;
    var messages_1 = require_messages2();
    var TokenFormat;
    (function(TokenFormat2) {
      TokenFormat2.Relative = "relative";
    })(TokenFormat || (exports2.TokenFormat = TokenFormat = {}));
    var SemanticTokensRegistrationType;
    (function(SemanticTokensRegistrationType2) {
      SemanticTokensRegistrationType2.method = "textDocument/semanticTokens";
      SemanticTokensRegistrationType2.type = new messages_1.RegistrationType(SemanticTokensRegistrationType2.method);
    })(SemanticTokensRegistrationType || (exports2.SemanticTokensRegistrationType = SemanticTokensRegistrationType = {}));
    var SemanticTokensRequest;
    (function(SemanticTokensRequest2) {
      SemanticTokensRequest2.method = "textDocument/semanticTokens/full";
      SemanticTokensRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRequest2.method);
      SemanticTokensRequest2.registrationMethod = SemanticTokensRegistrationType.method;
    })(SemanticTokensRequest || (exports2.SemanticTokensRequest = SemanticTokensRequest = {}));
    var SemanticTokensDeltaRequest;
    (function(SemanticTokensDeltaRequest2) {
      SemanticTokensDeltaRequest2.method = "textDocument/semanticTokens/full/delta";
      SemanticTokensDeltaRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensDeltaRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest2.method);
      SemanticTokensDeltaRequest2.registrationMethod = SemanticTokensRegistrationType.method;
    })(SemanticTokensDeltaRequest || (exports2.SemanticTokensDeltaRequest = SemanticTokensDeltaRequest = {}));
    var SemanticTokensRangeRequest;
    (function(SemanticTokensRangeRequest2) {
      SemanticTokensRangeRequest2.method = "textDocument/semanticTokens/range";
      SemanticTokensRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensRangeRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest2.method);
      SemanticTokensRangeRequest2.registrationMethod = SemanticTokensRegistrationType.method;
    })(SemanticTokensRangeRequest || (exports2.SemanticTokensRangeRequest = SemanticTokensRangeRequest = {}));
    var SemanticTokensRefreshRequest;
    (function(SemanticTokensRefreshRequest2) {
      SemanticTokensRefreshRequest2.method = `workspace/semanticTokens/refresh`;
      SemanticTokensRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      SemanticTokensRefreshRequest2.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest2.method);
    })(SemanticTokensRefreshRequest || (exports2.SemanticTokensRefreshRequest = SemanticTokensRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js
var require_protocol_showDocument = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ShowDocumentRequest = void 0;
    var messages_1 = require_messages2();
    var ShowDocumentRequest;
    (function(ShowDocumentRequest2) {
      ShowDocumentRequest2.method = "window/showDocument";
      ShowDocumentRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowDocumentRequest2.type = new messages_1.ProtocolRequestType(ShowDocumentRequest2.method);
    })(ShowDocumentRequest || (exports2.ShowDocumentRequest = ShowDocumentRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js
var require_protocol_linkedEditingRange = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LinkedEditingRangeRequest = void 0;
    var messages_1 = require_messages2();
    var LinkedEditingRangeRequest;
    (function(LinkedEditingRangeRequest2) {
      LinkedEditingRangeRequest2.method = "textDocument/linkedEditingRange";
      LinkedEditingRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      LinkedEditingRangeRequest2.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest2.method);
    })(LinkedEditingRangeRequest || (exports2.LinkedEditingRangeRequest = LinkedEditingRangeRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js
var require_protocol_fileOperations = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WillDeleteFilesRequest = exports2.DidDeleteFilesNotification = exports2.DidRenameFilesNotification = exports2.WillRenameFilesRequest = exports2.DidCreateFilesNotification = exports2.WillCreateFilesRequest = exports2.FileOperationPatternKind = void 0;
    var messages_1 = require_messages2();
    var FileOperationPatternKind;
    (function(FileOperationPatternKind2) {
      FileOperationPatternKind2.file = "file";
      FileOperationPatternKind2.folder = "folder";
    })(FileOperationPatternKind || (exports2.FileOperationPatternKind = FileOperationPatternKind = {}));
    var WillCreateFilesRequest;
    (function(WillCreateFilesRequest2) {
      WillCreateFilesRequest2.method = "workspace/willCreateFiles";
      WillCreateFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillCreateFilesRequest2.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest2.method);
    })(WillCreateFilesRequest || (exports2.WillCreateFilesRequest = WillCreateFilesRequest = {}));
    var DidCreateFilesNotification;
    (function(DidCreateFilesNotification2) {
      DidCreateFilesNotification2.method = "workspace/didCreateFiles";
      DidCreateFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCreateFilesNotification2.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification2.method);
    })(DidCreateFilesNotification || (exports2.DidCreateFilesNotification = DidCreateFilesNotification = {}));
    var WillRenameFilesRequest;
    (function(WillRenameFilesRequest2) {
      WillRenameFilesRequest2.method = "workspace/willRenameFiles";
      WillRenameFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillRenameFilesRequest2.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest2.method);
    })(WillRenameFilesRequest || (exports2.WillRenameFilesRequest = WillRenameFilesRequest = {}));
    var DidRenameFilesNotification;
    (function(DidRenameFilesNotification2) {
      DidRenameFilesNotification2.method = "workspace/didRenameFiles";
      DidRenameFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidRenameFilesNotification2.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification2.method);
    })(DidRenameFilesNotification || (exports2.DidRenameFilesNotification = DidRenameFilesNotification = {}));
    var DidDeleteFilesNotification;
    (function(DidDeleteFilesNotification2) {
      DidDeleteFilesNotification2.method = "workspace/didDeleteFiles";
      DidDeleteFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidDeleteFilesNotification2.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification2.method);
    })(DidDeleteFilesNotification || (exports2.DidDeleteFilesNotification = DidDeleteFilesNotification = {}));
    var WillDeleteFilesRequest;
    (function(WillDeleteFilesRequest2) {
      WillDeleteFilesRequest2.method = "workspace/willDeleteFiles";
      WillDeleteFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillDeleteFilesRequest2.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest2.method);
    })(WillDeleteFilesRequest || (exports2.WillDeleteFilesRequest = WillDeleteFilesRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js
var require_protocol_moniker = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MonikerRequest = exports2.MonikerKind = exports2.UniquenessLevel = void 0;
    var messages_1 = require_messages2();
    var UniquenessLevel;
    (function(UniquenessLevel2) {
      UniquenessLevel2.document = "document";
      UniquenessLevel2.project = "project";
      UniquenessLevel2.group = "group";
      UniquenessLevel2.scheme = "scheme";
      UniquenessLevel2.global = "global";
    })(UniquenessLevel || (exports2.UniquenessLevel = UniquenessLevel = {}));
    var MonikerKind;
    (function(MonikerKind2) {
      MonikerKind2.$import = "import";
      MonikerKind2.$export = "export";
      MonikerKind2.local = "local";
    })(MonikerKind || (exports2.MonikerKind = MonikerKind = {}));
    var MonikerRequest;
    (function(MonikerRequest2) {
      MonikerRequest2.method = "textDocument/moniker";
      MonikerRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      MonikerRequest2.type = new messages_1.ProtocolRequestType(MonikerRequest2.method);
    })(MonikerRequest || (exports2.MonikerRequest = MonikerRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js
var require_protocol_typeHierarchy = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeHierarchySubtypesRequest = exports2.TypeHierarchySupertypesRequest = exports2.TypeHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var TypeHierarchyPrepareRequest;
    (function(TypeHierarchyPrepareRequest2) {
      TypeHierarchyPrepareRequest2.method = "textDocument/prepareTypeHierarchy";
      TypeHierarchyPrepareRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchyPrepareRequest2.method);
    })(TypeHierarchyPrepareRequest || (exports2.TypeHierarchyPrepareRequest = TypeHierarchyPrepareRequest = {}));
    var TypeHierarchySupertypesRequest;
    (function(TypeHierarchySupertypesRequest2) {
      TypeHierarchySupertypesRequest2.method = "typeHierarchy/supertypes";
      TypeHierarchySupertypesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchySupertypesRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchySupertypesRequest2.method);
    })(TypeHierarchySupertypesRequest || (exports2.TypeHierarchySupertypesRequest = TypeHierarchySupertypesRequest = {}));
    var TypeHierarchySubtypesRequest;
    (function(TypeHierarchySubtypesRequest2) {
      TypeHierarchySubtypesRequest2.method = "typeHierarchy/subtypes";
      TypeHierarchySubtypesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchySubtypesRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchySubtypesRequest2.method);
    })(TypeHierarchySubtypesRequest || (exports2.TypeHierarchySubtypesRequest = TypeHierarchySubtypesRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js
var require_protocol_inlineValue = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlineValueRefreshRequest = exports2.InlineValueRequest = void 0;
    var messages_1 = require_messages2();
    var InlineValueRequest;
    (function(InlineValueRequest2) {
      InlineValueRequest2.method = "textDocument/inlineValue";
      InlineValueRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlineValueRequest2.type = new messages_1.ProtocolRequestType(InlineValueRequest2.method);
    })(InlineValueRequest || (exports2.InlineValueRequest = InlineValueRequest = {}));
    var InlineValueRefreshRequest;
    (function(InlineValueRefreshRequest2) {
      InlineValueRefreshRequest2.method = `workspace/inlineValue/refresh`;
      InlineValueRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      InlineValueRefreshRequest2.type = new messages_1.ProtocolRequestType0(InlineValueRefreshRequest2.method);
    })(InlineValueRefreshRequest || (exports2.InlineValueRefreshRequest = InlineValueRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js
var require_protocol_inlayHint = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlayHintRefreshRequest = exports2.InlayHintResolveRequest = exports2.InlayHintRequest = void 0;
    var messages_1 = require_messages2();
    var InlayHintRequest;
    (function(InlayHintRequest2) {
      InlayHintRequest2.method = "textDocument/inlayHint";
      InlayHintRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlayHintRequest2.type = new messages_1.ProtocolRequestType(InlayHintRequest2.method);
    })(InlayHintRequest || (exports2.InlayHintRequest = InlayHintRequest = {}));
    var InlayHintResolveRequest;
    (function(InlayHintResolveRequest2) {
      InlayHintResolveRequest2.method = "inlayHint/resolve";
      InlayHintResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlayHintResolveRequest2.type = new messages_1.ProtocolRequestType(InlayHintResolveRequest2.method);
    })(InlayHintResolveRequest || (exports2.InlayHintResolveRequest = InlayHintResolveRequest = {}));
    var InlayHintRefreshRequest;
    (function(InlayHintRefreshRequest2) {
      InlayHintRefreshRequest2.method = `workspace/inlayHint/refresh`;
      InlayHintRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      InlayHintRefreshRequest2.type = new messages_1.ProtocolRequestType0(InlayHintRefreshRequest2.method);
    })(InlayHintRefreshRequest || (exports2.InlayHintRefreshRequest = InlayHintRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js
var require_protocol_diagnostic = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DiagnosticRefreshRequest = exports2.WorkspaceDiagnosticRequest = exports2.DocumentDiagnosticRequest = exports2.DocumentDiagnosticReportKind = exports2.DiagnosticServerCancellationData = void 0;
    var vscode_jsonrpc_1 = require_main();
    var Is2 = require_is2();
    var messages_1 = require_messages2();
    var DiagnosticServerCancellationData;
    (function(DiagnosticServerCancellationData2) {
      function is(value) {
        const candidate = value;
        return candidate && Is2.boolean(candidate.retriggerRequest);
      }
      DiagnosticServerCancellationData2.is = is;
    })(DiagnosticServerCancellationData || (exports2.DiagnosticServerCancellationData = DiagnosticServerCancellationData = {}));
    var DocumentDiagnosticReportKind2;
    (function(DocumentDiagnosticReportKind3) {
      DocumentDiagnosticReportKind3.Full = "full";
      DocumentDiagnosticReportKind3.Unchanged = "unchanged";
    })(DocumentDiagnosticReportKind2 || (exports2.DocumentDiagnosticReportKind = DocumentDiagnosticReportKind2 = {}));
    var DocumentDiagnosticRequest;
    (function(DocumentDiagnosticRequest2) {
      DocumentDiagnosticRequest2.method = "textDocument/diagnostic";
      DocumentDiagnosticRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentDiagnosticRequest2.type = new messages_1.ProtocolRequestType(DocumentDiagnosticRequest2.method);
      DocumentDiagnosticRequest2.partialResult = new vscode_jsonrpc_1.ProgressType();
    })(DocumentDiagnosticRequest || (exports2.DocumentDiagnosticRequest = DocumentDiagnosticRequest = {}));
    var WorkspaceDiagnosticRequest;
    (function(WorkspaceDiagnosticRequest2) {
      WorkspaceDiagnosticRequest2.method = "workspace/diagnostic";
      WorkspaceDiagnosticRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceDiagnosticRequest2.type = new messages_1.ProtocolRequestType(WorkspaceDiagnosticRequest2.method);
      WorkspaceDiagnosticRequest2.partialResult = new vscode_jsonrpc_1.ProgressType();
    })(WorkspaceDiagnosticRequest || (exports2.WorkspaceDiagnosticRequest = WorkspaceDiagnosticRequest = {}));
    var DiagnosticRefreshRequest;
    (function(DiagnosticRefreshRequest2) {
      DiagnosticRefreshRequest2.method = `workspace/diagnostic/refresh`;
      DiagnosticRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      DiagnosticRefreshRequest2.type = new messages_1.ProtocolRequestType0(DiagnosticRefreshRequest2.method);
    })(DiagnosticRefreshRequest || (exports2.DiagnosticRefreshRequest = DiagnosticRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js
var require_protocol_notebook = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DidCloseNotebookDocumentNotification = exports2.DidSaveNotebookDocumentNotification = exports2.DidChangeNotebookDocumentNotification = exports2.NotebookCellArrayChange = exports2.DidOpenNotebookDocumentNotification = exports2.NotebookDocumentSyncRegistrationType = exports2.NotebookDocument = exports2.NotebookCell = exports2.ExecutionSummary = exports2.NotebookCellKind = void 0;
    var vscode_languageserver_types_1 = (init_main(), __toCommonJS(main_exports));
    var Is2 = require_is2();
    var messages_1 = require_messages2();
    var NotebookCellKind;
    (function(NotebookCellKind2) {
      NotebookCellKind2.Markup = 1;
      NotebookCellKind2.Code = 2;
      function is(value) {
        return value === 1 || value === 2;
      }
      NotebookCellKind2.is = is;
    })(NotebookCellKind || (exports2.NotebookCellKind = NotebookCellKind = {}));
    var ExecutionSummary;
    (function(ExecutionSummary2) {
      function create(executionOrder, success) {
        const result = { executionOrder };
        if (success === true || success === false) {
          result.success = success;
        }
        return result;
      }
      ExecutionSummary2.create = create;
      function is(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.executionOrder) && (candidate.success === void 0 || Is2.boolean(candidate.success));
      }
      ExecutionSummary2.is = is;
      function equals(one, other) {
        if (one === other) {
          return true;
        }
        if (one === null || one === void 0 || other === null || other === void 0) {
          return false;
        }
        return one.executionOrder === other.executionOrder && one.success === other.success;
      }
      ExecutionSummary2.equals = equals;
    })(ExecutionSummary || (exports2.ExecutionSummary = ExecutionSummary = {}));
    var NotebookCell;
    (function(NotebookCell2) {
      function create(kind, document2) {
        return { kind, document: document2 };
      }
      NotebookCell2.create = create;
      function is(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && NotebookCellKind.is(candidate.kind) && vscode_languageserver_types_1.DocumentUri.is(candidate.document) && (candidate.metadata === void 0 || Is2.objectLiteral(candidate.metadata));
      }
      NotebookCell2.is = is;
      function diff(one, two) {
        const result = /* @__PURE__ */ new Set();
        if (one.document !== two.document) {
          result.add("document");
        }
        if (one.kind !== two.kind) {
          result.add("kind");
        }
        if (one.executionSummary !== two.executionSummary) {
          result.add("executionSummary");
        }
        if ((one.metadata !== void 0 || two.metadata !== void 0) && !equalsMetadata(one.metadata, two.metadata)) {
          result.add("metadata");
        }
        if ((one.executionSummary !== void 0 || two.executionSummary !== void 0) && !ExecutionSummary.equals(one.executionSummary, two.executionSummary)) {
          result.add("executionSummary");
        }
        return result;
      }
      NotebookCell2.diff = diff;
      function equalsMetadata(one, other) {
        if (one === other) {
          return true;
        }
        if (one === null || one === void 0 || other === null || other === void 0) {
          return false;
        }
        if (typeof one !== typeof other) {
          return false;
        }
        if (typeof one !== "object") {
          return false;
        }
        const oneArray = Array.isArray(one);
        const otherArray = Array.isArray(other);
        if (oneArray !== otherArray) {
          return false;
        }
        if (oneArray && otherArray) {
          if (one.length !== other.length) {
            return false;
          }
          for (let i = 0; i < one.length; i++) {
            if (!equalsMetadata(one[i], other[i])) {
              return false;
            }
          }
        }
        if (Is2.objectLiteral(one) && Is2.objectLiteral(other)) {
          const oneKeys = Object.keys(one);
          const otherKeys = Object.keys(other);
          if (oneKeys.length !== otherKeys.length) {
            return false;
          }
          oneKeys.sort();
          otherKeys.sort();
          if (!equalsMetadata(oneKeys, otherKeys)) {
            return false;
          }
          for (let i = 0; i < oneKeys.length; i++) {
            const prop = oneKeys[i];
            if (!equalsMetadata(one[prop], other[prop])) {
              return false;
            }
          }
        }
        return true;
      }
    })(NotebookCell || (exports2.NotebookCell = NotebookCell = {}));
    var NotebookDocument;
    (function(NotebookDocument2) {
      function create(uri, notebookType, version, cells) {
        return { uri, notebookType, version, cells };
      }
      NotebookDocument2.create = create;
      function is(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && Is2.string(candidate.uri) && vscode_languageserver_types_1.integer.is(candidate.version) && Is2.typedArray(candidate.cells, NotebookCell.is);
      }
      NotebookDocument2.is = is;
    })(NotebookDocument || (exports2.NotebookDocument = NotebookDocument = {}));
    var NotebookDocumentSyncRegistrationType;
    (function(NotebookDocumentSyncRegistrationType2) {
      NotebookDocumentSyncRegistrationType2.method = "notebookDocument/sync";
      NotebookDocumentSyncRegistrationType2.messageDirection = messages_1.MessageDirection.clientToServer;
      NotebookDocumentSyncRegistrationType2.type = new messages_1.RegistrationType(NotebookDocumentSyncRegistrationType2.method);
    })(NotebookDocumentSyncRegistrationType || (exports2.NotebookDocumentSyncRegistrationType = NotebookDocumentSyncRegistrationType = {}));
    var DidOpenNotebookDocumentNotification;
    (function(DidOpenNotebookDocumentNotification2) {
      DidOpenNotebookDocumentNotification2.method = "notebookDocument/didOpen";
      DidOpenNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidOpenNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenNotebookDocumentNotification2.method);
      DidOpenNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidOpenNotebookDocumentNotification || (exports2.DidOpenNotebookDocumentNotification = DidOpenNotebookDocumentNotification = {}));
    var NotebookCellArrayChange;
    (function(NotebookCellArrayChange2) {
      function is(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.start) && vscode_languageserver_types_1.uinteger.is(candidate.deleteCount) && (candidate.cells === void 0 || Is2.typedArray(candidate.cells, NotebookCell.is));
      }
      NotebookCellArrayChange2.is = is;
      function create(start, deleteCount, cells) {
        const result = { start, deleteCount };
        if (cells !== void 0) {
          result.cells = cells;
        }
        return result;
      }
      NotebookCellArrayChange2.create = create;
    })(NotebookCellArrayChange || (exports2.NotebookCellArrayChange = NotebookCellArrayChange = {}));
    var DidChangeNotebookDocumentNotification;
    (function(DidChangeNotebookDocumentNotification2) {
      DidChangeNotebookDocumentNotification2.method = "notebookDocument/didChange";
      DidChangeNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeNotebookDocumentNotification2.method);
      DidChangeNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidChangeNotebookDocumentNotification || (exports2.DidChangeNotebookDocumentNotification = DidChangeNotebookDocumentNotification = {}));
    var DidSaveNotebookDocumentNotification;
    (function(DidSaveNotebookDocumentNotification2) {
      DidSaveNotebookDocumentNotification2.method = "notebookDocument/didSave";
      DidSaveNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidSaveNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveNotebookDocumentNotification2.method);
      DidSaveNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidSaveNotebookDocumentNotification || (exports2.DidSaveNotebookDocumentNotification = DidSaveNotebookDocumentNotification = {}));
    var DidCloseNotebookDocumentNotification;
    (function(DidCloseNotebookDocumentNotification2) {
      DidCloseNotebookDocumentNotification2.method = "notebookDocument/didClose";
      DidCloseNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCloseNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseNotebookDocumentNotification2.method);
      DidCloseNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidCloseNotebookDocumentNotification || (exports2.DidCloseNotebookDocumentNotification = DidCloseNotebookDocumentNotification = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineCompletion.js
var require_protocol_inlineCompletion = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineCompletion.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlineCompletionRequest = void 0;
    var messages_1 = require_messages2();
    var InlineCompletionRequest;
    (function(InlineCompletionRequest2) {
      InlineCompletionRequest2.method = "textDocument/inlineCompletion";
      InlineCompletionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlineCompletionRequest2.type = new messages_1.ProtocolRequestType(InlineCompletionRequest2.method);
    })(InlineCompletionRequest || (exports2.InlineCompletionRequest = InlineCompletionRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.js
var require_protocol = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkspaceSymbolRequest = exports2.CodeActionResolveRequest = exports2.CodeActionRequest = exports2.DocumentSymbolRequest = exports2.DocumentHighlightRequest = exports2.ReferencesRequest = exports2.DefinitionRequest = exports2.SignatureHelpRequest = exports2.SignatureHelpTriggerKind = exports2.HoverRequest = exports2.CompletionResolveRequest = exports2.CompletionRequest = exports2.CompletionTriggerKind = exports2.PublishDiagnosticsNotification = exports2.WatchKind = exports2.RelativePattern = exports2.FileChangeType = exports2.DidChangeWatchedFilesNotification = exports2.WillSaveTextDocumentWaitUntilRequest = exports2.WillSaveTextDocumentNotification = exports2.TextDocumentSaveReason = exports2.DidSaveTextDocumentNotification = exports2.DidCloseTextDocumentNotification = exports2.DidChangeTextDocumentNotification = exports2.TextDocumentContentChangeEvent = exports2.DidOpenTextDocumentNotification = exports2.TextDocumentSyncKind = exports2.TelemetryEventNotification = exports2.LogMessageNotification = exports2.ShowMessageRequest = exports2.ShowMessageNotification = exports2.MessageType = exports2.DidChangeConfigurationNotification = exports2.ExitNotification = exports2.ShutdownRequest = exports2.InitializedNotification = exports2.InitializeErrorCodes = exports2.InitializeRequest = exports2.WorkDoneProgressOptions = exports2.TextDocumentRegistrationOptions = exports2.StaticRegistrationOptions = exports2.PositionEncodingKind = exports2.FailureHandlingKind = exports2.ResourceOperationKind = exports2.UnregistrationRequest = exports2.RegistrationRequest = exports2.DocumentSelector = exports2.NotebookCellTextDocumentFilter = exports2.NotebookDocumentFilter = exports2.TextDocumentFilter = void 0;
    exports2.MonikerRequest = exports2.MonikerKind = exports2.UniquenessLevel = exports2.WillDeleteFilesRequest = exports2.DidDeleteFilesNotification = exports2.WillRenameFilesRequest = exports2.DidRenameFilesNotification = exports2.WillCreateFilesRequest = exports2.DidCreateFilesNotification = exports2.FileOperationPatternKind = exports2.LinkedEditingRangeRequest = exports2.ShowDocumentRequest = exports2.SemanticTokensRegistrationType = exports2.SemanticTokensRefreshRequest = exports2.SemanticTokensRangeRequest = exports2.SemanticTokensDeltaRequest = exports2.SemanticTokensRequest = exports2.TokenFormat = exports2.CallHierarchyPrepareRequest = exports2.CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyIncomingCallsRequest = exports2.WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCreateRequest = exports2.WorkDoneProgress = exports2.SelectionRangeRequest = exports2.DeclarationRequest = exports2.FoldingRangeRefreshRequest = exports2.FoldingRangeRequest = exports2.ColorPresentationRequest = exports2.DocumentColorRequest = exports2.ConfigurationRequest = exports2.DidChangeWorkspaceFoldersNotification = exports2.WorkspaceFoldersRequest = exports2.TypeDefinitionRequest = exports2.ImplementationRequest = exports2.ApplyWorkspaceEditRequest = exports2.ExecuteCommandRequest = exports2.PrepareRenameRequest = exports2.RenameRequest = exports2.PrepareSupportDefaultBehavior = exports2.DocumentOnTypeFormattingRequest = exports2.DocumentRangesFormattingRequest = exports2.DocumentRangeFormattingRequest = exports2.DocumentFormattingRequest = exports2.DocumentLinkResolveRequest = exports2.DocumentLinkRequest = exports2.CodeLensRefreshRequest = exports2.CodeLensResolveRequest = exports2.CodeLensRequest = exports2.WorkspaceSymbolResolveRequest = void 0;
    exports2.InlineCompletionRequest = exports2.DidCloseNotebookDocumentNotification = exports2.DidSaveNotebookDocumentNotification = exports2.DidChangeNotebookDocumentNotification = exports2.NotebookCellArrayChange = exports2.DidOpenNotebookDocumentNotification = exports2.NotebookDocumentSyncRegistrationType = exports2.NotebookDocument = exports2.NotebookCell = exports2.ExecutionSummary = exports2.NotebookCellKind = exports2.DiagnosticRefreshRequest = exports2.WorkspaceDiagnosticRequest = exports2.DocumentDiagnosticRequest = exports2.DocumentDiagnosticReportKind = exports2.DiagnosticServerCancellationData = exports2.InlayHintRefreshRequest = exports2.InlayHintResolveRequest = exports2.InlayHintRequest = exports2.InlineValueRefreshRequest = exports2.InlineValueRequest = exports2.TypeHierarchySupertypesRequest = exports2.TypeHierarchySubtypesRequest = exports2.TypeHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var vscode_languageserver_types_1 = (init_main(), __toCommonJS(main_exports));
    var Is2 = require_is2();
    var protocol_implementation_1 = require_protocol_implementation();
    Object.defineProperty(exports2, "ImplementationRequest", { enumerable: true, get: function() {
      return protocol_implementation_1.ImplementationRequest;
    } });
    var protocol_typeDefinition_1 = require_protocol_typeDefinition();
    Object.defineProperty(exports2, "TypeDefinitionRequest", { enumerable: true, get: function() {
      return protocol_typeDefinition_1.TypeDefinitionRequest;
    } });
    var protocol_workspaceFolder_1 = require_protocol_workspaceFolder();
    Object.defineProperty(exports2, "WorkspaceFoldersRequest", { enumerable: true, get: function() {
      return protocol_workspaceFolder_1.WorkspaceFoldersRequest;
    } });
    Object.defineProperty(exports2, "DidChangeWorkspaceFoldersNotification", { enumerable: true, get: function() {
      return protocol_workspaceFolder_1.DidChangeWorkspaceFoldersNotification;
    } });
    var protocol_configuration_1 = require_protocol_configuration();
    Object.defineProperty(exports2, "ConfigurationRequest", { enumerable: true, get: function() {
      return protocol_configuration_1.ConfigurationRequest;
    } });
    var protocol_colorProvider_1 = require_protocol_colorProvider();
    Object.defineProperty(exports2, "DocumentColorRequest", { enumerable: true, get: function() {
      return protocol_colorProvider_1.DocumentColorRequest;
    } });
    Object.defineProperty(exports2, "ColorPresentationRequest", { enumerable: true, get: function() {
      return protocol_colorProvider_1.ColorPresentationRequest;
    } });
    var protocol_foldingRange_1 = require_protocol_foldingRange();
    Object.defineProperty(exports2, "FoldingRangeRequest", { enumerable: true, get: function() {
      return protocol_foldingRange_1.FoldingRangeRequest;
    } });
    Object.defineProperty(exports2, "FoldingRangeRefreshRequest", { enumerable: true, get: function() {
      return protocol_foldingRange_1.FoldingRangeRefreshRequest;
    } });
    var protocol_declaration_1 = require_protocol_declaration();
    Object.defineProperty(exports2, "DeclarationRequest", { enumerable: true, get: function() {
      return protocol_declaration_1.DeclarationRequest;
    } });
    var protocol_selectionRange_1 = require_protocol_selectionRange();
    Object.defineProperty(exports2, "SelectionRangeRequest", { enumerable: true, get: function() {
      return protocol_selectionRange_1.SelectionRangeRequest;
    } });
    var protocol_progress_1 = require_protocol_progress();
    Object.defineProperty(exports2, "WorkDoneProgress", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgress;
    } });
    Object.defineProperty(exports2, "WorkDoneProgressCreateRequest", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgressCreateRequest;
    } });
    Object.defineProperty(exports2, "WorkDoneProgressCancelNotification", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgressCancelNotification;
    } });
    var protocol_callHierarchy_1 = require_protocol_callHierarchy();
    Object.defineProperty(exports2, "CallHierarchyIncomingCallsRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest;
    } });
    Object.defineProperty(exports2, "CallHierarchyOutgoingCallsRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest;
    } });
    Object.defineProperty(exports2, "CallHierarchyPrepareRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyPrepareRequest;
    } });
    var protocol_semanticTokens_1 = require_protocol_semanticTokens();
    Object.defineProperty(exports2, "TokenFormat", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.TokenFormat;
    } });
    Object.defineProperty(exports2, "SemanticTokensRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensDeltaRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensDeltaRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensRangeRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRangeRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensRefreshRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRefreshRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensRegistrationType", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRegistrationType;
    } });
    var protocol_showDocument_1 = require_protocol_showDocument();
    Object.defineProperty(exports2, "ShowDocumentRequest", { enumerable: true, get: function() {
      return protocol_showDocument_1.ShowDocumentRequest;
    } });
    var protocol_linkedEditingRange_1 = require_protocol_linkedEditingRange();
    Object.defineProperty(exports2, "LinkedEditingRangeRequest", { enumerable: true, get: function() {
      return protocol_linkedEditingRange_1.LinkedEditingRangeRequest;
    } });
    var protocol_fileOperations_1 = require_protocol_fileOperations();
    Object.defineProperty(exports2, "FileOperationPatternKind", { enumerable: true, get: function() {
      return protocol_fileOperations_1.FileOperationPatternKind;
    } });
    Object.defineProperty(exports2, "DidCreateFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidCreateFilesNotification;
    } });
    Object.defineProperty(exports2, "WillCreateFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillCreateFilesRequest;
    } });
    Object.defineProperty(exports2, "DidRenameFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidRenameFilesNotification;
    } });
    Object.defineProperty(exports2, "WillRenameFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillRenameFilesRequest;
    } });
    Object.defineProperty(exports2, "DidDeleteFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidDeleteFilesNotification;
    } });
    Object.defineProperty(exports2, "WillDeleteFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillDeleteFilesRequest;
    } });
    var protocol_moniker_1 = require_protocol_moniker();
    Object.defineProperty(exports2, "UniquenessLevel", { enumerable: true, get: function() {
      return protocol_moniker_1.UniquenessLevel;
    } });
    Object.defineProperty(exports2, "MonikerKind", { enumerable: true, get: function() {
      return protocol_moniker_1.MonikerKind;
    } });
    Object.defineProperty(exports2, "MonikerRequest", { enumerable: true, get: function() {
      return protocol_moniker_1.MonikerRequest;
    } });
    var protocol_typeHierarchy_1 = require_protocol_typeHierarchy();
    Object.defineProperty(exports2, "TypeHierarchyPrepareRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchyPrepareRequest;
    } });
    Object.defineProperty(exports2, "TypeHierarchySubtypesRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchySubtypesRequest;
    } });
    Object.defineProperty(exports2, "TypeHierarchySupertypesRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchySupertypesRequest;
    } });
    var protocol_inlineValue_1 = require_protocol_inlineValue();
    Object.defineProperty(exports2, "InlineValueRequest", { enumerable: true, get: function() {
      return protocol_inlineValue_1.InlineValueRequest;
    } });
    Object.defineProperty(exports2, "InlineValueRefreshRequest", { enumerable: true, get: function() {
      return protocol_inlineValue_1.InlineValueRefreshRequest;
    } });
    var protocol_inlayHint_1 = require_protocol_inlayHint();
    Object.defineProperty(exports2, "InlayHintRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintRequest;
    } });
    Object.defineProperty(exports2, "InlayHintResolveRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintResolveRequest;
    } });
    Object.defineProperty(exports2, "InlayHintRefreshRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintRefreshRequest;
    } });
    var protocol_diagnostic_1 = require_protocol_diagnostic();
    Object.defineProperty(exports2, "DiagnosticServerCancellationData", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DiagnosticServerCancellationData;
    } });
    Object.defineProperty(exports2, "DocumentDiagnosticReportKind", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DocumentDiagnosticReportKind;
    } });
    Object.defineProperty(exports2, "DocumentDiagnosticRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DocumentDiagnosticRequest;
    } });
    Object.defineProperty(exports2, "WorkspaceDiagnosticRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.WorkspaceDiagnosticRequest;
    } });
    Object.defineProperty(exports2, "DiagnosticRefreshRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DiagnosticRefreshRequest;
    } });
    var protocol_notebook_1 = require_protocol_notebook();
    Object.defineProperty(exports2, "NotebookCellKind", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCellKind;
    } });
    Object.defineProperty(exports2, "ExecutionSummary", { enumerable: true, get: function() {
      return protocol_notebook_1.ExecutionSummary;
    } });
    Object.defineProperty(exports2, "NotebookCell", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCell;
    } });
    Object.defineProperty(exports2, "NotebookDocument", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookDocument;
    } });
    Object.defineProperty(exports2, "NotebookDocumentSyncRegistrationType", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookDocumentSyncRegistrationType;
    } });
    Object.defineProperty(exports2, "DidOpenNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidOpenNotebookDocumentNotification;
    } });
    Object.defineProperty(exports2, "NotebookCellArrayChange", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCellArrayChange;
    } });
    Object.defineProperty(exports2, "DidChangeNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidChangeNotebookDocumentNotification;
    } });
    Object.defineProperty(exports2, "DidSaveNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidSaveNotebookDocumentNotification;
    } });
    Object.defineProperty(exports2, "DidCloseNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidCloseNotebookDocumentNotification;
    } });
    var protocol_inlineCompletion_1 = require_protocol_inlineCompletion();
    Object.defineProperty(exports2, "InlineCompletionRequest", { enumerable: true, get: function() {
      return protocol_inlineCompletion_1.InlineCompletionRequest;
    } });
    var TextDocumentFilter;
    (function(TextDocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is2.string(candidate) || (Is2.string(candidate.language) || Is2.string(candidate.scheme) || Is2.string(candidate.pattern));
      }
      TextDocumentFilter2.is = is;
    })(TextDocumentFilter || (exports2.TextDocumentFilter = TextDocumentFilter = {}));
    var NotebookDocumentFilter;
    (function(NotebookDocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && (Is2.string(candidate.notebookType) || Is2.string(candidate.scheme) || Is2.string(candidate.pattern));
      }
      NotebookDocumentFilter2.is = is;
    })(NotebookDocumentFilter || (exports2.NotebookDocumentFilter = NotebookDocumentFilter = {}));
    var NotebookCellTextDocumentFilter;
    (function(NotebookCellTextDocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && (Is2.string(candidate.notebook) || NotebookDocumentFilter.is(candidate.notebook)) && (candidate.language === void 0 || Is2.string(candidate.language));
      }
      NotebookCellTextDocumentFilter2.is = is;
    })(NotebookCellTextDocumentFilter || (exports2.NotebookCellTextDocumentFilter = NotebookCellTextDocumentFilter = {}));
    var DocumentSelector;
    (function(DocumentSelector2) {
      function is(value) {
        if (!Array.isArray(value)) {
          return false;
        }
        for (let elem of value) {
          if (!Is2.string(elem) && !TextDocumentFilter.is(elem) && !NotebookCellTextDocumentFilter.is(elem)) {
            return false;
          }
        }
        return true;
      }
      DocumentSelector2.is = is;
    })(DocumentSelector || (exports2.DocumentSelector = DocumentSelector = {}));
    var RegistrationRequest;
    (function(RegistrationRequest2) {
      RegistrationRequest2.method = "client/registerCapability";
      RegistrationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      RegistrationRequest2.type = new messages_1.ProtocolRequestType(RegistrationRequest2.method);
    })(RegistrationRequest || (exports2.RegistrationRequest = RegistrationRequest = {}));
    var UnregistrationRequest;
    (function(UnregistrationRequest2) {
      UnregistrationRequest2.method = "client/unregisterCapability";
      UnregistrationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      UnregistrationRequest2.type = new messages_1.ProtocolRequestType(UnregistrationRequest2.method);
    })(UnregistrationRequest || (exports2.UnregistrationRequest = UnregistrationRequest = {}));
    var ResourceOperationKind;
    (function(ResourceOperationKind2) {
      ResourceOperationKind2.Create = "create";
      ResourceOperationKind2.Rename = "rename";
      ResourceOperationKind2.Delete = "delete";
    })(ResourceOperationKind || (exports2.ResourceOperationKind = ResourceOperationKind = {}));
    var FailureHandlingKind;
    (function(FailureHandlingKind2) {
      FailureHandlingKind2.Abort = "abort";
      FailureHandlingKind2.Transactional = "transactional";
      FailureHandlingKind2.TextOnlyTransactional = "textOnlyTransactional";
      FailureHandlingKind2.Undo = "undo";
    })(FailureHandlingKind || (exports2.FailureHandlingKind = FailureHandlingKind = {}));
    var PositionEncodingKind;
    (function(PositionEncodingKind2) {
      PositionEncodingKind2.UTF8 = "utf-8";
      PositionEncodingKind2.UTF16 = "utf-16";
      PositionEncodingKind2.UTF32 = "utf-32";
    })(PositionEncodingKind || (exports2.PositionEncodingKind = PositionEncodingKind = {}));
    var StaticRegistrationOptions;
    (function(StaticRegistrationOptions2) {
      function hasId(value) {
        const candidate = value;
        return candidate && Is2.string(candidate.id) && candidate.id.length > 0;
      }
      StaticRegistrationOptions2.hasId = hasId;
    })(StaticRegistrationOptions || (exports2.StaticRegistrationOptions = StaticRegistrationOptions = {}));
    var TextDocumentRegistrationOptions;
    (function(TextDocumentRegistrationOptions2) {
      function is(value) {
        const candidate = value;
        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
      }
      TextDocumentRegistrationOptions2.is = is;
    })(TextDocumentRegistrationOptions || (exports2.TextDocumentRegistrationOptions = TextDocumentRegistrationOptions = {}));
    var WorkDoneProgressOptions;
    (function(WorkDoneProgressOptions2) {
      function is(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && (candidate.workDoneProgress === void 0 || Is2.boolean(candidate.workDoneProgress));
      }
      WorkDoneProgressOptions2.is = is;
      function hasWorkDoneProgress(value) {
        const candidate = value;
        return candidate && Is2.boolean(candidate.workDoneProgress);
      }
      WorkDoneProgressOptions2.hasWorkDoneProgress = hasWorkDoneProgress;
    })(WorkDoneProgressOptions || (exports2.WorkDoneProgressOptions = WorkDoneProgressOptions = {}));
    var InitializeRequest;
    (function(InitializeRequest2) {
      InitializeRequest2.method = "initialize";
      InitializeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InitializeRequest2.type = new messages_1.ProtocolRequestType(InitializeRequest2.method);
    })(InitializeRequest || (exports2.InitializeRequest = InitializeRequest = {}));
    var InitializeErrorCodes;
    (function(InitializeErrorCodes2) {
      InitializeErrorCodes2.unknownProtocolVersion = 1;
    })(InitializeErrorCodes || (exports2.InitializeErrorCodes = InitializeErrorCodes = {}));
    var InitializedNotification;
    (function(InitializedNotification2) {
      InitializedNotification2.method = "initialized";
      InitializedNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      InitializedNotification2.type = new messages_1.ProtocolNotificationType(InitializedNotification2.method);
    })(InitializedNotification || (exports2.InitializedNotification = InitializedNotification = {}));
    var ShutdownRequest;
    (function(ShutdownRequest2) {
      ShutdownRequest2.method = "shutdown";
      ShutdownRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ShutdownRequest2.type = new messages_1.ProtocolRequestType0(ShutdownRequest2.method);
    })(ShutdownRequest || (exports2.ShutdownRequest = ShutdownRequest = {}));
    var ExitNotification;
    (function(ExitNotification2) {
      ExitNotification2.method = "exit";
      ExitNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      ExitNotification2.type = new messages_1.ProtocolNotificationType0(ExitNotification2.method);
    })(ExitNotification || (exports2.ExitNotification = ExitNotification = {}));
    var DidChangeConfigurationNotification2;
    (function(DidChangeConfigurationNotification3) {
      DidChangeConfigurationNotification3.method = "workspace/didChangeConfiguration";
      DidChangeConfigurationNotification3.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeConfigurationNotification3.type = new messages_1.ProtocolNotificationType(DidChangeConfigurationNotification3.method);
    })(DidChangeConfigurationNotification2 || (exports2.DidChangeConfigurationNotification = DidChangeConfigurationNotification2 = {}));
    var MessageType;
    (function(MessageType2) {
      MessageType2.Error = 1;
      MessageType2.Warning = 2;
      MessageType2.Info = 3;
      MessageType2.Log = 4;
      MessageType2.Debug = 5;
    })(MessageType || (exports2.MessageType = MessageType = {}));
    var ShowMessageNotification;
    (function(ShowMessageNotification2) {
      ShowMessageNotification2.method = "window/showMessage";
      ShowMessageNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowMessageNotification2.type = new messages_1.ProtocolNotificationType(ShowMessageNotification2.method);
    })(ShowMessageNotification || (exports2.ShowMessageNotification = ShowMessageNotification = {}));
    var ShowMessageRequest;
    (function(ShowMessageRequest2) {
      ShowMessageRequest2.method = "window/showMessageRequest";
      ShowMessageRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowMessageRequest2.type = new messages_1.ProtocolRequestType(ShowMessageRequest2.method);
    })(ShowMessageRequest || (exports2.ShowMessageRequest = ShowMessageRequest = {}));
    var LogMessageNotification;
    (function(LogMessageNotification2) {
      LogMessageNotification2.method = "window/logMessage";
      LogMessageNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      LogMessageNotification2.type = new messages_1.ProtocolNotificationType(LogMessageNotification2.method);
    })(LogMessageNotification || (exports2.LogMessageNotification = LogMessageNotification = {}));
    var TelemetryEventNotification;
    (function(TelemetryEventNotification2) {
      TelemetryEventNotification2.method = "telemetry/event";
      TelemetryEventNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      TelemetryEventNotification2.type = new messages_1.ProtocolNotificationType(TelemetryEventNotification2.method);
    })(TelemetryEventNotification || (exports2.TelemetryEventNotification = TelemetryEventNotification = {}));
    var TextDocumentSyncKind2;
    (function(TextDocumentSyncKind3) {
      TextDocumentSyncKind3.None = 0;
      TextDocumentSyncKind3.Full = 1;
      TextDocumentSyncKind3.Incremental = 2;
    })(TextDocumentSyncKind2 || (exports2.TextDocumentSyncKind = TextDocumentSyncKind2 = {}));
    var DidOpenTextDocumentNotification;
    (function(DidOpenTextDocumentNotification2) {
      DidOpenTextDocumentNotification2.method = "textDocument/didOpen";
      DidOpenTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidOpenTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification2.method);
    })(DidOpenTextDocumentNotification || (exports2.DidOpenTextDocumentNotification = DidOpenTextDocumentNotification = {}));
    var TextDocumentContentChangeEvent;
    (function(TextDocumentContentChangeEvent2) {
      function isIncremental(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
      }
      TextDocumentContentChangeEvent2.isIncremental = isIncremental;
      function isFull(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
      }
      TextDocumentContentChangeEvent2.isFull = isFull;
    })(TextDocumentContentChangeEvent || (exports2.TextDocumentContentChangeEvent = TextDocumentContentChangeEvent = {}));
    var DidChangeTextDocumentNotification;
    (function(DidChangeTextDocumentNotification2) {
      DidChangeTextDocumentNotification2.method = "textDocument/didChange";
      DidChangeTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification2.method);
    })(DidChangeTextDocumentNotification || (exports2.DidChangeTextDocumentNotification = DidChangeTextDocumentNotification = {}));
    var DidCloseTextDocumentNotification;
    (function(DidCloseTextDocumentNotification2) {
      DidCloseTextDocumentNotification2.method = "textDocument/didClose";
      DidCloseTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCloseTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification2.method);
    })(DidCloseTextDocumentNotification || (exports2.DidCloseTextDocumentNotification = DidCloseTextDocumentNotification = {}));
    var DidSaveTextDocumentNotification;
    (function(DidSaveTextDocumentNotification2) {
      DidSaveTextDocumentNotification2.method = "textDocument/didSave";
      DidSaveTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification2.method);
    })(DidSaveTextDocumentNotification || (exports2.DidSaveTextDocumentNotification = DidSaveTextDocumentNotification = {}));
    var TextDocumentSaveReason;
    (function(TextDocumentSaveReason2) {
      TextDocumentSaveReason2.Manual = 1;
      TextDocumentSaveReason2.AfterDelay = 2;
      TextDocumentSaveReason2.FocusOut = 3;
    })(TextDocumentSaveReason || (exports2.TextDocumentSaveReason = TextDocumentSaveReason = {}));
    var WillSaveTextDocumentNotification;
    (function(WillSaveTextDocumentNotification2) {
      WillSaveTextDocumentNotification2.method = "textDocument/willSave";
      WillSaveTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification2.method);
    })(WillSaveTextDocumentNotification || (exports2.WillSaveTextDocumentNotification = WillSaveTextDocumentNotification = {}));
    var WillSaveTextDocumentWaitUntilRequest;
    (function(WillSaveTextDocumentWaitUntilRequest2) {
      WillSaveTextDocumentWaitUntilRequest2.method = "textDocument/willSaveWaitUntil";
      WillSaveTextDocumentWaitUntilRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillSaveTextDocumentWaitUntilRequest2.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest2.method);
    })(WillSaveTextDocumentWaitUntilRequest || (exports2.WillSaveTextDocumentWaitUntilRequest = WillSaveTextDocumentWaitUntilRequest = {}));
    var DidChangeWatchedFilesNotification;
    (function(DidChangeWatchedFilesNotification2) {
      DidChangeWatchedFilesNotification2.method = "workspace/didChangeWatchedFiles";
      DidChangeWatchedFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeWatchedFilesNotification2.type = new messages_1.ProtocolNotificationType(DidChangeWatchedFilesNotification2.method);
    })(DidChangeWatchedFilesNotification || (exports2.DidChangeWatchedFilesNotification = DidChangeWatchedFilesNotification = {}));
    var FileChangeType;
    (function(FileChangeType2) {
      FileChangeType2.Created = 1;
      FileChangeType2.Changed = 2;
      FileChangeType2.Deleted = 3;
    })(FileChangeType || (exports2.FileChangeType = FileChangeType = {}));
    var RelativePattern;
    (function(RelativePattern2) {
      function is(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && (vscode_languageserver_types_1.URI.is(candidate.baseUri) || vscode_languageserver_types_1.WorkspaceFolder.is(candidate.baseUri)) && Is2.string(candidate.pattern);
      }
      RelativePattern2.is = is;
    })(RelativePattern || (exports2.RelativePattern = RelativePattern = {}));
    var WatchKind;
    (function(WatchKind2) {
      WatchKind2.Create = 1;
      WatchKind2.Change = 2;
      WatchKind2.Delete = 4;
    })(WatchKind || (exports2.WatchKind = WatchKind = {}));
    var PublishDiagnosticsNotification;
    (function(PublishDiagnosticsNotification2) {
      PublishDiagnosticsNotification2.method = "textDocument/publishDiagnostics";
      PublishDiagnosticsNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      PublishDiagnosticsNotification2.type = new messages_1.ProtocolNotificationType(PublishDiagnosticsNotification2.method);
    })(PublishDiagnosticsNotification || (exports2.PublishDiagnosticsNotification = PublishDiagnosticsNotification = {}));
    var CompletionTriggerKind;
    (function(CompletionTriggerKind2) {
      CompletionTriggerKind2.Invoked = 1;
      CompletionTriggerKind2.TriggerCharacter = 2;
      CompletionTriggerKind2.TriggerForIncompleteCompletions = 3;
    })(CompletionTriggerKind || (exports2.CompletionTriggerKind = CompletionTriggerKind = {}));
    var CompletionRequest;
    (function(CompletionRequest2) {
      CompletionRequest2.method = "textDocument/completion";
      CompletionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CompletionRequest2.type = new messages_1.ProtocolRequestType(CompletionRequest2.method);
    })(CompletionRequest || (exports2.CompletionRequest = CompletionRequest = {}));
    var CompletionResolveRequest;
    (function(CompletionResolveRequest2) {
      CompletionResolveRequest2.method = "completionItem/resolve";
      CompletionResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CompletionResolveRequest2.type = new messages_1.ProtocolRequestType(CompletionResolveRequest2.method);
    })(CompletionResolveRequest || (exports2.CompletionResolveRequest = CompletionResolveRequest = {}));
    var HoverRequest;
    (function(HoverRequest2) {
      HoverRequest2.method = "textDocument/hover";
      HoverRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      HoverRequest2.type = new messages_1.ProtocolRequestType(HoverRequest2.method);
    })(HoverRequest || (exports2.HoverRequest = HoverRequest = {}));
    var SignatureHelpTriggerKind;
    (function(SignatureHelpTriggerKind2) {
      SignatureHelpTriggerKind2.Invoked = 1;
      SignatureHelpTriggerKind2.TriggerCharacter = 2;
      SignatureHelpTriggerKind2.ContentChange = 3;
    })(SignatureHelpTriggerKind || (exports2.SignatureHelpTriggerKind = SignatureHelpTriggerKind = {}));
    var SignatureHelpRequest;
    (function(SignatureHelpRequest2) {
      SignatureHelpRequest2.method = "textDocument/signatureHelp";
      SignatureHelpRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SignatureHelpRequest2.type = new messages_1.ProtocolRequestType(SignatureHelpRequest2.method);
    })(SignatureHelpRequest || (exports2.SignatureHelpRequest = SignatureHelpRequest = {}));
    var DefinitionRequest;
    (function(DefinitionRequest2) {
      DefinitionRequest2.method = "textDocument/definition";
      DefinitionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DefinitionRequest2.type = new messages_1.ProtocolRequestType(DefinitionRequest2.method);
    })(DefinitionRequest || (exports2.DefinitionRequest = DefinitionRequest = {}));
    var ReferencesRequest;
    (function(ReferencesRequest2) {
      ReferencesRequest2.method = "textDocument/references";
      ReferencesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ReferencesRequest2.type = new messages_1.ProtocolRequestType(ReferencesRequest2.method);
    })(ReferencesRequest || (exports2.ReferencesRequest = ReferencesRequest = {}));
    var DocumentHighlightRequest;
    (function(DocumentHighlightRequest2) {
      DocumentHighlightRequest2.method = "textDocument/documentHighlight";
      DocumentHighlightRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentHighlightRequest2.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest2.method);
    })(DocumentHighlightRequest || (exports2.DocumentHighlightRequest = DocumentHighlightRequest = {}));
    var DocumentSymbolRequest;
    (function(DocumentSymbolRequest2) {
      DocumentSymbolRequest2.method = "textDocument/documentSymbol";
      DocumentSymbolRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentSymbolRequest2.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest2.method);
    })(DocumentSymbolRequest || (exports2.DocumentSymbolRequest = DocumentSymbolRequest = {}));
    var CodeActionRequest;
    (function(CodeActionRequest2) {
      CodeActionRequest2.method = "textDocument/codeAction";
      CodeActionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeActionRequest2.type = new messages_1.ProtocolRequestType(CodeActionRequest2.method);
    })(CodeActionRequest || (exports2.CodeActionRequest = CodeActionRequest = {}));
    var CodeActionResolveRequest;
    (function(CodeActionResolveRequest2) {
      CodeActionResolveRequest2.method = "codeAction/resolve";
      CodeActionResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeActionResolveRequest2.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest2.method);
    })(CodeActionResolveRequest || (exports2.CodeActionResolveRequest = CodeActionResolveRequest = {}));
    var WorkspaceSymbolRequest;
    (function(WorkspaceSymbolRequest2) {
      WorkspaceSymbolRequest2.method = "workspace/symbol";
      WorkspaceSymbolRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceSymbolRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest2.method);
    })(WorkspaceSymbolRequest || (exports2.WorkspaceSymbolRequest = WorkspaceSymbolRequest = {}));
    var WorkspaceSymbolResolveRequest;
    (function(WorkspaceSymbolResolveRequest2) {
      WorkspaceSymbolResolveRequest2.method = "workspaceSymbol/resolve";
      WorkspaceSymbolResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceSymbolResolveRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolResolveRequest2.method);
    })(WorkspaceSymbolResolveRequest || (exports2.WorkspaceSymbolResolveRequest = WorkspaceSymbolResolveRequest = {}));
    var CodeLensRequest;
    (function(CodeLensRequest2) {
      CodeLensRequest2.method = "textDocument/codeLens";
      CodeLensRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeLensRequest2.type = new messages_1.ProtocolRequestType(CodeLensRequest2.method);
    })(CodeLensRequest || (exports2.CodeLensRequest = CodeLensRequest = {}));
    var CodeLensResolveRequest;
    (function(CodeLensResolveRequest2) {
      CodeLensResolveRequest2.method = "codeLens/resolve";
      CodeLensResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeLensResolveRequest2.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest2.method);
    })(CodeLensResolveRequest || (exports2.CodeLensResolveRequest = CodeLensResolveRequest = {}));
    var CodeLensRefreshRequest;
    (function(CodeLensRefreshRequest2) {
      CodeLensRefreshRequest2.method = `workspace/codeLens/refresh`;
      CodeLensRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      CodeLensRefreshRequest2.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest2.method);
    })(CodeLensRefreshRequest || (exports2.CodeLensRefreshRequest = CodeLensRefreshRequest = {}));
    var DocumentLinkRequest;
    (function(DocumentLinkRequest2) {
      DocumentLinkRequest2.method = "textDocument/documentLink";
      DocumentLinkRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentLinkRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkRequest2.method);
    })(DocumentLinkRequest || (exports2.DocumentLinkRequest = DocumentLinkRequest = {}));
    var DocumentLinkResolveRequest;
    (function(DocumentLinkResolveRequest2) {
      DocumentLinkResolveRequest2.method = "documentLink/resolve";
      DocumentLinkResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentLinkResolveRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest2.method);
    })(DocumentLinkResolveRequest || (exports2.DocumentLinkResolveRequest = DocumentLinkResolveRequest = {}));
    var DocumentFormattingRequest;
    (function(DocumentFormattingRequest2) {
      DocumentFormattingRequest2.method = "textDocument/formatting";
      DocumentFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest2.method);
    })(DocumentFormattingRequest || (exports2.DocumentFormattingRequest = DocumentFormattingRequest = {}));
    var DocumentRangeFormattingRequest;
    (function(DocumentRangeFormattingRequest2) {
      DocumentRangeFormattingRequest2.method = "textDocument/rangeFormatting";
      DocumentRangeFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentRangeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest2.method);
    })(DocumentRangeFormattingRequest || (exports2.DocumentRangeFormattingRequest = DocumentRangeFormattingRequest = {}));
    var DocumentRangesFormattingRequest;
    (function(DocumentRangesFormattingRequest2) {
      DocumentRangesFormattingRequest2.method = "textDocument/rangesFormatting";
      DocumentRangesFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentRangesFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentRangesFormattingRequest2.method);
    })(DocumentRangesFormattingRequest || (exports2.DocumentRangesFormattingRequest = DocumentRangesFormattingRequest = {}));
    var DocumentOnTypeFormattingRequest;
    (function(DocumentOnTypeFormattingRequest2) {
      DocumentOnTypeFormattingRequest2.method = "textDocument/onTypeFormatting";
      DocumentOnTypeFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentOnTypeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest2.method);
    })(DocumentOnTypeFormattingRequest || (exports2.DocumentOnTypeFormattingRequest = DocumentOnTypeFormattingRequest = {}));
    var PrepareSupportDefaultBehavior;
    (function(PrepareSupportDefaultBehavior2) {
      PrepareSupportDefaultBehavior2.Identifier = 1;
    })(PrepareSupportDefaultBehavior || (exports2.PrepareSupportDefaultBehavior = PrepareSupportDefaultBehavior = {}));
    var RenameRequest;
    (function(RenameRequest2) {
      RenameRequest2.method = "textDocument/rename";
      RenameRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      RenameRequest2.type = new messages_1.ProtocolRequestType(RenameRequest2.method);
    })(RenameRequest || (exports2.RenameRequest = RenameRequest = {}));
    var PrepareRenameRequest;
    (function(PrepareRenameRequest2) {
      PrepareRenameRequest2.method = "textDocument/prepareRename";
      PrepareRenameRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      PrepareRenameRequest2.type = new messages_1.ProtocolRequestType(PrepareRenameRequest2.method);
    })(PrepareRenameRequest || (exports2.PrepareRenameRequest = PrepareRenameRequest = {}));
    var ExecuteCommandRequest;
    (function(ExecuteCommandRequest2) {
      ExecuteCommandRequest2.method = "workspace/executeCommand";
      ExecuteCommandRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ExecuteCommandRequest2.type = new messages_1.ProtocolRequestType(ExecuteCommandRequest2.method);
    })(ExecuteCommandRequest || (exports2.ExecuteCommandRequest = ExecuteCommandRequest = {}));
    var ApplyWorkspaceEditRequest;
    (function(ApplyWorkspaceEditRequest2) {
      ApplyWorkspaceEditRequest2.method = "workspace/applyEdit";
      ApplyWorkspaceEditRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ApplyWorkspaceEditRequest2.type = new messages_1.ProtocolRequestType("workspace/applyEdit");
    })(ApplyWorkspaceEditRequest || (exports2.ApplyWorkspaceEditRequest = ApplyWorkspaceEditRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/connection.js
var require_connection2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/connection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createProtocolConnection = void 0;
    var vscode_jsonrpc_1 = require_main();
    function createProtocolConnection(input, output, logger, options) {
      if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
      }
      return (0, vscode_jsonrpc_1.createMessageConnection)(input, output, logger, options);
    }
    exports2.createProtocolConnection = createProtocolConnection;
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/api.js
var require_api2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/api.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LSPErrorCodes = exports2.createProtocolConnection = void 0;
    __exportStar(require_main(), exports2);
    __exportStar((init_main(), __toCommonJS(main_exports)), exports2);
    __exportStar(require_messages2(), exports2);
    __exportStar(require_protocol(), exports2);
    var connection_1 = require_connection2();
    Object.defineProperty(exports2, "createProtocolConnection", { enumerable: true, get: function() {
      return connection_1.createProtocolConnection;
    } });
    var LSPErrorCodes;
    (function(LSPErrorCodes2) {
      LSPErrorCodes2.lspReservedErrorRangeStart = -32899;
      LSPErrorCodes2.RequestFailed = -32803;
      LSPErrorCodes2.ServerCancelled = -32802;
      LSPErrorCodes2.ContentModified = -32801;
      LSPErrorCodes2.RequestCancelled = -32800;
      LSPErrorCodes2.lspReservedErrorRangeEnd = -32800;
    })(LSPErrorCodes || (exports2.LSPErrorCodes = LSPErrorCodes = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/browser/main.js
var require_main2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/browser/main.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createProtocolConnection = void 0;
    var browser_1 = require_browser();
    __exportStar(require_browser(), exports2);
    __exportStar(require_api2(), exports2);
    function createProtocolConnection(reader, writer, logger, options) {
      return (0, browser_1.createMessageConnection)(reader, writer, logger, options);
    }
    exports2.createProtocolConnection = createProtocolConnection;
  }
});

// node_modules/vscode-languageserver/lib/common/semanticTokens.js
var require_semanticTokens = __commonJS({
  "node_modules/vscode-languageserver/lib/common/semanticTokens.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SemanticTokensBuilder = exports2.SemanticTokensDiff = exports2.SemanticTokensFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main2();
    var SemanticTokensFeature = (Base) => {
      return class extends Base {
        get semanticTokens() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.SemanticTokensRefreshRequest.type);
            },
            on: (handler) => {
              const type = vscode_languageserver_protocol_1.SemanticTokensRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            },
            onDelta: (handler) => {
              const type = vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            },
            onRange: (handler) => {
              const type = vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
    exports2.SemanticTokensFeature = SemanticTokensFeature;
    var SemanticTokensDiff = class {
      constructor(originalSequence, modifiedSequence) {
        this.originalSequence = originalSequence;
        this.modifiedSequence = modifiedSequence;
      }
      computeDiff() {
        const originalLength = this.originalSequence.length;
        const modifiedLength = this.modifiedSequence.length;
        let startIndex = 0;
        while (startIndex < modifiedLength && startIndex < originalLength && this.originalSequence[startIndex] === this.modifiedSequence[startIndex]) {
          startIndex++;
        }
        if (startIndex < modifiedLength && startIndex < originalLength) {
          let originalEndIndex = originalLength - 1;
          let modifiedEndIndex = modifiedLength - 1;
          while (originalEndIndex >= startIndex && modifiedEndIndex >= startIndex && this.originalSequence[originalEndIndex] === this.modifiedSequence[modifiedEndIndex]) {
            originalEndIndex--;
            modifiedEndIndex--;
          }
          if (originalEndIndex < startIndex || modifiedEndIndex < startIndex) {
            originalEndIndex++;
            modifiedEndIndex++;
          }
          const deleteCount = originalEndIndex - startIndex + 1;
          const newData = this.modifiedSequence.slice(startIndex, modifiedEndIndex + 1);
          if (newData.length === 1 && newData[0] === this.originalSequence[originalEndIndex]) {
            return [
              { start: startIndex, deleteCount: deleteCount - 1 }
            ];
          } else {
            return [
              { start: startIndex, deleteCount, data: newData }
            ];
          }
        } else if (startIndex < modifiedLength) {
          return [
            { start: startIndex, deleteCount: 0, data: this.modifiedSequence.slice(startIndex) }
          ];
        } else if (startIndex < originalLength) {
          return [
            { start: startIndex, deleteCount: originalLength - startIndex }
          ];
        } else {
          return [];
        }
      }
    };
    exports2.SemanticTokensDiff = SemanticTokensDiff;
    var SemanticTokensBuilder = class {
      constructor() {
        this._prevData = void 0;
        this.initialize();
      }
      initialize() {
        this._id = Date.now();
        this._prevLine = 0;
        this._prevChar = 0;
        this._data = [];
        this._dataLen = 0;
      }
      push(line, char, length, tokenType, tokenModifiers2) {
        let pushLine = line;
        let pushChar = char;
        if (this._dataLen > 0) {
          pushLine -= this._prevLine;
          if (pushLine === 0) {
            pushChar -= this._prevChar;
          }
        }
        this._data[this._dataLen++] = pushLine;
        this._data[this._dataLen++] = pushChar;
        this._data[this._dataLen++] = length;
        this._data[this._dataLen++] = tokenType;
        this._data[this._dataLen++] = tokenModifiers2;
        this._prevLine = line;
        this._prevChar = char;
      }
      get id() {
        return this._id.toString();
      }
      previousResult(id) {
        if (this.id === id) {
          this._prevData = this._data;
        }
        this.initialize();
      }
      build() {
        this._prevData = void 0;
        return {
          resultId: this.id,
          data: this._data
        };
      }
      canBuildEdits() {
        return this._prevData !== void 0;
      }
      buildEdits() {
        if (this._prevData !== void 0) {
          return {
            resultId: this.id,
            edits: new SemanticTokensDiff(this._prevData, this._data).computeDiff()
          };
        } else {
          return this.build();
        }
      }
    };
    exports2.SemanticTokensBuilder = SemanticTokensBuilder;
  }
});

// node_modules/vscode-languageserver/lib/common/inlineCompletion.proposed.js
var require_inlineCompletion_proposed = __commonJS({
  "node_modules/vscode-languageserver/lib/common/inlineCompletion.proposed.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlineCompletionFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main2();
    var InlineCompletionFeature = (Base) => {
      return class extends Base {
        get inlineCompletion() {
          return {
            on: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.InlineCompletionRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params));
              });
            }
          };
        }
      };
    };
    exports2.InlineCompletionFeature = InlineCompletionFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/textDocuments.js
var require_textDocuments = __commonJS({
  "node_modules/vscode-languageserver/lib/common/textDocuments.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TextDocuments = void 0;
    var vscode_languageserver_protocol_1 = require_main2();
    var TextDocuments2 = class {
      /**
       * Create a new text document manager.
       */
      constructor(configuration) {
        this._configuration = configuration;
        this._syncedDocuments = /* @__PURE__ */ new Map();
        this._onDidChangeContent = new vscode_languageserver_protocol_1.Emitter();
        this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();
        this._onDidClose = new vscode_languageserver_protocol_1.Emitter();
        this._onDidSave = new vscode_languageserver_protocol_1.Emitter();
        this._onWillSave = new vscode_languageserver_protocol_1.Emitter();
      }
      /**
       * An event that fires when a text document managed by this manager
       * has been opened.
       */
      get onDidOpen() {
        return this._onDidOpen.event;
      }
      /**
       * An event that fires when a text document managed by this manager
       * has been opened or the content changes.
       */
      get onDidChangeContent() {
        return this._onDidChangeContent.event;
      }
      /**
       * An event that fires when a text document managed by this manager
       * will be saved.
       */
      get onWillSave() {
        return this._onWillSave.event;
      }
      /**
       * Sets a handler that will be called if a participant wants to provide
       * edits during a text document save.
       */
      onWillSaveWaitUntil(handler) {
        this._willSaveWaitUntil = handler;
      }
      /**
       * An event that fires when a text document managed by this manager
       * has been saved.
       */
      get onDidSave() {
        return this._onDidSave.event;
      }
      /**
       * An event that fires when a text document managed by this manager
       * has been closed.
       */
      get onDidClose() {
        return this._onDidClose.event;
      }
      /**
       * Returns the document for the given URI. Returns undefined if
       * the document is not managed by this instance.
       *
       * @param uri The text document's URI to retrieve.
       * @return the text document or `undefined`.
       */
      get(uri) {
        return this._syncedDocuments.get(uri);
      }
      /**
       * Returns all text documents managed by this instance.
       *
       * @return all text documents.
       */
      all() {
        return Array.from(this._syncedDocuments.values());
      }
      /**
       * Returns the URIs of all text documents managed by this instance.
       *
       * @return the URI's of all text documents.
       */
      keys() {
        return Array.from(this._syncedDocuments.keys());
      }
      /**
       * Listens for `low level` notification on the given connection to
       * update the text documents managed by this instance.
       *
       * Please note that the connection only provides handlers not an event model. Therefore
       * listening on a connection will overwrite the following handlers on a connection:
       * `onDidOpenTextDocument`, `onDidChangeTextDocument`, `onDidCloseTextDocument`,
       * `onWillSaveTextDocument`, `onWillSaveTextDocumentWaitUntil` and `onDidSaveTextDocument`.
       *
       * Use the corresponding events on the TextDocuments instance instead.
       *
       * @param connection The connection to listen on.
       */
      listen(connection2) {
        connection2.__textDocumentSync = vscode_languageserver_protocol_1.TextDocumentSyncKind.Incremental;
        const disposables = [];
        disposables.push(connection2.onDidOpenTextDocument((event) => {
          const td = event.textDocument;
          const document2 = this._configuration.create(td.uri, td.languageId, td.version, td.text);
          this._syncedDocuments.set(td.uri, document2);
          const toFire = Object.freeze({ document: document2 });
          this._onDidOpen.fire(toFire);
          this._onDidChangeContent.fire(toFire);
        }));
        disposables.push(connection2.onDidChangeTextDocument((event) => {
          const td = event.textDocument;
          const changes = event.contentChanges;
          if (changes.length === 0) {
            return;
          }
          const { version } = td;
          if (version === null || version === void 0) {
            throw new Error(`Received document change event for ${td.uri} without valid version identifier`);
          }
          let syncedDocument = this._syncedDocuments.get(td.uri);
          if (syncedDocument !== void 0) {
            syncedDocument = this._configuration.update(syncedDocument, changes, version);
            this._syncedDocuments.set(td.uri, syncedDocument);
            this._onDidChangeContent.fire(Object.freeze({ document: syncedDocument }));
          }
        }));
        disposables.push(connection2.onDidCloseTextDocument((event) => {
          let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
          if (syncedDocument !== void 0) {
            this._syncedDocuments.delete(event.textDocument.uri);
            this._onDidClose.fire(Object.freeze({ document: syncedDocument }));
          }
        }));
        disposables.push(connection2.onWillSaveTextDocument((event) => {
          let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
          if (syncedDocument !== void 0) {
            this._onWillSave.fire(Object.freeze({ document: syncedDocument, reason: event.reason }));
          }
        }));
        disposables.push(connection2.onWillSaveTextDocumentWaitUntil((event, token) => {
          let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
          if (syncedDocument !== void 0 && this._willSaveWaitUntil) {
            return this._willSaveWaitUntil(Object.freeze({ document: syncedDocument, reason: event.reason }), token);
          } else {
            return [];
          }
        }));
        disposables.push(connection2.onDidSaveTextDocument((event) => {
          let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
          if (syncedDocument !== void 0) {
            this._onDidSave.fire(Object.freeze({ document: syncedDocument }));
          }
        }));
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          disposables.forEach((disposable) => disposable.dispose());
        });
      }
    };
    exports2.TextDocuments = TextDocuments2;
  }
});

// node_modules/vscode-languageserver/lib/common/notebook.js
var require_notebook = __commonJS({
  "node_modules/vscode-languageserver/lib/common/notebook.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NotebookDocuments = exports2.NotebookSyncFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main2();
    var textDocuments_1 = require_textDocuments();
    var NotebookSyncFeature = (Base) => {
      return class extends Base {
        get synchronization() {
          return {
            onDidOpenNotebookDocument: (handler) => {
              return this.connection.onNotification(vscode_languageserver_protocol_1.DidOpenNotebookDocumentNotification.type, (params) => {
                handler(params);
              });
            },
            onDidChangeNotebookDocument: (handler) => {
              return this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeNotebookDocumentNotification.type, (params) => {
                handler(params);
              });
            },
            onDidSaveNotebookDocument: (handler) => {
              return this.connection.onNotification(vscode_languageserver_protocol_1.DidSaveNotebookDocumentNotification.type, (params) => {
                handler(params);
              });
            },
            onDidCloseNotebookDocument: (handler) => {
              return this.connection.onNotification(vscode_languageserver_protocol_1.DidCloseNotebookDocumentNotification.type, (params) => {
                handler(params);
              });
            }
          };
        }
      };
    };
    exports2.NotebookSyncFeature = NotebookSyncFeature;
    var CellTextDocumentConnection = class _CellTextDocumentConnection {
      onDidOpenTextDocument(handler) {
        this.openHandler = handler;
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          this.openHandler = void 0;
        });
      }
      openTextDocument(params) {
        this.openHandler && this.openHandler(params);
      }
      onDidChangeTextDocument(handler) {
        this.changeHandler = handler;
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          this.changeHandler = handler;
        });
      }
      changeTextDocument(params) {
        this.changeHandler && this.changeHandler(params);
      }
      onDidCloseTextDocument(handler) {
        this.closeHandler = handler;
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          this.closeHandler = void 0;
        });
      }
      closeTextDocument(params) {
        this.closeHandler && this.closeHandler(params);
      }
      onWillSaveTextDocument() {
        return _CellTextDocumentConnection.NULL_DISPOSE;
      }
      onWillSaveTextDocumentWaitUntil() {
        return _CellTextDocumentConnection.NULL_DISPOSE;
      }
      onDidSaveTextDocument() {
        return _CellTextDocumentConnection.NULL_DISPOSE;
      }
    };
    CellTextDocumentConnection.NULL_DISPOSE = Object.freeze({ dispose: () => {
    } });
    var NotebookDocuments = class {
      constructor(configurationOrTextDocuments) {
        if (configurationOrTextDocuments instanceof textDocuments_1.TextDocuments) {
          this._cellTextDocuments = configurationOrTextDocuments;
        } else {
          this._cellTextDocuments = new textDocuments_1.TextDocuments(configurationOrTextDocuments);
        }
        this.notebookDocuments = /* @__PURE__ */ new Map();
        this.notebookCellMap = /* @__PURE__ */ new Map();
        this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();
        this._onDidChange = new vscode_languageserver_protocol_1.Emitter();
        this._onDidSave = new vscode_languageserver_protocol_1.Emitter();
        this._onDidClose = new vscode_languageserver_protocol_1.Emitter();
      }
      get cellTextDocuments() {
        return this._cellTextDocuments;
      }
      getCellTextDocument(cell) {
        return this._cellTextDocuments.get(cell.document);
      }
      getNotebookDocument(uri) {
        return this.notebookDocuments.get(uri);
      }
      getNotebookCell(uri) {
        const value = this.notebookCellMap.get(uri);
        return value && value[0];
      }
      findNotebookDocumentForCell(cell) {
        const key = typeof cell === "string" ? cell : cell.document;
        const value = this.notebookCellMap.get(key);
        return value && value[1];
      }
      get onDidOpen() {
        return this._onDidOpen.event;
      }
      get onDidSave() {
        return this._onDidSave.event;
      }
      get onDidChange() {
        return this._onDidChange.event;
      }
      get onDidClose() {
        return this._onDidClose.event;
      }
      /**
       * Listens for `low level` notification on the given connection to
       * update the notebook documents managed by this instance.
       *
       * Please note that the connection only provides handlers not an event model. Therefore
       * listening on a connection will overwrite the following handlers on a connection:
       * `onDidOpenNotebookDocument`, `onDidChangeNotebookDocument`, `onDidSaveNotebookDocument`,
       *  and `onDidCloseNotebookDocument`.
       *
       * @param connection The connection to listen on.
       */
      listen(connection2) {
        const cellTextDocumentConnection = new CellTextDocumentConnection();
        const disposables = [];
        disposables.push(this.cellTextDocuments.listen(cellTextDocumentConnection));
        disposables.push(connection2.notebooks.synchronization.onDidOpenNotebookDocument((params) => {
          this.notebookDocuments.set(params.notebookDocument.uri, params.notebookDocument);
          for (const cellTextDocument of params.cellTextDocuments) {
            cellTextDocumentConnection.openTextDocument({ textDocument: cellTextDocument });
          }
          this.updateCellMap(params.notebookDocument);
          this._onDidOpen.fire(params.notebookDocument);
        }));
        disposables.push(connection2.notebooks.synchronization.onDidChangeNotebookDocument((params) => {
          const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
          if (notebookDocument === void 0) {
            return;
          }
          notebookDocument.version = params.notebookDocument.version;
          const oldMetadata = notebookDocument.metadata;
          let metadataChanged = false;
          const change = params.change;
          if (change.metadata !== void 0) {
            metadataChanged = true;
            notebookDocument.metadata = change.metadata;
          }
          const opened = [];
          const closed = [];
          const data = [];
          const text = [];
          if (change.cells !== void 0) {
            const changedCells = change.cells;
            if (changedCells.structure !== void 0) {
              const array = changedCells.structure.array;
              notebookDocument.cells.splice(array.start, array.deleteCount, ...array.cells !== void 0 ? array.cells : []);
              if (changedCells.structure.didOpen !== void 0) {
                for (const open of changedCells.structure.didOpen) {
                  cellTextDocumentConnection.openTextDocument({ textDocument: open });
                  opened.push(open.uri);
                }
              }
              if (changedCells.structure.didClose) {
                for (const close of changedCells.structure.didClose) {
                  cellTextDocumentConnection.closeTextDocument({ textDocument: close });
                  closed.push(close.uri);
                }
              }
            }
            if (changedCells.data !== void 0) {
              const cellUpdates = new Map(changedCells.data.map((cell) => [cell.document, cell]));
              for (let i = 0; i <= notebookDocument.cells.length; i++) {
                const change2 = cellUpdates.get(notebookDocument.cells[i].document);
                if (change2 !== void 0) {
                  const old = notebookDocument.cells.splice(i, 1, change2);
                  data.push({ old: old[0], new: change2 });
                  cellUpdates.delete(change2.document);
                  if (cellUpdates.size === 0) {
                    break;
                  }
                }
              }
            }
            if (changedCells.textContent !== void 0) {
              for (const cellTextDocument of changedCells.textContent) {
                cellTextDocumentConnection.changeTextDocument({ textDocument: cellTextDocument.document, contentChanges: cellTextDocument.changes });
                text.push(cellTextDocument.document.uri);
              }
            }
          }
          this.updateCellMap(notebookDocument);
          const changeEvent = { notebookDocument };
          if (metadataChanged) {
            changeEvent.metadata = { old: oldMetadata, new: notebookDocument.metadata };
          }
          const added = [];
          for (const open of opened) {
            added.push(this.getNotebookCell(open));
          }
          const removed = [];
          for (const close of closed) {
            removed.push(this.getNotebookCell(close));
          }
          const textContent = [];
          for (const change2 of text) {
            textContent.push(this.getNotebookCell(change2));
          }
          if (added.length > 0 || removed.length > 0 || data.length > 0 || textContent.length > 0) {
            changeEvent.cells = { added, removed, changed: { data, textContent } };
          }
          if (changeEvent.metadata !== void 0 || changeEvent.cells !== void 0) {
            this._onDidChange.fire(changeEvent);
          }
        }));
        disposables.push(connection2.notebooks.synchronization.onDidSaveNotebookDocument((params) => {
          const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
          if (notebookDocument === void 0) {
            return;
          }
          this._onDidSave.fire(notebookDocument);
        }));
        disposables.push(connection2.notebooks.synchronization.onDidCloseNotebookDocument((params) => {
          const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
          if (notebookDocument === void 0) {
            return;
          }
          this._onDidClose.fire(notebookDocument);
          for (const cellTextDocument of params.cellTextDocuments) {
            cellTextDocumentConnection.closeTextDocument({ textDocument: cellTextDocument });
          }
          this.notebookDocuments.delete(params.notebookDocument.uri);
          for (const cell of notebookDocument.cells) {
            this.notebookCellMap.delete(cell.document);
          }
        }));
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          disposables.forEach((disposable) => disposable.dispose());
        });
      }
      updateCellMap(notebookDocument) {
        for (const cell of notebookDocument.cells) {
          this.notebookCellMap.set(cell.document, [cell, notebookDocument]);
        }
      }
    };
    exports2.NotebookDocuments = NotebookDocuments;
  }
});

// node_modules/vscode-languageserver/lib/common/utils/is.js
var require_is3 = __commonJS({
  "node_modules/vscode-languageserver/lib/common/utils/is.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.thenable = exports2.typedArray = exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports2.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports2.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports2.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports2.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports2.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports2.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports2.stringArray = stringArray;
    function typedArray(value, check) {
      return Array.isArray(value) && value.every(check);
    }
    exports2.typedArray = typedArray;
    function thenable(value) {
      return value && func(value.then);
    }
    exports2.thenable = thenable;
  }
});

// node_modules/vscode-languageserver/lib/common/utils/uuid.js
var require_uuid = __commonJS({
  "node_modules/vscode-languageserver/lib/common/utils/uuid.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generateUuid = exports2.parse = exports2.isUUID = exports2.v4 = exports2.empty = void 0;
    var ValueUUID = class {
      constructor(_value) {
        this._value = _value;
      }
      asHex() {
        return this._value;
      }
      equals(other) {
        return this.asHex() === other.asHex();
      }
    };
    var V4UUID = class _V4UUID extends ValueUUID {
      static _oneOf(array) {
        return array[Math.floor(array.length * Math.random())];
      }
      static _randomHex() {
        return _V4UUID._oneOf(_V4UUID._chars);
      }
      constructor() {
        super([
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          "-",
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          "-",
          "4",
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          "-",
          _V4UUID._oneOf(_V4UUID._timeHighBits),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          "-",
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex()
        ].join(""));
      }
    };
    V4UUID._chars = ["0", "1", "2", "3", "4", "5", "6", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
    V4UUID._timeHighBits = ["8", "9", "a", "b"];
    exports2.empty = new ValueUUID("00000000-0000-0000-0000-000000000000");
    function v4() {
      return new V4UUID();
    }
    exports2.v4 = v4;
    var _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    function isUUID(value) {
      return _UUIDPattern.test(value);
    }
    exports2.isUUID = isUUID;
    function parse(value) {
      if (!isUUID(value)) {
        throw new Error("invalid uuid");
      }
      return new ValueUUID(value);
    }
    exports2.parse = parse;
    function generateUuid() {
      return v4().asHex();
    }
    exports2.generateUuid = generateUuid;
  }
});

// node_modules/vscode-languageserver/lib/common/progress.js
var require_progress = __commonJS({
  "node_modules/vscode-languageserver/lib/common/progress.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.attachPartialResult = exports2.ProgressFeature = exports2.attachWorkDone = void 0;
    var vscode_languageserver_protocol_1 = require_main2();
    var uuid_1 = require_uuid();
    var WorkDoneProgressReporterImpl = class _WorkDoneProgressReporterImpl {
      constructor(_connection, _token) {
        this._connection = _connection;
        this._token = _token;
        _WorkDoneProgressReporterImpl.Instances.set(this._token, this);
      }
      begin(title, percentage, message, cancellable) {
        let param = {
          kind: "begin",
          title,
          percentage,
          message,
          cancellable
        };
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
      }
      report(arg0, arg1) {
        let param = {
          kind: "report"
        };
        if (typeof arg0 === "number") {
          param.percentage = arg0;
          if (arg1 !== void 0) {
            param.message = arg1;
          }
        } else {
          param.message = arg0;
        }
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
      }
      done() {
        _WorkDoneProgressReporterImpl.Instances.delete(this._token);
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, { kind: "end" });
      }
    };
    WorkDoneProgressReporterImpl.Instances = /* @__PURE__ */ new Map();
    var WorkDoneProgressServerReporterImpl = class extends WorkDoneProgressReporterImpl {
      constructor(connection2, token) {
        super(connection2, token);
        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
      }
      get token() {
        return this._source.token;
      }
      done() {
        this._source.dispose();
        super.done();
      }
      cancel() {
        this._source.cancel();
      }
    };
    var NullProgressReporter = class {
      constructor() {
      }
      begin() {
      }
      report() {
      }
      done() {
      }
    };
    var NullProgressServerReporter = class extends NullProgressReporter {
      constructor() {
        super();
        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
      }
      get token() {
        return this._source.token;
      }
      done() {
        this._source.dispose();
      }
      cancel() {
        this._source.cancel();
      }
    };
    function attachWorkDone(connection2, params) {
      if (params === void 0 || params.workDoneToken === void 0) {
        return new NullProgressReporter();
      }
      const token = params.workDoneToken;
      delete params.workDoneToken;
      return new WorkDoneProgressReporterImpl(connection2, token);
    }
    exports2.attachWorkDone = attachWorkDone;
    var ProgressFeature = (Base) => {
      return class extends Base {
        constructor() {
          super();
          this._progressSupported = false;
        }
        initialize(capabilities) {
          super.initialize(capabilities);
          if (capabilities?.window?.workDoneProgress === true) {
            this._progressSupported = true;
            this.connection.onNotification(vscode_languageserver_protocol_1.WorkDoneProgressCancelNotification.type, (params) => {
              let progress = WorkDoneProgressReporterImpl.Instances.get(params.token);
              if (progress instanceof WorkDoneProgressServerReporterImpl || progress instanceof NullProgressServerReporter) {
                progress.cancel();
              }
            });
          }
        }
        attachWorkDoneProgress(token) {
          if (token === void 0) {
            return new NullProgressReporter();
          } else {
            return new WorkDoneProgressReporterImpl(this.connection, token);
          }
        }
        createWorkDoneProgress() {
          if (this._progressSupported) {
            const token = (0, uuid_1.generateUuid)();
            return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.type, { token }).then(() => {
              const result = new WorkDoneProgressServerReporterImpl(this.connection, token);
              return result;
            });
          } else {
            return Promise.resolve(new NullProgressServerReporter());
          }
        }
      };
    };
    exports2.ProgressFeature = ProgressFeature;
    var ResultProgress;
    (function(ResultProgress2) {
      ResultProgress2.type = new vscode_languageserver_protocol_1.ProgressType();
    })(ResultProgress || (ResultProgress = {}));
    var ResultProgressReporterImpl = class {
      constructor(_connection, _token) {
        this._connection = _connection;
        this._token = _token;
      }
      report(data) {
        this._connection.sendProgress(ResultProgress.type, this._token, data);
      }
    };
    function attachPartialResult(connection2, params) {
      if (params === void 0 || params.partialResultToken === void 0) {
        return void 0;
      }
      const token = params.partialResultToken;
      delete params.partialResultToken;
      return new ResultProgressReporterImpl(connection2, token);
    }
    exports2.attachPartialResult = attachPartialResult;
  }
});

// node_modules/vscode-languageserver/lib/common/configuration.js
var require_configuration = __commonJS({
  "node_modules/vscode-languageserver/lib/common/configuration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConfigurationFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main2();
    var Is2 = require_is3();
    var ConfigurationFeature = (Base) => {
      return class extends Base {
        getConfiguration(arg) {
          if (!arg) {
            return this._getConfiguration({});
          } else if (Is2.string(arg)) {
            return this._getConfiguration({ section: arg });
          } else {
            return this._getConfiguration(arg);
          }
        }
        _getConfiguration(arg) {
          let params = {
            items: Array.isArray(arg) ? arg : [arg]
          };
          return this.connection.sendRequest(vscode_languageserver_protocol_1.ConfigurationRequest.type, params).then((result) => {
            if (Array.isArray(result)) {
              return Array.isArray(arg) ? result : result[0];
            } else {
              return Array.isArray(arg) ? [] : null;
            }
          });
        }
      };
    };
    exports2.ConfigurationFeature = ConfigurationFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/workspaceFolder.js
var require_workspaceFolder = __commonJS({
  "node_modules/vscode-languageserver/lib/common/workspaceFolder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkspaceFoldersFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main2();
    var WorkspaceFoldersFeature = (Base) => {
      return class extends Base {
        constructor() {
          super();
          this._notificationIsAutoRegistered = false;
        }
        initialize(capabilities) {
          super.initialize(capabilities);
          let workspaceCapabilities = capabilities.workspace;
          if (workspaceCapabilities && workspaceCapabilities.workspaceFolders) {
            this._onDidChangeWorkspaceFolders = new vscode_languageserver_protocol_1.Emitter();
            this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type, (params) => {
              this._onDidChangeWorkspaceFolders.fire(params.event);
            });
          }
        }
        fillServerCapabilities(capabilities) {
          super.fillServerCapabilities(capabilities);
          const changeNotifications = capabilities.workspace?.workspaceFolders?.changeNotifications;
          this._notificationIsAutoRegistered = changeNotifications === true || typeof changeNotifications === "string";
        }
        getWorkspaceFolders() {
          return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkspaceFoldersRequest.type);
        }
        get onDidChangeWorkspaceFolders() {
          if (!this._onDidChangeWorkspaceFolders) {
            throw new Error("Client doesn't support sending workspace folder change events.");
          }
          if (!this._notificationIsAutoRegistered && !this._unregistration) {
            this._unregistration = this.connection.client.register(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type);
          }
          return this._onDidChangeWorkspaceFolders.event;
        }
      };
    };
    exports2.WorkspaceFoldersFeature = WorkspaceFoldersFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/callHierarchy.js
var require_callHierarchy = __commonJS({
  "node_modules/vscode-languageserver/lib/common/callHierarchy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CallHierarchyFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main2();
    var CallHierarchyFeature = (Base) => {
      return class extends Base {
        get callHierarchy() {
          return {
            onPrepare: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), void 0);
              });
            },
            onIncomingCalls: (handler) => {
              const type = vscode_languageserver_protocol_1.CallHierarchyIncomingCallsRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            },
            onOutgoingCalls: (handler) => {
              const type = vscode_languageserver_protocol_1.CallHierarchyOutgoingCallsRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
    exports2.CallHierarchyFeature = CallHierarchyFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/showDocument.js
var require_showDocument = __commonJS({
  "node_modules/vscode-languageserver/lib/common/showDocument.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ShowDocumentFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main2();
    var ShowDocumentFeature = (Base) => {
      return class extends Base {
        showDocument(params) {
          return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowDocumentRequest.type, params);
        }
      };
    };
    exports2.ShowDocumentFeature = ShowDocumentFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/fileOperations.js
var require_fileOperations = __commonJS({
  "node_modules/vscode-languageserver/lib/common/fileOperations.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FileOperationsFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main2();
    var FileOperationsFeature = (Base) => {
      return class extends Base {
        onDidCreateFiles(handler) {
          return this.connection.onNotification(vscode_languageserver_protocol_1.DidCreateFilesNotification.type, (params) => {
            handler(params);
          });
        }
        onDidRenameFiles(handler) {
          return this.connection.onNotification(vscode_languageserver_protocol_1.DidRenameFilesNotification.type, (params) => {
            handler(params);
          });
        }
        onDidDeleteFiles(handler) {
          return this.connection.onNotification(vscode_languageserver_protocol_1.DidDeleteFilesNotification.type, (params) => {
            handler(params);
          });
        }
        onWillCreateFiles(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.WillCreateFilesRequest.type, (params, cancel) => {
            return handler(params, cancel);
          });
        }
        onWillRenameFiles(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.WillRenameFilesRequest.type, (params, cancel) => {
            return handler(params, cancel);
          });
        }
        onWillDeleteFiles(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.WillDeleteFilesRequest.type, (params, cancel) => {
            return handler(params, cancel);
          });
        }
      };
    };
    exports2.FileOperationsFeature = FileOperationsFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/linkedEditingRange.js
var require_linkedEditingRange = __commonJS({
  "node_modules/vscode-languageserver/lib/common/linkedEditingRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LinkedEditingRangeFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main2();
    var LinkedEditingRangeFeature = (Base) => {
      return class extends Base {
        onLinkedEditingRange(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.LinkedEditingRangeRequest.type, (params, cancel) => {
            return handler(params, cancel, this.attachWorkDoneProgress(params), void 0);
          });
        }
      };
    };
    exports2.LinkedEditingRangeFeature = LinkedEditingRangeFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/typeHierarchy.js
var require_typeHierarchy = __commonJS({
  "node_modules/vscode-languageserver/lib/common/typeHierarchy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeHierarchyFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main2();
    var TypeHierarchyFeature = (Base) => {
      return class extends Base {
        get typeHierarchy() {
          return {
            onPrepare: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.TypeHierarchyPrepareRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), void 0);
              });
            },
            onSupertypes: (handler) => {
              const type = vscode_languageserver_protocol_1.TypeHierarchySupertypesRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            },
            onSubtypes: (handler) => {
              const type = vscode_languageserver_protocol_1.TypeHierarchySubtypesRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
    exports2.TypeHierarchyFeature = TypeHierarchyFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/inlineValue.js
var require_inlineValue = __commonJS({
  "node_modules/vscode-languageserver/lib/common/inlineValue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlineValueFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main2();
    var InlineValueFeature = (Base) => {
      return class extends Base {
        get inlineValue() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.InlineValueRefreshRequest.type);
            },
            on: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.InlineValueRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params));
              });
            }
          };
        }
      };
    };
    exports2.InlineValueFeature = InlineValueFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/foldingRange.js
var require_foldingRange = __commonJS({
  "node_modules/vscode-languageserver/lib/common/foldingRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FoldingRangeFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main2();
    var FoldingRangeFeature = (Base) => {
      return class extends Base {
        get foldingRange() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.FoldingRangeRefreshRequest.type);
            },
            on: (handler) => {
              const type = vscode_languageserver_protocol_1.FoldingRangeRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
    exports2.FoldingRangeFeature = FoldingRangeFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/inlayHint.js
var require_inlayHint = __commonJS({
  "node_modules/vscode-languageserver/lib/common/inlayHint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlayHintFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main2();
    var InlayHintFeature = (Base) => {
      return class extends Base {
        get inlayHint() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.InlayHintRefreshRequest.type);
            },
            on: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.InlayHintRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params));
              });
            },
            resolve: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.InlayHintResolveRequest.type, (params, cancel) => {
                return handler(params, cancel);
              });
            }
          };
        }
      };
    };
    exports2.InlayHintFeature = InlayHintFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/diagnostic.js
var require_diagnostic = __commonJS({
  "node_modules/vscode-languageserver/lib/common/diagnostic.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DiagnosticFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main2();
    var DiagnosticFeature = (Base) => {
      return class extends Base {
        get diagnostics() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.DiagnosticRefreshRequest.type);
            },
            on: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.partialResult, params));
              });
            },
            onWorkspace: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.partialResult, params));
              });
            }
          };
        }
      };
    };
    exports2.DiagnosticFeature = DiagnosticFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/moniker.js
var require_moniker = __commonJS({
  "node_modules/vscode-languageserver/lib/common/moniker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MonikerFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main2();
    var MonikerFeature = (Base) => {
      return class extends Base {
        get moniker() {
          return {
            on: (handler) => {
              const type = vscode_languageserver_protocol_1.MonikerRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
    exports2.MonikerFeature = MonikerFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/server.js
var require_server = __commonJS({
  "node_modules/vscode-languageserver/lib/common/server.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createConnection = exports2.combineFeatures = exports2.combineNotebooksFeatures = exports2.combineLanguagesFeatures = exports2.combineWorkspaceFeatures = exports2.combineWindowFeatures = exports2.combineClientFeatures = exports2.combineTracerFeatures = exports2.combineTelemetryFeatures = exports2.combineConsoleFeatures = exports2._NotebooksImpl = exports2._LanguagesImpl = exports2.BulkUnregistration = exports2.BulkRegistration = exports2.ErrorMessageTracker = void 0;
    var vscode_languageserver_protocol_1 = require_main2();
    var Is2 = require_is3();
    var UUID = require_uuid();
    var progress_1 = require_progress();
    var configuration_1 = require_configuration();
    var workspaceFolder_1 = require_workspaceFolder();
    var callHierarchy_1 = require_callHierarchy();
    var semanticTokens_1 = require_semanticTokens();
    var showDocument_1 = require_showDocument();
    var fileOperations_1 = require_fileOperations();
    var linkedEditingRange_1 = require_linkedEditingRange();
    var typeHierarchy_1 = require_typeHierarchy();
    var inlineValue_1 = require_inlineValue();
    var foldingRange_1 = require_foldingRange();
    var inlayHint_1 = require_inlayHint();
    var diagnostic_1 = require_diagnostic();
    var notebook_1 = require_notebook();
    var moniker_1 = require_moniker();
    function null2Undefined(value) {
      if (value === null) {
        return void 0;
      }
      return value;
    }
    var ErrorMessageTracker = class {
      constructor() {
        this._messages = /* @__PURE__ */ Object.create(null);
      }
      /**
       * Add a message to the tracker.
       *
       * @param message The message to add.
       */
      add(message) {
        let count = this._messages[message];
        if (!count) {
          count = 0;
        }
        count++;
        this._messages[message] = count;
      }
      /**
       * Send all tracked messages to the connection's window.
       *
       * @param connection The connection established between client and server.
       */
      sendErrors(connection2) {
        Object.keys(this._messages).forEach((message) => {
          connection2.window.showErrorMessage(message);
        });
      }
    };
    exports2.ErrorMessageTracker = ErrorMessageTracker;
    var RemoteConsoleImpl = class {
      constructor() {
      }
      rawAttach(connection2) {
        this._rawConnection = connection2;
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      fillServerCapabilities(_capabilities) {
      }
      initialize(_capabilities) {
      }
      error(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Error, message);
      }
      warn(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Warning, message);
      }
      info(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Info, message);
      }
      log(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Log, message);
      }
      debug(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Debug, message);
      }
      send(type, message) {
        if (this._rawConnection) {
          this._rawConnection.sendNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, { type, message }).catch(() => {
            (0, vscode_languageserver_protocol_1.RAL)().console.error(`Sending log message failed`);
          });
        }
      }
    };
    var _RemoteWindowImpl = class {
      constructor() {
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      showErrorMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Error, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
      }
      showWarningMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Warning, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
      }
      showInformationMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Info, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
      }
    };
    var RemoteWindowImpl = (0, showDocument_1.ShowDocumentFeature)((0, progress_1.ProgressFeature)(_RemoteWindowImpl));
    var BulkRegistration;
    (function(BulkRegistration2) {
      function create() {
        return new BulkRegistrationImpl();
      }
      BulkRegistration2.create = create;
    })(BulkRegistration || (exports2.BulkRegistration = BulkRegistration = {}));
    var BulkRegistrationImpl = class {
      constructor() {
        this._registrations = [];
        this._registered = /* @__PURE__ */ new Set();
      }
      add(type, registerOptions) {
        const method = Is2.string(type) ? type : type.method;
        if (this._registered.has(method)) {
          throw new Error(`${method} is already added to this registration`);
        }
        const id = UUID.generateUuid();
        this._registrations.push({
          id,
          method,
          registerOptions: registerOptions || {}
        });
        this._registered.add(method);
      }
      asRegistrationParams() {
        return {
          registrations: this._registrations
        };
      }
    };
    var BulkUnregistration;
    (function(BulkUnregistration2) {
      function create() {
        return new BulkUnregistrationImpl(void 0, []);
      }
      BulkUnregistration2.create = create;
    })(BulkUnregistration || (exports2.BulkUnregistration = BulkUnregistration = {}));
    var BulkUnregistrationImpl = class {
      constructor(_connection, unregistrations) {
        this._connection = _connection;
        this._unregistrations = /* @__PURE__ */ new Map();
        unregistrations.forEach((unregistration) => {
          this._unregistrations.set(unregistration.method, unregistration);
        });
      }
      get isAttached() {
        return !!this._connection;
      }
      attach(connection2) {
        this._connection = connection2;
      }
      add(unregistration) {
        this._unregistrations.set(unregistration.method, unregistration);
      }
      dispose() {
        let unregistrations = [];
        for (let unregistration of this._unregistrations.values()) {
          unregistrations.push(unregistration);
        }
        let params = {
          unregisterations: unregistrations
        };
        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).catch(() => {
          this._connection.console.info(`Bulk unregistration failed.`);
        });
      }
      disposeSingle(arg) {
        const method = Is2.string(arg) ? arg : arg.method;
        const unregistration = this._unregistrations.get(method);
        if (!unregistration) {
          return false;
        }
        let params = {
          unregisterations: [unregistration]
        };
        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(() => {
          this._unregistrations.delete(method);
        }, (_error) => {
          this._connection.console.info(`Un-registering request handler for ${unregistration.id} failed.`);
        });
        return true;
      }
    };
    var RemoteClientImpl = class {
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      register(typeOrRegistrations, registerOptionsOrType, registerOptions) {
        if (typeOrRegistrations instanceof BulkRegistrationImpl) {
          return this.registerMany(typeOrRegistrations);
        } else if (typeOrRegistrations instanceof BulkUnregistrationImpl) {
          return this.registerSingle1(typeOrRegistrations, registerOptionsOrType, registerOptions);
        } else {
          return this.registerSingle2(typeOrRegistrations, registerOptionsOrType);
        }
      }
      registerSingle1(unregistration, type, registerOptions) {
        const method = Is2.string(type) ? type : type.method;
        const id = UUID.generateUuid();
        let params = {
          registrations: [{ id, method, registerOptions: registerOptions || {} }]
        };
        if (!unregistration.isAttached) {
          unregistration.attach(this.connection);
        }
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
          unregistration.add({ id, method });
          return unregistration;
        }, (_error) => {
          this.connection.console.info(`Registering request handler for ${method} failed.`);
          return Promise.reject(_error);
        });
      }
      registerSingle2(type, registerOptions) {
        const method = Is2.string(type) ? type : type.method;
        const id = UUID.generateUuid();
        let params = {
          registrations: [{ id, method, registerOptions: registerOptions || {} }]
        };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
          return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.unregisterSingle(id, method).catch(() => {
              this.connection.console.info(`Un-registering capability with id ${id} failed.`);
            });
          });
        }, (_error) => {
          this.connection.console.info(`Registering request handler for ${method} failed.`);
          return Promise.reject(_error);
        });
      }
      unregisterSingle(id, method) {
        let params = {
          unregisterations: [{ id, method }]
        };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).catch(() => {
          this.connection.console.info(`Un-registering request handler for ${id} failed.`);
        });
      }
      registerMany(registrations) {
        let params = registrations.asRegistrationParams();
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then(() => {
          return new BulkUnregistrationImpl(this._connection, params.registrations.map((registration) => {
            return { id: registration.id, method: registration.method };
          }));
        }, (_error) => {
          this.connection.console.info(`Bulk registration failed.`);
          return Promise.reject(_error);
        });
      }
    };
    var _RemoteWorkspaceImpl = class {
      constructor() {
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      applyEdit(paramOrEdit) {
        function isApplyWorkspaceEditParams(value) {
          return value && !!value.edit;
        }
        let params = isApplyWorkspaceEditParams(paramOrEdit) ? paramOrEdit : { edit: paramOrEdit };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, params);
      }
    };
    var RemoteWorkspaceImpl = (0, fileOperations_1.FileOperationsFeature)((0, workspaceFolder_1.WorkspaceFoldersFeature)((0, configuration_1.ConfigurationFeature)(_RemoteWorkspaceImpl)));
    var TracerImpl = class {
      constructor() {
        this._trace = vscode_languageserver_protocol_1.Trace.Off;
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      set trace(value) {
        this._trace = value;
      }
      log(message, verbose) {
        if (this._trace === vscode_languageserver_protocol_1.Trace.Off) {
          return;
        }
        this.connection.sendNotification(vscode_languageserver_protocol_1.LogTraceNotification.type, {
          message,
          verbose: this._trace === vscode_languageserver_protocol_1.Trace.Verbose ? verbose : void 0
        }).catch(() => {
        });
      }
    };
    var TelemetryImpl = class {
      constructor() {
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      logEvent(data) {
        this.connection.sendNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, data).catch(() => {
          this.connection.console.log(`Sending TelemetryEventNotification failed`);
        });
      }
    };
    var _LanguagesImpl = class {
      constructor() {
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      attachWorkDoneProgress(params) {
        return (0, progress_1.attachWorkDone)(this.connection, params);
      }
      attachPartialResultProgress(_type, params) {
        return (0, progress_1.attachPartialResult)(this.connection, params);
      }
    };
    exports2._LanguagesImpl = _LanguagesImpl;
    var LanguagesImpl = (0, foldingRange_1.FoldingRangeFeature)((0, moniker_1.MonikerFeature)((0, diagnostic_1.DiagnosticFeature)((0, inlayHint_1.InlayHintFeature)((0, inlineValue_1.InlineValueFeature)((0, typeHierarchy_1.TypeHierarchyFeature)((0, linkedEditingRange_1.LinkedEditingRangeFeature)((0, semanticTokens_1.SemanticTokensFeature)((0, callHierarchy_1.CallHierarchyFeature)(_LanguagesImpl)))))))));
    var _NotebooksImpl = class {
      constructor() {
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      attachWorkDoneProgress(params) {
        return (0, progress_1.attachWorkDone)(this.connection, params);
      }
      attachPartialResultProgress(_type, params) {
        return (0, progress_1.attachPartialResult)(this.connection, params);
      }
    };
    exports2._NotebooksImpl = _NotebooksImpl;
    var NotebooksImpl = (0, notebook_1.NotebookSyncFeature)(_NotebooksImpl);
    function combineConsoleFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineConsoleFeatures = combineConsoleFeatures;
    function combineTelemetryFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineTelemetryFeatures = combineTelemetryFeatures;
    function combineTracerFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineTracerFeatures = combineTracerFeatures;
    function combineClientFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineClientFeatures = combineClientFeatures;
    function combineWindowFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineWindowFeatures = combineWindowFeatures;
    function combineWorkspaceFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineWorkspaceFeatures = combineWorkspaceFeatures;
    function combineLanguagesFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineLanguagesFeatures = combineLanguagesFeatures;
    function combineNotebooksFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineNotebooksFeatures = combineNotebooksFeatures;
    function combineFeatures(one, two) {
      function combine(one2, two2, func) {
        if (one2 && two2) {
          return func(one2, two2);
        } else if (one2) {
          return one2;
        } else {
          return two2;
        }
      }
      let result = {
        __brand: "features",
        console: combine(one.console, two.console, combineConsoleFeatures),
        tracer: combine(one.tracer, two.tracer, combineTracerFeatures),
        telemetry: combine(one.telemetry, two.telemetry, combineTelemetryFeatures),
        client: combine(one.client, two.client, combineClientFeatures),
        window: combine(one.window, two.window, combineWindowFeatures),
        workspace: combine(one.workspace, two.workspace, combineWorkspaceFeatures),
        languages: combine(one.languages, two.languages, combineLanguagesFeatures),
        notebooks: combine(one.notebooks, two.notebooks, combineNotebooksFeatures)
      };
      return result;
    }
    exports2.combineFeatures = combineFeatures;
    function createConnection2(connectionFactory, watchDog, factories) {
      const logger = factories && factories.console ? new (factories.console(RemoteConsoleImpl))() : new RemoteConsoleImpl();
      const connection2 = connectionFactory(logger);
      logger.rawAttach(connection2);
      const tracer = factories && factories.tracer ? new (factories.tracer(TracerImpl))() : new TracerImpl();
      const telemetry = factories && factories.telemetry ? new (factories.telemetry(TelemetryImpl))() : new TelemetryImpl();
      const client = factories && factories.client ? new (factories.client(RemoteClientImpl))() : new RemoteClientImpl();
      const remoteWindow = factories && factories.window ? new (factories.window(RemoteWindowImpl))() : new RemoteWindowImpl();
      const workspace = factories && factories.workspace ? new (factories.workspace(RemoteWorkspaceImpl))() : new RemoteWorkspaceImpl();
      const languages = factories && factories.languages ? new (factories.languages(LanguagesImpl))() : new LanguagesImpl();
      const notebooks = factories && factories.notebooks ? new (factories.notebooks(NotebooksImpl))() : new NotebooksImpl();
      const allRemotes = [logger, tracer, telemetry, client, remoteWindow, workspace, languages, notebooks];
      function asPromise(value) {
        if (value instanceof Promise) {
          return value;
        } else if (Is2.thenable(value)) {
          return new Promise((resolve, reject) => {
            value.then((resolved) => resolve(resolved), (error) => reject(error));
          });
        } else {
          return Promise.resolve(value);
        }
      }
      let shutdownHandler = void 0;
      let initializeHandler = void 0;
      let exitHandler = void 0;
      let protocolConnection = {
        listen: () => connection2.listen(),
        sendRequest: (type, ...params) => connection2.sendRequest(Is2.string(type) ? type : type.method, ...params),
        onRequest: (type, handler) => connection2.onRequest(type, handler),
        sendNotification: (type, param) => {
          const method = Is2.string(type) ? type : type.method;
          return connection2.sendNotification(method, param);
        },
        onNotification: (type, handler) => connection2.onNotification(type, handler),
        onProgress: connection2.onProgress,
        sendProgress: connection2.sendProgress,
        onInitialize: (handler) => {
          initializeHandler = handler;
          return {
            dispose: () => {
              initializeHandler = void 0;
            }
          };
        },
        onInitialized: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.InitializedNotification.type, handler),
        onShutdown: (handler) => {
          shutdownHandler = handler;
          return {
            dispose: () => {
              shutdownHandler = void 0;
            }
          };
        },
        onExit: (handler) => {
          exitHandler = handler;
          return {
            dispose: () => {
              exitHandler = void 0;
            }
          };
        },
        get console() {
          return logger;
        },
        get telemetry() {
          return telemetry;
        },
        get tracer() {
          return tracer;
        },
        get client() {
          return client;
        },
        get window() {
          return remoteWindow;
        },
        get workspace() {
          return workspace;
        },
        get languages() {
          return languages;
        },
        get notebooks() {
          return notebooks;
        },
        onDidChangeConfiguration: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, handler),
        onDidChangeWatchedFiles: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, handler),
        __textDocumentSync: void 0,
        onDidOpenTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, handler),
        onDidChangeTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, handler),
        onDidCloseTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, handler),
        onWillSaveTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, handler),
        onWillSaveTextDocumentWaitUntil: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, handler),
        onDidSaveTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, handler),
        sendDiagnostics: (params) => connection2.sendNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, params),
        onHover: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.HoverRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        onCompletion: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CompletionRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onCompletionResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, handler),
        onSignatureHelp: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        onDeclaration: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onDefinition: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onTypeDefinition: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onImplementation: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onReferences: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onDocumentHighlight: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onDocumentSymbol: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onWorkspaceSymbol: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onWorkspaceSymbolResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolResolveRequest.type, handler),
        onCodeAction: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onCodeActionResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onCodeLens: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onCodeLensResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onDocumentFormatting: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        onDocumentRangeFormatting: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        onDocumentOnTypeFormatting: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onRenameRequest: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.RenameRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        onPrepareRename: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onDocumentLinks: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onDocumentLinkResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onDocumentColor: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onColorPresentation: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onFoldingRanges: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onSelectionRanges: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onExecuteCommand: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        dispose: () => connection2.dispose()
      };
      for (let remote of allRemotes) {
        remote.attach(protocolConnection);
      }
      connection2.onRequest(vscode_languageserver_protocol_1.InitializeRequest.type, (params) => {
        watchDog.initialize(params);
        if (Is2.string(params.trace)) {
          tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.trace);
        }
        for (let remote of allRemotes) {
          remote.initialize(params.capabilities);
        }
        if (initializeHandler) {
          let result = initializeHandler(params, new vscode_languageserver_protocol_1.CancellationTokenSource().token, (0, progress_1.attachWorkDone)(connection2, params), void 0);
          return asPromise(result).then((value) => {
            if (value instanceof vscode_languageserver_protocol_1.ResponseError) {
              return value;
            }
            let result2 = value;
            if (!result2) {
              result2 = { capabilities: {} };
            }
            let capabilities = result2.capabilities;
            if (!capabilities) {
              capabilities = {};
              result2.capabilities = capabilities;
            }
            if (capabilities.textDocumentSync === void 0 || capabilities.textDocumentSync === null) {
              capabilities.textDocumentSync = Is2.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
            } else if (!Is2.number(capabilities.textDocumentSync) && !Is2.number(capabilities.textDocumentSync.change)) {
              capabilities.textDocumentSync.change = Is2.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
            }
            for (let remote of allRemotes) {
              remote.fillServerCapabilities(capabilities);
            }
            return result2;
          });
        } else {
          let result = { capabilities: { textDocumentSync: vscode_languageserver_protocol_1.TextDocumentSyncKind.None } };
          for (let remote of allRemotes) {
            remote.fillServerCapabilities(result.capabilities);
          }
          return result;
        }
      });
      connection2.onRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, () => {
        watchDog.shutdownReceived = true;
        if (shutdownHandler) {
          return shutdownHandler(new vscode_languageserver_protocol_1.CancellationTokenSource().token);
        } else {
          return void 0;
        }
      });
      connection2.onNotification(vscode_languageserver_protocol_1.ExitNotification.type, () => {
        try {
          if (exitHandler) {
            exitHandler();
          }
        } finally {
          if (watchDog.shutdownReceived) {
            watchDog.exit(0);
          } else {
            watchDog.exit(1);
          }
        }
      });
      connection2.onNotification(vscode_languageserver_protocol_1.SetTraceNotification.type, (params) => {
        tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.value);
      });
      return protocolConnection;
    }
    exports2.createConnection = createConnection2;
  }
});

// node_modules/vscode-languageserver/lib/common/api.js
var require_api3 = __commonJS({
  "node_modules/vscode-languageserver/lib/common/api.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProposedFeatures = exports2.NotebookDocuments = exports2.TextDocuments = exports2.SemanticTokensBuilder = void 0;
    var semanticTokens_1 = require_semanticTokens();
    Object.defineProperty(exports2, "SemanticTokensBuilder", { enumerable: true, get: function() {
      return semanticTokens_1.SemanticTokensBuilder;
    } });
    var ic = require_inlineCompletion_proposed();
    __exportStar(require_main2(), exports2);
    var textDocuments_1 = require_textDocuments();
    Object.defineProperty(exports2, "TextDocuments", { enumerable: true, get: function() {
      return textDocuments_1.TextDocuments;
    } });
    var notebook_1 = require_notebook();
    Object.defineProperty(exports2, "NotebookDocuments", { enumerable: true, get: function() {
      return notebook_1.NotebookDocuments;
    } });
    __exportStar(require_server(), exports2);
    var ProposedFeatures2;
    (function(ProposedFeatures3) {
      ProposedFeatures3.all = {
        __brand: "features",
        languages: ic.InlineCompletionFeature
      };
    })(ProposedFeatures2 || (exports2.ProposedFeatures = ProposedFeatures2 = {}));
  }
});

// node_modules/vscode-languageserver-protocol/browser.js
var require_browser2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/browser.js"(exports2, module2) {
    "use strict";
    module2.exports = require_main2();
  }
});

// node_modules/vscode-languageserver/lib/browser/main.js
var require_main3 = __commonJS({
  "node_modules/vscode-languageserver/lib/browser/main.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createConnection = void 0;
    var api_1 = require_api3();
    __exportStar(require_browser2(), exports2);
    __exportStar(require_api3(), exports2);
    var _shutdownReceived = false;
    var watchDog = {
      initialize: (_params) => {
      },
      get shutdownReceived() {
        return _shutdownReceived;
      },
      set shutdownReceived(value) {
        _shutdownReceived = value;
      },
      exit: (_code) => {
      }
    };
    function createConnection2(arg1, arg2, arg3, arg4) {
      let factories;
      let reader;
      let writer;
      let options;
      if (arg1 !== void 0 && arg1.__brand === "features") {
        factories = arg1;
        arg1 = arg2;
        arg2 = arg3;
        arg3 = arg4;
      }
      if (api_1.ConnectionStrategy.is(arg1) || api_1.ConnectionOptions.is(arg1)) {
        options = arg1;
      } else {
        reader = arg1;
        writer = arg2;
        options = arg3;
      }
      const connectionFactory = (logger) => {
        return (0, api_1.createProtocolConnection)(reader, writer, logger, options);
      };
      return (0, api_1.createConnection)(connectionFactory, watchDog, factories);
    }
    exports2.createConnection = createConnection2;
  }
});

// node_modules/vscode-languageserver/browser.js
var require_browser3 = __commonJS({
  "node_modules/vscode-languageserver/browser.js"(exports2, module2) {
    "use strict";
    module2.exports = require_main3();
  }
});

// ../_build/default/jslib/main.bc.js
var require_main_bc = __commonJS({
  "../_build/default/jslib/main.bc.js"(exports, module) {
    (function(Object2) {
      typeof globalThis !== "object" && (this ? get() : (Object2.defineProperty(Object2.prototype, "_T_", { configurable: true, get }), _T_));
      function get() {
        var global = this || self;
        global.globalThis = global;
        delete Object2.prototype._T_;
      }
    })(Object);
    (function(globalThis) {
      "use strict";
      function caml_int64_is_zero(x2) {
        return +x2.isZero();
      }
      function caml_str_repeat(n, s2) {
        if (n == 0)
          return "";
        if (s2.repeat)
          return s2.repeat(n);
        var r = "", l = 0;
        for (; ; ) {
          if (n & 1)
            r += s2;
          n >>= 1;
          if (n == 0)
            return r;
          s2 += s2;
          l++;
          if (l == 9)
            s2.slice(0, 1);
        }
      }
      var caml_int64_offset = Math.pow(2, -24);
      function caml_raise_constant(tag) {
        throw tag;
      }
      var caml_global_data = [0];
      function caml_raise_zero_divide() {
        caml_raise_constant(caml_global_data.Division_by_zero);
      }
      function MlInt64(lo, mi, hi) {
        this.lo = lo & 16777215;
        this.mi = mi & 16777215;
        this.hi = hi & 65535;
      }
      MlInt64.prototype.caml_custom = "_j";
      MlInt64.prototype.copy = function() {
        return new MlInt64(this.lo, this.mi, this.hi);
      };
      MlInt64.prototype.ucompare = function(x2) {
        if (this.hi > x2.hi)
          return 1;
        if (this.hi < x2.hi)
          return -1;
        if (this.mi > x2.mi)
          return 1;
        if (this.mi < x2.mi)
          return -1;
        if (this.lo > x2.lo)
          return 1;
        if (this.lo < x2.lo)
          return -1;
        return 0;
      };
      MlInt64.prototype.compare = function(x2) {
        var hi = this.hi << 16, xhi = x2.hi << 16;
        if (hi > xhi)
          return 1;
        if (hi < xhi)
          return -1;
        if (this.mi > x2.mi)
          return 1;
        if (this.mi < x2.mi)
          return -1;
        if (this.lo > x2.lo)
          return 1;
        if (this.lo < x2.lo)
          return -1;
        return 0;
      };
      MlInt64.prototype.neg = function() {
        var lo = -this.lo, mi = -this.mi + (lo >> 24), hi = -this.hi + (mi >> 24);
        return new MlInt64(lo, mi, hi);
      };
      MlInt64.prototype.add = function(x2) {
        var lo = this.lo + x2.lo, mi = this.mi + x2.mi + (lo >> 24), hi = this.hi + x2.hi + (mi >> 24);
        return new MlInt64(lo, mi, hi);
      };
      MlInt64.prototype.sub = function(x2) {
        var lo = this.lo - x2.lo, mi = this.mi - x2.mi + (lo >> 24), hi = this.hi - x2.hi + (mi >> 24);
        return new MlInt64(lo, mi, hi);
      };
      MlInt64.prototype.mul = function(x2) {
        var lo = this.lo * x2.lo, mi = (lo * caml_int64_offset | 0) + this.mi * x2.lo + this.lo * x2.mi, hi = (mi * caml_int64_offset | 0) + this.hi * x2.lo + this.mi * x2.mi + this.lo * x2.hi;
        return new MlInt64(lo, mi, hi);
      };
      MlInt64.prototype.isZero = function() {
        return (this.lo | this.mi | this.hi) == 0;
      };
      MlInt64.prototype.isNeg = function() {
        return this.hi << 16 < 0;
      };
      MlInt64.prototype.and = function(x2) {
        return new MlInt64(this.lo & x2.lo, this.mi & x2.mi, this.hi & x2.hi);
      };
      MlInt64.prototype.or = function(x2) {
        return new MlInt64(this.lo | x2.lo, this.mi | x2.mi, this.hi | x2.hi);
      };
      MlInt64.prototype.xor = function(x2) {
        return new MlInt64(this.lo ^ x2.lo, this.mi ^ x2.mi, this.hi ^ x2.hi);
      };
      MlInt64.prototype.shift_left = function(s2) {
        s2 = s2 & 63;
        if (s2 == 0)
          return this;
        if (s2 < 24)
          return new MlInt64(
            this.lo << s2,
            this.mi << s2 | this.lo >> 24 - s2,
            this.hi << s2 | this.mi >> 24 - s2
          );
        if (s2 < 48)
          return new MlInt64(0, this.lo << s2 - 24, this.mi << s2 - 24 | this.lo >> 48 - s2);
        return new MlInt64(0, 0, this.lo << s2 - 48);
      };
      MlInt64.prototype.shift_right_unsigned = function(s2) {
        s2 = s2 & 63;
        if (s2 == 0)
          return this;
        if (s2 < 24)
          return new MlInt64(
            this.lo >> s2 | this.mi << 24 - s2,
            this.mi >> s2 | this.hi << 24 - s2,
            this.hi >> s2
          );
        if (s2 < 48)
          return new MlInt64(this.mi >> s2 - 24 | this.hi << 48 - s2, this.hi >> s2 - 24, 0);
        return new MlInt64(this.hi >> s2 - 48, 0, 0);
      };
      MlInt64.prototype.shift_right = function(s2) {
        s2 = s2 & 63;
        if (s2 == 0)
          return this;
        var h = this.hi << 16 >> 16;
        if (s2 < 24)
          return new MlInt64(
            this.lo >> s2 | this.mi << 24 - s2,
            this.mi >> s2 | h << 24 - s2,
            this.hi << 16 >> s2 >>> 16
          );
        var sign = this.hi << 16 >> 31;
        if (s2 < 48)
          return new MlInt64(
            this.mi >> s2 - 24 | this.hi << 48 - s2,
            this.hi << 16 >> s2 - 24 >> 16,
            sign & 65535
          );
        return new MlInt64(this.hi << 16 >> s2 - 32, sign, sign);
      };
      MlInt64.prototype.lsl1 = function() {
        this.hi = this.hi << 1 | this.mi >> 23;
        this.mi = (this.mi << 1 | this.lo >> 23) & 16777215;
        this.lo = this.lo << 1 & 16777215;
      };
      MlInt64.prototype.lsr1 = function() {
        this.lo = (this.lo >>> 1 | this.mi << 23) & 16777215;
        this.mi = (this.mi >>> 1 | this.hi << 23) & 16777215;
        this.hi = this.hi >>> 1;
      };
      MlInt64.prototype.udivmod = function(x2) {
        var offset = 0, modulus = this.copy(), divisor = x2.copy(), quotient = new MlInt64(0, 0, 0);
        while (modulus.ucompare(divisor) > 0) {
          offset++;
          divisor.lsl1();
        }
        while (offset >= 0) {
          offset--;
          quotient.lsl1();
          if (modulus.ucompare(divisor) >= 0) {
            quotient.lo++;
            modulus = modulus.sub(divisor);
          }
          divisor.lsr1();
        }
        return { quotient, modulus };
      };
      MlInt64.prototype.div = function(y) {
        var x2 = this;
        if (y.isZero())
          caml_raise_zero_divide();
        var sign = x2.hi ^ y.hi;
        if (x2.hi & 32768)
          x2 = x2.neg();
        if (y.hi & 32768)
          y = y.neg();
        var q = x2.udivmod(y).quotient;
        if (sign & 32768)
          q = q.neg();
        return q;
      };
      MlInt64.prototype.mod = function(y) {
        var x2 = this;
        if (y.isZero())
          caml_raise_zero_divide();
        var sign = x2.hi;
        if (x2.hi & 32768)
          x2 = x2.neg();
        if (y.hi & 32768)
          y = y.neg();
        var r = x2.udivmod(y).modulus;
        if (sign & 32768)
          r = r.neg();
        return r;
      };
      MlInt64.prototype.toInt = function() {
        return this.lo | this.mi << 24;
      };
      MlInt64.prototype.toFloat = function() {
        return (this.hi << 16) * Math.pow(2, 32) + this.mi * Math.pow(2, 24) + this.lo;
      };
      MlInt64.prototype.toArray = function() {
        return [
          this.hi >> 8,
          this.hi & 255,
          this.mi >> 16,
          this.mi >> 8 & 255,
          this.mi & 255,
          this.lo >> 16,
          this.lo >> 8 & 255,
          this.lo & 255
        ];
      };
      MlInt64.prototype.lo32 = function() {
        return this.lo | (this.mi & 255) << 24;
      };
      MlInt64.prototype.hi32 = function() {
        return this.mi >>> 8 & 65535 | this.hi << 16;
      };
      function caml_int64_of_int32(x2) {
        return new MlInt64(x2 & 16777215, x2 >> 24 & 16777215, x2 >> 31 & 65535);
      }
      function caml_int64_to_int32(x2) {
        return x2.toInt();
      }
      function caml_int64_is_negative(x2) {
        return +x2.isNeg();
      }
      function caml_int64_neg(x2) {
        return x2.neg();
      }
      function caml_jsbytes_of_string(x2) {
        return x2;
      }
      function jsoo_sys_getenv(n) {
        var process = globalThis.process;
        if (process && process.env && process.env[n] != void 0)
          return process.env[n];
        if (globalThis.jsoo_static_env && globalThis.jsoo_static_env[n])
          return globalThis.jsoo_static_env[n];
      }
      var caml_record_backtrace_flag = 0;
      (function() {
        var r = jsoo_sys_getenv("OCAMLRUNPARAM");
        if (r !== void 0) {
          var l = r.split(",");
          for (var i = 0; i < l.length; i++)
            if (l[i] == "b") {
              caml_record_backtrace_flag = 1;
              break;
            } else if (l[i].startsWith("b="))
              caml_record_backtrace_flag = +l[i].slice(2);
            else
              continue;
        }
      })();
      function caml_exn_with_js_backtrace(exn, force) {
        if (!exn.js_error || force || exn[0] == 248)
          exn.js_error = new globalThis.Error("Js exception containing backtrace");
        return exn;
      }
      function caml_maybe_attach_backtrace(exn, force) {
        return caml_record_backtrace_flag ? caml_exn_with_js_backtrace(exn, force) : exn;
      }
      function caml_raise_with_arg(tag, arg) {
        throw caml_maybe_attach_backtrace([0, tag, arg]);
      }
      function caml_string_of_jsbytes(x2) {
        return x2;
      }
      function caml_raise_with_string(tag, msg) {
        caml_raise_with_arg(tag, caml_string_of_jsbytes(msg));
      }
      function caml_invalid_argument(msg) {
        caml_raise_with_string(caml_global_data.Invalid_argument, msg);
      }
      function caml_parse_format(fmt) {
        fmt = caml_jsbytes_of_string(fmt);
        var len = fmt.length;
        if (len > 31)
          caml_invalid_argument("format_int: format too long");
        var f = {
          justify: "+",
          signstyle: "-",
          filler: " ",
          alternate: false,
          base: 0,
          signedconv: false,
          width: 0,
          uppercase: false,
          sign: 1,
          prec: -1,
          conv: "f"
        };
        for (var i = 0; i < len; i++) {
          var c = fmt.charAt(i);
          switch (c) {
            case "-":
              f.justify = "-";
              break;
            case "+":
            case " ":
              f.signstyle = c;
              break;
            case "0":
              f.filler = "0";
              break;
            case "#":
              f.alternate = true;
              break;
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
              f.width = 0;
              while (c = fmt.charCodeAt(i) - 48, c >= 0 && c <= 9) {
                f.width = f.width * 10 + c;
                i++;
              }
              i--;
              break;
            case ".":
              f.prec = 0;
              i++;
              while (c = fmt.charCodeAt(i) - 48, c >= 0 && c <= 9) {
                f.prec = f.prec * 10 + c;
                i++;
              }
              i--;
            case "d":
            case "i":
              f.signedconv = true;
            case "u":
              f.base = 10;
              break;
            case "x":
              f.base = 16;
              break;
            case "X":
              f.base = 16;
              f.uppercase = true;
              break;
            case "o":
              f.base = 8;
              break;
            case "e":
            case "f":
            case "g":
              f.signedconv = true;
              f.conv = c;
              break;
            case "E":
            case "F":
            case "G":
              f.signedconv = true;
              f.uppercase = true;
              f.conv = c.toLowerCase();
              break;
          }
        }
        return f;
      }
      function caml_finish_formatting(f, rawbuffer) {
        if (f.uppercase)
          rawbuffer = rawbuffer.toUpperCase();
        var len = rawbuffer.length;
        if (f.signedconv && (f.sign < 0 || f.signstyle != "-"))
          len++;
        if (f.alternate) {
          if (f.base == 8)
            len += 1;
          if (f.base == 16)
            len += 2;
        }
        var buffer = "";
        if (f.justify == "+" && f.filler == " ")
          for (var i = len; i < f.width; i++)
            buffer += " ";
        if (f.signedconv) {
          if (f.sign < 0)
            buffer += "-";
          else if (f.signstyle != "-")
            buffer += f.signstyle;
        }
        if (f.alternate && f.base == 8)
          buffer += "0";
        if (f.alternate && f.base == 16)
          buffer += f.uppercase ? "0X" : "0x";
        if (f.justify == "+" && f.filler == "0")
          for (var i = len; i < f.width; i++)
            buffer += "0";
        buffer += rawbuffer;
        if (f.justify == "-")
          for (var i = len; i < f.width; i++)
            buffer += " ";
        return caml_string_of_jsbytes(buffer);
      }
      function caml_int64_format(fmt, x2) {
        var f = caml_parse_format(fmt);
        if (f.signedconv && caml_int64_is_negative(x2)) {
          f.sign = -1;
          x2 = caml_int64_neg(x2);
        }
        var buffer = "", wbase = caml_int64_of_int32(f.base), cvtbl = "0123456789abcdef";
        do {
          var p = x2.udivmod(wbase);
          x2 = p.quotient;
          buffer = cvtbl.charAt(caml_int64_to_int32(p.modulus)) + buffer;
        } while (!caml_int64_is_zero(x2));
        if (f.prec >= 0) {
          f.filler = " ";
          var n = f.prec - buffer.length;
          if (n > 0)
            buffer = caml_str_repeat(n, "0") + buffer;
        }
        return caml_finish_formatting(f, buffer);
      }
      function caml_expm1_float(x2) {
        return Math.expm1(x2);
      }
      function caml_ml_condition_broadcast(t) {
        return 0;
      }
      function jsoo_is_ascii(s2) {
        if (s2.length < 24) {
          for (var i = 0; i < s2.length; i++)
            if (s2.charCodeAt(i) > 127)
              return false;
          return true;
        } else
          return !/[^\x00-\x7f]/.test(s2);
      }
      function caml_utf16_of_utf8(s2) {
        for (var b = "", t = "", c, c1, c2, v, i = 0, l = s2.length; i < l; i++) {
          c1 = s2.charCodeAt(i);
          if (c1 < 128) {
            for (var j = i + 1; j < l && (c1 = s2.charCodeAt(j)) < 128; j++)
              ;
            if (j - i > 512) {
              t.substr(0, 1);
              b += t;
              t = "";
              b += s2.slice(i, j);
            } else
              t += s2.slice(i, j);
            if (j == l)
              break;
            i = j;
          }
          v = 1;
          if (++i < l && ((c2 = s2.charCodeAt(i)) & -64) == 128) {
            c = c2 + (c1 << 6);
            if (c1 < 224) {
              v = c - 12416;
              if (v < 128)
                v = 1;
            } else {
              v = 2;
              if (++i < l && ((c2 = s2.charCodeAt(i)) & -64) == 128) {
                c = c2 + (c << 6);
                if (c1 < 240) {
                  v = c - 925824;
                  if (v < 2048 || v >= 55295 && v < 57344)
                    v = 2;
                } else {
                  v = 3;
                  if (++i < l && ((c2 = s2.charCodeAt(i)) & -64) == 128 && c1 < 245) {
                    v = c2 - 63447168 + (c << 6);
                    if (v < 65536 || v > 1114111)
                      v = 3;
                  }
                }
              }
            }
          }
          if (v < 4) {
            i -= v;
            t += "\uFFFD";
          } else if (v > 65535)
            t += String.fromCharCode(55232 + (v >> 10), 56320 + (v & 1023));
          else
            t += String.fromCharCode(v);
          if (t.length > 1024) {
            t.substr(0, 1);
            b += t;
            t = "";
          }
        }
        return b + t;
      }
      function caml_jsstring_of_string(s2) {
        if (jsoo_is_ascii(s2))
          return s2;
        return caml_utf16_of_utf8(s2);
      }
      function fs_node_supported() {
        return typeof globalThis.process !== "undefined" && typeof globalThis.process.versions !== "undefined" && typeof globalThis.process.versions.node !== "undefined";
      }
      function make_path_is_absolute() {
        function posix(path) {
          if (path.charAt(0) === "/")
            return ["", path.substring(1)];
          return;
        }
        function win32(path) {
          var splitDeviceRe = /^([a-zA-Z]:|[\\/]{2}[^\\/]+[\\/]+[^\\/]+)?([\\/])?([\s\S]*?)$/, result = splitDeviceRe.exec(path), device = result[1] || "", isUnc = Boolean(device && device.charAt(1) !== ":");
          if (Boolean(result[2] || isUnc)) {
            var root = result[1] || "", sep = result[2] || "";
            return [root, path.substring(root.length + sep.length)];
          }
          return;
        }
        return fs_node_supported() && globalThis.process && globalThis.process.platform ? globalThis.process.platform === "win32" ? win32 : posix : posix;
      }
      var path_is_absolute = make_path_is_absolute();
      function caml_trailing_slash(name) {
        return name.slice(-1) !== "/" ? name + "/" : name;
      }
      if (fs_node_supported() && globalThis.process && globalThis.process.cwd)
        var caml_current_dir = globalThis.process.cwd().replace(/\\/g, "/");
      else
        var caml_current_dir = "/static";
      caml_current_dir = caml_trailing_slash(caml_current_dir);
      function caml_make_path(name) {
        name = caml_jsstring_of_string(name);
        if (!path_is_absolute(name))
          name = caml_current_dir + name;
        var comp0 = path_is_absolute(name), comp = comp0[1].split("/"), ncomp = [];
        for (var i = 0; i < comp.length; i++)
          switch (comp[i]) {
            case "..":
              if (ncomp.length > 1)
                ncomp.pop();
              break;
            case ".":
              break;
            case "":
              break;
            default:
              ncomp.push(comp[i]);
              break;
          }
        ncomp.unshift(comp0[0]);
        ncomp.orig = name;
        return ncomp;
      }
      function caml_utf8_of_utf16(s2) {
        for (var b = "", t = b, c, d, i = 0, l = s2.length; i < l; i++) {
          c = s2.charCodeAt(i);
          if (c < 128) {
            for (var j = i + 1; j < l && (c = s2.charCodeAt(j)) < 128; j++)
              ;
            if (j - i > 512) {
              t.substr(0, 1);
              b += t;
              t = "";
              b += s2.slice(i, j);
            } else
              t += s2.slice(i, j);
            if (j == l)
              break;
            i = j;
          }
          if (c < 2048) {
            t += String.fromCharCode(192 | c >> 6);
            t += String.fromCharCode(128 | c & 63);
          } else if (c < 55296 || c >= 57343)
            t += String.fromCharCode(224 | c >> 12, 128 | c >> 6 & 63, 128 | c & 63);
          else if (c >= 56319 || i + 1 == l || (d = s2.charCodeAt(i + 1)) < 56320 || d > 57343)
            t += "\xEF\xBF\xBD";
          else {
            i++;
            c = (c << 10) + d - 56613888;
            t += String.fromCharCode(
              240 | c >> 18,
              128 | c >> 12 & 63,
              128 | c >> 6 & 63,
              128 | c & 63
            );
          }
          if (t.length > 1024) {
            t.substr(0, 1);
            b += t;
            t = "";
          }
        }
        return b + t;
      }
      function caml_string_of_jsstring(s2) {
        return jsoo_is_ascii(s2) ? caml_string_of_jsbytes(s2) : caml_string_of_jsbytes(caml_utf8_of_utf16(s2));
      }
      var unix_error = [
        "E2BIG",
        "EACCES",
        "EAGAIN",
        "EBADF",
        "EBUSY",
        "ECHILD",
        "EDEADLK",
        "EDOM",
        "EEXIST",
        "EFAULT",
        "EFBIG",
        "EINTR",
        "EINVAL",
        "EIO",
        "EISDIR",
        "EMFILE",
        "EMLINK",
        "ENAMETOOLONG",
        "ENFILE",
        "ENODEV",
        "ENOENT",
        "ENOEXEC",
        "ENOLCK",
        "ENOMEM",
        "ENOSPC",
        "ENOSYS",
        "ENOTDIR",
        "ENOTEMPTY",
        "ENOTTY",
        "ENXIO",
        "EPERM",
        "EPIPE",
        "ERANGE",
        "EROFS",
        "ESPIPE",
        "ESRCH",
        "EXDEV",
        "EWOULDBLOCK",
        "EINPROGRESS",
        "EALREADY",
        "ENOTSOCK",
        "EDESTADDRREQ",
        "EMSGSIZE",
        "EPROTOTYPE",
        "ENOPROTOOPT",
        "EPROTONOSUPPORT",
        "ESOCKTNOSUPPORT",
        "EOPNOTSUPP",
        "EPFNOSUPPORT",
        "EAFNOSUPPORT",
        "EADDRINUSE",
        "EADDRNOTAVAIL",
        "ENETDOWN",
        "ENETUNREACH",
        "ENETRESET",
        "ECONNABORTED",
        "ECONNRESET",
        "ENOBUFS",
        "EISCONN",
        "ENOTCONN",
        "ESHUTDOWN",
        "ETOOMANYREFS",
        "ETIMEDOUT",
        "ECONNREFUSED",
        "EHOSTDOWN",
        "EHOSTUNREACH",
        "ELOOP",
        "EOVERFLOW"
      ];
      function make_unix_err_args(code, syscall, path, errno) {
        var variant = unix_error.indexOf(code);
        if (variant < 0) {
          if (errno == null)
            errno = -9999;
          variant = [0, errno];
        }
        var args = [
          variant,
          caml_string_of_jsstring(syscall || ""),
          caml_string_of_jsstring(path || "")
        ];
        return args;
      }
      var caml_named_values = {};
      function caml_named_value(nm) {
        return caml_named_values[nm];
      }
      function caml_raise_with_args(tag, args) {
        throw caml_maybe_attach_backtrace([0, tag].concat(args));
      }
      function caml_subarray_to_jsbytes(a, i, len) {
        var f = String.fromCharCode;
        if (i == 0 && len <= 4096 && len == a.length)
          return f.apply(null, a);
        var s2 = "";
        for (; 0 < len; i += 1024, len -= 1024)
          s2 += f.apply(null, a.slice(i, i + Math.min(len, 1024)));
        return s2;
      }
      function caml_convert_string_to_bytes(s2) {
        if (s2.t == 2)
          s2.c += caml_str_repeat(s2.l - s2.c.length, "\0");
        else
          s2.c = caml_subarray_to_jsbytes(s2.c, 0, s2.c.length);
        s2.t = 0;
      }
      function MlBytes(tag, contents, length) {
        this.t = tag;
        this.c = contents;
        this.l = length;
      }
      MlBytes.prototype.toString = function() {
        switch (this.t) {
          case 9:
            return this.c;
          default:
            caml_convert_string_to_bytes(this);
          case 0:
            if (jsoo_is_ascii(this.c)) {
              this.t = 9;
              return this.c;
            }
            this.t = 8;
          case 8:
            return this.c;
        }
      };
      MlBytes.prototype.toUtf16 = function() {
        var r = this.toString();
        if (this.t == 9)
          return r;
        return caml_utf16_of_utf8(r);
      };
      MlBytes.prototype.slice = function() {
        var content = this.t == 4 ? this.c.slice() : this.c;
        return new MlBytes(this.t, content, this.l);
      };
      function caml_is_ml_bytes(s2) {
        return s2 instanceof MlBytes;
      }
      function caml_is_ml_string(s2) {
        return typeof s2 === "string" && !/[^\x00-\xff]/.test(s2);
      }
      function caml_bytes_of_array(a) {
        if (!(a instanceof Uint8Array))
          a = new Uint8Array(a);
        return new MlBytes(4, a, a.length);
      }
      function caml_bytes_of_jsbytes(s2) {
        return new MlBytes(0, s2, s2.length);
      }
      function caml_bytes_of_string(s2) {
        return caml_bytes_of_jsbytes(caml_jsbytes_of_string(s2));
      }
      function caml_raise_sys_error(msg) {
        caml_raise_with_string(caml_global_data.Sys_error, msg);
      }
      function caml_raise_no_such_file(name) {
        caml_raise_sys_error(name + ": No such file or directory");
      }
      function caml_convert_bytes_to_array(s2) {
        var a = new Uint8Array(s2.l), b = s2.c, l = b.length, i = 0;
        for (; i < l; i++)
          a[i] = b.charCodeAt(i);
        for (l = s2.l; i < l; i++)
          a[i] = 0;
        s2.c = a;
        s2.t = 4;
        return a;
      }
      function caml_uint8_array_of_bytes(s2) {
        if (s2.t != 4)
          caml_convert_bytes_to_array(s2);
        return s2.c;
      }
      function caml_create_bytes(len) {
        if (len < 0)
          caml_invalid_argument("Bytes.create");
        return new MlBytes(len ? 2 : 9, "", len);
      }
      function caml_ml_bytes_length(s2) {
        return s2.l;
      }
      function caml_blit_bytes(s1, i1, s2, i2, len) {
        if (len == 0)
          return 0;
        if (i2 == 0 && (len >= s2.l || s2.t == 2 && len >= s2.c.length)) {
          s2.c = s1.t == 4 ? caml_subarray_to_jsbytes(s1.c, i1, len) : i1 == 0 && s1.c.length == len ? s1.c : s1.c.substr(i1, len);
          s2.t = s2.c.length == s2.l ? 0 : 2;
        } else if (s2.t == 2 && i2 == s2.c.length) {
          s2.c += s1.t == 4 ? caml_subarray_to_jsbytes(s1.c, i1, len) : i1 == 0 && s1.c.length == len ? s1.c : s1.c.substr(i1, len);
          s2.t = s2.c.length == s2.l ? 0 : 2;
        } else {
          if (s2.t != 4)
            caml_convert_bytes_to_array(s2);
          var c1 = s1.c, c2 = s2.c;
          if (s1.t == 4)
            if (i2 <= i1)
              for (var i = 0; i < len; i++)
                c2[i2 + i] = c1[i1 + i];
            else
              for (var i = len - 1; i >= 0; i--)
                c2[i2 + i] = c1[i1 + i];
          else {
            var l = Math.min(len, c1.length - i1);
            for (var i = 0; i < l; i++)
              c2[i2 + i] = c1.charCodeAt(i1 + i);
            for (; i < len; i++)
              c2[i2 + i] = 0;
          }
        }
        return 0;
      }
      function MlFile() {
      }
      function MlFakeFile(content) {
        this.data = content;
      }
      MlFakeFile.prototype = new MlFile();
      MlFakeFile.prototype.constructor = MlFakeFile;
      MlFakeFile.prototype.truncate = function(len) {
        var old = this.data;
        this.data = caml_create_bytes(len | 0);
        caml_blit_bytes(old, 0, this.data, 0, len);
      };
      MlFakeFile.prototype.length = function() {
        return caml_ml_bytes_length(this.data);
      };
      MlFakeFile.prototype.write = function(offset, buf, pos, len) {
        var clen = this.length();
        if (offset + len >= clen) {
          var new_str = caml_create_bytes(offset + len), old_data = this.data;
          this.data = new_str;
          caml_blit_bytes(old_data, 0, this.data, 0, clen);
        }
        caml_blit_bytes(caml_bytes_of_array(buf), pos, this.data, offset, len);
        return 0;
      };
      MlFakeFile.prototype.read = function(offset, buf, pos, len) {
        var clen = this.length();
        if (offset + len >= clen)
          len = clen - offset;
        if (len) {
          var data = caml_create_bytes(len | 0);
          caml_blit_bytes(this.data, offset, data, 0, len);
          buf.set(caml_uint8_array_of_bytes(data), pos);
        }
        return len;
      };
      function MlFakeFd(name, file, flags) {
        this.file = file;
        this.name = name;
        this.flags = flags;
      }
      MlFakeFd.prototype.err_closed = function() {
        caml_raise_sys_error(this.name + ": file descriptor already closed");
      };
      MlFakeFd.prototype.length = function() {
        if (this.file)
          return this.file.length();
        this.err_closed();
      };
      MlFakeFd.prototype.write = function(offset, buf, pos, len) {
        if (this.file)
          return this.file.write(offset, buf, pos, len);
        this.err_closed();
      };
      MlFakeFd.prototype.read = function(offset, buf, pos, len) {
        if (this.file)
          return this.file.read(offset, buf, pos, len);
        this.err_closed();
      };
      MlFakeFd.prototype.close = function() {
        this.file = void 0;
      };
      function MlFakeDevice(root, f) {
        this.content = {};
        this.root = root;
        this.lookupFun = f;
      }
      MlFakeDevice.prototype.nm = function(name) {
        return this.root + name;
      };
      MlFakeDevice.prototype.create_dir_if_needed = function(name) {
        var comp = name.split("/"), res = "";
        for (var i = 0; i < comp.length - 1; i++) {
          res += comp[i] + "/";
          if (this.content[res])
            continue;
          this.content[res] = Symbol("directory");
        }
      };
      MlFakeDevice.prototype.slash = function(name) {
        return /\/$/.test(name) ? name : name + "/";
      };
      MlFakeDevice.prototype.lookup = function(name) {
        if (!this.content[name] && this.lookupFun) {
          var res = this.lookupFun(caml_string_of_jsbytes(this.root), caml_string_of_jsbytes(name));
          if (res !== 0) {
            this.create_dir_if_needed(name);
            this.content[name] = new MlFakeFile(caml_bytes_of_string(res[1]));
          }
        }
      };
      MlFakeDevice.prototype.exists = function(name) {
        if (name == "")
          return 1;
        var name_slash = this.slash(name);
        if (this.content[name_slash])
          return 1;
        this.lookup(name);
        return this.content[name] ? 1 : 0;
      };
      MlFakeDevice.prototype.isFile = function(name) {
        return this.exists(name) && !this.is_dir(name) ? 1 : 0;
      };
      MlFakeDevice.prototype.mkdir = function(name, mode, raise_unix) {
        var unix_error2 = raise_unix && caml_named_value("Unix.Unix_error");
        if (this.exists(name))
          if (unix_error2)
            caml_raise_with_args(unix_error2, make_unix_err_args("EEXIST", "mkdir", this.nm(name)));
          else
            caml_raise_sys_error(name + ": File exists");
        var parent = /^(.*)\/[^/]+/.exec(name);
        parent = parent && parent[1] || "";
        if (!this.exists(parent))
          if (unix_error2)
            caml_raise_with_args(unix_error2, make_unix_err_args("ENOENT", "mkdir", this.nm(parent)));
          else
            caml_raise_sys_error(parent + ": No such file or directory");
        if (!this.is_dir(parent))
          if (unix_error2)
            caml_raise_with_args(unix_error2, make_unix_err_args("ENOTDIR", "mkdir", this.nm(parent)));
          else
            caml_raise_sys_error(parent + ": Not a directory");
        this.create_dir_if_needed(this.slash(name));
      };
      MlFakeDevice.prototype.rmdir = function(name, raise_unix) {
        var unix_error2 = raise_unix && caml_named_value("Unix.Unix_error"), name_slash = name == "" ? "" : this.slash(name), r = new RegExp("^" + name_slash + "([^/]+)");
        if (!this.exists(name))
          if (unix_error2)
            caml_raise_with_args(unix_error2, make_unix_err_args("ENOENT", "rmdir", this.nm(name)));
          else
            caml_raise_sys_error(name + ": No such file or directory");
        if (!this.is_dir(name))
          if (unix_error2)
            caml_raise_with_args(unix_error2, make_unix_err_args("ENOTDIR", "rmdir", this.nm(name)));
          else
            caml_raise_sys_error(name + ": Not a directory");
        for (var n in this.content)
          if (n.match(r))
            if (unix_error2)
              caml_raise_with_args(unix_error2, make_unix_err_args("ENOTEMPTY", "rmdir", this.nm(name)));
            else
              caml_raise_sys_error(this.nm(name) + ": Directory not empty");
        delete this.content[name_slash];
      };
      MlFakeDevice.prototype.readdir = function(name) {
        var name_slash = name == "" ? "" : this.slash(name);
        if (!this.exists(name))
          caml_raise_sys_error(name + ": No such file or directory");
        if (!this.is_dir(name))
          caml_raise_sys_error(name + ": Not a directory");
        var r = new RegExp("^" + name_slash + "([^/]+)"), seen = {}, a = [];
        for (var n in this.content) {
          var m = n.match(r);
          if (m && !seen[m[1]]) {
            seen[m[1]] = true;
            a.push(m[1]);
          }
        }
        return a;
      };
      MlFakeDevice.prototype.opendir = function(name, raise_unix) {
        var unix_error2 = raise_unix && caml_named_value("Unix.Unix_error"), a = this.readdir(name), c = false, i = 0;
        return {
          readSync: function() {
            if (c)
              if (unix_error2)
                caml_raise_with_args(
                  unix_error2,
                  make_unix_err_args("EBADF", "closedir", this.nm(name))
                );
              else
                caml_raise_sys_error(name + ": closedir failed");
            if (i == a.length)
              return null;
            var entry = a[i];
            i++;
            return { name: entry };
          },
          closeSync: function() {
            if (c)
              if (unix_error2)
                caml_raise_with_args(
                  unix_error2,
                  make_unix_err_args("EBADF", "closedir", this.nm(name))
                );
              else
                caml_raise_sys_error(name + ": closedir failed");
            c = true;
            a = [];
          }
        };
      };
      MlFakeDevice.prototype.is_dir = function(name) {
        if (name == "")
          return true;
        var name_slash = this.slash(name);
        return this.content[name_slash] ? 1 : 0;
      };
      MlFakeDevice.prototype.unlink = function(name) {
        var ok = this.content[name] ? true : false;
        delete this.content[name];
        return ok;
      };
      MlFakeDevice.prototype.open = function(name, f) {
        var file;
        if (f.rdonly && f.wronly)
          caml_raise_sys_error(this.nm(name) + " : flags Open_rdonly and Open_wronly are not compatible");
        if (f.text && f.binary)
          caml_raise_sys_error(this.nm(name) + " : flags Open_text and Open_binary are not compatible");
        this.lookup(name);
        if (this.content[name]) {
          if (this.is_dir(name))
            caml_raise_sys_error(this.nm(name) + " : is a directory");
          if (f.create && f.excl)
            caml_raise_sys_error(this.nm(name) + " : file already exists");
          file = this.content[name];
          if (f.truncate)
            file.truncate();
        } else if (f.create) {
          this.create_dir_if_needed(name);
          this.content[name] = new MlFakeFile(caml_create_bytes(0));
          file = this.content[name];
        } else
          caml_raise_no_such_file(this.nm(name));
        return new MlFakeFd(this.nm(name), file, f);
      };
      MlFakeDevice.prototype.open = function(name, f) {
        var file;
        if (f.rdonly && f.wronly)
          caml_raise_sys_error(this.nm(name) + " : flags Open_rdonly and Open_wronly are not compatible");
        if (f.text && f.binary)
          caml_raise_sys_error(this.nm(name) + " : flags Open_text and Open_binary are not compatible");
        this.lookup(name);
        if (this.content[name]) {
          if (this.is_dir(name))
            caml_raise_sys_error(this.nm(name) + " : is a directory");
          if (f.create && f.excl)
            caml_raise_sys_error(this.nm(name) + " : file already exists");
          file = this.content[name];
          if (f.truncate)
            file.truncate();
        } else if (f.create) {
          this.create_dir_if_needed(name);
          this.content[name] = new MlFakeFile(caml_create_bytes(0));
          file = this.content[name];
        } else
          caml_raise_no_such_file(this.nm(name));
        return new MlFakeFd(this.nm(name), file, f);
      };
      MlFakeDevice.prototype.register = function(name, content) {
        var file;
        if (this.content[name])
          caml_raise_sys_error(this.nm(name) + " : file already exists");
        if (caml_is_ml_bytes(content))
          file = new MlFakeFile(content);
        if (caml_is_ml_string(content))
          file = new MlFakeFile(caml_bytes_of_string(content));
        else if (content instanceof Array)
          file = new MlFakeFile(caml_bytes_of_array(content));
        else if (typeof content === "string")
          file = new MlFakeFile(caml_bytes_of_jsbytes(content));
        else if (content.toString) {
          var bytes = caml_bytes_of_string(caml_string_of_jsstring(content.toString()));
          file = new MlFakeFile(bytes);
        }
        if (file) {
          this.create_dir_if_needed(name);
          this.content[name] = file;
        } else
          caml_raise_sys_error(this.nm(name) + " : registering file with invalid content type");
      };
      MlFakeDevice.prototype.constructor = MlFakeDevice;
      function caml_ml_string_length(s2) {
        return s2.length;
      }
      function caml_string_unsafe_get(s2, i) {
        return s2.charCodeAt(i);
      }
      function caml_uint8_array_of_string(s2) {
        var l = caml_ml_string_length(s2), a = new Uint8Array(l), i = 0;
        for (; i < l; i++)
          a[i] = caml_string_unsafe_get(s2, i);
        return a;
      }
      function caml_bytes_bound_error() {
        caml_invalid_argument("index out of bounds");
      }
      function caml_bytes_unsafe_set(s2, i, c) {
        c &= 255;
        if (s2.t != 4) {
          if (i == s2.c.length) {
            s2.c += String.fromCharCode(c);
            if (i + 1 == s2.l)
              s2.t = 0;
            return 0;
          }
          caml_convert_bytes_to_array(s2);
        }
        s2.c[i] = c;
        return 0;
      }
      function caml_bytes_set(s2, i, c) {
        if (i >>> 0 >= s2.l)
          caml_bytes_bound_error();
        return caml_bytes_unsafe_set(s2, i, c);
      }
      function MlNodeFd(fd, flags) {
        this.fs = __require("fs");
        this.fd = fd;
        this.flags = flags;
      }
      MlNodeFd.prototype = new MlFile();
      MlNodeFd.prototype.constructor = MlNodeFd;
      MlNodeFd.prototype.truncate = function(len) {
        try {
          this.fs.ftruncateSync(this.fd, len | 0);
        } catch (err) {
          caml_raise_sys_error(err.toString());
        }
      };
      MlNodeFd.prototype.length = function() {
        try {
          return this.fs.fstatSync(this.fd).size;
        } catch (err) {
          caml_raise_sys_error(err.toString());
        }
      };
      MlNodeFd.prototype.write = function(offset, buf, buf_offset, len) {
        try {
          if (this.flags.isCharacterDevice)
            this.fs.writeSync(this.fd, buf, buf_offset, len);
          else
            this.fs.writeSync(this.fd, buf, buf_offset, len, offset);
        } catch (err) {
          caml_raise_sys_error(err.toString());
        }
        return 0;
      };
      MlNodeFd.prototype.read = function(offset, a, buf_offset, len) {
        try {
          if (this.flags.isCharacterDevice)
            var read = this.fs.readSync(this.fd, a, buf_offset, len);
          else
            var read = this.fs.readSync(this.fd, a, buf_offset, len, offset);
          return read;
        } catch (err) {
          caml_raise_sys_error(err.toString());
        }
      };
      MlNodeFd.prototype.close = function() {
        try {
          this.fs.closeSync(this.fd);
          return 0;
        } catch (err) {
          caml_raise_sys_error(err.toString());
        }
      };
      function MlNodeDevice(root) {
        this.fs = __require("fs");
        this.root = root;
      }
      MlNodeDevice.prototype.nm = function(name) {
        return this.root + name;
      };
      MlNodeDevice.prototype.exists = function(name) {
        try {
          return this.fs.existsSync(this.nm(name)) ? 1 : 0;
        } catch (err) {
          return 0;
        }
      };
      MlNodeDevice.prototype.isFile = function(name) {
        try {
          return this.fs.statSync(this.nm(name)).isFile() ? 1 : 0;
        } catch (err) {
          caml_raise_sys_error(err.toString());
        }
      };
      MlNodeDevice.prototype.mkdir = function(name, mode, raise_unix) {
        try {
          this.fs.mkdirSync(this.nm(name), { mode });
          return 0;
        } catch (err) {
          this.raise_nodejs_error(err, raise_unix);
        }
      };
      MlNodeDevice.prototype.rmdir = function(name, raise_unix) {
        try {
          this.fs.rmdirSync(this.nm(name));
          return 0;
        } catch (err) {
          this.raise_nodejs_error(err, raise_unix);
        }
      };
      MlNodeDevice.prototype.readdir = function(name, raise_unix) {
        try {
          return this.fs.readdirSync(this.nm(name));
        } catch (err) {
          this.raise_nodejs_error(err, raise_unix);
        }
      };
      MlNodeDevice.prototype.is_dir = function(name) {
        try {
          return this.fs.statSync(this.nm(name)).isDirectory() ? 1 : 0;
        } catch (err) {
          caml_raise_sys_error(err.toString());
        }
      };
      MlNodeDevice.prototype.unlink = function(name, raise_unix) {
        try {
          var b = this.fs.existsSync(this.nm(name)) ? 1 : 0;
          this.fs.unlinkSync(this.nm(name));
          return b;
        } catch (err) {
          this.raise_nodejs_error(err, raise_unix);
        }
      };
      MlNodeDevice.prototype.open = function(name, f, raise_unix) {
        var consts = __require("constants"), res = 0;
        for (var key in f)
          switch (key) {
            case "rdonly":
              res |= consts.O_RDONLY;
              break;
            case "wronly":
              res |= consts.O_WRONLY;
              break;
            case "append":
              res |= consts.O_WRONLY | consts.O_APPEND;
              break;
            case "create":
              res |= consts.O_CREAT;
              break;
            case "truncate":
              res |= consts.O_TRUNC;
              break;
            case "excl":
              res |= consts.O_EXCL;
              break;
            case "binary":
              res |= consts.O_BINARY;
              break;
            case "text":
              res |= consts.O_TEXT;
              break;
            case "nonblock":
              res |= consts.O_NONBLOCK;
              break;
          }
        try {
          var fd = this.fs.openSync(this.nm(name), res), isCharacterDevice = this.fs.lstatSync(this.nm(name)).isCharacterDevice();
          f.isCharacterDevice = isCharacterDevice;
          return new MlNodeFd(fd, f);
        } catch (err) {
          this.raise_nodejs_error(err, raise_unix);
        }
      };
      MlNodeDevice.prototype.rename = function(o, n, raise_unix) {
        try {
          this.fs.renameSync(this.nm(o), this.nm(n));
        } catch (err) {
          this.raise_nodejs_error(err, raise_unix);
        }
      };
      MlNodeDevice.prototype.stat = function(name, raise_unix) {
        try {
          var js_stats = this.fs.statSync(this.nm(name));
          return this.stats_from_js(js_stats);
        } catch (err) {
          this.raise_nodejs_error(err, raise_unix);
        }
      };
      MlNodeDevice.prototype.lstat = function(name, raise_unix) {
        try {
          var js_stats = this.fs.lstatSync(this.nm(name));
          return this.stats_from_js(js_stats);
        } catch (err) {
          this.raise_nodejs_error(err, raise_unix);
        }
      };
      MlNodeDevice.prototype.symlink = function(to_dir, target, path, raise_unix) {
        try {
          this.fs.symlinkSync(this.nm(target), this.nm(path), to_dir ? "dir" : "file");
          return 0;
        } catch (err) {
          this.raise_nodejs_error(err, raise_unix);
        }
      };
      MlNodeDevice.prototype.readlink = function(name, raise_unix) {
        try {
          var link = this.fs.readlinkSync(this.nm(name), "utf8");
          return caml_string_of_jsstring(link);
        } catch (err) {
          this.raise_nodejs_error(err, raise_unix);
        }
      };
      MlNodeDevice.prototype.opendir = function(name, raise_unix) {
        try {
          return this.fs.opendirSync(this.nm(name));
        } catch (err) {
          this.raise_nodejs_error(err, raise_unix);
        }
      };
      MlNodeDevice.prototype.raise_nodejs_error = function(err, raise_unix) {
        var unix_error2 = caml_named_value("Unix.Unix_error");
        if (raise_unix && unix_error2) {
          var args = make_unix_err_args(err.code, err.syscall, err.path, err.errno);
          caml_raise_with_args(unix_error2, args);
        } else
          caml_raise_sys_error(err.toString());
      };
      MlNodeDevice.prototype.stats_from_js = function(js_stats) {
        var file_kind;
        if (js_stats.isFile())
          file_kind = 0;
        else if (js_stats.isDirectory())
          file_kind = 1;
        else if (js_stats.isCharacterDevice())
          file_kind = 2;
        else if (js_stats.isBlockDevice())
          file_kind = 3;
        else if (js_stats.isSymbolicLink())
          file_kind = 4;
        else if (js_stats.isFIFO())
          file_kind = 5;
        else if (js_stats.isSocket())
          file_kind = 6;
        return [
          0,
          js_stats.dev,
          js_stats.ino,
          file_kind,
          js_stats.mode,
          js_stats.nlink,
          js_stats.uid,
          js_stats.gid,
          js_stats.rdev,
          js_stats.size,
          js_stats.atimeMs,
          js_stats.mtimeMs,
          js_stats.ctimeMs
        ];
      };
      MlNodeDevice.prototype.constructor = MlNodeDevice;
      function caml_get_root(path) {
        var x2 = path_is_absolute(path);
        if (!x2)
          return;
        return x2[0] + "/";
      }
      function caml_failwith(msg) {
        if (!caml_global_data.Failure)
          caml_global_data.Failure = [248, caml_string_of_jsbytes("Failure"), -3];
        caml_raise_with_string(caml_global_data.Failure, msg);
      }
      var caml_root = caml_get_root(caml_current_dir) || caml_failwith("unable to compute caml_root"), jsoo_mount_point = [];
      if (fs_node_supported())
        jsoo_mount_point.push({ path: caml_root, device: new MlNodeDevice(caml_root) });
      else
        jsoo_mount_point.push({ path: caml_root, device: new MlFakeDevice(caml_root) });
      jsoo_mount_point.push({ path: "/static/", device: new MlFakeDevice("/static/") });
      function resolve_fs_device(name) {
        var path = caml_make_path(name), name = path.join("/"), name_slash = caml_trailing_slash(name), res;
        for (var i = 0; i < jsoo_mount_point.length; i++) {
          var m = jsoo_mount_point[i];
          if (name_slash.search(m.path) == 0 && (!res || res.path.length < m.path.length))
            res = {
              path: m.path,
              device: m.device,
              rest: name.substring(m.path.length, name.length)
            };
        }
        if (!res && fs_node_supported()) {
          var root = caml_get_root(name);
          if (root && root.match(/^[a-zA-Z]:\/$/)) {
            var m = { path: root, device: new MlNodeDevice(root) };
            jsoo_mount_point.push(m);
            res = {
              path: m.path,
              device: m.device,
              rest: name.substring(m.path.length, name.length)
            };
          }
        }
        if (res)
          return res;
        caml_raise_sys_error("no device found for " + name_slash);
      }
      function caml_sys_is_directory(name) {
        var root = resolve_fs_device(name), a = root.device.is_dir(root.rest);
        return a ? 1 : 0;
      }
      function caml_raise_not_found() {
        caml_raise_constant(caml_global_data.Not_found);
      }
      function caml_sys_getenv(name) {
        var r = jsoo_sys_getenv(caml_jsstring_of_string(name));
        if (r === void 0)
          caml_raise_not_found();
        return caml_string_of_jsstring(r);
      }
      function shift_right_nat(nat1, ofs1, len1, nat2, ofs2, nbits) {
        if (nbits == 0) {
          nat2.data[ofs2] = 0;
          return 0;
        }
        var wrap = 0;
        for (var i = len1 - 1; i >= 0; i--) {
          var a = nat1.data[ofs1 + i] >>> 0;
          nat1.data[ofs1 + i] = a >>> nbits | wrap;
          wrap = a << 32 - nbits;
        }
        nat2.data[ofs2] = wrap;
        return 0;
      }
      var caml_gr_state;
      function caml_gr_state_get() {
        if (caml_gr_state)
          return caml_gr_state;
        throw caml_maybe_attach_backtrace([
          0,
          caml_named_value("Graphics.Graphic_failure"),
          caml_string_of_jsbytes("Not initialized")
        ]);
      }
      function caml_gr_point_color(x2, y) {
        var s2 = caml_gr_state_get(), im = s2.context.getImageData(x2, s2.height - y, 1, 1), d = im.data;
        return (d[0] << 16) + (d[1] << 8) + d[2];
      }
      function caml_runtime_events_user_resolve() {
        return 0;
      }
      var MlObjectTable;
      if (typeof globalThis.Map === "undefined")
        MlObjectTable = function() {
          function NaiveLookup(objs) {
            this.objs = objs;
          }
          NaiveLookup.prototype.get = function(v) {
            for (var i = 0; i < this.objs.length; i++)
              if (this.objs[i] === v)
                return i;
          };
          NaiveLookup.prototype.set = function() {
          };
          return function() {
            this.objs = [];
            this.lookup = new NaiveLookup(this.objs);
          };
        }();
      else
        MlObjectTable = function() {
          this.objs = [];
          this.lookup = new globalThis.Map();
        };
      MlObjectTable.prototype.store = function(v) {
        this.lookup.set(v, this.objs.length);
        this.objs.push(v);
      };
      MlObjectTable.prototype.recall = function(v) {
        var i = this.lookup.get(v);
        return i === void 0 ? void 0 : this.objs.length - i;
      };
      function caml_sys_rename(o, n) {
        var o_root = resolve_fs_device(o), n_root = resolve_fs_device(n);
        if (o_root.device != n_root.device)
          caml_failwith("caml_sys_rename: cannot move file between two filesystem");
        if (!o_root.device.rename)
          caml_failwith("caml_sys_rename: no implemented");
        o_root.device.rename(o_root.rest, n_root.rest);
      }
      function caml_log10_float(x2) {
        return Math.log10(x2);
      }
      var caml_runtime_warnings = 0;
      function caml_ml_enable_runtime_warnings(bool) {
        caml_runtime_warnings = bool;
        return 0;
      }
      function caml_classify_float(x2) {
        if (isFinite(x2)) {
          if (Math.abs(x2) >= 22250738585072014e-324)
            return 0;
          if (x2 != 0)
            return 1;
          return 2;
        }
        return isNaN(x2) ? 4 : 3;
      }
      var caml_ml_channels = new Array();
      function caml_refill(chan) {
        if (chan.refill != null) {
          var str = chan.refill(), str_a = caml_uint8_array_of_string(str);
          if (str_a.length == 0)
            chan.refill = null;
          else {
            if (chan.buffer.length < chan.buffer_max + str_a.length) {
              var b = new Uint8Array(chan.buffer_max + str_a.length);
              b.set(chan.buffer);
              chan.buffer = b;
            }
            chan.buffer.set(str_a, chan.buffer_max);
            chan.offset += str_a.length;
            chan.buffer_max += str_a.length;
          }
        } else {
          var nread = chan.file.read(
            chan.offset,
            chan.buffer,
            chan.buffer_max,
            chan.buffer.length - chan.buffer_max
          );
          chan.offset += nread;
          chan.buffer_max += nread;
        }
      }
      function caml_array_bound_error() {
        caml_invalid_argument("index out of bounds");
      }
      function caml_ml_input_scan_line(chanid) {
        var chan = caml_ml_channels[chanid], p = chan.buffer_curr;
        do
          if (p >= chan.buffer_max) {
            if (chan.buffer_curr > 0) {
              chan.buffer.set(chan.buffer.subarray(chan.buffer_curr), 0);
              p -= chan.buffer_curr;
              chan.buffer_max -= chan.buffer_curr;
              chan.buffer_curr = 0;
            }
            if (chan.buffer_max >= chan.buffer.length)
              return -chan.buffer_max | 0;
            var prev_max = chan.buffer_max;
            caml_refill(chan);
            if (prev_max == chan.buffer_max)
              return -chan.buffer_max | 0;
          }
        while (chan.buffer[p++] != 10);
        return p - chan.buffer_curr | 0;
      }
      function caml_gc_minor(unit) {
        if (typeof globalThis.gc == "function")
          globalThis.gc(true);
        return 0;
      }
      function caml_ml_condition_new(unit) {
        return { condition: 1 };
      }
      function caml_ba_to_typed_array(ba) {
        return ba.data;
      }
      function caml_ml_input_block(chanid, ba, i, l) {
        var chan = caml_ml_channels[chanid], n = l, avail = chan.buffer_max - chan.buffer_curr;
        if (l <= avail) {
          ba.set(chan.buffer.subarray(chan.buffer_curr, chan.buffer_curr + l), i);
          chan.buffer_curr += l;
        } else if (avail > 0) {
          ba.set(chan.buffer.subarray(chan.buffer_curr, chan.buffer_curr + avail), i);
          chan.buffer_curr += avail;
          n = avail;
        } else {
          chan.buffer_curr = 0;
          chan.buffer_max = 0;
          caml_refill(chan);
          var avail = chan.buffer_max - chan.buffer_curr;
          if (n > avail)
            n = avail;
          ba.set(chan.buffer.subarray(chan.buffer_curr, chan.buffer_curr + n), i);
          chan.buffer_curr += n;
        }
        return n | 0;
      }
      function caml_ml_input_bigarray(chanid, b, i, l) {
        var ba = caml_ba_to_typed_array(b);
        return caml_ml_input_block(chanid, ba, i, l);
      }
      function caml_int64_of_bytes(a) {
        return new MlInt64(
          a[7] << 0 | a[6] << 8 | a[5] << 16,
          a[4] << 0 | a[3] << 8 | a[2] << 16,
          a[1] << 0 | a[0] << 8
        );
      }
      function caml_ba_uint8_get64(ba, i0) {
        var ofs = ba.offset(i0);
        if (ofs + 7 >= ba.data.length)
          caml_array_bound_error();
        var b1 = ba.get(ofs + 0), b2 = ba.get(ofs + 1), b3 = ba.get(ofs + 2), b4 = ba.get(ofs + 3), b5 = ba.get(ofs + 4), b6 = ba.get(ofs + 5), b7 = ba.get(ofs + 6), b8 = ba.get(ofs + 7);
        return caml_int64_of_bytes([b8, b7, b6, b5, b4, b3, b2, b1]);
      }
      function caml_int64_to_bytes(x2) {
        return x2.toArray();
      }
      function caml_int64_marshal(writer, v, sizes) {
        var b = caml_int64_to_bytes(v);
        for (var i = 0; i < 8; i++)
          writer.write(8, b[i]);
        sizes[0] = 8;
        sizes[1] = 8;
      }
      function caml_ba_num_dims(ba) {
        return ba.dims.length;
      }
      function caml_wrap_exception(e) {
        {
          if (e instanceof Array)
            return e;
          var exn;
          if (globalThis.RangeError && e instanceof globalThis.RangeError && e.message && e.message.match(/maximum call stack/i))
            exn = caml_global_data.Stack_overflow;
          else if (globalThis.InternalError && e instanceof globalThis.InternalError && e.message && e.message.match(/too much recursion/i))
            exn = caml_global_data.Stack_overflow;
          else if (e instanceof globalThis.Error && caml_named_value("jsError"))
            exn = [0, caml_named_value("jsError"), e];
          else
            exn = [0, caml_global_data.Failure, caml_string_of_jsstring(String(e))];
          if (e instanceof globalThis.Error)
            exn.js_error = e;
          return exn;
        }
      }
      function caml_create_file(name, content) {
        var root = resolve_fs_device(name);
        if (!root.device.register)
          caml_failwith("cannot register file");
        root.device.register(root.rest, content);
        return 0;
      }
      function jsoo_create_file(name, content) {
        var name = caml_string_of_jsbytes(name), content = caml_string_of_jsbytes(content);
        return caml_create_file(name, content);
      }
      function caml_fs_init() {
        var tmp = globalThis.caml_fs_tmp;
        if (tmp)
          for (var i = 0; i < tmp.length; i++)
            jsoo_create_file(tmp[i].name, tmp[i].content);
        globalThis.jsoo_create_file = jsoo_create_file;
        globalThis.caml_fs_tmp = [];
        return 0;
      }
      function caml_get_continuation_callstack() {
        return [0];
      }
      var caml_parser_trace = 0;
      function caml_set_parser_trace(bool) {
        var oldflag = caml_parser_trace;
        caml_parser_trace = bool;
        return oldflag;
      }
      function caml_list_of_js_array(a) {
        var l = 0;
        for (var i = a.length - 1; i >= 0; i--) {
          var e = a[i];
          l = [0, e, l];
        }
        return l;
      }
      function caml_mul(a, b) {
        return Math.imul(a, b);
      }
      function caml_hash_mix_int(h, d) {
        d = caml_mul(d, 3432918353 | 0);
        d = d << 15 | d >>> 32 - 15;
        d = caml_mul(d, 461845907);
        h ^= d;
        h = h << 13 | h >>> 32 - 13;
        return (h + (h << 2) | 0) + (3864292196 | 0) | 0;
      }
      function num_digits_nat(nat, ofs, len) {
        for (var i = len - 1; i >= 0; i--)
          if (nat.data[ofs + i] != 0)
            return i + 1;
        return 1;
      }
      function caml_hash_nat(x2) {
        var len = num_digits_nat(x2, 0, x2.data.length), h = 0;
        for (var i = 0; i < len; i++)
          h = caml_hash_mix_int(h, x2.data[i]);
        return h;
      }
      function caml_call_gen(f, args) {
        var n = f.l >= 0 ? f.l : f.l = f.length, argsLen = args.length, d = n - argsLen;
        if (d == 0)
          return f.apply(null, args);
        else if (d < 0) {
          var g = f.apply(null, args.slice(0, n));
          if (typeof g !== "function")
            return g;
          return caml_call_gen(g, args.slice(n));
        } else {
          switch (d) {
            case 1: {
              var g = function(x2) {
                var nargs = new Array(argsLen + 1);
                for (var i = 0; i < argsLen; i++)
                  nargs[i] = args[i];
                nargs[argsLen] = x2;
                return f.apply(null, nargs);
              };
              break;
            }
            case 2: {
              var g = function(x2, y) {
                var nargs = new Array(argsLen + 2);
                for (var i = 0; i < argsLen; i++)
                  nargs[i] = args[i];
                nargs[argsLen] = x2;
                nargs[argsLen + 1] = y;
                return f.apply(null, nargs);
              };
              break;
            }
            default:
              var g = function() {
                var extra_args = arguments.length == 0 ? 1 : arguments.length, nargs = new Array(args.length + extra_args);
                for (var i = 0; i < args.length; i++)
                  nargs[i] = args[i];
                for (var i = 0; i < arguments.length; i++)
                  nargs[args.length + i] = arguments[i];
                return caml_call_gen(f, nargs);
              };
          }
          g.l = d;
          return g;
        }
      }
      var caml_callback = caml_call_gen;
      function caml_js_wrap_callback_arguments(f) {
        return function() {
          var len = arguments.length, args = new Array(len);
          for (var i = 0; i < len; i++)
            args[i] = arguments[i];
          return caml_callback(f, [args]);
        };
      }
      function caml_sys_chdir(dir) {
        var root = resolve_fs_device(dir);
        if (root.device.exists(root.rest)) {
          if (root.rest)
            caml_current_dir = caml_trailing_slash(root.path + root.rest);
          else
            caml_current_dir = root.path;
          return 0;
        } else
          caml_raise_no_such_file(caml_jsbytes_of_string(dir));
      }
      function caml_obj_update_tag(b, o, n) {
        if (b[0] == o) {
          b[0] = n;
          return 1;
        }
        return 0;
      }
      function caml_lazy_update_to_forcing(o) {
        return o instanceof Array && o[0] == o[0] >>> 0 && caml_obj_update_tag(o, 246, 244) ? 0 : 1;
      }
      function caml_gc_counters() {
        return [254, 0, 0, 0];
      }
      function caml_gr_synchronize() {
        caml_failwith("caml_gr_synchronize not Implemented");
      }
      function caml_unix_closedir(dir_handle) {
        try {
          dir_handle.pointer.closeSync();
        } catch (e) {
          var unix_error2 = caml_named_value("Unix.Unix_error");
          caml_raise_with_args(unix_error2, make_unix_err_args("EBADF", "closedir", dir_handle.path));
        }
      }
      function caml_unix_opendir(path) {
        var root = resolve_fs_device(path);
        if (!root.device.opendir)
          caml_failwith("caml_unix_opendir: not implemented");
        var dir_handle = root.device.opendir(root.rest, true);
        return { pointer: dir_handle, path };
      }
      function caml_unix_rewinddir(dir_handle) {
        caml_unix_closedir(dir_handle);
        var new_dir_handle = caml_unix_opendir(dir_handle.path);
        dir_handle.pointer = new_dir_handle.pointer;
        return 0;
      }
      function caml_raise_end_of_file() {
        caml_raise_constant(caml_global_data.End_of_file);
      }
      function caml_unix_readdir(dir_handle) {
        var entry;
        try {
          entry = dir_handle.pointer.readSync();
        } catch (e) {
          var unix_error2 = caml_named_value("Unix.Unix_error");
          caml_raise_with_args(unix_error2, make_unix_err_args("EBADF", "readdir", dir_handle.path));
        }
        if (entry === null)
          caml_raise_end_of_file();
        else
          return caml_string_of_jsstring(entry.name);
      }
      function caml_unix_findfirst(path) {
        var path_js = caml_jsstring_of_string(path);
        path_js = path_js.replace(/(^|[\\\/])\*\.\*$/, "");
        path = caml_string_of_jsstring(path_js);
        var dir_handle = caml_unix_opendir(path), first_entry = caml_unix_readdir(dir_handle);
        return [0, first_entry, dir_handle];
      }
      function caml_is_continuation_tag(t) {
        return t == 245 ? 1 : 0;
      }
      var log2_ok = Math.log2 && Math.log2(11235582092889474e291) == 1020;
      function jsoo_floor_log2(x2) {
        if (log2_ok)
          return Math.floor(Math.log2(x2));
        var i = 0;
        if (x2 == 0)
          return -Infinity;
        if (x2 >= 1)
          while (x2 >= 2) {
            x2 /= 2;
            i++;
          }
        else
          while (x2 < 1) {
            x2 *= 2;
            i--;
          }
        return i;
      }
      function caml_int32_bits_of_float(x2) {
        var float32a = new Float32Array(1);
        float32a[0] = x2;
        var int32a = new Int32Array(float32a.buffer);
        return int32a[0] | 0;
      }
      function caml_int64_create_lo_mi_hi(lo, mi, hi) {
        return new MlInt64(lo, mi, hi);
      }
      function caml_int64_bits_of_float(x2) {
        if (!isFinite(x2)) {
          if (isNaN(x2))
            return caml_int64_create_lo_mi_hi(1, 0, 32752);
          return x2 > 0 ? caml_int64_create_lo_mi_hi(0, 0, 32752) : caml_int64_create_lo_mi_hi(0, 0, 65520);
        }
        var sign = x2 == 0 && 1 / x2 == -Infinity ? 32768 : x2 >= 0 ? 0 : 32768;
        if (sign)
          x2 = -x2;
        var exp = jsoo_floor_log2(x2) + 1023;
        if (exp <= 0) {
          exp = 0;
          x2 /= Math.pow(2, -1026);
        } else {
          x2 /= Math.pow(2, exp - 1027);
          if (x2 < 16) {
            x2 *= 2;
            exp -= 1;
          }
          if (exp == 0)
            x2 /= 2;
        }
        var k = Math.pow(2, 24), r3 = x2 | 0;
        x2 = (x2 - r3) * k;
        var r2 = x2 | 0;
        x2 = (x2 - r2) * k;
        var r1 = x2 | 0;
        r3 = r3 & 15 | sign | exp << 4;
        return caml_int64_create_lo_mi_hi(r1, r2, r3);
      }
      function caml_ba_serialize(writer, ba, sz) {
        writer.write(32, ba.dims.length);
        writer.write(32, ba.kind | ba.layout << 8);
        if (ba.caml_custom == "_bigarr02")
          for (var i = 0; i < ba.dims.length; i++)
            if (ba.dims[i] < 65535)
              writer.write(16, ba.dims[i]);
            else {
              writer.write(16, 65535);
              writer.write(32, 0);
              writer.write(32, ba.dims[i]);
            }
        else
          for (var i = 0; i < ba.dims.length; i++)
            writer.write(32, ba.dims[i]);
        switch (ba.kind) {
          case 2:
          case 3:
          case 12:
            for (var i = 0; i < ba.data.length; i++)
              writer.write(8, ba.data[i]);
            break;
          case 4:
          case 5:
            for (var i = 0; i < ba.data.length; i++)
              writer.write(16, ba.data[i]);
            break;
          case 6:
            for (var i = 0; i < ba.data.length; i++)
              writer.write(32, ba.data[i]);
            break;
          case 8:
          case 9:
            writer.write(8, 0);
            for (var i = 0; i < ba.data.length; i++)
              writer.write(32, ba.data[i]);
            break;
          case 7:
            for (var i = 0; i < ba.data.length / 2; i++) {
              var b = caml_int64_to_bytes(ba.get(i));
              for (var j = 0; j < 8; j++)
                writer.write(8, b[j]);
            }
            break;
          case 1:
            for (var i = 0; i < ba.data.length; i++) {
              var b = caml_int64_to_bytes(caml_int64_bits_of_float(ba.get(i)));
              for (var j = 0; j < 8; j++)
                writer.write(8, b[j]);
            }
            break;
          case 0:
            for (var i = 0; i < ba.data.length; i++) {
              var b = caml_int32_bits_of_float(ba.get(i));
              writer.write(32, b);
            }
            break;
          case 10:
            for (var i = 0; i < ba.data.length / 2; i++) {
              var j = ba.get(i);
              writer.write(32, caml_int32_bits_of_float(j[1]));
              writer.write(32, caml_int32_bits_of_float(j[2]));
            }
            break;
          case 11:
            for (var i = 0; i < ba.data.length / 2; i++) {
              var complex = ba.get(i), b = caml_int64_to_bytes(caml_int64_bits_of_float(complex[1]));
              for (var j = 0; j < 8; j++)
                writer.write(8, b[j]);
              var b = caml_int64_to_bytes(caml_int64_bits_of_float(complex[2]));
              for (var j = 0; j < 8; j++)
                writer.write(8, b[j]);
            }
            break;
        }
        sz[0] = (4 + ba.dims.length) * 4;
        sz[1] = (4 + ba.dims.length) * 8;
      }
      function caml_ba_get_size_per_element(kind) {
        switch (kind) {
          case 7:
          case 10:
          case 11:
            return 2;
          default:
            return 1;
        }
      }
      function caml_ba_create_buffer(kind, size) {
        var view;
        switch (kind) {
          case 0:
            view = Float32Array;
            break;
          case 1:
            view = Float64Array;
            break;
          case 2:
            view = Int8Array;
            break;
          case 3:
            view = Uint8Array;
            break;
          case 4:
            view = Int16Array;
            break;
          case 5:
            view = Uint16Array;
            break;
          case 6:
            view = Int32Array;
            break;
          case 7:
            view = Int32Array;
            break;
          case 8:
            view = Int32Array;
            break;
          case 9:
            view = Int32Array;
            break;
          case 10:
            view = Float32Array;
            break;
          case 11:
            view = Float64Array;
            break;
          case 12:
            view = Uint8Array;
            break;
        }
        if (!view)
          caml_invalid_argument("Bigarray.create: unsupported kind");
        var data = new view(size * caml_ba_get_size_per_element(kind));
        return data;
      }
      function caml_int32_float_of_bits(x2) {
        var int32a = new Int32Array(1);
        int32a[0] = x2;
        var float32a = new Float32Array(int32a.buffer);
        return float32a[0];
      }
      function caml_int64_float_of_bits(x2) {
        var lo = x2.lo, mi = x2.mi, hi = x2.hi, exp = (hi & 32767) >> 4;
        if (exp == 2047)
          return (lo | mi | hi & 15) == 0 ? hi & 32768 ? -Infinity : Infinity : NaN;
        var k = Math.pow(2, -24), res = (lo * k + mi) * k + (hi & 15);
        if (exp > 0) {
          res += 16;
          res *= Math.pow(2, exp - 1027);
        } else
          res *= Math.pow(2, -1026);
        if (hi & 32768)
          res = -res;
        return res;
      }
      function caml_ba_get_size(dims) {
        var n_dims = dims.length, size = 1;
        for (var i = 0; i < n_dims; i++) {
          if (dims[i] < 0)
            caml_invalid_argument("Bigarray.create: negative dimension");
          size = size * dims[i];
        }
        return size;
      }
      function caml_int64_create_lo_hi(lo, hi) {
        return new MlInt64(
          lo & 16777215,
          lo >>> 24 & 255 | (hi & 65535) << 8,
          hi >>> 16 & 65535
        );
      }
      function caml_int64_hi32(v) {
        return v.hi32();
      }
      function caml_int64_lo32(v) {
        return v.lo32();
      }
      var caml_ba_custom_name = "_bigarr02";
      function Ml_Bigarray(kind, layout, dims, buffer) {
        this.kind = kind;
        this.layout = layout;
        this.dims = dims;
        this.data = buffer;
      }
      Ml_Bigarray.prototype.caml_custom = caml_ba_custom_name;
      Ml_Bigarray.prototype.offset = function(arg) {
        var ofs = 0;
        if (typeof arg === "number")
          arg = [arg];
        if (!(arg instanceof Array))
          caml_invalid_argument("bigarray.js: invalid offset");
        if (this.dims.length != arg.length)
          caml_invalid_argument("Bigarray.get/set: bad number of dimensions");
        if (this.layout == 0)
          for (var i = 0; i < this.dims.length; i++) {
            if (arg[i] < 0 || arg[i] >= this.dims[i])
              caml_array_bound_error();
            ofs = ofs * this.dims[i] + arg[i];
          }
        else
          for (var i = this.dims.length - 1; i >= 0; i--) {
            if (arg[i] < 1 || arg[i] > this.dims[i])
              caml_array_bound_error();
            ofs = ofs * this.dims[i] + (arg[i] - 1);
          }
        return ofs;
      };
      Ml_Bigarray.prototype.get = function(ofs) {
        switch (this.kind) {
          case 7:
            var l = this.data[ofs * 2 + 0], h = this.data[ofs * 2 + 1];
            return caml_int64_create_lo_hi(l, h);
          case 10:
          case 11:
            var r = this.data[ofs * 2 + 0], i = this.data[ofs * 2 + 1];
            return [254, r, i];
          default:
            return this.data[ofs];
        }
      };
      Ml_Bigarray.prototype.set = function(ofs, v) {
        switch (this.kind) {
          case 7:
            this.data[ofs * 2 + 0] = caml_int64_lo32(v);
            this.data[ofs * 2 + 1] = caml_int64_hi32(v);
            break;
          case 10:
          case 11:
            this.data[ofs * 2 + 0] = v[1];
            this.data[ofs * 2 + 1] = v[2];
            break;
          default:
            this.data[ofs] = v;
            break;
        }
        return 0;
      };
      Ml_Bigarray.prototype.fill = function(v) {
        switch (this.kind) {
          case 7:
            var a = caml_int64_lo32(v), b = caml_int64_hi32(v);
            if (a == b)
              this.data.fill(a);
            else
              for (var i = 0; i < this.data.length; i++)
                this.data[i] = i % 2 == 0 ? a : b;
            break;
          case 10:
          case 11:
            var im = v[1], re = v[2];
            if (im == re)
              this.data.fill(im);
            else
              for (var i = 0; i < this.data.length; i++)
                this.data[i] = i % 2 == 0 ? im : re;
            break;
          default:
            this.data.fill(v);
            break;
        }
      };
      Ml_Bigarray.prototype.compare = function(b, total) {
        if (this.layout != b.layout || this.kind != b.kind) {
          var k1 = this.kind | this.layout << 8, k2 = b.kind | b.layout << 8;
          return k2 - k1;
        }
        if (this.dims.length != b.dims.length)
          return b.dims.length - this.dims.length;
        for (var i = 0; i < this.dims.length; i++)
          if (this.dims[i] != b.dims[i])
            return this.dims[i] < b.dims[i] ? -1 : 1;
        switch (this.kind) {
          case 0:
          case 1:
          case 10:
          case 11:
            var x2, y;
            for (var i = 0; i < this.data.length; i++) {
              x2 = this.data[i];
              y = b.data[i];
              if (x2 < y)
                return -1;
              if (x2 > y)
                return 1;
              if (x2 != y) {
                if (!total)
                  return NaN;
                if (x2 == x2)
                  return 1;
                if (y == y)
                  return -1;
              }
            }
            break;
          case 7:
            for (var i = 0; i < this.data.length; i += 2) {
              if (this.data[i + 1] < b.data[i + 1])
                return -1;
              if (this.data[i + 1] > b.data[i + 1])
                return 1;
              if (this.data[i] >>> 0 < b.data[i] >>> 0)
                return -1;
              if (this.data[i] >>> 0 > b.data[i] >>> 0)
                return 1;
            }
            break;
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 8:
          case 9:
          case 12:
            for (var i = 0; i < this.data.length; i++) {
              if (this.data[i] < b.data[i])
                return -1;
              if (this.data[i] > b.data[i])
                return 1;
            }
            break;
        }
        return 0;
      };
      function Ml_Bigarray_c_1_1(kind, layout, dims, buffer) {
        this.kind = kind;
        this.layout = layout;
        this.dims = dims;
        this.data = buffer;
      }
      Ml_Bigarray_c_1_1.prototype = new Ml_Bigarray();
      Ml_Bigarray_c_1_1.prototype.offset = function(arg) {
        if (typeof arg !== "number")
          if (arg instanceof Array && arg.length == 1)
            arg = arg[0];
          else
            caml_invalid_argument("Ml_Bigarray_c_1_1.offset");
        if (arg < 0 || arg >= this.dims[0])
          caml_array_bound_error();
        return arg;
      };
      Ml_Bigarray_c_1_1.prototype.get = function(ofs) {
        return this.data[ofs];
      };
      Ml_Bigarray_c_1_1.prototype.set = function(ofs, v) {
        this.data[ofs] = v;
        return 0;
      };
      Ml_Bigarray_c_1_1.prototype.fill = function(v) {
        this.data.fill(v);
        return 0;
      };
      function caml_ba_create_unsafe(kind, layout, dims, data) {
        var size_per_element = caml_ba_get_size_per_element(kind);
        if (caml_ba_get_size(dims) * size_per_element != data.length)
          caml_invalid_argument("length doesn't match dims");
        if (layout == 0 && dims.length == 1 && size_per_element == 1)
          return new Ml_Bigarray_c_1_1(kind, layout, dims, data);
        return new Ml_Bigarray(kind, layout, dims, data);
      }
      function caml_ba_deserialize(reader, sz, name) {
        var num_dims = reader.read32s();
        if (num_dims < 0 || num_dims > 16)
          caml_failwith("input_value: wrong number of bigarray dimensions");
        var tag = reader.read32s(), kind = tag & 255, layout = tag >> 8 & 1, dims = [];
        if (name == "_bigarr02")
          for (var i = 0; i < num_dims; i++) {
            var size_dim = reader.read16u();
            if (size_dim == 65535) {
              var size_dim_hi = reader.read32u(), size_dim_lo = reader.read32u();
              if (size_dim_hi != 0)
                caml_failwith("input_value: bigarray dimension overflow in 32bit");
              size_dim = size_dim_lo;
            }
            dims.push(size_dim);
          }
        else
          for (var i = 0; i < num_dims; i++)
            dims.push(reader.read32u());
        var size = caml_ba_get_size(dims), data = caml_ba_create_buffer(kind, size), ba = caml_ba_create_unsafe(kind, layout, dims, data);
        switch (kind) {
          case 2:
            for (var i = 0; i < size; i++)
              data[i] = reader.read8s();
            break;
          case 3:
          case 12:
            for (var i = 0; i < size; i++)
              data[i] = reader.read8u();
            break;
          case 4:
            for (var i = 0; i < size; i++)
              data[i] = reader.read16s();
            break;
          case 5:
            for (var i = 0; i < size; i++)
              data[i] = reader.read16u();
            break;
          case 6:
            for (var i = 0; i < size; i++)
              data[i] = reader.read32s();
            break;
          case 8:
          case 9:
            var sixty = reader.read8u();
            if (sixty)
              caml_failwith("input_value: cannot read bigarray with 64-bit OCaml ints");
            for (var i = 0; i < size; i++)
              data[i] = reader.read32s();
            break;
          case 7:
            var t = new Array(8);
            for (var i = 0; i < size; i++) {
              for (var j = 0; j < 8; j++)
                t[j] = reader.read8u();
              var int64 = caml_int64_of_bytes(t);
              ba.set(i, int64);
            }
            break;
          case 1:
            var t = new Array(8);
            for (var i = 0; i < size; i++) {
              for (var j = 0; j < 8; j++)
                t[j] = reader.read8u();
              var f = caml_int64_float_of_bits(caml_int64_of_bytes(t));
              ba.set(i, f);
            }
            break;
          case 0:
            for (var i = 0; i < size; i++) {
              var f = caml_int32_float_of_bits(reader.read32s());
              ba.set(i, f);
            }
            break;
          case 10:
            for (var i = 0; i < size; i++) {
              var re = caml_int32_float_of_bits(reader.read32s()), im = caml_int32_float_of_bits(reader.read32s());
              ba.set(i, [254, re, im]);
            }
            break;
          case 11:
            var t = new Array(8);
            for (var i = 0; i < size; i++) {
              for (var j = 0; j < 8; j++)
                t[j] = reader.read8u();
              var re = caml_int64_float_of_bits(caml_int64_of_bytes(t));
              for (var j = 0; j < 8; j++)
                t[j] = reader.read8u();
              var im = caml_int64_float_of_bits(caml_int64_of_bytes(t));
              ba.set(i, [254, re, im]);
            }
            break;
        }
        sz[0] = (4 + num_dims) * 4;
        return caml_ba_create_unsafe(kind, layout, dims, data);
      }
      function caml_ba_compare(a, b, total) {
        return a.compare(b, total);
      }
      function caml_hash_mix_int64(h, v) {
        h = caml_hash_mix_int(h, caml_int64_lo32(v));
        h = caml_hash_mix_int(h, caml_int64_hi32(v));
        return h;
      }
      function caml_hash_mix_float(h, v0) {
        return caml_hash_mix_int64(h, caml_int64_bits_of_float(v0));
      }
      function caml_ba_hash(ba) {
        var num_elts = caml_ba_get_size(ba.dims), h = 0;
        switch (ba.kind) {
          case 2:
          case 3:
          case 12:
            if (num_elts > 256)
              num_elts = 256;
            var w = 0, i = 0;
            for (i = 0; i + 4 <= ba.data.length; i += 4) {
              w = ba.data[i + 0] | ba.data[i + 1] << 8 | ba.data[i + 2] << 16 | ba.data[i + 3] << 24;
              h = caml_hash_mix_int(h, w);
            }
            w = 0;
            switch (num_elts & 3) {
              case 3:
                w = ba.data[i + 2] << 16;
              case 2:
                w |= ba.data[i + 1] << 8;
              case 1:
                w |= ba.data[i + 0];
                h = caml_hash_mix_int(h, w);
            }
            break;
          case 4:
          case 5:
            if (num_elts > 128)
              num_elts = 128;
            var w = 0, i = 0;
            for (i = 0; i + 2 <= ba.data.length; i += 2) {
              w = ba.data[i + 0] | ba.data[i + 1] << 16;
              h = caml_hash_mix_int(h, w);
            }
            if ((num_elts & 1) != 0)
              h = caml_hash_mix_int(h, ba.data[i]);
            break;
          case 6:
            if (num_elts > 64)
              num_elts = 64;
            for (var i = 0; i < num_elts; i++)
              h = caml_hash_mix_int(h, ba.data[i]);
            break;
          case 8:
          case 9:
            if (num_elts > 64)
              num_elts = 64;
            for (var i = 0; i < num_elts; i++)
              h = caml_hash_mix_int(h, ba.data[i]);
            break;
          case 7:
            if (num_elts > 32)
              num_elts = 32;
            num_elts *= 2;
            for (var i = 0; i < num_elts; i++)
              h = caml_hash_mix_int(h, ba.data[i]);
            break;
          case 10:
            num_elts *= 2;
          case 0:
            if (num_elts > 64)
              num_elts = 64;
            for (var i = 0; i < num_elts; i++)
              h = caml_hash_mix_float(h, ba.data[i]);
            break;
          case 11:
            num_elts *= 2;
          case 1:
            if (num_elts > 32)
              num_elts = 32;
            for (var i = 0; i < num_elts; i++)
              h = caml_hash_mix_float(h, ba.data[i]);
            break;
        }
        return h;
      }
      function caml_int32_unmarshal(reader, size) {
        size[0] = 4;
        return reader.read32s();
      }
      function caml_nativeint_unmarshal(reader, size) {
        switch (reader.read8u()) {
          case 1:
            size[0] = 4;
            return reader.read32s();
          case 2:
            caml_failwith("input_value: native integer value too large");
          default:
            caml_failwith("input_value: ill-formed native integer");
        }
      }
      function caml_int64_unmarshal(reader, size) {
        var t = new Array(8);
        for (var j = 0; j < 8; j++)
          t[j] = reader.read8u();
        size[0] = 8;
        return caml_int64_of_bytes(t);
      }
      function caml_int64_compare(x2, y, total) {
        return x2.compare(y);
      }
      function caml_int64_hash(v) {
        return v.lo32() ^ v.hi32();
      }
      var caml_custom_ops = {
        "_j": {
          deserialize: caml_int64_unmarshal,
          serialize: caml_int64_marshal,
          fixed_length: 8,
          compare: caml_int64_compare,
          hash: caml_int64_hash
        },
        "_i": { deserialize: caml_int32_unmarshal, fixed_length: 4 },
        "_n": { deserialize: caml_nativeint_unmarshal, fixed_length: 4 },
        "_bigarray": {
          deserialize: function(reader, sz) {
            return caml_ba_deserialize(reader, sz, "_bigarray");
          },
          serialize: caml_ba_serialize,
          compare: caml_ba_compare,
          hash: caml_ba_hash
        },
        "_bigarr02": {
          deserialize: function(reader, sz) {
            return caml_ba_deserialize(reader, sz, "_bigarr02");
          },
          serialize: caml_ba_serialize,
          compare: caml_ba_compare,
          hash: caml_ba_hash
        }
      };
      function caml_compare_val_get_custom(a) {
        return caml_custom_ops[a.caml_custom] && caml_custom_ops[a.caml_custom].compare;
      }
      function caml_compare_val_number_custom(num, custom, swap, total) {
        var comp = caml_compare_val_get_custom(custom);
        if (comp) {
          var x2 = swap > 0 ? comp(custom, num, total) : comp(num, custom, total);
          if (total && x2 != x2)
            return swap;
          if (+x2 != +x2)
            return +x2;
          if ((x2 | 0) != 0)
            return x2 | 0;
        }
        return swap;
      }
      function caml_compare_val_tag(a) {
        if (typeof a === "number")
          return 1e3;
        else if (caml_is_ml_bytes(a))
          return 252;
        else if (caml_is_ml_string(a))
          return 1252;
        else if (a instanceof Array && a[0] === a[0] >>> 0 && a[0] <= 255) {
          var tag = a[0] | 0;
          return tag == 254 ? 0 : tag;
        } else if (a instanceof String)
          return 12520;
        else if (typeof a == "string")
          return 12520;
        else if (a instanceof Number)
          return 1e3;
        else if (a && a.caml_custom)
          return 1255;
        else if (a && a.compare)
          return 1256;
        else if (typeof a == "function")
          return 1247;
        else if (typeof a == "symbol")
          return 1251;
        return 1001;
      }
      function caml_int_compare(a, b) {
        if (a < b)
          return -1;
        if (a == b)
          return 0;
        return 1;
      }
      function caml_string_compare(s1, s2) {
        return s1 < s2 ? -1 : s1 > s2 ? 1 : 0;
      }
      function caml_bytes_compare(s1, s2) {
        s1.t & 6 && caml_convert_string_to_bytes(s1);
        s2.t & 6 && caml_convert_string_to_bytes(s2);
        return s1.c < s2.c ? -1 : s1.c > s2.c ? 1 : 0;
      }
      function caml_compare_val(a, b, total) {
        var stack = [];
        for (; ; ) {
          if (!(total && a === b)) {
            var tag_a = caml_compare_val_tag(a);
            if (tag_a == 250) {
              a = a[1];
              continue;
            }
            var tag_b = caml_compare_val_tag(b);
            if (tag_b == 250) {
              b = b[1];
              continue;
            }
            if (tag_a !== tag_b) {
              if (tag_a == 1e3) {
                if (tag_b == 1255)
                  return caml_compare_val_number_custom(a, b, -1, total);
                return -1;
              }
              if (tag_b == 1e3) {
                if (tag_a == 1255)
                  return caml_compare_val_number_custom(b, a, 1, total);
                return 1;
              }
              return tag_a < tag_b ? -1 : 1;
            }
            switch (tag_a) {
              case 247:
                caml_invalid_argument("compare: functional value");
                break;
              case 248:
                var x2 = caml_int_compare(a[2], b[2]);
                if (x2 != 0)
                  return x2 | 0;
                break;
              case 249:
                caml_invalid_argument("compare: functional value");
                break;
              case 250:
                caml_invalid_argument("equal: got Forward_tag, should not happen");
                break;
              case 251:
                caml_invalid_argument("equal: abstract value");
                break;
              case 252:
                if (a !== b) {
                  var x2 = caml_bytes_compare(a, b);
                  if (x2 != 0)
                    return x2 | 0;
                }
                break;
              case 253:
                caml_invalid_argument("equal: got Double_tag, should not happen");
                break;
              case 254:
                caml_invalid_argument("equal: got Double_array_tag, should not happen");
                break;
              case 255:
                caml_invalid_argument("equal: got Custom_tag, should not happen");
                break;
              case 1247:
                caml_invalid_argument("compare: functional value");
                break;
              case 1255:
                var comp = caml_compare_val_get_custom(a);
                if (comp != caml_compare_val_get_custom(b))
                  return a.caml_custom < b.caml_custom ? -1 : 1;
                if (!comp)
                  caml_invalid_argument("compare: abstract value");
                var x2 = comp(a, b, total);
                if (x2 != x2)
                  return total ? -1 : x2;
                if (x2 !== (x2 | 0))
                  return -1;
                if (x2 != 0)
                  return x2 | 0;
                break;
              case 1256:
                var x2 = a.compare(b, total);
                if (x2 != x2)
                  return total ? -1 : x2;
                if (x2 !== (x2 | 0))
                  return -1;
                if (x2 != 0)
                  return x2 | 0;
                break;
              case 1e3:
                a = +a;
                b = +b;
                if (a < b)
                  return -1;
                if (a > b)
                  return 1;
                if (a != b) {
                  if (!total)
                    return NaN;
                  if (a == a)
                    return 1;
                  if (b == b)
                    return -1;
                }
                break;
              case 1001:
                if (a < b)
                  return -1;
                if (a > b)
                  return 1;
                if (a != b) {
                  if (!total)
                    return NaN;
                  if (a == a)
                    return 1;
                  if (b == b)
                    return -1;
                }
                break;
              case 1251:
                if (a !== b) {
                  if (!total)
                    return NaN;
                  return 1;
                }
                break;
              case 1252:
                var a = caml_jsbytes_of_string(a), b = caml_jsbytes_of_string(b);
                if (a !== b) {
                  if (a < b)
                    return -1;
                  if (a > b)
                    return 1;
                }
                break;
              case 12520:
                var a = a.toString(), b = b.toString();
                if (a !== b) {
                  if (a < b)
                    return -1;
                  if (a > b)
                    return 1;
                }
                break;
              case 246:
              case 254:
              default:
                if (caml_is_continuation_tag(tag_a)) {
                  caml_invalid_argument("compare: continuation value");
                  break;
                }
                if (a.length != b.length)
                  return a.length < b.length ? -1 : 1;
                if (a.length > 1)
                  stack.push(a, b, 1);
                break;
            }
          }
          if (stack.length == 0)
            return 0;
          var i = stack.pop();
          b = stack.pop();
          a = stack.pop();
          if (i + 1 < a.length)
            stack.push(a, b, i + 1);
          a = a[i];
          b = b[i];
        }
      }
      function caml_greaterthan(x2, y) {
        return +(caml_compare_val(x2, y, false) > 0);
      }
      function div_helper(a, b, c) {
        var x2 = a * 65536 + (b >>> 16), y = Math.floor(x2 / c) * 65536, z = x2 % c * 65536, w = z + (b & 65535);
        return [y + Math.floor(w / c), w % c];
      }
      function div_digit_nat(natq, ofsq, natr, ofsr, nat1, ofs1, len, nat2, ofs2) {
        var rem = nat1.data[ofs1 + len - 1] >>> 0;
        for (var i = len - 2; i >= 0; i--) {
          var x2 = div_helper(rem, nat1.data[ofs1 + i] >>> 0, nat2.data[ofs2] >>> 0);
          natq.data[ofsq + i] = x2[0];
          rem = x2[1];
        }
        natr.data[ofsr] = rem;
        return 0;
      }
      function num_leading_zero_bits_in_digit(nat, ofs) {
        var a = nat.data[ofs], b = 0;
        if (a & 4294901760) {
          b += 16;
          a >>>= 16;
        }
        if (a & 65280) {
          b += 8;
          a >>>= 8;
        }
        if (a & 240) {
          b += 4;
          a >>>= 4;
        }
        if (a & 12) {
          b += 2;
          a >>>= 2;
        }
        if (a & 2) {
          b += 1;
          a >>>= 1;
        }
        if (a & 1)
          b += 1;
        return 32 - b;
      }
      function shift_left_nat(nat1, ofs1, len1, nat2, ofs2, nbits) {
        if (nbits == 0) {
          nat2.data[ofs2] = 0;
          return 0;
        }
        var wrap = 0;
        for (var i = 0; i < len1; i++) {
          var a = nat1.data[ofs1 + i] >>> 0;
          nat1.data[ofs1 + i] = a << nbits | wrap;
          wrap = a >>> 32 - nbits;
        }
        nat2.data[ofs2] = wrap;
        return 0;
      }
      function MlNat(x2) {
        this.data = new Int32Array(x2);
        this.length = this.data.length + 2;
      }
      MlNat.prototype.caml_custom = "_nat";
      function create_nat(size) {
        var arr = new MlNat(size);
        for (var i = 0; i < size; i++)
          arr.data[i] = -1;
        return arr;
      }
      function set_to_zero_nat(nat, ofs, len) {
        for (var i = 0; i < len; i++)
          nat.data[ofs + i] = 0;
        return 0;
      }
      function incr_nat(nat, ofs, len, carry_in) {
        var carry = carry_in;
        for (var i = 0; i < len; i++) {
          var x2 = (nat.data[ofs + i] >>> 0) + carry;
          nat.data[ofs + i] = x2 | 0;
          if (x2 == x2 >>> 0) {
            carry = 0;
            break;
          } else
            carry = 1;
        }
        return carry;
      }
      function add_nat(nat1, ofs1, len1, nat2, ofs2, len2, carry_in) {
        var carry = carry_in;
        for (var i = 0; i < len2; i++) {
          var x2 = (nat1.data[ofs1 + i] >>> 0) + (nat2.data[ofs2 + i] >>> 0) + carry;
          nat1.data[ofs1 + i] = x2;
          if (x2 == x2 >>> 0)
            carry = 0;
          else
            carry = 1;
        }
        return incr_nat(nat1, ofs1 + len2, len1 - len2, carry);
      }
      function nat_of_array(l) {
        return new MlNat(l);
      }
      function mult_digit_nat(nat1, ofs1, len1, nat2, ofs2, len2, nat3, ofs3) {
        var carry = 0, a = nat3.data[ofs3] >>> 0;
        for (var i = 0; i < len2; i++) {
          var x1 = (nat1.data[ofs1 + i] >>> 0) + (nat2.data[ofs2 + i] >>> 0) * (a & 65535) + carry, x2 = (nat2.data[ofs2 + i] >>> 0) * (a >>> 16);
          carry = Math.floor(x2 / 65536);
          var x3 = x1 + x2 % 65536 * 65536;
          nat1.data[ofs1 + i] = x3;
          carry += Math.floor(x3 / 4294967296);
        }
        return len2 < len1 && carry ? add_nat(nat1, ofs1 + len2, len1 - len2, nat_of_array([carry]), 0, 1, 0) : carry;
      }
      function decr_nat(nat, ofs, len, carry_in) {
        var borrow = carry_in == 1 ? 0 : 1;
        for (var i = 0; i < len; i++) {
          var x2 = (nat.data[ofs + i] >>> 0) - borrow;
          nat.data[ofs + i] = x2;
          if (x2 >= 0) {
            borrow = 0;
            break;
          } else
            borrow = 1;
        }
        return borrow == 1 ? 0 : 1;
      }
      function sub_nat(nat1, ofs1, len1, nat2, ofs2, len2, carry_in) {
        var borrow = carry_in == 1 ? 0 : 1;
        for (var i = 0; i < len2; i++) {
          var x2 = (nat1.data[ofs1 + i] >>> 0) - (nat2.data[ofs2 + i] >>> 0) - borrow;
          nat1.data[ofs1 + i] = x2;
          if (x2 >= 0)
            borrow = 0;
          else
            borrow = 1;
        }
        return decr_nat(nat1, ofs1 + len2, len1 - len2, borrow == 1 ? 0 : 1);
      }
      function compare_nat(nat1, ofs1, len1, nat2, ofs2, len2) {
        var a = num_digits_nat(nat1, ofs1, len1), b = num_digits_nat(nat2, ofs2, len2);
        if (a > b)
          return 1;
        if (a < b)
          return -1;
        for (var i = len1 - 1; i >= 0; i--) {
          if (nat1.data[ofs1 + i] >>> 0 > nat2.data[ofs2 + i] >>> 0)
            return 1;
          if (nat1.data[ofs1 + i] >>> 0 < nat2.data[ofs2 + i] >>> 0)
            return -1;
        }
        return 0;
      }
      function div_nat(nat1, ofs1, len1, nat2, ofs2, len2) {
        if (len2 == 1) {
          div_digit_nat(nat1, ofs1 + 1, nat1, ofs1, nat1, ofs1, len1, nat2, ofs2);
          return 0;
        }
        var s2 = num_leading_zero_bits_in_digit(nat2, ofs2 + len2 - 1);
        shift_left_nat(nat2, ofs2, len2, nat_of_array([0]), 0, s2);
        shift_left_nat(nat1, ofs1, len1, nat_of_array([0]), 0, s2);
        var d = (nat2.data[ofs2 + len2 - 1] >>> 0) + 1, a = create_nat(len2 + 1);
        for (var i = len1 - 1; i >= len2; i--) {
          var quo = d == 4294967296 ? nat1.data[ofs1 + i] >>> 0 : div_helper(nat1.data[ofs1 + i] >>> 0, nat1.data[ofs1 + i - 1] >>> 0, d)[0];
          set_to_zero_nat(a, 0, len2 + 1);
          mult_digit_nat(a, 0, len2 + 1, nat2, ofs2, len2, nat_of_array([quo]), 0);
          sub_nat(nat1, ofs1 + i - len2, len2 + 1, a, 0, len2 + 1, 1);
          while (nat1.data[ofs1 + i] != 0 || compare_nat(nat1, ofs1 + i - len2, len2, nat2, ofs2, len2) >= 0) {
            quo = quo + 1;
            sub_nat(nat1, ofs1 + i - len2, len2 + 1, nat2, ofs2, len2, 1);
          }
          nat1.data[ofs1 + i] = quo;
        }
        shift_right_nat(nat1, ofs1, len2, nat_of_array([0]), 0, s2);
        shift_right_nat(nat2, ofs2, len2, nat_of_array([0]), 0, s2);
        return 0;
      }
      function caml_ba_blit(src, dst) {
        if (dst.dims.length != src.dims.length)
          caml_invalid_argument("Bigarray.blit: dimension mismatch");
        for (var i = 0; i < dst.dims.length; i++)
          if (dst.dims[i] != src.dims[i])
            caml_invalid_argument("Bigarray.blit: dimension mismatch");
        dst.data.set(src.data);
        return 0;
      }
      function is_digit_int(nat, ofs) {
        if (nat.data[ofs] >= 0)
          return 1;
        return 0;
      }
      function caml_int64_div(x2, y) {
        return x2.div(y);
      }
      function caml_js_html_entities(s2) {
        var entity = /^&#?[0-9a-zA-Z]+;$/;
        if (s2.match(entity)) {
          var str, temp = document.createElement("p");
          temp.innerHTML = s2;
          str = temp.textContent || temp.innerText;
          temp = null;
          return str;
        } else
          caml_failwith("Invalid entity " + s2);
      }
      function caml_string_unsafe_set(s2, i, c) {
        caml_failwith("caml_string_unsafe_set");
      }
      function caml_int64_of_float(x2) {
        if (x2 < 0)
          x2 = Math.ceil(x2);
        return new MlInt64(
          x2 & 16777215,
          Math.floor(x2 * caml_int64_offset) & 16777215,
          Math.floor(x2 * caml_int64_offset * caml_int64_offset) & 65535
        );
      }
      function caml_ml_channel_size_64(chanid) {
        var chan = caml_ml_channels[chanid];
        return caml_int64_of_float(chan.file.length());
      }
      function caml_ba_set_2(ba, i0, i1, v) {
        ba.set(ba.offset([i0, i1]), v);
        return 0;
      }
      var caml_argv = function() {
        var process = globalThis.process, main = "a.out", args = [];
        if (process && process.argv && process.argv.length > 1) {
          var argv = process.argv;
          main = argv[1];
          args = argv.slice(2);
        }
        var p = caml_string_of_jsstring(main), args2 = [0, p];
        for (var i = 0; i < args.length; i++)
          args2.push(caml_string_of_jsstring(args[i]));
        return args2;
      }(), caml_executable_name = caml_argv[1];
      function caml_js_eval_string(s) {
        return eval(caml_jsstring_of_string(s));
      }
      function serialize_nat(writer, nat, sz) {
        var len = nat.data.length;
        writer.write(32, len);
        for (var i = 0; i < len; i++)
          writer.write(32, nat.data[i]);
        sz[0] = len * 4;
        sz[1] = len * 8;
      }
      function caml_memprof_set(_control) {
        return 0;
      }
      function caml_sys_exit(code) {
        if (globalThis.quit)
          globalThis.quit(code);
        if (globalThis.process && globalThis.process.exit)
          globalThis.process.exit(code);
        caml_invalid_argument("Function 'exit' not implemented");
      }
      function caml_channel_descriptor(chanid) {
        var chan = caml_ml_channels[chanid];
        return chan.fd;
      }
      function caml_js_from_array(a) {
        return a.slice(1);
      }
      function caml_ba_reshape(ba, vind) {
        vind = caml_js_from_array(vind);
        var new_dim = [], num_dims = vind.length;
        if (num_dims < 0 || num_dims > 16)
          caml_invalid_argument("Bigarray.reshape: bad number of dimensions");
        var num_elts = 1;
        for (var i = 0; i < num_dims; i++) {
          new_dim[i] = vind[i];
          if (new_dim[i] < 0)
            caml_invalid_argument("Bigarray.reshape: negative dimension");
          num_elts = num_elts * new_dim[i];
        }
        var size = caml_ba_get_size(ba.dims);
        if (num_elts != size)
          caml_invalid_argument("Bigarray.reshape: size mismatch");
        return caml_ba_create_unsafe(ba.kind, ba.layout, new_dim, ba.data);
      }
      var caml_oo_last_id = 0;
      function caml_set_oo_id(b) {
        b[2] = caml_oo_last_id++;
        return b;
      }
      function caml_gr_fill_rect(x2, y, w, h) {
        var s2 = caml_gr_state_get();
        s2.context.fillRect(x2, s2.height - y, w, -h);
        return 0;
      }
      function caml_bigstring_blit_string_to_ba(str1, pos1, ba2, pos2, len) {
        if (12 != ba2.kind)
          caml_invalid_argument("caml_bigstring_blit_string_to_ba: kind mismatch");
        if (len == 0)
          return 0;
        var ofs2 = ba2.offset(pos2);
        if (pos1 + len > caml_ml_string_length(str1))
          caml_array_bound_error();
        if (ofs2 + len > ba2.data.length)
          caml_array_bound_error();
        var slice = caml_uint8_array_of_string(str1).slice(pos1, pos1 + len);
        ba2.data.set(slice, ofs2);
        return 0;
      }
      function caml_gr_set_window_title(name) {
        var s2 = caml_gr_state_get();
        s2.title = name;
        var jsname = caml_jsstring_of_string(name);
        if (s2.set_title)
          s2.set_title(jsname);
        return 0;
      }
      function caml_get_global_data() {
        return caml_global_data;
      }
      function caml_int64_shift_right_unsigned(x2, s2) {
        return x2.shift_right_unsigned(s2);
      }
      function caml_ba_uint8_get16(ba, i0) {
        var ofs = ba.offset(i0);
        if (ofs + 1 >= ba.data.length)
          caml_array_bound_error();
        var b1 = ba.get(ofs), b2 = ba.get(ofs + 1);
        return b1 | b2 << 8;
      }
      function caml_compare(a, b) {
        return caml_compare_val(a, b, true);
      }
      var caml_MD5Transform = /* @__PURE__ */ function() {
        function add(x2, y) {
          return x2 + y | 0;
        }
        function xx(q, a, b, x2, s2, t) {
          a = add(add(a, q), add(x2, t));
          return add(a << s2 | a >>> 32 - s2, b);
        }
        function ff(a, b, c, d, x2, s2, t) {
          return xx(b & c | ~b & d, a, b, x2, s2, t);
        }
        function gg(a, b, c, d, x2, s2, t) {
          return xx(b & d | c & ~d, a, b, x2, s2, t);
        }
        function hh(a, b, c, d, x2, s2, t) {
          return xx(b ^ c ^ d, a, b, x2, s2, t);
        }
        function ii(a, b, c, d, x2, s2, t) {
          return xx(c ^ (b | ~d), a, b, x2, s2, t);
        }
        return function(w, buffer) {
          var a = w[0], b = w[1], c = w[2], d = w[3];
          a = ff(a, b, c, d, buffer[0], 7, 3614090360);
          d = ff(d, a, b, c, buffer[1], 12, 3905402710);
          c = ff(c, d, a, b, buffer[2], 17, 606105819);
          b = ff(b, c, d, a, buffer[3], 22, 3250441966);
          a = ff(a, b, c, d, buffer[4], 7, 4118548399);
          d = ff(d, a, b, c, buffer[5], 12, 1200080426);
          c = ff(c, d, a, b, buffer[6], 17, 2821735955);
          b = ff(b, c, d, a, buffer[7], 22, 4249261313);
          a = ff(a, b, c, d, buffer[8], 7, 1770035416);
          d = ff(d, a, b, c, buffer[9], 12, 2336552879);
          c = ff(c, d, a, b, buffer[10], 17, 4294925233);
          b = ff(b, c, d, a, buffer[11], 22, 2304563134);
          a = ff(a, b, c, d, buffer[12], 7, 1804603682);
          d = ff(d, a, b, c, buffer[13], 12, 4254626195);
          c = ff(c, d, a, b, buffer[14], 17, 2792965006);
          b = ff(b, c, d, a, buffer[15], 22, 1236535329);
          a = gg(a, b, c, d, buffer[1], 5, 4129170786);
          d = gg(d, a, b, c, buffer[6], 9, 3225465664);
          c = gg(c, d, a, b, buffer[11], 14, 643717713);
          b = gg(b, c, d, a, buffer[0], 20, 3921069994);
          a = gg(a, b, c, d, buffer[5], 5, 3593408605);
          d = gg(d, a, b, c, buffer[10], 9, 38016083);
          c = gg(c, d, a, b, buffer[15], 14, 3634488961);
          b = gg(b, c, d, a, buffer[4], 20, 3889429448);
          a = gg(a, b, c, d, buffer[9], 5, 568446438);
          d = gg(d, a, b, c, buffer[14], 9, 3275163606);
          c = gg(c, d, a, b, buffer[3], 14, 4107603335);
          b = gg(b, c, d, a, buffer[8], 20, 1163531501);
          a = gg(a, b, c, d, buffer[13], 5, 2850285829);
          d = gg(d, a, b, c, buffer[2], 9, 4243563512);
          c = gg(c, d, a, b, buffer[7], 14, 1735328473);
          b = gg(b, c, d, a, buffer[12], 20, 2368359562);
          a = hh(a, b, c, d, buffer[5], 4, 4294588738);
          d = hh(d, a, b, c, buffer[8], 11, 2272392833);
          c = hh(c, d, a, b, buffer[11], 16, 1839030562);
          b = hh(b, c, d, a, buffer[14], 23, 4259657740);
          a = hh(a, b, c, d, buffer[1], 4, 2763975236);
          d = hh(d, a, b, c, buffer[4], 11, 1272893353);
          c = hh(c, d, a, b, buffer[7], 16, 4139469664);
          b = hh(b, c, d, a, buffer[10], 23, 3200236656);
          a = hh(a, b, c, d, buffer[13], 4, 681279174);
          d = hh(d, a, b, c, buffer[0], 11, 3936430074);
          c = hh(c, d, a, b, buffer[3], 16, 3572445317);
          b = hh(b, c, d, a, buffer[6], 23, 76029189);
          a = hh(a, b, c, d, buffer[9], 4, 3654602809);
          d = hh(d, a, b, c, buffer[12], 11, 3873151461);
          c = hh(c, d, a, b, buffer[15], 16, 530742520);
          b = hh(b, c, d, a, buffer[2], 23, 3299628645);
          a = ii(a, b, c, d, buffer[0], 6, 4096336452);
          d = ii(d, a, b, c, buffer[7], 10, 1126891415);
          c = ii(c, d, a, b, buffer[14], 15, 2878612391);
          b = ii(b, c, d, a, buffer[5], 21, 4237533241);
          a = ii(a, b, c, d, buffer[12], 6, 1700485571);
          d = ii(d, a, b, c, buffer[3], 10, 2399980690);
          c = ii(c, d, a, b, buffer[10], 15, 4293915773);
          b = ii(b, c, d, a, buffer[1], 21, 2240044497);
          a = ii(a, b, c, d, buffer[8], 6, 1873313359);
          d = ii(d, a, b, c, buffer[15], 10, 4264355552);
          c = ii(c, d, a, b, buffer[6], 15, 2734768916);
          b = ii(b, c, d, a, buffer[13], 21, 1309151649);
          a = ii(a, b, c, d, buffer[4], 6, 4149444226);
          d = ii(d, a, b, c, buffer[11], 10, 3174756917);
          c = ii(c, d, a, b, buffer[2], 15, 718787259);
          b = ii(b, c, d, a, buffer[9], 21, 3951481745);
          w[0] = add(a, w[0]);
          w[1] = add(b, w[1]);
          w[2] = add(c, w[2]);
          w[3] = add(d, w[3]);
        };
      }();
      function caml_MD5Update(ctx, input, input_len) {
        var in_buf = ctx.len & 63, input_pos = 0;
        ctx.len += input_len;
        if (in_buf) {
          var missing = 64 - in_buf;
          if (input_len < missing) {
            ctx.b8.set(input.subarray(0, input_len), in_buf);
            return;
          }
          ctx.b8.set(input.subarray(0, missing), in_buf);
          caml_MD5Transform(ctx.w, ctx.b32);
          input_len -= missing;
          input_pos += missing;
        }
        while (input_len >= 64) {
          ctx.b8.set(input.subarray(input_pos, input_pos + 64), 0);
          caml_MD5Transform(ctx.w, ctx.b32);
          input_len -= 64;
          input_pos += 64;
        }
        if (input_len)
          ctx.b8.set(input.subarray(input_pos, input_pos + input_len), 0);
      }
      function caml_runtime_events_read_poll(cursor, callbacks, num) {
        return 0;
      }
      function caml_fresh_oo_id() {
        return caml_oo_last_id++;
      }
      function caml_int64_to_float(x2) {
        return x2.toFloat();
      }
      function caml_ba_get_1(ba, i0) {
        return ba.get(ba.offset(i0));
      }
      function caml_bigstring_memcmp(s1, pos1, s2, pos2, len) {
        for (var i = 0; i < len; i++) {
          var a = caml_ba_get_1(s1, pos1 + i), b = caml_ba_get_1(s2, pos2 + i);
          if (a < b)
            return -1;
          if (a > b)
            return 1;
        }
        return 0;
      }
      function caml_new_string(s2) {
        return caml_string_of_jsbytes(s2);
      }
      function caml_erf_float(x2) {
        var a1 = 0.254829592, a2 = -0.284496736, a3 = 1.421413741, a4 = -1.453152027, a5 = 1.061405429, p = 0.3275911, sign = 1;
        if (x2 < 0)
          sign = -1;
        x2 = Math.abs(x2);
        var t = 1 / (1 + p * x2), y = 1 - ((((a5 * t + a4) * t + a3) * t + a2) * t + a1) * t * Math.exp(-(x2 * x2));
        return sign * y;
      }
      function caml_ba_uint8_get32(ba, i0) {
        var ofs = ba.offset(i0);
        if (ofs + 3 >= ba.data.length)
          caml_array_bound_error();
        var b1 = ba.get(ofs + 0), b2 = ba.get(ofs + 1), b3 = ba.get(ofs + 2), b4 = ba.get(ofs + 3);
        return b1 << 0 | b2 << 8 | b3 << 16 | b4 << 24;
      }
      function caml_raw_backtrace_length() {
        return 0;
      }
      function caml_str_initialize(unit) {
        return 0;
      }
      function caml_obj_block(tag, size) {
        var o = new Array(size + 1);
        o[0] = tag;
        for (var i = 1; i <= size; i++)
          o[i] = 0;
        return o;
      }
      function caml_gr_clear_graph() {
        var s2 = caml_gr_state_get();
        s2.canvas.width = s2.width;
        s2.canvas.height = s2.height;
        return 0;
      }
      function bigstring_to_array_buffer(bs) {
        return bs.data.buffer;
      }
      function caml_sys_const_naked_pointers_checked(_unit) {
        return 0;
      }
      function lxor_digit_nat(nat1, ofs1, nat2, ofs2) {
        nat1.data[ofs1] ^= nat2.data[ofs2];
        return 0;
      }
      function caml_obj_add_offset(v, offset) {
        caml_failwith("Obj.add_offset is not supported");
      }
      function caml_final_release() {
        return 0;
      }
      var caml_marshal_header_size = 16;
      function caml_js_to_array(a) {
        var len = a.length, b = new Array(len + 1);
        b[0] = 0;
        for (var i = 0; i < len; i++)
          b[i + 1] = a[i];
        return b;
      }
      function caml_sys_is_regular_file(name) {
        var root = resolve_fs_device(name);
        return root.device.isFile(root.rest);
      }
      function caml_gr_plot(x2, y) {
        var s2 = caml_gr_state_get(), im = s2.context.createImageData(1, 1), d = im.data, color = s2.color;
        d[0] = color >> 16 & 255;
        d[1] = color >> 8 & 255, d[2] = color >> 0 & 255;
        d[3] = 255;
        s2.x = x2;
        s2.y = y;
        s2.context.putImageData(im, x2, s2.height - y);
        return 0;
      }
      function caml_bytes_set64(s2, i, i64) {
        if (i >>> 0 >= s2.l - 7)
          caml_bytes_bound_error();
        var a = caml_int64_to_bytes(i64);
        for (var j = 0; j < 8; j++)
          caml_bytes_unsafe_set(s2, i + 7 - j, a[j]);
        return 0;
      }
      function caml_string_set16(s2, i, i16) {
        caml_failwith("caml_string_set16");
      }
      function caml_int64_bswap(x2) {
        var y = caml_int64_to_bytes(x2);
        return caml_int64_of_bytes([y[7], y[6], y[5], y[4], y[3], y[2], y[1], y[0]]);
      }
      function caml_gc_major(unit) {
        if (typeof globalThis.gc == "function")
          globalThis.gc();
        return 0;
      }
      function caml_lex_array(s2) {
        s2 = caml_jsbytes_of_string(s2);
        var l = s2.length / 2, a = new Array(l);
        for (var i = 0; i < l; i++)
          a[i] = (s2.charCodeAt(2 * i) | s2.charCodeAt(2 * i + 1) << 8) << 16 >> 16;
        return a;
      }
      function caml_lex_engine(tbl, start_state, lexbuf) {
        var lex_buffer = 2, lex_buffer_len = 3, lex_start_pos = 5, lex_curr_pos = 6, lex_last_pos = 7, lex_last_action = 8, lex_eof_reached = 9, lex_base = 1, lex_backtrk = 2, lex_default = 3, lex_trans = 4, lex_check = 5;
        if (!tbl.lex_default) {
          tbl.lex_base = caml_lex_array(tbl[lex_base]);
          tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
          tbl.lex_check = caml_lex_array(tbl[lex_check]);
          tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
          tbl.lex_default = caml_lex_array(tbl[lex_default]);
        }
        var c, state = start_state, buffer = caml_uint8_array_of_bytes(lexbuf[lex_buffer]);
        if (state >= 0) {
          lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
          lexbuf[lex_last_action] = -1;
        } else
          state = -state - 1;
        for (; ; ) {
          var base = tbl.lex_base[state];
          if (base < 0)
            return -base - 1;
          var backtrk = tbl.lex_backtrk[state];
          if (backtrk >= 0) {
            lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
            lexbuf[lex_last_action] = backtrk;
          }
          if (lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
            if (lexbuf[lex_eof_reached] == 0)
              return -state - 1;
            else
              c = 256;
          else {
            c = buffer[lexbuf[lex_curr_pos]];
            lexbuf[lex_curr_pos]++;
          }
          if (tbl.lex_check[base + c] == state)
            state = tbl.lex_trans[base + c];
          else
            state = tbl.lex_default[state];
          if (state < 0) {
            lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
            if (lexbuf[lex_last_action] == -1)
              caml_failwith("lexing: empty token");
            else
              return lexbuf[lex_last_action];
          } else if (c == 256)
            lexbuf[lex_eof_reached] = 0;
        }
      }
      function caml_sys_file_exists(name) {
        var root = resolve_fs_device(name);
        return root.device.exists(root.rest);
      }
      function caml_convert_raw_backtrace_slot() {
        caml_failwith("caml_convert_raw_backtrace_slot");
      }
      function caml_array_sub(a, i, len) {
        var a2 = new Array(len + 1);
        a2[0] = 0;
        for (var i2 = 1, i1 = i + 1; i2 <= len; i2++, i1++)
          a2[i2] = a[i1];
        return a2;
      }
      function caml_bytes_equal(s1, s2) {
        if (s1 === s2)
          return 1;
        s1.t & 6 && caml_convert_string_to_bytes(s1);
        s2.t & 6 && caml_convert_string_to_bytes(s2);
        return s1.c == s2.c ? 1 : 0;
      }
      function caml_gr_size_x() {
        var s2 = caml_gr_state_get();
        return s2.width;
      }
      function caml_ml_debug_info_status() {
        return 0;
      }
      function caml_atomic_fetch_add(ref, i) {
        var old = ref[1];
        ref[1] += i;
        return old;
      }
      var os_type = globalThis.process && globalThis.process.platform && globalThis.process.platform == "win32" ? "Cygwin" : "Unix";
      function caml_sys_const_ostype_cygwin() {
        return os_type == "Cygwin" ? 1 : 0;
      }
      function caml_cosh_float(x2) {
        return Math.cosh(x2);
      }
      function MlMutex() {
        this.locked = false;
      }
      function caml_ml_mutex_new(unit) {
        return new MlMutex();
      }
      var caml_ephe_key_offset = 3;
      function caml_ephe_check_key(x2, i) {
        var weak = x2[caml_ephe_key_offset + i];
        if (globalThis.WeakRef && weak instanceof globalThis.WeakRef)
          weak = weak.deref();
        return weak === void 0 ? 0 : 1;
      }
      function caml_hash_mix_final(h) {
        h ^= h >>> 16;
        h = caml_mul(h, 2246822507 | 0);
        h ^= h >>> 13;
        h = caml_mul(h, 3266489909 | 0);
        h ^= h >>> 16;
        return h;
      }
      function caml_gr_text_size(txt) {
        var s2 = caml_gr_state_get(), w = s2.context.measureText(caml_jsstring_of_string(txt)).width;
        return [0, w, s2.text_size];
      }
      function caml_lex_run_mem(s2, i, mem, curr_pos) {
        for (; ; ) {
          var dst = s2.charCodeAt(i);
          i++;
          if (dst == 255)
            return;
          var src = s2.charCodeAt(i);
          i++;
          if (src == 255)
            mem[dst + 1] = curr_pos;
          else
            mem[dst + 1] = mem[src + 1];
        }
      }
      function caml_lex_run_tag(s2, i, mem) {
        for (; ; ) {
          var dst = s2.charCodeAt(i);
          i++;
          if (dst == 255)
            return;
          var src = s2.charCodeAt(i);
          i++;
          if (src == 255)
            mem[dst + 1] = -1;
          else
            mem[dst + 1] = mem[src + 1];
        }
      }
      function caml_new_lex_engine(tbl, start_state, lexbuf) {
        var lex_buffer = 2, lex_buffer_len = 3, lex_start_pos = 5, lex_curr_pos = 6, lex_last_pos = 7, lex_last_action = 8, lex_eof_reached = 9, lex_mem = 10, lex_base = 1, lex_backtrk = 2, lex_default = 3, lex_trans = 4, lex_check = 5, lex_base_code = 6, lex_backtrk_code = 7, lex_default_code = 8, lex_trans_code = 9, lex_check_code = 10, lex_code = 11;
        if (!tbl.lex_default) {
          tbl.lex_base = caml_lex_array(tbl[lex_base]);
          tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
          tbl.lex_check = caml_lex_array(tbl[lex_check]);
          tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
          tbl.lex_default = caml_lex_array(tbl[lex_default]);
        }
        if (!tbl.lex_default_code) {
          tbl.lex_base_code = caml_lex_array(tbl[lex_base_code]);
          tbl.lex_backtrk_code = caml_lex_array(tbl[lex_backtrk_code]);
          tbl.lex_check_code = caml_lex_array(tbl[lex_check_code]);
          tbl.lex_trans_code = caml_lex_array(tbl[lex_trans_code]);
          tbl.lex_default_code = caml_lex_array(tbl[lex_default_code]);
        }
        if (tbl.lex_code == null)
          tbl.lex_code = caml_jsbytes_of_string(tbl[lex_code]);
        var c, state = start_state, buffer = caml_uint8_array_of_bytes(lexbuf[lex_buffer]);
        if (state >= 0) {
          lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
          lexbuf[lex_last_action] = -1;
        } else
          state = -state - 1;
        for (; ; ) {
          var base = tbl.lex_base[state];
          if (base < 0) {
            var pc_off = tbl.lex_base_code[state];
            caml_lex_run_tag(tbl.lex_code, pc_off, lexbuf[lex_mem]);
            return -base - 1;
          }
          var backtrk = tbl.lex_backtrk[state];
          if (backtrk >= 0) {
            var pc_off = tbl.lex_backtrk_code[state];
            caml_lex_run_tag(tbl.lex_code, pc_off, lexbuf[lex_mem]);
            lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
            lexbuf[lex_last_action] = backtrk;
          }
          if (lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
            if (lexbuf[lex_eof_reached] == 0)
              return -state - 1;
            else
              c = 256;
          else {
            c = buffer[lexbuf[lex_curr_pos]];
            lexbuf[lex_curr_pos]++;
          }
          var pstate = state;
          if (tbl.lex_check[base + c] == state)
            state = tbl.lex_trans[base + c];
          else
            state = tbl.lex_default[state];
          if (state < 0) {
            lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
            if (lexbuf[lex_last_action] == -1)
              caml_failwith("lexing: empty token");
            else
              return lexbuf[lex_last_action];
          } else {
            var base_code = tbl.lex_base_code[pstate], pc_off;
            if (tbl.lex_check_code[base_code + c] == pstate)
              pc_off = tbl.lex_trans_code[base_code + c];
            else
              pc_off = tbl.lex_default_code[pstate];
            if (pc_off > 0)
              caml_lex_run_mem(tbl.lex_code, pc_off, lexbuf[lex_mem], lexbuf[lex_curr_pos]);
            if (c == 256)
              lexbuf[lex_eof_reached] = 0;
          }
        }
      }
      function caml_ba_uint8_set64(ba, i0, v) {
        var ofs = ba.offset(i0);
        if (ofs + 7 >= ba.data.length)
          caml_array_bound_error();
        var v = caml_int64_to_bytes(v);
        for (var i = 0; i < 8; i++)
          ba.set(ofs + i, v[7 - i]);
        return 0;
      }
      function caml_sys_executable_name(a) {
        return caml_executable_name;
      }
      function caml_lessequal(x2, y) {
        return +(caml_compare_val(x2, y, false) <= 0);
      }
      function caml_acosh_float(x2) {
        return Math.acosh(x2);
      }
      function caml_MD5Init() {
        var buffer = new ArrayBuffer(64), b32 = new Uint32Array(buffer), b8 = new Uint8Array(buffer);
        return {
          len: 0,
          w: new Uint32Array([1732584193, 4023233417, 2562383102, 271733878]),
          b32,
          b8
        };
      }
      function caml_ml_flush(chanid) {
        var chan = caml_ml_channels[chanid];
        if (!chan.opened)
          caml_raise_sys_error("Cannot flush a closed channel");
        if (!chan.buffer || chan.buffer_curr == 0)
          return 0;
        if (chan.output)
          chan.output(caml_subarray_to_jsbytes(chan.buffer, 0, chan.buffer_curr));
        else
          chan.file.write(chan.offset, chan.buffer, 0, chan.buffer_curr);
        chan.offset += chan.buffer_curr;
        chan.buffer_curr = 0;
        return 0;
      }
      function caml_seek_out(chanid, pos) {
        caml_ml_flush(chanid);
        var chan = caml_ml_channels[chanid];
        chan.offset = pos;
        return 0;
      }
      function caml_ml_seek_out_64(chanid, pos) {
        var pos = caml_int64_to_float(pos);
        return caml_seek_out(chanid, pos);
      }
      function compare_nat_real(nat1, nat2) {
        return compare_nat(nat1, 0, nat1.data.length, nat2, 0, nat2.data.length);
      }
      function caml_gc_set(_control) {
        return 0;
      }
      function caml_js_get(o, f) {
        return o[f];
      }
      function caml_unix_isatty(fileDescriptor) {
        if (fs_node_supported()) {
          var tty = __require("tty");
          return tty.isatty(fileDescriptor) ? 1 : 0;
        } else
          return 0;
      }
      function caml_ml_set_buffered(chanid, v) {
        caml_ml_channels[chanid].buffered = v;
        if (!v)
          caml_ml_flush(chanid);
        return 0;
      }
      function caml_gc_compaction() {
        return 0;
      }
      function caml_ephe_get_key(x2, i) {
        if (i < 0 || caml_ephe_key_offset + i >= x2.length)
          caml_invalid_argument("Weak.get_key");
        var weak = x2[caml_ephe_key_offset + i];
        if (globalThis.WeakRef && weak instanceof globalThis.WeakRef)
          weak = weak.deref();
        return weak === void 0 ? 0 : [0, weak];
      }
      function caml_unix_localtime(t) {
        var d = new Date(t * 1e3), d_num = d.getTime(), januaryfirst = new Date(d.getFullYear(), 0, 1).getTime(), doy = Math.floor((d_num - januaryfirst) / 864e5), jan = new Date(d.getFullYear(), 0, 1), jul = new Date(d.getFullYear(), 6, 1), stdTimezoneOffset = Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
        return [
          0,
          d.getSeconds(),
          d.getMinutes(),
          d.getHours(),
          d.getDate(),
          d.getMonth(),
          d.getFullYear() - 1900,
          d.getDay(),
          doy,
          d.getTimezoneOffset() < stdTimezoneOffset | 0
        ];
      }
      function caml_unix_mktime(tm) {
        var d = new Date(tm[6] + 1900, tm[5], tm[4], tm[3], tm[2], tm[1]).getTime(), t = Math.floor(d / 1e3), tm2 = caml_unix_localtime(t);
        return [0, t, tm2];
      }
      function caml_bigstring_blit_bytes_to_ba(str1, pos1, ba2, pos2, len) {
        if (12 != ba2.kind)
          caml_invalid_argument("caml_bigstring_blit_string_to_ba: kind mismatch");
        if (len == 0)
          return 0;
        var ofs2 = ba2.offset(pos2);
        if (pos1 + len > caml_ml_bytes_length(str1))
          caml_array_bound_error();
        if (ofs2 + len > ba2.data.length)
          caml_array_bound_error();
        var slice = caml_uint8_array_of_bytes(str1).slice(pos1, pos1 + len);
        ba2.data.set(slice, ofs2);
        return 0;
      }
      var caml_sys_fds = new Array(3);
      function caml_sys_close(fd) {
        var file = caml_sys_fds[fd];
        if (file)
          file.close();
        delete caml_sys_fds[fd];
        return 0;
      }
      function caml_ml_close_channel(chanid) {
        var chan = caml_ml_channels[chanid];
        if (chan.opened) {
          chan.opened = false;
          caml_sys_close(chan.fd);
          chan.fd = -1;
          chan.buffer = new Uint8Array(0);
          chan.buffer_curr = 0;
          chan.buffer_max = 0;
        }
        return 0;
      }
      function caml_atomic_exchange(ref, v) {
        var r = ref[1];
        ref[1] = v;
        return r;
      }
      function caml_sys_isatty(_chan) {
        return 0;
      }
      function is_digit_zero(nat, ofs) {
        if (nat.data[ofs] == 0)
          return 1;
        return 0;
      }
      function caml_unix_lstat(name) {
        var root = resolve_fs_device(name);
        if (!root.device.lstat)
          caml_failwith("caml_unix_lstat: not implemented");
        return root.device.lstat(root.rest, true);
      }
      function caml_unix_lstat_64(name) {
        var r = caml_unix_lstat(name);
        r[9] = caml_int64_of_int32(r[9]);
        return r;
      }
      function caml_js_set(o, f, v) {
        o[f] = v;
        return 0;
      }
      function caml_array_get(array, index) {
        if (index < 0 || index >= array.length - 1)
          caml_array_bound_error();
        return array[index + 1];
      }
      function caml_continuation_use_noexc(cont) {
        var stack = cont[1];
        cont[1] = 0;
        return stack;
      }
      function caml_unix_rmdir(name) {
        var root = resolve_fs_device(name);
        if (!root.device.rmdir)
          caml_failwith("caml_unix_rmdir: not implemented");
        return root.device.rmdir(root.rest, true);
      }
      function caml_log2_float(x2) {
        return Math.log2(x2);
      }
      function caml_gc_huge_fallback_count(unit) {
        return 0;
      }
      function caml_spacetime_only_works_for_native_code() {
        caml_failwith("Spacetime profiling only works for native code");
      }
      function caml_int64_sub(x2, y) {
        return x2.sub(y);
      }
      function caml_seek_in(chanid, pos) {
        var chan = caml_ml_channels[chanid];
        if (chan.refill != null)
          caml_raise_sys_error("Illegal seek");
        if (pos >= chan.offset - chan.buffer_max && pos <= chan.offset && chan.file.flags.binary)
          chan.buffer_curr = chan.buffer_max - (chan.offset - pos);
        else {
          chan.offset = pos;
          chan.buffer_curr = 0;
          chan.buffer_max = 0;
        }
        return 0;
      }
      function caml_ml_seek_in_64(chanid, pos) {
        var pos = caml_int64_to_float(pos);
        return caml_seek_in(chanid, pos);
      }
      var caml_domain_id = 0;
      function caml_ml_mutex_unlock(t) {
        t.locked = false;
        return 0;
      }
      var caml_domain_latest_idx = 1;
      function caml_domain_spawn(f, mutex) {
        var id = caml_domain_latest_idx++, old = caml_domain_id;
        caml_domain_id = id;
        var res = caml_callback(f, [0]);
        caml_domain_id = old;
        caml_ml_mutex_unlock(mutex);
        return id;
      }
      function caml_unix_mkdir(name, perm) {
        var root = resolve_fs_device(name);
        if (!root.device.mkdir)
          caml_failwith("caml_unix_mkdir: not implemented");
        return root.device.mkdir(root.rest, perm, true);
      }
      function caml_int64_shift_left(x2, s2) {
        return x2.shift_left(s2);
      }
      function caml_notequal(x2, y) {
        return +(caml_compare_val(x2, y, false) != 0);
      }
      function caml_sys_const_int_size() {
        return 32;
      }
      function caml_js_wrap_callback(f) {
        return function() {
          var len = arguments.length;
          if (len > 0) {
            var args = new Array(len);
            for (var i = 0; i < len; i++)
              args[i] = arguments[i];
          } else
            args = [void 0];
          var res = caml_callback(f, args);
          return res instanceof Function ? caml_js_wrap_callback(res) : res;
        };
      }
      function caml_js_wrap_meth_callback(f) {
        return function() {
          var len = arguments.length, args = new Array(len + 1);
          args[0] = this;
          for (var i = 0; i < len; i++)
            args[i + 1] = arguments[i];
          var res = caml_callback(f, args);
          return res instanceof Function ? caml_js_wrap_callback(res) : res;
        };
      }
      function caml_is_js() {
        return 1;
      }
      function caml_lazy_update_to_forward(o) {
        caml_obj_update_tag(o, 244, 250);
        return 0;
      }
      function caml_ba_dim(ba, i) {
        if (i < 0 || i >= ba.dims.length)
          caml_invalid_argument("Bigarray.dim");
        return ba.dims[i];
      }
      function caml_ba_dim_1(ba) {
        return caml_ba_dim(ba, 0);
      }
      function caml_js_meth_call(o, f, args) {
        return o[caml_jsstring_of_string(f)].apply(o, caml_js_from_array(args));
      }
      var caml_ephe_data_offset = 2;
      function caml_weak_create(n) {
        if (n < 0)
          caml_invalid_argument("Weak.create");
        var x2 = [251, "caml_ephe_list_head"];
        x2.length = caml_ephe_key_offset + n;
        return x2;
      }
      function caml_ephe_create(n) {
        var x2 = caml_weak_create(n);
        return x2;
      }
      function caml_js_to_byte_string(s2) {
        return caml_string_of_jsbytes(s2);
      }
      function caml_trampoline(res) {
        var c = 1;
        while (res && res.joo_tramp) {
          res = res.joo_tramp.apply(null, res.joo_args);
          c++;
        }
        return res;
      }
      function caml_maybe_print_stats(unit) {
        return 0;
      }
      function caml_bytes_unsafe_get(s2, i) {
        switch (s2.t & 6) {
          default:
            if (i >= s2.c.length)
              return 0;
          case 0:
            return s2.c.charCodeAt(i);
          case 4:
            return s2.c[i];
        }
      }
      function caml_bytes_get64(s2, i) {
        if (i >>> 0 >= s2.l - 7)
          caml_bytes_bound_error();
        var a = new Array(8);
        for (var j = 0; j < 8; j++)
          a[7 - j] = caml_bytes_unsafe_get(s2, i + j);
        return caml_int64_of_bytes(a);
      }
      var caml_custom_event_index = 0;
      function caml_runtime_events_user_register(event_name, event_tag, event_type) {
        caml_custom_event_index += 1;
        return [0, caml_custom_event_index, event_name, event_type, event_tag];
      }
      function caml_unix_has_symlink(unit) {
        return fs_node_supported() ? 1 : 0;
      }
      function caml_ephe_set_key(x2, i, v) {
        if (i < 0 || caml_ephe_key_offset + i >= x2.length)
          caml_invalid_argument("Weak.set");
        if (v instanceof Object && globalThis.WeakRef) {
          if (x2[1].register)
            x2[1].register(v, void 0, v);
          x2[caml_ephe_key_offset + i] = new globalThis.WeakRef(v);
        } else
          x2[caml_ephe_key_offset + i] = v;
        return 0;
      }
      function caml_ephe_unset_key(x2, i) {
        if (i < 0 || caml_ephe_key_offset + i >= x2.length)
          caml_invalid_argument("Weak.set");
        if (globalThis.WeakRef && x2[caml_ephe_key_offset + i] instanceof globalThis.WeakRef && x2[1].unregister) {
          var old = x2[caml_ephe_key_offset + i].deref();
          if (old !== void 0) {
            var count = 0;
            for (var j = caml_ephe_key_offset; j < x2.length; j++) {
              var key = x2[j];
              if (key instanceof globalThis.WeakRef) {
                key = key.deref();
                if (key === old)
                  count++;
              }
            }
            if (count == 1)
              x2[1].unregister(old);
          }
        }
        x2[caml_ephe_key_offset + i] = void 0;
        return 0;
      }
      function caml_weak_set(x2, i, v) {
        if (v == 0)
          caml_ephe_unset_key(x2, i);
        else
          caml_ephe_set_key(x2, i, v[1]);
        return 0;
      }
      function caml_sys_remove(name) {
        var root = resolve_fs_device(name), ok = root.device.unlink(root.rest);
        if (ok == 0)
          caml_raise_no_such_file(caml_jsbytes_of_string(name));
        return 0;
      }
      function caml_string_bound_error() {
        caml_invalid_argument("index out of bounds");
      }
      function caml_string_get32(s2, i) {
        if (i >>> 0 >= caml_ml_string_length(s2) - 3)
          caml_string_bound_error();
        var b1 = caml_string_unsafe_get(s2, i), b2 = caml_string_unsafe_get(s2, i + 1), b3 = caml_string_unsafe_get(s2, i + 2), b4 = caml_string_unsafe_get(s2, i + 3);
        return b4 << 24 | b3 << 16 | b2 << 8 | b1;
      }
      function caml_bytes_get(s2, i) {
        if (i >>> 0 >= s2.l)
          caml_bytes_bound_error();
        return caml_bytes_unsafe_get(s2, i);
      }
      function caml_hypot_float(x2, y) {
        return Math.hypot(x2, y);
      }
      function caml_js_call(f, o, args) {
        return f.apply(o, caml_js_from_array(args));
      }
      function caml_sys_const_max_wosize() {
        return 2147483647 / 4 | 0;
      }
      function caml_unix_inet_addr_of_string() {
        return 0;
      }
      function caml_hash_mix_bytes_arr(h, s2) {
        var len = s2.length, i, w;
        for (i = 0; i + 4 <= len; i += 4) {
          w = s2[i] | s2[i + 1] << 8 | s2[i + 2] << 16 | s2[i + 3] << 24;
          h = caml_hash_mix_int(h, w);
        }
        w = 0;
        switch (len & 3) {
          case 3:
            w = s2[i + 2] << 16;
          case 2:
            w |= s2[i + 1] << 8;
          case 1:
            w |= s2[i];
            h = caml_hash_mix_int(h, w);
        }
        h ^= len;
        return h;
      }
      function caml_hash_mix_jsbytes(h, s2) {
        var len = s2.length, i, w;
        for (i = 0; i + 4 <= len; i += 4) {
          w = s2.charCodeAt(i) | s2.charCodeAt(i + 1) << 8 | s2.charCodeAt(i + 2) << 16 | s2.charCodeAt(i + 3) << 24;
          h = caml_hash_mix_int(h, w);
        }
        w = 0;
        switch (len & 3) {
          case 3:
            w = s2.charCodeAt(i + 2) << 16;
          case 2:
            w |= s2.charCodeAt(i + 1) << 8;
          case 1:
            w |= s2.charCodeAt(i);
            h = caml_hash_mix_int(h, w);
        }
        h ^= len;
        return h;
      }
      function caml_ml_bytes_content(s2) {
        switch (s2.t & 6) {
          default:
            caml_convert_string_to_bytes(s2);
          case 0:
            return s2.c;
          case 4:
            return s2.c;
        }
      }
      function caml_hash_mix_bytes(h, v) {
        var content = caml_ml_bytes_content(v);
        return typeof content === "string" ? caml_hash_mix_jsbytes(h, content) : caml_hash_mix_bytes_arr(h, content);
      }
      function caml_bytes_lessthan(s1, s2) {
        s1.t & 6 && caml_convert_string_to_bytes(s1);
        s2.t & 6 && caml_convert_string_to_bytes(s2);
        return s1.c < s2.c ? 1 : 0;
      }
      function caml_erfc_float(x2) {
        return 1 - caml_erf_float(x2);
      }
      function caml_gr_fill_poly(ar) {
        var s2 = caml_gr_state_get();
        s2.context.beginPath();
        s2.context.moveTo(ar[1][1], s2.height - ar[1][2]);
        for (var i = 2; i < ar.length; i++)
          s2.context.lineTo(ar[i][1], s2.height - ar[i][2]);
        s2.context.lineTo(ar[1][1], s2.height - ar[1][2]);
        s2.context.fill();
        return 0;
      }
      function caml_gc_quick_stat() {
        return [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      }
      function caml_ml_input_char(chanid) {
        var chan = caml_ml_channels[chanid];
        if (chan.buffer_curr >= chan.buffer_max) {
          chan.buffer_curr = 0;
          chan.buffer_max = 0;
          caml_refill(chan);
        }
        if (chan.buffer_curr >= chan.buffer_max)
          caml_raise_end_of_file();
        var res = chan.buffer[chan.buffer_curr];
        chan.buffer_curr++;
        return res;
      }
      function caml_ml_input_int(chanid) {
        var chan = caml_ml_channels[chanid], res = 0;
        for (var i = 0; i < 4; i++)
          res = (res << 8) + caml_ml_input_char(chanid) | 0;
        return res | 0;
      }
      function caml_gr_display_mode() {
        caml_failwith("caml_gr_display_mode not Implemented");
      }
      function caml_obj_reachable_words(o) {
        return 0;
      }
      function nth_digit_nat(nat, ofs) {
        return nat.data[ofs];
      }
      function caml_array_blit(a1, i1, a2, i2, len) {
        if (i2 <= i1)
          for (var j = 1; j <= len; j++)
            a2[i2 + j] = a1[i1 + j];
        else
          for (var j = len; j >= 1; j--)
            a2[i2 + j] = a1[i1 + j];
        return 0;
      }
      function caml_float_of_string(s2) {
        var res;
        s2 = caml_jsbytes_of_string(s2);
        res = +s2;
        if (s2.length > 0 && res === res)
          return res;
        s2 = s2.replace(/_/g, "");
        res = +s2;
        if (s2.length > 0 && res === res || /^[+-]?nan$/i.test(s2))
          return res;
        var m = /^ *([+-]?)0x([0-9a-f]+)\.?([0-9a-f]*)(p([+-]?[0-9]+))?/i.exec(s2);
        if (m) {
          var m3 = m[3].replace(/0+$/, ""), mantissa = parseInt(m[1] + m[2] + m3, 16), exponent = (m[5] | 0) - 4 * m3.length;
          res = mantissa * Math.pow(2, exponent);
          return res;
        }
        if (/^\+?inf(inity)?$/i.test(s2))
          return Infinity;
        if (/^-inf(inity)?$/i.test(s2))
          return -Infinity;
        caml_failwith("float_of_string");
      }
      function caml_sys_getcwd() {
        return caml_string_of_jsbytes(caml_current_dir);
      }
      function caml_int64_add(x2, y) {
        return x2.add(y);
      }
      function caml_int64_mul(x2, y) {
        return x2.mul(y);
      }
      function caml_int64_ult(x2, y) {
        return x2.ucompare(y) < 0;
      }
      function caml_parse_sign_and_base(s2) {
        var i = 0, len = caml_ml_string_length(s2), base = 10, sign = 1;
        if (len > 0)
          switch (caml_string_unsafe_get(s2, i)) {
            case 45:
              i++;
              sign = -1;
              break;
            case 43:
              i++;
              sign = 1;
              break;
          }
        if (i + 1 < len && caml_string_unsafe_get(s2, i) == 48)
          switch (caml_string_unsafe_get(s2, i + 1)) {
            case 120:
            case 88:
              base = 16;
              i += 2;
              break;
            case 111:
            case 79:
              base = 8;
              i += 2;
              break;
            case 98:
            case 66:
              base = 2;
              i += 2;
              break;
            case 117:
            case 85:
              i += 2;
              break;
          }
        return [i, sign, base];
      }
      function caml_parse_digit(c) {
        if (c >= 48 && c <= 57)
          return c - 48;
        if (c >= 65 && c <= 90)
          return c - 55;
        if (c >= 97 && c <= 122)
          return c - 87;
        return -1;
      }
      function caml_int64_of_string(s2) {
        var r = caml_parse_sign_and_base(s2), i = r[0], sign = r[1], base = r[2], base64 = caml_int64_of_int32(base), threshold = new MlInt64(16777215, 268435455, 65535).udivmod(base64).quotient, c = caml_string_unsafe_get(s2, i), d = caml_parse_digit(c);
        if (d < 0 || d >= base)
          caml_failwith("int_of_string");
        var res = caml_int64_of_int32(d);
        for (; ; ) {
          i++;
          c = caml_string_unsafe_get(s2, i);
          if (c == 95)
            continue;
          d = caml_parse_digit(c);
          if (d < 0 || d >= base)
            break;
          if (caml_int64_ult(threshold, res))
            caml_failwith("int_of_string");
          d = caml_int64_of_int32(d);
          res = caml_int64_add(caml_int64_mul(base64, res), d);
          if (caml_int64_ult(res, d))
            caml_failwith("int_of_string");
        }
        if (i != caml_ml_string_length(s2))
          caml_failwith("int_of_string");
        if (base == 10 && caml_int64_ult(new MlInt64(0, 0, 32768), res))
          caml_failwith("int_of_string");
        if (sign < 0)
          res = caml_int64_neg(res);
        return res;
      }
      function caml_ba_set_1(ba, i0, v) {
        ba.set(ba.offset(i0), v);
        return 0;
      }
      function caml_int64_xor(x2, y) {
        return x2.xor(y);
      }
      function caml_int64_or(x2, y) {
        return x2.or(y);
      }
      function caml_lxm_next(v) {
        function shift_l(x2, k) {
          return caml_int64_shift_left(x2, k);
        }
        function shift_r(x2, k) {
          return caml_int64_shift_right_unsigned(x2, k);
        }
        function or(a2, b) {
          return caml_int64_or(a2, b);
        }
        function xor(a2, b) {
          return caml_int64_xor(a2, b);
        }
        function add(a2, b) {
          return caml_int64_add(a2, b);
        }
        function mul(a2, b) {
          return caml_int64_mul(a2, b);
        }
        function rotl(x2, k) {
          return or(shift_l(x2, k), shift_r(x2, 64 - k));
        }
        function get(a2, i) {
          return caml_ba_get_1(a2, i);
        }
        function set(a2, i, x2) {
          return caml_ba_set_1(a2, i, x2);
        }
        var M = caml_int64_of_string(caml_new_string("0xd1342543de82ef95")), daba = caml_int64_of_string(caml_new_string("0xdaba0b6eb09322e3")), z, q0, q1, st = v, a = get(st, 0), s2 = get(st, 1), x0 = get(st, 2), x1 = get(st, 3);
        z = add(s2, x0);
        z = mul(xor(z, shift_r(z, 32)), daba);
        z = mul(xor(z, shift_r(z, 32)), daba);
        z = xor(z, shift_r(z, 32));
        set(st, 1, add(mul(s2, M), a));
        var q0 = x0, q1 = x1;
        q1 = xor(q1, q0);
        q0 = rotl(q0, 24);
        q0 = xor(xor(q0, q1), shift_l(q1, 16));
        q1 = rotl(q1, 37);
        set(st, 2, q0);
        set(st, 3, q1);
        return z;
      }
      function caml_sys_const_big_endian() {
        return 0;
      }
      function caml_list_to_js_array(l) {
        var a = [];
        for (; l !== 0; l = l[2])
          a.push(l[1]);
        return a;
      }
      var caml_output_val = function() {
        function Writer() {
          this.chunk = [];
        }
        Writer.prototype = {
          chunk_idx: 20,
          block_len: 0,
          obj_counter: 0,
          size_32: 0,
          size_64: 0,
          write: function(size, value) {
            for (var i = size - 8; i >= 0; i -= 8)
              this.chunk[this.chunk_idx++] = value >> i & 255;
          },
          write_at: function(pos, size, value) {
            var pos = pos;
            for (var i = size - 8; i >= 0; i -= 8)
              this.chunk[pos++] = value >> i & 255;
          },
          write_code: function(size, code, value) {
            this.chunk[this.chunk_idx++] = code;
            for (var i = size - 8; i >= 0; i -= 8)
              this.chunk[this.chunk_idx++] = value >> i & 255;
          },
          write_shared: function(offset) {
            if (offset < 1 << 8)
              this.write_code(8, 4, offset);
            else if (offset < 1 << 16)
              this.write_code(16, 5, offset);
            else
              this.write_code(32, 6, offset);
          },
          pos: function() {
            return this.chunk_idx;
          },
          finalize: function() {
            this.block_len = this.chunk_idx - 20;
            this.chunk_idx = 0;
            this.write(32, 2224400062);
            this.write(32, this.block_len);
            this.write(32, this.obj_counter);
            this.write(32, this.size_32);
            this.write(32, this.size_64);
            return this.chunk;
          }
        };
        return function(v, flags) {
          flags = caml_list_to_js_array(flags);
          var no_sharing = flags.indexOf(0) !== -1, closures = flags.indexOf(1) !== -1;
          if (closures)
            console.warn("in caml_output_val: flag Marshal.Closures is not supported.");
          var writer = new Writer(), stack = [], intern_obj_table = no_sharing ? null : new MlObjectTable();
          function memo(v2) {
            if (no_sharing)
              return false;
            var existing_offset = intern_obj_table.recall(v2);
            if (existing_offset) {
              writer.write_shared(existing_offset);
              return true;
            } else {
              intern_obj_table.store(v2);
              return false;
            }
          }
          function extern_rec(v2) {
            if (v2.caml_custom) {
              if (memo(v2))
                return;
              var name = v2.caml_custom, ops = caml_custom_ops[name], sz_32_64 = [0, 0];
              if (!ops.serialize)
                caml_invalid_argument("output_value: abstract value (Custom)");
              if (ops.fixed_length == void 0) {
                writer.write(8, 24);
                for (var i2 = 0; i2 < name.length; i2++)
                  writer.write(8, name.charCodeAt(i2));
                writer.write(8, 0);
                var header_pos = writer.pos();
                for (var i2 = 0; i2 < 12; i2++)
                  writer.write(8, 0);
                ops.serialize(writer, v2, sz_32_64);
                writer.write_at(header_pos, 32, sz_32_64[0]);
                writer.write_at(header_pos + 4, 32, 0);
                writer.write_at(header_pos + 8, 32, sz_32_64[1]);
              } else {
                writer.write(8, 25);
                for (var i2 = 0; i2 < name.length; i2++)
                  writer.write(8, name.charCodeAt(i2));
                writer.write(8, 0);
                var old_pos = writer.pos();
                ops.serialize(writer, v2, sz_32_64);
                if (ops.fixed_length != writer.pos() - old_pos)
                  caml_failwith("output_value: incorrect fixed sizes specified by " + name);
              }
              writer.size_32 += 2 + (sz_32_64[0] + 3 >> 2);
              writer.size_64 += 2 + (sz_32_64[1] + 7 >> 3);
            } else if (v2 instanceof Array && v2[0] === (v2[0] | 0)) {
              if (v2[0] == 251)
                caml_failwith("output_value: abstract value (Abstract)");
              if (caml_is_continuation_tag(v2[0]))
                caml_invalid_argument("output_value: continuation value");
              if (v2.length > 1 && memo(v2))
                return;
              if (v2[0] < 16 && v2.length - 1 < 8)
                writer.write(8, 128 + v2[0] + (v2.length - 1 << 4));
              else
                writer.write_code(32, 8, v2.length - 1 << 10 | v2[0]);
              writer.size_32 += v2.length;
              writer.size_64 += v2.length;
              if (v2.length > 1)
                stack.push(v2, 1);
            } else if (caml_is_ml_bytes(v2)) {
              if (!caml_is_ml_bytes(caml_string_of_jsbytes("")))
                caml_failwith("output_value: [Bytes.t] cannot safely be marshaled with [--enable use-js-string]");
              if (memo(v2))
                return;
              var len = caml_ml_bytes_length(v2);
              if (len < 32)
                writer.write(8, 32 + len);
              else if (len < 256)
                writer.write_code(8, 9, len);
              else
                writer.write_code(32, 10, len);
              for (var i2 = 0; i2 < len; i2++)
                writer.write(8, caml_bytes_unsafe_get(v2, i2));
              writer.size_32 += 1 + ((len + 4) / 4 | 0);
              writer.size_64 += 1 + ((len + 8) / 8 | 0);
            } else if (caml_is_ml_string(v2)) {
              if (memo(v2))
                return;
              var len = caml_ml_string_length(v2);
              if (len < 32)
                writer.write(8, 32 + len);
              else if (len < 256)
                writer.write_code(8, 9, len);
              else
                writer.write_code(32, 10, len);
              for (var i2 = 0; i2 < len; i2++)
                writer.write(8, caml_string_unsafe_get(v2, i2));
              writer.size_32 += 1 + ((len + 4) / 4 | 0);
              writer.size_64 += 1 + ((len + 8) / 8 | 0);
            } else if (v2 != (v2 | 0)) {
              var type_of_v = typeof v2;
              caml_failwith("output_value: abstract value (" + type_of_v + ")");
            } else if (v2 >= 0 && v2 < 64)
              writer.write(8, 64 + v2);
            else if (v2 >= -(1 << 7) && v2 < 1 << 7)
              writer.write_code(8, 0, v2);
            else if (v2 >= -(1 << 15) && v2 < 1 << 15)
              writer.write_code(16, 1, v2);
            else
              writer.write_code(32, 2, v2);
          }
          extern_rec(v);
          while (stack.length > 0) {
            var i = stack.pop(), v = stack.pop();
            if (i + 1 < v.length)
              stack.push(v, i + 1);
            extern_rec(v[i]);
          }
          if (intern_obj_table)
            writer.obj_counter = intern_obj_table.objs.length;
          writer.finalize();
          return writer.chunk;
        };
      }();
      function caml_string_of_array(a) {
        return caml_string_of_jsbytes(caml_subarray_to_jsbytes(a, 0, a.length));
      }
      function caml_output_value_to_string(v, flags) {
        return caml_string_of_array(caml_output_val(v, flags));
      }
      function caml_raise_not_a_dir(name) {
        caml_raise_sys_error(name + ": Not a directory");
      }
      function caml_sys_system_command(cmd) {
        var cmd = caml_jsstring_of_string(cmd);
        if (typeof __require != "undefined") {
          var child_process = __require("child_process");
          if (child_process && child_process.execSync)
            try {
              child_process.execSync(cmd, { stdio: "inherit" });
              return 0;
            } catch (e) {
              return 1;
            }
        } else
          return 127;
      }
      function caml_js_error_of_exception(exn) {
        if (exn.js_error)
          return exn.js_error;
        return null;
      }
      function caml_unix_getuid(unit) {
        if (globalThis.process && globalThis.process.getuid)
          return globalThis.process.getuid();
        caml_raise_not_found();
      }
      function deserialize_nat(reader, sz) {
        var len = reader.read32s(), nat = new MlNat(len);
        for (var i = 0; i < len; i++)
          nat.data[i] = reader.read32s();
        sz[0] = len * 4;
        return nat;
      }
      function initialize_nat() {
        caml_custom_ops["_nat"] = {
          deserialize: deserialize_nat,
          serialize: serialize_nat,
          hash: caml_hash_nat
        };
      }
      function caml_bytes_of_utf16_jsstring(s2) {
        var tag = 9;
        if (!jsoo_is_ascii(s2))
          tag = 8, s2 = caml_utf8_of_utf16(s2);
        return new MlBytes(tag, s2, s2.length);
      }
      function caml_gr_open_subwindow(a, b, c, d) {
        caml_failwith("caml_gr_open_subwindow not Implemented");
      }
      function UInt8ArrayReader(s2, i) {
        this.s = s2;
        this.i = i;
      }
      UInt8ArrayReader.prototype = {
        read8u: function() {
          return this.s[this.i++];
        },
        read8s: function() {
          return this.s[this.i++] << 24 >> 24;
        },
        read16u: function() {
          var s2 = this.s, i = this.i;
          this.i = i + 2;
          return s2[i] << 8 | s2[i + 1];
        },
        read16s: function() {
          var s2 = this.s, i = this.i;
          this.i = i + 2;
          return s2[i] << 24 >> 16 | s2[i + 1];
        },
        read32u: function() {
          var s2 = this.s, i = this.i;
          this.i = i + 4;
          return (s2[i] << 24 | s2[i + 1] << 16 | s2[i + 2] << 8 | s2[i + 3]) >>> 0;
        },
        read32s: function() {
          var s2 = this.s, i = this.i;
          this.i = i + 4;
          return s2[i] << 24 | s2[i + 1] << 16 | s2[i + 2] << 8 | s2[i + 3];
        },
        readstr: function(len) {
          var i = this.i;
          this.i = i + len;
          return caml_string_of_array(this.s.subarray(i, i + len));
        },
        readuint8array: function(len) {
          var i = this.i;
          this.i = i + len;
          return this.s.subarray(i, i + len);
        }
      };
      function caml_marshal_data_size(s2, ofs) {
        var r = new UInt8ArrayReader(caml_uint8_array_of_bytes(s2), ofs);
        function readvlq(overflow2) {
          var c = r.read8u(), n = c & 127;
          while ((c & 128) != 0) {
            c = r.read8u();
            var n7 = n << 7;
            if (n != n7 >> 7)
              overflow2[0] = true;
            n = n7 | c & 127;
          }
          return n;
        }
        switch (r.read32u()) {
          case 2224400062:
            var header_len = 20, data_len = r.read32u();
            break;
          case 2224400061:
            var header_len = r.read8u() & 63, overflow = [false], data_len = readvlq(overflow);
            if (overflow[0])
              caml_failwith("Marshal.data_size: object too large to be read back on this platform");
            break;
          case 2224400063:
          default:
            caml_failwith("Marshal.data_size: bad object");
            break;
        }
        return header_len - caml_marshal_header_size + data_len;
      }
      function MlStringReader(s2, i) {
        this.s = caml_jsbytes_of_string(s2);
        this.i = i;
      }
      MlStringReader.prototype = {
        read8u: function() {
          return this.s.charCodeAt(this.i++);
        },
        read8s: function() {
          return this.s.charCodeAt(this.i++) << 24 >> 24;
        },
        read16u: function() {
          var s2 = this.s, i = this.i;
          this.i = i + 2;
          return s2.charCodeAt(i) << 8 | s2.charCodeAt(i + 1);
        },
        read16s: function() {
          var s2 = this.s, i = this.i;
          this.i = i + 2;
          return s2.charCodeAt(i) << 24 >> 16 | s2.charCodeAt(i + 1);
        },
        read32u: function() {
          var s2 = this.s, i = this.i;
          this.i = i + 4;
          return (s2.charCodeAt(i) << 24 | s2.charCodeAt(i + 1) << 16 | s2.charCodeAt(i + 2) << 8 | s2.charCodeAt(i + 3)) >>> 0;
        },
        read32s: function() {
          var s2 = this.s, i = this.i;
          this.i = i + 4;
          return s2.charCodeAt(i) << 24 | s2.charCodeAt(i + 1) << 16 | s2.charCodeAt(i + 2) << 8 | s2.charCodeAt(i + 3);
        },
        readstr: function(len) {
          var i = this.i;
          this.i = i + len;
          return caml_string_of_jsbytes(this.s.substring(i, i + len));
        },
        readuint8array: function(len) {
          var b = new Uint8Array(len), s2 = this.s, i = this.i;
          for (var j = 0; j < len; j++)
            b[j] = s2.charCodeAt(i + j);
          this.i = i + len;
          return b;
        }
      };
      var caml_decompress_input = null;
      function caml_float_of_bytes(a) {
        return caml_int64_float_of_bits(caml_int64_of_bytes(a));
      }
      function caml_input_value_from_reader(reader, ofs) {
        function readvlq(overflow2) {
          var c = reader.read8u(), n = c & 127;
          while ((c & 128) != 0) {
            c = reader.read8u();
            var n7 = n << 7;
            if (n != n7 >> 7)
              overflow2[0] = true;
            n = n7 | c & 127;
          }
          return n;
        }
        var magic = reader.read32u();
        switch (magic) {
          case 2224400062:
            var header_len = 20, compressed = 0, data_len = reader.read32u(), uncompressed_data_len = data_len, num_objects = reader.read32u(), _size_32 = reader.read32u(), _size_64 = reader.read32u();
            break;
          case 2224400061:
            var header_len = reader.read8u() & 63, compressed = 1, overflow = [false], data_len = readvlq(overflow), uncompressed_data_len = readvlq(overflow), num_objects = readvlq(overflow), _size_32 = readvlq(overflow), _size_64 = readvlq(overflow);
            if (overflow[0])
              caml_failwith("caml_input_value_from_reader: object too large to be read back on this platform");
            break;
          case 2224400063:
            caml_failwith("caml_input_value_from_reader: object too large to be read back on a 32-bit platform");
            break;
          default:
            caml_failwith("caml_input_value_from_reader: bad object");
            break;
        }
        var stack = [], intern_obj_table = num_objects > 0 ? [] : null, obj_counter = 0;
        function intern_rec(reader2) {
          var code = reader2.read8u();
          if (code >= 64)
            if (code >= 128) {
              var tag = code & 15, size2 = code >> 4 & 7, v2 = [tag];
              if (size2 == 0)
                return v2;
              if (intern_obj_table)
                intern_obj_table[obj_counter++] = v2;
              stack.push(v2, size2);
              return v2;
            } else
              return code & 63;
          else if (code >= 32) {
            var len = code & 31, v2 = reader2.readstr(len);
            if (intern_obj_table)
              intern_obj_table[obj_counter++] = v2;
            return v2;
          } else
            switch (code) {
              case 0:
                return reader2.read8s();
              case 1:
                return reader2.read16s();
              case 2:
                return reader2.read32s();
              case 3:
                caml_failwith("input_value: integer too large");
                break;
              case 4:
                var offset = reader2.read8u();
                if (compressed == 0)
                  offset = obj_counter - offset;
                return intern_obj_table[offset];
              case 5:
                var offset = reader2.read16u();
                if (compressed == 0)
                  offset = obj_counter - offset;
                return intern_obj_table[offset];
              case 6:
                var offset = reader2.read32u();
                if (compressed == 0)
                  offset = obj_counter - offset;
                return intern_obj_table[offset];
              case 8:
                var header = reader2.read32u(), tag = header & 255, size2 = header >> 10, v2 = [tag];
                if (size2 == 0)
                  return v2;
                if (intern_obj_table)
                  intern_obj_table[obj_counter++] = v2;
                stack.push(v2, size2);
                return v2;
              case 19:
                caml_failwith("input_value: data block too large");
                break;
              case 9:
                var len = reader2.read8u(), v2 = reader2.readstr(len);
                if (intern_obj_table)
                  intern_obj_table[obj_counter++] = v2;
                return v2;
              case 10:
                var len = reader2.read32u(), v2 = reader2.readstr(len);
                if (intern_obj_table)
                  intern_obj_table[obj_counter++] = v2;
                return v2;
              case 12:
                var t = new Array(8);
                for (var i = 0; i < 8; i++)
                  t[7 - i] = reader2.read8u();
                var v2 = caml_float_of_bytes(t);
                if (intern_obj_table)
                  intern_obj_table[obj_counter++] = v2;
                return v2;
              case 11:
                var t = new Array(8);
                for (var i = 0; i < 8; i++)
                  t[i] = reader2.read8u();
                var v2 = caml_float_of_bytes(t);
                if (intern_obj_table)
                  intern_obj_table[obj_counter++] = v2;
                return v2;
              case 14:
                var len = reader2.read8u(), v2 = new Array(len + 1);
                v2[0] = 254;
                var t = new Array(8);
                if (intern_obj_table)
                  intern_obj_table[obj_counter++] = v2;
                for (var i = 1; i <= len; i++) {
                  for (var j = 0; j < 8; j++)
                    t[7 - j] = reader2.read8u();
                  v2[i] = caml_float_of_bytes(t);
                }
                return v2;
              case 13:
                var len = reader2.read8u(), v2 = new Array(len + 1);
                v2[0] = 254;
                var t = new Array(8);
                if (intern_obj_table)
                  intern_obj_table[obj_counter++] = v2;
                for (var i = 1; i <= len; i++) {
                  for (var j = 0; j < 8; j++)
                    t[j] = reader2.read8u();
                  v2[i] = caml_float_of_bytes(t);
                }
                return v2;
              case 7:
                var len = reader2.read32u(), v2 = new Array(len + 1);
                v2[0] = 254;
                if (intern_obj_table)
                  intern_obj_table[obj_counter++] = v2;
                var t = new Array(8);
                for (var i = 1; i <= len; i++) {
                  for (var j = 0; j < 8; j++)
                    t[7 - j] = reader2.read8u();
                  v2[i] = caml_float_of_bytes(t);
                }
                return v2;
              case 15:
                var len = reader2.read32u(), v2 = new Array(len + 1);
                v2[0] = 254;
                var t = new Array(8);
                for (var i = 1; i <= len; i++) {
                  for (var j = 0; j < 8; j++)
                    t[j] = reader2.read8u();
                  v2[i] = caml_float_of_bytes(t);
                }
                return v2;
              case 16:
              case 17:
                caml_failwith("input_value: code pointer");
                break;
              case 18:
              case 24:
              case 25:
                var c, s2 = "";
                while ((c = reader2.read8u()) != 0)
                  s2 += String.fromCharCode(c);
                var ops = caml_custom_ops[s2], expected_size;
                if (!ops)
                  caml_failwith("input_value: unknown custom block identifier");
                switch (code) {
                  case 18:
                    break;
                  case 25:
                    if (!ops.fixed_length)
                      caml_failwith("input_value: expected a fixed-size custom block");
                    expected_size = ops.fixed_length;
                    break;
                  case 24:
                    expected_size = reader2.read32u();
                    reader2.read32s();
                    reader2.read32s();
                    break;
                }
                var old_pos = reader2.i, size2 = [0], v2 = ops.deserialize(reader2, size2);
                if (expected_size != void 0) {
                  if (expected_size != size2[0])
                    caml_failwith("input_value: incorrect length of serialized custom block");
                }
                if (intern_obj_table)
                  intern_obj_table[obj_counter++] = v2;
                return v2;
              default:
                caml_failwith("input_value: ill-formed message");
            }
        }
        if (compressed)
          if (caml_decompress_input)
            var data = reader.readuint8array(data_len), res = new Uint8Array(uncompressed_data_len), res = caml_decompress_input(data, res), reader = new UInt8ArrayReader(res, 0);
          else
            caml_failwith("input_value: compressed object, cannot decompress");
        var res = intern_rec(reader);
        while (stack.length > 0) {
          var size = stack.pop(), v = stack.pop(), d = v.length;
          if (d < size)
            stack.push(v, size);
          v[d] = intern_rec(reader);
        }
        if (typeof ofs != "number")
          ofs[0] = reader.i;
        return res;
      }
      function caml_string_of_bytes(s2) {
        s2.t & 6 && caml_convert_string_to_bytes(s2);
        return caml_string_of_jsbytes(s2.c);
      }
      function caml_input_value_from_bytes(s2, ofs) {
        var reader = new MlStringReader(caml_string_of_bytes(s2), typeof ofs == "number" ? ofs : ofs[0]);
        return caml_input_value_from_reader(reader, ofs);
      }
      function caml_input_value(chanid) {
        var chan = caml_ml_channels[chanid], header = new Uint8Array(caml_marshal_header_size);
        function block(buffer, offset2, n) {
          var r2 = 0;
          while (r2 < n) {
            if (chan.buffer_curr >= chan.buffer_max) {
              chan.buffer_curr = 0;
              chan.buffer_max = 0;
              caml_refill(chan);
            }
            if (chan.buffer_curr >= chan.buffer_max)
              break;
            buffer[offset2 + r2] = chan.buffer[chan.buffer_curr];
            chan.buffer_curr++;
            r2++;
          }
          return r2;
        }
        var r = block(header, 0, caml_marshal_header_size);
        if (r == 0)
          caml_raise_end_of_file();
        else if (r < caml_marshal_header_size)
          caml_failwith("input_value: truncated object");
        var len = caml_marshal_data_size(caml_bytes_of_array(header), 0), buf = new Uint8Array(len + caml_marshal_header_size);
        buf.set(header, 0);
        var r = block(buf, caml_marshal_header_size, len);
        if (r < len)
          caml_failwith("input_value: truncated object " + r + "  " + len);
        var offset = [0], res = caml_input_value_from_bytes(caml_bytes_of_array(buf), offset);
        chan.offset = chan.offset + offset[0];
        return res;
      }
      function caml_input_value_to_outside_heap(c) {
        return caml_input_value(c);
      }
      function caml_atomic_cas(ref, o, n) {
        if (ref[1] === o) {
          ref[1] = n;
          return 1;
        }
        return 0;
      }
      function caml_copysign_float(x2, y) {
        if (y == 0)
          y = 1 / y;
        x2 = Math.abs(x2);
        return y < 0 ? -x2 : x2;
      }
      function caml_gr_set_text_size(size) {
        var s2 = caml_gr_state_get();
        s2.text_size = size;
        s2.context.font = s2.text_size + "px " + caml_jsstring_of_string(s2.font);
        return 0;
      }
      function caml_atomic_load(ref) {
        return ref[1];
      }
      function caml_MD5Final(ctx) {
        var in_buf = ctx.len & 63;
        ctx.b8[in_buf] = 128;
        in_buf++;
        if (in_buf > 56) {
          for (var j = in_buf; j < 64; j++)
            ctx.b8[j] = 0;
          caml_MD5Transform(ctx.w, ctx.b32);
          for (var j = 0; j < 56; j++)
            ctx.b8[j] = 0;
        } else
          for (var j = in_buf; j < 56; j++)
            ctx.b8[j] = 0;
        ctx.b32[14] = ctx.len << 3;
        ctx.b32[15] = ctx.len >> 29 & 536870911;
        caml_MD5Transform(ctx.w, ctx.b32);
        var t = new Uint8Array(16);
        for (var i = 0; i < 4; i++)
          for (var j = 0; j < 4; j++)
            t[i * 4 + j] = ctx.w[i] >> 8 * j & 255;
        return t;
      }
      function caml_md5_bytes(s2, ofs, len) {
        var ctx = caml_MD5Init(), a = caml_uint8_array_of_bytes(s2);
        caml_MD5Update(ctx, a.subarray(ofs, ofs + len), len);
        return caml_string_of_array(caml_MD5Final(ctx));
      }
      function caml_ba_set_generic(ba, i, v) {
        ba.set(ba.offset(caml_js_from_array(i)), v);
        return 0;
      }
      function caml_ml_condition_wait(t, mutext) {
        return 0;
      }
      function caml_string_lessequal(s1, s2) {
        return s1 <= s2 ? 1 : 0;
      }
      function caml_string_greaterequal(s1, s2) {
        return caml_string_lessequal(s2, s1);
      }
      function caml_nextafter_float(x2, y) {
        if (isNaN(x2) || isNaN(y))
          return NaN;
        if (x2 == y)
          return y;
        if (x2 == 0)
          return y < 0 ? -Math.pow(2, -1074) : Math.pow(2, -1074);
        var bits = caml_int64_bits_of_float(x2), one = caml_int64_of_int32(1);
        if (x2 < y == x2 > 0)
          bits = caml_int64_add(bits, one);
        else
          bits = caml_int64_sub(bits, one);
        return caml_int64_float_of_bits(bits);
      }
      function caml_gr_size_y() {
        var s2 = caml_gr_state_get();
        return s2.height;
      }
      function caml_pos_in(chanid) {
        var chan = caml_ml_channels[chanid];
        return chan.offset - (chan.buffer_max - chan.buffer_curr) | 0;
      }
      function caml_ml_pos_in(chanid) {
        return caml_pos_in(chanid);
      }
      function caml_int64_and(x2, y) {
        return x2.and(y);
      }
      function caml_ml_runtime_events_resume() {
        return 0;
      }
      function caml_sys_const_word_size() {
        return 32;
      }
      function caml_unix_unlink(name) {
        var root = resolve_fs_device(name);
        if (!root.device.unlink)
          caml_failwith("caml_unix_unlink: not implemented");
        return root.device.unlink(root.rest, true);
      }
      function caml_sys_open_for_node(fd, flags) {
        if (flags.name)
          try {
            var fs = __require("fs"), fd2 = fs.openSync(flags.name, "rs");
            return new MlNodeFd(fd2, flags);
          } catch (e) {
          }
        return new MlNodeFd(fd, flags);
      }
      function MlFakeFd_out(fd, flags) {
        MlFakeFile.call(this, caml_create_bytes(0));
        this.log = function(s2) {
          return 0;
        };
        if (fd == 1 && typeof console.log == "function")
          this.log = console.log;
        else if (fd == 2 && typeof console.error == "function")
          this.log = console.error;
        else if (typeof console.log == "function")
          this.log = console.log;
        this.flags = flags;
      }
      MlFakeFd_out.prototype.length = function() {
        return 0;
      };
      MlFakeFd_out.prototype.write = function(offset, buf, pos, len) {
        if (this.log) {
          if (len > 0 && pos >= 0 && pos + len <= buf.length && buf[pos + len - 1] == 10)
            len--;
          var src = caml_create_bytes(len);
          caml_blit_bytes(caml_bytes_of_array(buf), pos, src, 0, len);
          this.log(src.toUtf16());
          return 0;
        }
        caml_raise_sys_error(this.fd + ": file descriptor already closed");
      };
      MlFakeFd_out.prototype.read = function(offset, buf, pos, len) {
        caml_raise_sys_error(this.fd + ": file descriptor is write only");
      };
      MlFakeFd_out.prototype.close = function() {
        this.log = void 0;
      };
      function caml_sys_open_internal(file, idx) {
        if (idx == void 0)
          idx = caml_sys_fds.length;
        caml_sys_fds[idx] = file;
        return idx | 0;
      }
      function caml_sys_open(name, flags, _perms) {
        var f = {};
        while (flags) {
          switch (flags[1]) {
            case 0:
              f.rdonly = 1;
              break;
            case 1:
              f.wronly = 1;
              break;
            case 2:
              f.append = 1;
              break;
            case 3:
              f.create = 1;
              break;
            case 4:
              f.truncate = 1;
              break;
            case 5:
              f.excl = 1;
              break;
            case 6:
              f.binary = 1;
              break;
            case 7:
              f.text = 1;
              break;
            case 8:
              f.nonblock = 1;
              break;
          }
          flags = flags[2];
        }
        if (f.rdonly && f.wronly)
          caml_raise_sys_error(caml_jsbytes_of_string(name) + " : flags Open_rdonly and Open_wronly are not compatible");
        if (f.text && f.binary)
          caml_raise_sys_error(caml_jsbytes_of_string(name) + " : flags Open_text and Open_binary are not compatible");
        var root = resolve_fs_device(name), file = root.device.open(root.rest, f);
        return caml_sys_open_internal(file, void 0);
      }
      (function() {
        function file(fd, flags) {
          return fs_node_supported() ? caml_sys_open_for_node(fd, flags) : new MlFakeFd_out(fd, flags);
        }
        caml_sys_open_internal(
          file(0, { rdonly: 1, altname: "/dev/stdin", isCharacterDevice: true }),
          0
        );
        caml_sys_open_internal(file(1, { buffered: 2, wronly: 1, isCharacterDevice: true }), 1);
        caml_sys_open_internal(file(2, { buffered: 2, wronly: 1, isCharacterDevice: true }), 2);
      })();
      function caml_string_get(s2, i) {
        if (i >>> 0 >= caml_ml_string_length(s2))
          caml_string_bound_error();
        return caml_string_unsafe_get(s2, i);
      }
      var re_match = /* @__PURE__ */ function() {
        var re_word_letters = [
          0,
          0,
          0,
          0,
          0,
          0,
          255,
          3,
          254,
          255,
          255,
          135,
          254,
          255,
          255,
          7,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          255,
          255,
          127,
          255,
          255,
          255,
          127,
          255
        ], opcodes = {
          CHAR: 0,
          CHARNORM: 1,
          STRING: 2,
          STRINGNORM: 3,
          CHARCLASS: 4,
          BOL: 5,
          EOL: 6,
          WORDBOUNDARY: 7,
          BEGGROUP: 8,
          ENDGROUP: 9,
          REFGROUP: 10,
          ACCEPT: 11,
          SIMPLEOPT: 12,
          SIMPLESTAR: 13,
          SIMPLEPLUS: 14,
          GOTO: 15,
          PUSHBACK: 16,
          SETMARK: 17,
          CHECKPROGRESS: 18
        };
        function is_word_letter(c) {
          return re_word_letters[c >> 3] >> (c & 7) & 1;
        }
        function in_bitset(s2, i) {
          return caml_string_get(s2, i >> 3) >> (i & 7) & 1;
        }
        function re_match_impl(re, s2, pos, partial) {
          var prog = caml_js_from_array(re[1]), cpool = caml_js_from_array(re[2]), normtable = caml_jsbytes_of_string(re[3]), numgroups = re[4] | 0, numregisters = re[5] | 0, startchars = re[6] | 0, s2 = caml_uint8_array_of_string(s2), pc = 0, quit = false, stack = [], groups = new Array(numgroups), re_register = new Array(numregisters);
          for (var i = 0; i < groups.length; i++)
            groups[i] = { start: -1, end: -1 };
          groups[0].start = pos;
          function backtrack() {
            while (stack.length) {
              var item = stack.pop();
              if (item.undo)
                item.undo.obj[item.undo.prop] = item.undo.value;
              else if (item.pos) {
                pc = item.pos.pc;
                pos = item.pos.txt;
                return;
              }
            }
            quit = true;
          }
          function push(item) {
            stack.push(item);
          }
          function accept() {
            groups[0].end = pos;
            var result = new Array(1 + groups.length * 2);
            result[0] = 0;
            for (var i2 = 0; i2 < groups.length; i2++) {
              var g = groups[i2];
              if (g.start < 0 || g.end < 0)
                g.start = g.end = -1;
              result[2 * i2 + 1] = g.start;
              result[2 * i2 + 1 + 1] = g.end;
            }
            return result;
          }
          function prefix_match() {
            if (partial)
              return accept();
            else
              backtrack();
          }
          while (!quit) {
            var op = prog[pc] & 255, sarg = prog[pc] >> 8, uarg = sarg & 255, c = s2[pos], group;
            pc++;
            switch (op) {
              case opcodes.CHAR:
                if (pos === s2.length) {
                  prefix_match();
                  break;
                }
                if (c === uarg)
                  pos++;
                else
                  backtrack();
                break;
              case opcodes.CHARNORM:
                if (pos === s2.length) {
                  prefix_match();
                  break;
                }
                if (normtable.charCodeAt(c) === uarg)
                  pos++;
                else
                  backtrack();
                break;
              case opcodes.STRING:
                for (var arg = caml_jsbytes_of_string(cpool[uarg]), i = 0; i < arg.length; i++) {
                  if (pos === s2.length) {
                    prefix_match();
                    break;
                  }
                  if (c === arg.charCodeAt(i))
                    c = s2[++pos];
                  else {
                    backtrack();
                    break;
                  }
                }
                break;
              case opcodes.STRINGNORM:
                for (var arg = caml_jsbytes_of_string(cpool[uarg]), i = 0; i < arg.length; i++) {
                  if (pos === s2.length) {
                    prefix_match();
                    break;
                  }
                  if (normtable.charCodeAt(c) === arg.charCodeAt(i))
                    c = s2[++pos];
                  else {
                    backtrack();
                    break;
                  }
                }
                break;
              case opcodes.CHARCLASS:
                if (pos === s2.length) {
                  prefix_match();
                  break;
                }
                if (in_bitset(cpool[uarg], c))
                  pos++;
                else
                  backtrack();
                break;
              case opcodes.BOL:
                if (pos > 0 && s2[pos - 1] != 10)
                  backtrack();
                break;
              case opcodes.EOL:
                if (pos < s2.length && s2[pos] != 10)
                  backtrack();
                break;
              case opcodes.WORDBOUNDARY:
                if (pos == 0) {
                  if (pos === s2.length) {
                    prefix_match();
                    break;
                  }
                  if (is_word_letter(s2[0]))
                    break;
                  backtrack();
                } else if (pos === s2.length) {
                  if (is_word_letter(s2[pos - 1]))
                    break;
                  backtrack();
                } else {
                  if (is_word_letter(s2[pos - 1]) != is_word_letter(s2[pos]))
                    break;
                  backtrack();
                }
                break;
              case opcodes.BEGGROUP:
                group = groups[uarg];
                push({ undo: { obj: group, prop: "start", value: group.start } });
                group.start = pos;
                break;
              case opcodes.ENDGROUP:
                group = groups[uarg];
                push({ undo: { obj: group, prop: "end", value: group.end } });
                group.end = pos;
                break;
              case opcodes.REFGROUP:
                group = groups[uarg];
                if (group.start < 0 || group.end < 0) {
                  backtrack();
                  break;
                }
                for (var i = group.start; i < group.end; i++) {
                  if (pos === s2.length) {
                    prefix_match();
                    break;
                  }
                  if (s2[i] != s2[pos]) {
                    backtrack();
                    break;
                  }
                  pos++;
                }
                break;
              case opcodes.SIMPLEOPT:
                if (in_bitset(cpool[uarg], c))
                  pos++;
                break;
              case opcodes.SIMPLESTAR:
                while (in_bitset(cpool[uarg], c))
                  c = s2[++pos];
                break;
              case opcodes.SIMPLEPLUS:
                if (pos === s2.length) {
                  prefix_match();
                  break;
                }
                if (in_bitset(cpool[uarg], c))
                  do
                    c = s2[++pos];
                  while (in_bitset(cpool[uarg], c));
                else
                  backtrack();
                break;
              case opcodes.ACCEPT:
                return accept();
              case opcodes.GOTO:
                pc = pc + sarg;
                break;
              case opcodes.PUSHBACK:
                push({ pos: { pc: pc + sarg, txt: pos } });
                break;
              case opcodes.SETMARK:
                push({ undo: { obj: re_register, prop: uarg, value: re_register[uarg] } });
                re_register[uarg] = pos;
                break;
              case opcodes.CHECKPROGRESS:
                if (re_register[uarg] === pos)
                  backtrack();
                break;
              default:
                throw new Error("Invalid bytecode");
            }
          }
          return 0;
        }
        return re_match_impl;
      }();
      function re_search_backward(re, s2, pos) {
        if (pos < 0 || pos > caml_ml_string_length(s2))
          caml_invalid_argument("Str.search_backward");
        while (pos >= 0) {
          var res = re_match(re, s2, pos, 0);
          if (res)
            return res;
          pos--;
        }
        return [0];
      }
      function caml_js_from_string(s2) {
        return caml_jsstring_of_string(s2);
      }
      function caml_ml_output_ta(chanid, buffer, offset, len) {
        var chan = caml_ml_channels[chanid];
        if (!chan.opened)
          caml_raise_sys_error("Cannot output to a closed channel");
        buffer = buffer.subarray(offset, offset + len);
        if (chan.buffer_curr + buffer.length > chan.buffer.length) {
          var b = new Uint8Array(chan.buffer_curr + buffer.length);
          b.set(chan.buffer);
          chan.buffer = b;
        }
        switch (chan.buffered) {
          case 0:
            chan.buffer.set(buffer, chan.buffer_curr);
            chan.buffer_curr += buffer.length;
            caml_ml_flush(chanid);
            break;
          case 1:
            chan.buffer.set(buffer, chan.buffer_curr);
            chan.buffer_curr += buffer.length;
            if (chan.buffer_curr >= chan.buffer.length)
              caml_ml_flush(chanid);
            break;
          case 2:
            var id = buffer.lastIndexOf(10);
            if (id < 0) {
              chan.buffer.set(buffer, chan.buffer_curr);
              chan.buffer_curr += buffer.length;
              if (chan.buffer_curr >= chan.buffer.length)
                caml_ml_flush(chanid);
            } else {
              chan.buffer.set(buffer.subarray(0, id + 1), chan.buffer_curr);
              chan.buffer_curr += id + 1;
              caml_ml_flush(chanid);
              chan.buffer.set(buffer.subarray(id + 1), chan.buffer_curr);
              chan.buffer_curr += buffer.length - id - 1;
            }
            break;
        }
        return 0;
      }
      function caml_ba_sub(ba, ofs, len) {
        var changed_dim, mul = 1;
        if (ba.layout == 0) {
          for (var i = 1; i < ba.dims.length; i++)
            mul = mul * ba.dims[i];
          changed_dim = 0;
        } else {
          for (var i = 0; i < ba.dims.length - 1; i++)
            mul = mul * ba.dims[i];
          changed_dim = ba.dims.length - 1;
          ofs = ofs - 1;
        }
        if (ofs < 0 || len < 0 || ofs + len > ba.dims[changed_dim])
          caml_invalid_argument("Bigarray.sub: bad sub-array");
        var new_dims = [];
        for (var i = 0; i < ba.dims.length; i++)
          new_dims[i] = ba.dims[i];
        new_dims[changed_dim] = len;
        mul *= caml_ba_get_size_per_element(ba.kind);
        var new_data = ba.data.subarray(ofs * mul, (ofs + len) * mul);
        return caml_ba_create_unsafe(ba.kind, ba.layout, new_dims, new_data);
      }
      function caml_gc_full_major(unit) {
        if (typeof globalThis.gc == "function")
          globalThis.gc();
        return 0;
      }
      function caml_ml_mutex_try_lock(t) {
        if (!t.locked) {
          t.locked = true;
          return 1;
        }
        return 0;
      }
      function caml_bytes_set32(s2, i, i32) {
        if (i >>> 0 >= s2.l - 3)
          caml_bytes_bound_error();
        var b4 = 255 & i32 >> 24, b3 = 255 & i32 >> 16, b2 = 255 & i32 >> 8, b1 = 255 & i32;
        caml_bytes_unsafe_set(s2, i + 0, b1);
        caml_bytes_unsafe_set(s2, i + 1, b2);
        caml_bytes_unsafe_set(s2, i + 2, b3);
        caml_bytes_unsafe_set(s2, i + 3, b4);
        return 0;
      }
      function caml_gr_sigio_signal() {
        return 0;
      }
      function caml_ba_uint8_set32(ba, i0, v) {
        var ofs = ba.offset(i0);
        if (ofs + 3 >= ba.data.length)
          caml_array_bound_error();
        ba.set(ofs + 0, v & 255);
        ba.set(ofs + 1, v >>> 8 & 255);
        ba.set(ofs + 2, v >>> 16 & 255);
        ba.set(ofs + 3, v >>> 24 & 255);
        return 0;
      }
      function caml_sys_const_ostype_unix() {
        return os_type == "Unix" ? 1 : 0;
      }
      function caml_unix_gmtime(t) {
        var d = new Date(t * 1e3), d_num = d.getTime(), januaryfirst = new Date(Date.UTC(d.getUTCFullYear(), 0, 1)).getTime(), doy = Math.floor((d_num - januaryfirst) / 864e5);
        return [
          0,
          d.getUTCSeconds(),
          d.getUTCMinutes(),
          d.getUTCHours(),
          d.getUTCDate(),
          d.getUTCMonth(),
          d.getUTCFullYear() - 1900,
          d.getUTCDay(),
          doy,
          false | 0
        ];
      }
      function caml_signbit_float(x2) {
        if (x2 == 0)
          x2 = 1 / x2;
        return x2 < 0 ? 1 : 0;
      }
      function caml_gr_current_x() {
        var s2 = caml_gr_state_get();
        return s2.x;
      }
      function caml_gr_set_line_width(w) {
        var s2 = caml_gr_state_get();
        s2.line_width = w;
        s2.context.lineWidth = w;
        return 0;
      }
      function caml_gr_set_font(f) {
        var s2 = caml_gr_state_get();
        s2.font = f;
        s2.context.font = s2.text_size + "px " + caml_jsstring_of_string(s2.font);
        return 0;
      }
      function caml_gr_set_color(color) {
        var s2 = caml_gr_state_get();
        function convert(number) {
          var str = "" + number.toString(16);
          while (str.length < 2)
            str = "0" + str;
          return str;
        }
        var r = color >> 16 & 255, g = color >> 8 & 255, b = color >> 0 & 255;
        s2.color = color;
        var c_str = "#" + convert(r) + convert(g) + convert(b);
        s2.context.fillStyle = c_str;
        s2.context.strokeStyle = c_str;
        return 0;
      }
      function caml_gr_moveto(x2, y) {
        var s2 = caml_gr_state_get();
        s2.x = x2;
        s2.y = y;
        return 0;
      }
      function caml_gr_resize_window(w, h) {
        var s2 = caml_gr_state_get();
        s2.width = w;
        s2.height = h;
        s2.canvas.width = w;
        s2.canvas.height = h;
        return 0;
      }
      function caml_gr_state_init() {
        caml_gr_moveto(caml_gr_state.x, caml_gr_state.y);
        caml_gr_resize_window(caml_gr_state.width, caml_gr_state.height);
        caml_gr_set_line_width(caml_gr_state.line_width);
        caml_gr_set_text_size(caml_gr_state.text_size);
        caml_gr_set_font(caml_gr_state.font);
        caml_gr_set_color(caml_gr_state.color);
        caml_gr_set_window_title(caml_gr_state.title);
        caml_gr_state.context.textBaseline = "bottom";
      }
      function caml_ba_kind_of_typed_array(ta) {
        var kind;
        if (ta instanceof Float32Array)
          kind = 0;
        else if (ta instanceof Float64Array)
          kind = 1;
        else if (ta instanceof Int8Array)
          kind = 2;
        else if (ta instanceof Uint8Array)
          kind = 3;
        else if (ta instanceof Uint8ClampedArray)
          kind = 3;
        else if (ta instanceof Int16Array)
          kind = 4;
        else if (ta instanceof Uint16Array)
          kind = 5;
        else if (ta instanceof Int32Array)
          kind = 6;
        else if (ta instanceof Uint32Array)
          kind = 6;
        else
          caml_invalid_argument("caml_ba_kind_of_typed_array: unsupported kind");
        return kind;
      }
      function caml_ba_from_typed_array(ta) {
        var kind = caml_ba_kind_of_typed_array(ta), ta = ta instanceof Uint32Array ? new Int32Array(ta.buffer, ta.byteOffset, ta.length) : ta;
        return caml_ba_create_unsafe(kind, 0, [ta.length], ta);
      }
      function caml_ml_seek_out(chanid, pos) {
        return caml_seek_out(chanid, pos);
      }
      function caml_js_typeof(o) {
        return typeof o;
      }
      function caml_hash_mix_string(h, v) {
        return caml_hash_mix_jsbytes(h, caml_jsbytes_of_string(v));
      }
      function caml_string_hash(h, v) {
        var h = caml_hash_mix_string(h, v), h = caml_hash_mix_final(h);
        return h & 1073741823;
      }
      function caml_restore_raw_backtrace(exn, bt) {
        return 0;
      }
      function caml_gr_lineto(x2, y) {
        var s2 = caml_gr_state_get();
        s2.context.beginPath();
        s2.context.moveTo(s2.x, s2.height - s2.y);
        s2.context.lineTo(x2, s2.height - y);
        s2.context.stroke();
        s2.x = x2;
        s2.y = y;
        return 0;
      }
      function caml_js_function_arity(f) {
        return f.l >= 0 ? f.l : f.l = f.length;
      }
      function caml_js_wrap_meth_callback_unsafe(f) {
        return function() {
          var len = caml_js_function_arity(f) - 1, args = new Array(len + 1);
          args[0] = this;
          for (var i = 0; i < len; i++)
            args[i + 1] = arguments[i];
          return caml_callback(f, args);
        };
      }
      function caml_ba_dim_3(ba) {
        return caml_ba_dim(ba, 2);
      }
      function caml_is_special_exception(exn) {
        switch (exn[2]) {
          case -8:
          case -11:
          case -12:
            return 1;
          default:
            return 0;
        }
      }
      function caml_format_exception(exn) {
        var r = "";
        if (exn[0] == 0) {
          r += exn[1][1];
          if (exn.length == 3 && exn[2][0] == 0 && caml_is_special_exception(exn[1]))
            var bucket = exn[2], start = 1;
          else
            var start = 2, bucket = exn;
          r += "(";
          for (var i = start; i < bucket.length; i++) {
            if (i > start)
              r += ", ";
            var v = bucket[i];
            if (typeof v == "number")
              r += v.toString();
            else if (v instanceof MlBytes)
              r += '"' + v.toString() + '"';
            else if (typeof v == "string")
              r += '"' + v.toString() + '"';
            else
              r += "_";
          }
          r += ")";
        } else if (exn[0] == 248)
          r += exn[1];
        return r;
      }
      function caml_fatal_uncaught_exception(err) {
        if (err instanceof Array && (err[0] == 0 || err[0] == 248)) {
          var handler = caml_named_value("Printexc.handle_uncaught_exception");
          if (handler)
            caml_callback(handler, [err, false]);
          else {
            var msg = caml_format_exception(err), at_exit = caml_named_value("Pervasives.do_at_exit");
            if (at_exit)
              caml_callback(at_exit, [0]);
            console.error("Fatal error: exception " + msg);
            if (err.js_error)
              throw err.js_error;
          }
        } else
          throw err;
      }
      function caml_ephe_check_data(x2) {
        return x2[caml_ephe_data_offset] === void 0 ? 0 : 1;
      }
      function caml_bytes_get16(s2, i) {
        if (i >>> 0 >= s2.l - 1)
          caml_bytes_bound_error();
        var b1 = caml_bytes_unsafe_get(s2, i), b2 = caml_bytes_unsafe_get(s2, i + 1);
        return b2 << 8 | b1;
      }
      function caml_obj_make_forward(b, v) {
        b[0] = 250;
        b[1] = v;
        return 0;
      }
      function caml_js_from_bool(x2) {
        return !!x2;
      }
      function caml_ml_set_channel_name(chanid, name) {
        var chan = caml_ml_channels[chanid];
        chan.name = name;
        return 0;
      }
      function caml_exp2_float(x2) {
        return Math.pow(2, x2);
      }
      function caml_gr_close_graph() {
        var s2 = caml_gr_state_get();
        s2.canvas.width = 0;
        s2.canvas.height = 0;
        return 0;
      }
      function caml_ml_domain_cpu_relax(unit) {
        return 0;
      }
      function caml_create_string(len) {
        caml_invalid_argument("String.create");
      }
      function caml_md5_chan(chanid, toread) {
        var ctx = caml_MD5Init(), buffer = new Uint8Array(4096);
        if (toread < 0)
          while (true) {
            var read = caml_ml_input_block(chanid, buffer, 0, buffer.length);
            if (read == 0)
              break;
            caml_MD5Update(ctx, buffer.subarray(0, read), read);
          }
        else
          while (toread > 0) {
            var read = caml_ml_input_block(chanid, buffer, 0, toread > buffer.length ? buffer.length : toread);
            if (read == 0)
              caml_raise_end_of_file();
            caml_MD5Update(ctx, buffer.subarray(0, read), read);
            toread -= read;
          }
        return caml_string_of_array(caml_MD5Final(ctx));
      }
      function caml_atanh_float(x2) {
        return Math.atanh(x2);
      }
      function caml_ml_condition_signal(t) {
        return 0;
      }
      function caml_unix_findnext(dir_handle) {
        return caml_unix_readdir(dir_handle);
      }
      function caml_ml_output_bytes(chanid, buffer, offset, len) {
        var buffer = caml_uint8_array_of_bytes(buffer);
        return caml_ml_output_ta(chanid, buffer, offset, len);
      }
      function caml_ml_output(chanid, buffer, offset, len) {
        return caml_ml_output_bytes(chanid, caml_bytes_of_string(buffer), offset, len);
      }
      function caml_ml_domain_id(unit) {
        return caml_domain_id;
      }
      function caml_ephe_get_data(x2) {
        return x2[caml_ephe_data_offset] === void 0 ? 0 : [0, x2[caml_ephe_data_offset]];
      }
      function caml_xmlhttprequest_create(unit) {
        if (typeof globalThis.XMLHttpRequest !== "undefined")
          try {
            return new globalThis.XMLHttpRequest();
          } catch (e) {
          }
        if (typeof globalThis.activeXObject !== "undefined") {
          try {
            return new globalThis.activeXObject("Msxml2.XMLHTTP");
          } catch (e) {
          }
          try {
            return new globalThis.activeXObject("Msxml3.XMLHTTP");
          } catch (e) {
          }
          try {
            return new globalThis.activeXObject("Microsoft.XMLHTTP");
          } catch (e) {
          }
        }
        caml_failwith("Cannot create a XMLHttpRequest");
      }
      function caml_trampoline_return(f, args) {
        return { joo_tramp: f, joo_args: args };
      }
      function caml_ml_is_buffered(chanid) {
        return caml_ml_channels[chanid].buffered ? 1 : 0;
      }
      function caml_array_append(a1, a2) {
        var l1 = a1.length, l2 = a2.length, l = l1 + l2 - 1, a = new Array(l);
        a[0] = 0;
        var i = 1, j = 1;
        for (; i < l1; i++)
          a[i] = a1[i];
        for (; i < l; i++, j++)
          a[i] = a2[j];
        return a;
      }
      function caml_unix_gettimeofday() {
        return (/* @__PURE__ */ new Date()).getTime() / 1e3;
      }
      function caml_unix_time() {
        return Math.floor(caml_unix_gettimeofday());
      }
      function caml_ml_set_channel_refill(chanid, f) {
        caml_ml_channels[chanid].refill = f;
        return 0;
      }
      function caml_runtime_events_create_cursor(target) {
        return {};
      }
      function caml_fill_bytes(s2, i, l, c) {
        if (l > 0)
          if (i == 0 && (l >= s2.l || s2.t == 2 && l >= s2.c.length))
            if (c == 0) {
              s2.c = "";
              s2.t = 2;
            } else {
              s2.c = caml_str_repeat(l, String.fromCharCode(c));
              s2.t = l == s2.l ? 0 : 2;
            }
          else {
            if (s2.t != 4)
              caml_convert_bytes_to_array(s2);
            for (l += i; i < l; i++)
              s2.c[i] = c;
          }
        return 0;
      }
      function caml_js_expr(s) {
        console.error("caml_js_expr: fallback to runtime evaluation\n");
        return eval(caml_jsstring_of_string(s));
      }
      function caml_ml_runtime_warnings_enabled(_unit) {
        return caml_runtime_warnings;
      }
      function caml_output_value_to_bytes(v, flags) {
        return caml_bytes_of_array(caml_output_val(v, flags));
      }
      function caml_eventlog_resume(unit) {
        return 0;
      }
      function caml_md5_string(s2, ofs, len) {
        return caml_md5_bytes(caml_bytes_of_string(s2), ofs, len);
      }
      function caml_array_of_string(x2) {
        return caml_uint8_array_of_string(x2);
      }
      function caml_string_equal(s1, s2) {
        if (s1 === s2)
          return 1;
        return 0;
      }
      function caml_jsoo_flags_use_js_string(unit) {
        return 1;
      }
      var zstd_decompress = function() {
        "use strict";
        var ab = ArrayBuffer, u8 = Uint8Array, u16 = Uint16Array, i16 = Int16Array, u32 = Uint32Array, i32 = Int32Array;
        function slc(v, s2, e) {
          if (u8.prototype.slice)
            return u8.prototype.slice.call(v, s2, e);
          if (s2 == null || s2 < 0)
            s2 = 0;
          if (e == null || e > v.length)
            e = v.length;
          var n = new u8(e - s2);
          n.set(v.subarray(s2, e));
          return n;
        }
        function fill(v, n, s2, e) {
          if (u8.prototype.fill)
            return u8.prototype.fill.call(v, n, s2, e);
          if (s2 == null || s2 < 0)
            s2 = 0;
          if (e == null || e > v.length)
            e = v.length;
          for (; s2 < e; ++s2)
            v[s2] = n;
          return v;
        }
        function cpw(v, t, s2, e) {
          if (u8.prototype.copyWithin)
            return u8.prototype.copyWithin.call(v, t, s2, e);
          if (s2 == null || s2 < 0)
            s2 = 0;
          if (e == null || e > v.length)
            e = v.length;
          while (s2 < e)
            v[t++] = v[s2++];
        }
        var ec = [
          "invalid zstd data",
          "window size too large (>2046MB)",
          "invalid block type",
          "FSE accuracy too high",
          "match distance too far back",
          "unexpected EOF"
        ];
        function err(ind, msg, nt) {
          var e = new Error(msg || ec[ind]);
          e.code = ind;
          if (!nt)
            throw e;
          return e;
        }
        function rb(d, b, n) {
          var i = 0, o = 0;
          for (; i < n; ++i)
            o |= d[b++] << (i << 3);
          return o;
        }
        function b4(d, b) {
          return (d[b] | d[b + 1] << 8 | d[b + 2] << 16 | d[b + 3] << 24) >>> 0;
        }
        function rzfh(dat, w) {
          var n3 = dat[0] | dat[1] << 8 | dat[2] << 16;
          if (n3 == 3126568 && dat[3] == 253) {
            var flg = dat[4], ss = flg >> 5 & 1, cc = flg >> 2 & 1, df = flg & 3, fcf = flg >> 6;
            if (flg & 8)
              err(0);
            var bt = 6 - ss, db = df == 3 ? 4 : df, di = rb(dat, bt, db);
            bt += db;
            var fsb = fcf ? 1 << fcf : ss, fss = rb(dat, bt, fsb) + (fcf == 1 && 256), ws = fss;
            if (!ss) {
              var wb = 1 << 10 + (dat[5] >> 3);
              ws = wb + (wb >> 3) * (dat[5] & 7);
            }
            if (ws > 2145386496)
              err(1);
            var buf = new u8((w == 1 ? fss || ws : w ? 0 : ws) + 12);
            buf[0] = 1, buf[4] = 4, buf[8] = 8;
            return {
              b: bt + fsb,
              y: 0,
              l: 0,
              d: di,
              w: w && w != 1 ? w : buf.subarray(12),
              e: ws,
              o: new i32(buf.buffer, 0, 3),
              u: fss,
              c: cc,
              m: Math.min(131072, ws)
            };
          } else if ((n3 >> 4 | dat[3] << 20) == 25481893)
            return b4(dat, 4) + 8;
          err(0);
        }
        function msb(val) {
          var bits = 0;
          for (; 1 << bits <= val; ++bits)
            ;
          return bits - 1;
        }
        function rfse(dat, bt, mal) {
          var tpos = (bt << 3) + 4, al = (dat[bt] & 15) + 5;
          if (al > mal)
            err(3);
          var sz = 1 << al, probs = sz, sym = -1, re = -1, i = -1, ht = sz, buf = new ab(512 + (sz << 2)), freq = new i16(buf, 0, 256), dstate = new u16(buf, 0, 256), nstate = new u16(buf, 512, sz), bb1 = 512 + (sz << 1), syms = new u8(buf, bb1, sz), nbits = new u8(buf, bb1 + sz);
          while (sym < 255 && probs > 0) {
            var bits = msb(probs + 1), cbt = tpos >> 3, msk = (1 << bits + 1) - 1, val = (dat[cbt] | dat[cbt + 1] << 8 | dat[cbt + 2] << 16) >> (tpos & 7) & msk, msk1fb = (1 << bits) - 1, msv = msk - probs - 1, sval = val & msk1fb;
            if (sval < msv)
              tpos += bits, val = sval;
            else {
              tpos += bits + 1;
              if (val > msk1fb)
                val -= msv;
            }
            freq[++sym] = --val;
            if (val == -1) {
              probs += val;
              syms[--ht] = sym;
            } else
              probs -= val;
            if (!val)
              do {
                var rbt = tpos >> 3;
                re = (dat[rbt] | dat[rbt + 1] << 8) >> (tpos & 7) & 3;
                tpos += 2;
                sym += re;
              } while (re == 3);
          }
          if (sym > 255 || probs)
            err(0);
          var sympos = 0, sstep = (sz >> 1) + (sz >> 3) + 3, smask = sz - 1;
          for (var s2 = 0; s2 <= sym; ++s2) {
            var sf = freq[s2];
            if (sf < 1) {
              dstate[s2] = -sf;
              continue;
            }
            for (i = 0; i < sf; ++i) {
              syms[sympos] = s2;
              do
                sympos = sympos + sstep & smask;
              while (sympos >= ht);
            }
          }
          if (sympos)
            err(0);
          for (i = 0; i < sz; ++i) {
            var ns = dstate[syms[i]]++, nb = nbits[i] = al - msb(ns);
            nstate[i] = (ns << nb) - sz;
          }
          return [tpos + 7 >> 3, { b: al, s: syms, n: nbits, t: nstate }];
        }
        function rhu(dat, bt) {
          var i = 0, wc = -1, buf = new u8(292), hb = dat[bt], hw = buf.subarray(0, 256), rc = buf.subarray(256, 268), ri = new u16(buf.buffer, 268);
          if (hb < 128) {
            var _a = rfse(dat, bt + 1, 6), ebt = _a[0], fdt = _a[1];
            bt += hb;
            var epos = ebt << 3, lb = dat[bt];
            if (!lb)
              err(0);
            var st1 = 0, st2 = 0, btr1 = fdt.b, btr2 = btr1, fpos = (++bt << 3) - 8 + msb(lb);
            for (; ; ) {
              fpos -= btr1;
              if (fpos < epos)
                break;
              var cbt = fpos >> 3;
              st1 += (dat[cbt] | dat[cbt + 1] << 8) >> (fpos & 7) & (1 << btr1) - 1;
              hw[++wc] = fdt.s[st1];
              fpos -= btr2;
              if (fpos < epos)
                break;
              cbt = fpos >> 3;
              st2 += (dat[cbt] | dat[cbt + 1] << 8) >> (fpos & 7) & (1 << btr2) - 1;
              hw[++wc] = fdt.s[st2];
              btr1 = fdt.n[st1];
              st1 = fdt.t[st1];
              btr2 = fdt.n[st2];
              st2 = fdt.t[st2];
            }
            if (++wc > 255)
              err(0);
          } else {
            wc = hb - 127;
            for (; i < wc; i += 2) {
              var byte = dat[++bt];
              hw[i] = byte >> 4;
              hw[i + 1] = byte & 15;
            }
            ++bt;
          }
          var wes = 0;
          for (i = 0; i < wc; ++i) {
            var wt = hw[i];
            if (wt > 11)
              err(0);
            wes += wt && 1 << wt - 1;
          }
          var mb = msb(wes) + 1, ts = 1 << mb, rem = ts - wes;
          if (rem & rem - 1)
            err(0);
          hw[wc++] = msb(rem) + 1;
          for (i = 0; i < wc; ++i) {
            var wt = hw[i];
            ++rc[hw[i] = wt && mb + 1 - wt];
          }
          var hbuf = new u8(ts << 1), syms = hbuf.subarray(0, ts), nb = hbuf.subarray(ts);
          ri[mb] = 0;
          for (i = mb; i > 0; --i) {
            var pv = ri[i];
            fill(nb, i, pv, ri[i - 1] = pv + rc[i] * (1 << mb - i));
          }
          if (ri[0] != ts)
            err(0);
          for (i = 0; i < wc; ++i) {
            var bits = hw[i];
            if (bits) {
              var code = ri[bits];
              fill(syms, i, code, ri[bits] = code + (1 << mb - bits));
            }
          }
          return [bt, { n: nb, b: mb, s: syms }];
        }
        var dllt = rfse(
          new u8([
            81,
            16,
            99,
            140,
            49,
            198,
            24,
            99,
            12,
            33,
            196,
            24,
            99,
            102,
            102,
            134,
            70,
            146,
            4
          ]),
          0,
          6
        )[1], dmlt = rfse(
          new u8([
            33,
            20,
            196,
            24,
            99,
            140,
            33,
            132,
            16,
            66,
            8,
            33,
            132,
            16,
            66,
            8,
            33,
            68,
            68,
            68,
            68,
            68,
            68,
            68,
            68,
            36,
            9
          ]),
          0,
          6
        )[1], doct = rfse(
          new u8([32, 132, 16, 66, 102, 70, 68, 68, 68, 68, 36, 73, 2]),
          0,
          5
        )[1];
        function b2bl(b, s2) {
          var len = b.length, bl = new i32(len);
          for (var i = 0; i < len; ++i) {
            bl[i] = s2;
            s2 += 1 << b[i];
          }
          return bl;
        }
        var llb = new u8(
          new i32([
            0,
            0,
            0,
            0,
            16843009,
            50528770,
            134678020,
            202050057,
            269422093
          ]).buffer,
          0,
          36
        ), llbl = b2bl(llb, 0), mlb = new u8(
          new i32([
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            16843009,
            50528770,
            117769220,
            185207048,
            252579084,
            16
          ]).buffer,
          0,
          53
        ), mlbl = b2bl(mlb, 3);
        function dhu(dat, out, hu) {
          var len = dat.length, ss = out.length, lb = dat[len - 1], msk = (1 << hu.b) - 1, eb = -hu.b;
          if (!lb)
            err(0);
          var st = 0, btr = hu.b, pos = (len << 3) - 8 + msb(lb) - btr, i = -1;
          for (; pos > eb && i < ss; ) {
            var cbt = pos >> 3, val = (dat[cbt] | dat[cbt + 1] << 8 | dat[cbt + 2] << 16) >> (pos & 7);
            st = (st << btr | val) & msk;
            out[++i] = hu.s[st];
            pos -= btr = hu.n[st];
          }
          if (pos != eb || i + 1 != ss)
            err(0);
        }
        function dhu4(dat, out, hu) {
          var bt = 6, ss = out.length, sz1 = ss + 3 >> 2, sz2 = sz1 << 1, sz3 = sz1 + sz2;
          dhu(
            dat.subarray(bt, bt += dat[0] | dat[1] << 8),
            out.subarray(0, sz1),
            hu
          );
          dhu(
            dat.subarray(bt, bt += dat[2] | dat[3] << 8),
            out.subarray(sz1, sz2),
            hu
          );
          dhu(
            dat.subarray(bt, bt += dat[4] | dat[5] << 8),
            out.subarray(sz2, sz3),
            hu
          );
          dhu(dat.subarray(bt), out.subarray(sz3), hu);
        }
        function rzb(dat, st, out) {
          var _a, bt = st.b, b0 = dat[bt], btype = b0 >> 1 & 3;
          st.l = b0 & 1;
          var sz = b0 >> 3 | dat[bt + 1] << 5 | dat[bt + 2] << 13, ebt = (bt += 3) + sz;
          if (btype == 1) {
            if (bt >= dat.length)
              return;
            st.b = bt + 1;
            if (out) {
              fill(out, dat[bt], st.y, st.y += sz);
              return out;
            }
            return fill(new u8(sz), dat[bt]);
          }
          if (ebt > dat.length)
            return;
          if (btype == 0) {
            st.b = ebt;
            if (out) {
              out.set(dat.subarray(bt, ebt), st.y);
              st.y += sz;
              return out;
            }
            return slc(dat, bt, ebt);
          }
          if (btype == 2) {
            var b3 = dat[bt], lbt = b3 & 3, sf = b3 >> 2 & 3, lss = b3 >> 4, lcs = 0, s4 = 0;
            if (lbt < 2)
              if (sf & 1)
                lss |= dat[++bt] << 4 | (sf & 2 && dat[++bt] << 12);
              else
                lss = b3 >> 3;
            else {
              s4 = sf;
              if (sf < 2)
                lss |= (dat[++bt] & 63) << 4, lcs = dat[bt] >> 6 | dat[++bt] << 2;
              else if (sf == 2)
                lss |= dat[++bt] << 4 | (dat[++bt] & 3) << 12, lcs = dat[bt] >> 2 | dat[++bt] << 6;
              else
                lss |= dat[++bt] << 4 | (dat[++bt] & 63) << 12, lcs = dat[bt] >> 6 | dat[++bt] << 2 | dat[++bt] << 10;
            }
            ++bt;
            var buf = out ? out.subarray(st.y, st.y + st.m) : new u8(st.m), spl = buf.length - lss;
            if (lbt == 0)
              buf.set(dat.subarray(bt, bt += lss), spl);
            else if (lbt == 1)
              fill(buf, dat[bt++], spl);
            else {
              var hu = st.h;
              if (lbt == 2) {
                var hud = rhu(dat, bt);
                lcs += bt - (bt = hud[0]);
                st.h = hu = hud[1];
              } else if (!hu)
                err(0);
              (s4 ? dhu4 : dhu)(dat.subarray(bt, bt += lcs), buf.subarray(spl), hu);
            }
            var ns = dat[bt++];
            if (ns) {
              if (ns == 255)
                ns = (dat[bt++] | dat[bt++] << 8) + 32512;
              else if (ns > 127)
                ns = ns - 128 << 8 | dat[bt++];
              var scm = dat[bt++];
              if (scm & 3)
                err(0);
              var dts = [dmlt, doct, dllt];
              for (var i = 2; i > -1; --i) {
                var md = scm >> (i << 1) + 2 & 3;
                if (md == 1) {
                  var rbuf = new u8([0, 0, dat[bt++]]);
                  dts[i] = {
                    s: rbuf.subarray(2, 3),
                    n: rbuf.subarray(0, 1),
                    t: new u16(rbuf.buffer, 0, 1),
                    b: 0
                  };
                } else if (md == 2)
                  _a = rfse(dat, bt, 9 - (i & 1)), bt = _a[0], dts[i] = _a[1];
                else if (md == 3) {
                  if (!st.t)
                    err(0);
                  dts[i] = st.t[i];
                }
              }
              var _b = st.t = dts, mlt = _b[0], oct = _b[1], llt = _b[2], lb = dat[ebt - 1];
              if (!lb)
                err(0);
              var spos = (ebt << 3) - 8 + msb(lb) - llt.b, cbt = spos >> 3, oubt = 0, lst = (dat[cbt] | dat[cbt + 1] << 8) >> (spos & 7) & (1 << llt.b) - 1;
              cbt = (spos -= oct.b) >> 3;
              var ost = (dat[cbt] | dat[cbt + 1] << 8) >> (spos & 7) & (1 << oct.b) - 1;
              cbt = (spos -= mlt.b) >> 3;
              var mst = (dat[cbt] | dat[cbt + 1] << 8) >> (spos & 7) & (1 << mlt.b) - 1;
              for (++ns; --ns; ) {
                var llc = llt.s[lst], lbtr = llt.n[lst], mlc = mlt.s[mst], mbtr = mlt.n[mst], ofc = oct.s[ost], obtr = oct.n[ost];
                cbt = (spos -= ofc) >> 3;
                var ofp = 1 << ofc, off = ofp + ((dat[cbt] | dat[cbt + 1] << 8 | dat[cbt + 2] << 16 | dat[cbt + 3] << 24) >>> (spos & 7) & ofp - 1);
                cbt = (spos -= mlb[mlc]) >> 3;
                var ml = mlbl[mlc] + ((dat[cbt] | dat[cbt + 1] << 8 | dat[cbt + 2] << 16) >> (spos & 7) & (1 << mlb[mlc]) - 1);
                cbt = (spos -= llb[llc]) >> 3;
                var ll = llbl[llc] + ((dat[cbt] | dat[cbt + 1] << 8 | dat[cbt + 2] << 16) >> (spos & 7) & (1 << llb[llc]) - 1);
                cbt = (spos -= lbtr) >> 3;
                lst = llt.t[lst] + ((dat[cbt] | dat[cbt + 1] << 8) >> (spos & 7) & (1 << lbtr) - 1);
                cbt = (spos -= mbtr) >> 3;
                mst = mlt.t[mst] + ((dat[cbt] | dat[cbt + 1] << 8) >> (spos & 7) & (1 << mbtr) - 1);
                cbt = (spos -= obtr) >> 3;
                ost = oct.t[ost] + ((dat[cbt] | dat[cbt + 1] << 8) >> (spos & 7) & (1 << obtr) - 1);
                if (off > 3) {
                  st.o[2] = st.o[1];
                  st.o[1] = st.o[0];
                  st.o[0] = off -= 3;
                } else {
                  var idx = off - (ll != 0);
                  if (idx) {
                    off = idx == 3 ? st.o[0] - 1 : st.o[idx];
                    if (idx > 1)
                      st.o[2] = st.o[1];
                    st.o[1] = st.o[0];
                    st.o[0] = off;
                  } else
                    off = st.o[0];
                }
                for (var i = 0; i < ll; ++i)
                  buf[oubt + i] = buf[spl + i];
                oubt += ll, spl += ll;
                var stin = oubt - off;
                if (stin < 0) {
                  var len = -stin, bs = st.e + stin;
                  if (len > ml)
                    len = ml;
                  for (var i = 0; i < len; ++i)
                    buf[oubt + i] = st.w[bs + i];
                  oubt += len, ml -= len, stin = 0;
                }
                for (var i = 0; i < ml; ++i)
                  buf[oubt + i] = buf[stin + i];
                oubt += ml;
              }
              if (oubt != spl)
                while (spl < buf.length)
                  buf[oubt++] = buf[spl++];
              else
                oubt = buf.length;
              if (out)
                st.y += oubt;
              else
                buf = slc(buf, 0, oubt);
            } else if (out) {
              st.y += lss;
              if (spl)
                for (var i = 0; i < lss; ++i)
                  buf[i] = buf[spl + i];
            } else if (spl)
              buf = slc(buf, spl);
            st.b = ebt;
            return buf;
          }
          err(2);
        }
        function cct(bufs, ol) {
          if (bufs.length == 1)
            return bufs[0];
          var buf = new u8(ol);
          for (var i = 0, b = 0; i < bufs.length; ++i) {
            var chk = bufs[i];
            buf.set(chk, b);
            b += chk.length;
          }
          return buf;
        }
        return function(dat, buf) {
          var bt = 0, bufs = [], nb = +!buf, ol = 0;
          for (; dat.length; ) {
            var st = rzfh(dat, nb || buf);
            if (typeof st == "object") {
              if (nb) {
                buf = null;
                if (st.w.length == st.u) {
                  bufs.push(buf = st.w);
                  ol += st.u;
                }
              } else {
                bufs.push(buf);
                st.e = 0;
              }
              for (; !st.l; ) {
                var blk = rzb(dat, st, buf);
                if (!blk)
                  err(5);
                if (buf)
                  st.e = st.y;
                else {
                  bufs.push(blk);
                  ol += blk.length;
                  cpw(st.w, 0, blk.length);
                  st.w.set(blk, st.w.length - blk.length);
                }
              }
              bt = st.b + st.c * 4;
            } else
              bt = st;
            dat = dat.subarray(bt);
          }
          return cct(bufs, ol);
        };
      }();
      function caml_zstd_initialize(unit) {
        caml_decompress_input = zstd_decompress;
        return 1;
      }
      function caml_output_value_to_buffer(s2, ofs, len, v, flags) {
        var t = caml_output_val(v, flags);
        if (t.length > len)
          caml_failwith("Marshal.to_buffer: buffer overflow");
        caml_blit_bytes(t, 0, s2, ofs, t.length);
        return 0;
      }
      function re_replacement_text(repl, groups, orig) {
        var repl = caml_jsbytes_of_string(repl), len = repl.length, orig = caml_jsbytes_of_string(orig), res = "", n = 0, cur, start, end, c;
        while (n < len) {
          cur = repl.charAt(n++);
          if (cur != "\\")
            res += cur;
          else {
            if (n == len)
              caml_failwith("Str.replace: illegal backslash sequence");
            cur = repl.charAt(n++);
            switch (cur) {
              case "\\":
                res += cur;
                break;
              case "0":
              case "1":
              case "2":
              case "3":
              case "4":
              case "5":
              case "6":
              case "7":
              case "8":
              case "9":
                c = +cur;
                if (c * 2 >= groups.length - 1)
                  caml_failwith("Str.replace: reference to unmatched group");
                start = caml_array_get(groups, c * 2);
                end = caml_array_get(groups, c * 2 + 1);
                if (start == -1)
                  caml_failwith("Str.replace: reference to unmatched group");
                res += orig.slice(start, end);
                break;
              default:
                res += "\\" + cur;
            }
          }
        }
        return caml_string_of_jsbytes(res);
      }
      function caml_pure_js_expr(s) {
        console.error("caml_pure_js_expr: fallback to runtime evaluation\n");
        return eval(caml_jsstring_of_string(s));
      }
      function caml_blit_string(a, b, c, d, e) {
        caml_blit_bytes(caml_bytes_of_string(a), b, c, d, e);
        return 0;
      }
      function blit_nat(nat1, ofs1, nat2, ofs2, len) {
        for (var i = 0; i < len; i++)
          nat1.data[ofs1 + i] = nat2.data[ofs2 + i];
        return 0;
      }
      function caml_bigstring_blit_ba_to_bytes(ba1, pos1, bytes2, pos2, len) {
        if (12 != ba1.kind)
          caml_invalid_argument("caml_bigstring_blit_string_to_ba: kind mismatch");
        if (len == 0)
          return 0;
        var ofs1 = ba1.offset(pos1);
        if (ofs1 + len > ba1.data.length)
          caml_array_bound_error();
        if (pos2 + len > caml_ml_bytes_length(bytes2))
          caml_array_bound_error();
        var slice = ba1.data.slice(ofs1, ofs1 + len);
        caml_blit_bytes(caml_bytes_of_array(slice), 0, bytes2, pos2, len);
        return 0;
      }
      function caml_unix_stat(name) {
        var root = resolve_fs_device(name);
        if (!root.device.stat)
          caml_failwith("caml_unix_stat: not implemented");
        return root.device.stat(root.rest, true);
      }
      function caml_register_named_value(nm, v) {
        caml_named_values[caml_jsbytes_of_string(nm)] = v;
        return 0;
      }
      function jsoo_create_file_extern(name, content) {
        if (globalThis.jsoo_create_file)
          globalThis.jsoo_create_file(name, content);
        else {
          if (!globalThis.caml_fs_tmp)
            globalThis.caml_fs_tmp = [];
          globalThis.caml_fs_tmp.push({ name, content });
        }
        return 0;
      }
      function caml_unix_stat_64(name) {
        var r = caml_unix_stat(name);
        r[9] = caml_int64_of_int32(r[9]);
        return r;
      }
      function caml_to_js_string(s2) {
        return caml_jsstring_of_string(s2);
      }
      function caml_ml_mutex_lock(t) {
        if (t.locked)
          caml_failwith("Mutex.lock: mutex already locked. Cannot wait.");
        else
          t.locked = true;
        return 0;
      }
      function re_search_forward(re, s2, pos) {
        if (pos < 0 || pos > caml_ml_string_length(s2))
          caml_invalid_argument("Str.search_forward");
        while (pos <= caml_ml_string_length(s2)) {
          var res = re_match(re, s2, pos, 0);
          if (res)
            return res;
          pos++;
        }
        return [0];
      }
      function caml_make_vect(len, init) {
        if (len < 0)
          caml_array_bound_error();
        var len = len + 1 | 0, b = new Array(len);
        b[0] = 0;
        for (var i = 1; i < len; i++)
          b[i] = init;
        return b;
      }
      function caml_ml_seek_in(chanid, pos) {
        return caml_seek_in(chanid, pos);
      }
      function caml_sys_read_directory(name) {
        var root = resolve_fs_device(name), a = root.device.readdir(root.rest), l = new Array(a.length + 1);
        l[0] = 0;
        for (var i = 0; i < a.length; i++)
          l[i + 1] = caml_string_of_jsbytes(a[i]);
        return l;
      }
      function caml_ml_output_char(chanid, c) {
        var s2 = caml_string_of_jsbytes(String.fromCharCode(c));
        caml_ml_output(chanid, s2, 0, 1);
        return 0;
      }
      function caml_sys_const_ostype_win32() {
        return os_type == "Win32" ? 1 : 0;
      }
      function caml_obj_is_block(x2) {
        return +(x2 instanceof Array);
      }
      function caml_obj_set_raw_field(o, i, v) {
        return o[i + 1] = v;
      }
      function caml_js_var(x) {
        var x = caml_jsstring_of_string(x);
        if (!x.match(/^[a-zA-Z_$][a-zA-Z_$0-9]*(\.[a-zA-Z_$][a-zA-Z_$0-9]*)*$/))
          console.error('caml_js_var: "' + x + '" is not a valid JavaScript variable. continuing ..');
        return eval(x);
      }
      function caml_trunc_float(x2) {
        return Math.trunc(x2);
      }
      function caml_ephe_unset_data(x2) {
        if (globalThis.FinalizationRegistry && globalThis.WeakRef) {
          if (x2[1] instanceof globalThis.FinalizationRegistry)
            for (var j = caml_ephe_key_offset; j < x2.length; j++) {
              var key = x2[j];
              if (key instanceof globalThis.WeakRef) {
                key = key.deref();
                if (key)
                  x2[1].unregister(key);
              }
            }
        }
        x2[caml_ephe_data_offset] = void 0;
        return 0;
      }
      function caml_ephe_set_data(x2, data) {
        if (globalThis.FinalizationRegistry && globalThis.WeakRef) {
          if (!(x2[1] instanceof globalThis.FinalizationRegistry)) {
            x2[1] = new globalThis.FinalizationRegistry(function() {
              caml_ephe_unset_data(x2);
            });
            for (var j = caml_ephe_key_offset; j < x2.length; j++) {
              var key = x2[j];
              if (key instanceof globalThis.WeakRef) {
                key = key.deref();
                if (key)
                  x2[1].register(key, void 0, key);
              }
            }
          }
        }
        x2[caml_ephe_data_offset] = data;
        return 0;
      }
      function caml_ephe_blit_data(src, dst) {
        var n = src[caml_ephe_data_offset];
        if (n === void 0)
          caml_ephe_unset_data(dst);
        else
          caml_ephe_set_data(dst, n);
        return 0;
      }
      function length_nat(x2) {
        return x2.data.length;
      }
      function caml_is_printable(c) {
        return +(c > 31 && c < 127);
      }
      function caml_bytes_lessequal(s1, s2) {
        s1.t & 6 && caml_convert_string_to_bytes(s1);
        s2.t & 6 && caml_convert_string_to_bytes(s2);
        return s1.c <= s2.c ? 1 : 0;
      }
      function caml_array_of_bytes(x2) {
        return caml_uint8_array_of_bytes(x2);
      }
      function caml_equal(x2, y) {
        return +(caml_compare_val(x2, y, false) == 0);
      }
      function re_partial_match(re, s2, pos) {
        if (pos < 0 || pos > caml_ml_string_length(s2))
          caml_invalid_argument("Str.partial_match");
        var res = re_match(re, s2, pos, 1);
        return res ? res : [0];
      }
      function caml_sys_random_seed() {
        if (globalThis.crypto) {
          if (globalThis.crypto.getRandomValues) {
            var a = globalThis.crypto.getRandomValues(new Int32Array(4));
            return [0, a[0], a[1], a[2], a[3]];
          } else if (globalThis.crypto.randomBytes) {
            var a = new Int32Array(globalThis.crypto.randomBytes(16).buffer);
            return [0, a[0], a[1], a[2], a[3]];
          }
        }
        var now = (/* @__PURE__ */ new Date()).getTime(), x2 = now ^ 4294967295 * Math.random();
        return [0, x2];
      }
      var all_finalizers = new globalThis.Set();
      function caml_final_register_called_without_value(cb, a) {
        if (globalThis.FinalizationRegistry && a instanceof Object) {
          var x2 = new globalThis.FinalizationRegistry(function(x3) {
            all_finalizers.delete(x3);
            cb(0);
            return;
          });
          x2.register(a, x2);
          all_finalizers.add(x2);
        }
        return 0;
      }
      function caml_ba_get_2(ba, i0, i1) {
        return ba.get(ba.offset([i0, i1]));
      }
      function caml_ba_uint8_set16(ba, i0, v) {
        var ofs = ba.offset(i0);
        if (ofs + 1 >= ba.data.length)
          caml_array_bound_error();
        ba.set(ofs + 0, v & 255);
        ba.set(ofs + 1, v >>> 8 & 255);
        return 0;
      }
      function caml_lazy_reset_to_lazy(o) {
        caml_obj_update_tag(o, 244, 246);
        return 0;
      }
      function caml_js_delete(o, f) {
        delete o[f];
        return 0;
      }
      function caml_int_of_string(s2) {
        var r = caml_parse_sign_and_base(s2), i = r[0], sign = r[1], base = r[2], len = caml_ml_string_length(s2), threshold = -1 >>> 0, c = i < len ? caml_string_unsafe_get(s2, i) : 0, d = caml_parse_digit(c);
        if (d < 0 || d >= base)
          caml_failwith("int_of_string");
        var res = d;
        for (i++; i < len; i++) {
          c = caml_string_unsafe_get(s2, i);
          if (c == 95)
            continue;
          d = caml_parse_digit(c);
          if (d < 0 || d >= base)
            break;
          res = base * res + d;
          if (res > threshold)
            caml_failwith("int_of_string");
        }
        if (i != len)
          caml_failwith("int_of_string");
        res = sign * res;
        if (base == 10 && (res | 0) != res)
          caml_failwith("int_of_string");
        return res | 0;
      }
      function caml_list_mount_point() {
        var prev = 0;
        for (var i = 0; i < jsoo_mount_point.length; i++) {
          var old = prev;
          prev = [0, caml_string_of_jsbytes(jsoo_mount_point[i].path), old];
        }
        return prev;
      }
      var caml_marshal_constants = {
        PREFIX_SMALL_BLOCK: 128,
        PREFIX_SMALL_INT: 64,
        PREFIX_SMALL_STRING: 32,
        CODE_INT8: 0,
        CODE_INT16: 1,
        CODE_INT32: 2,
        CODE_INT64: 3,
        CODE_SHARED8: 4,
        CODE_SHARED16: 5,
        CODE_SHARED32: 6,
        CODE_BLOCK32: 8,
        CODE_BLOCK64: 19,
        CODE_STRING8: 9,
        CODE_STRING32: 10,
        CODE_DOUBLE_BIG: 11,
        CODE_DOUBLE_LITTLE: 12,
        CODE_DOUBLE_ARRAY8_BIG: 13,
        CODE_DOUBLE_ARRAY8_LITTLE: 14,
        CODE_DOUBLE_ARRAY32_BIG: 15,
        CODE_DOUBLE_ARRAY32_LITTLE: 7,
        CODE_CODEPOINTER: 16,
        CODE_INFIXPOINTER: 17,
        CODE_CUSTOM: 18,
        CODE_CUSTOM_LEN: 24,
        CODE_CUSTOM_FIXED: 25
      };
      function caml_obj_raw_field(o, i) {
        return o[i + 1];
      }
      function caml_js_equals(x2, y) {
        return +(x2 == y);
      }
      function caml_obj_compare_and_swap(x2, i, old, n) {
        if (x2[i + 1] == old) {
          x2[i + 1] = n;
          return 1;
        }
        return 0;
      }
      function bigstring_to_typed_array(bs) {
        return bs.data;
      }
      function caml_gr_arc_aux(ctx, cx, cy, ry, rx, a1, a2) {
        while (a1 > a2)
          a2 += 360;
        a1 /= 180;
        a2 /= 180;
        var rot = 0, xPos, yPos, xPos_prev, yPos_prev, space = 2, num = (a2 - a1) * Math.PI * ((rx + ry) / 2) / space | 0, delta = (a2 - a1) * Math.PI / num, i = a1 * Math.PI;
        for (var j = 0; j <= num; j++) {
          xPos = cx - rx * Math.sin(i) * Math.sin(rot * Math.PI) + ry * Math.cos(i) * Math.cos(rot * Math.PI);
          xPos = xPos.toFixed(2);
          yPos = cy + ry * Math.cos(i) * Math.sin(rot * Math.PI) + rx * Math.sin(i) * Math.cos(rot * Math.PI);
          yPos = yPos.toFixed(2);
          if (j == 0)
            ctx.moveTo(xPos, yPos);
          else if (xPos_prev != xPos || yPos_prev != yPos)
            ctx.lineTo(xPos, yPos);
          xPos_prev = xPos;
          yPos_prev = yPos;
          i -= delta;
        }
        return 0;
      }
      function caml_gr_fill_arc(x2, y, rx, ry, a1, a2) {
        var s2 = caml_gr_state_get();
        s2.context.beginPath();
        caml_gr_arc_aux(s2.context, x2, s2.height - y, rx, ry, a1, a2);
        s2.context.fill();
        return 0;
      }
      function caml_ba_slice(ba, vind) {
        vind = caml_js_from_array(vind);
        var num_inds = vind.length, index = [], sub_dims = [], ofs;
        if (num_inds > ba.dims.length)
          caml_invalid_argument("Bigarray.slice: too many indices");
        if (ba.layout == 0) {
          for (var i = 0; i < num_inds; i++)
            index[i] = vind[i];
          for (; i < ba.dims.length; i++)
            index[i] = 0;
          sub_dims = ba.dims.slice(num_inds);
        } else {
          for (var i = 0; i < num_inds; i++)
            index[ba.dims.length - num_inds + i] = vind[i];
          for (var i = 0; i < ba.dims.length - num_inds; i++)
            index[i] = 1;
          sub_dims = ba.dims.slice(0, ba.dims.length - num_inds);
        }
        ofs = ba.offset(index);
        var size = caml_ba_get_size(sub_dims), size_per_element = caml_ba_get_size_per_element(ba.kind), new_data = ba.data.subarray(ofs * size_per_element, (ofs + size) * size_per_element);
        return caml_ba_create_unsafe(ba.kind, ba.layout, sub_dims, new_data);
      }
      function caml_js_wrap_callback_unsafe(f) {
        return function() {
          var len = caml_js_function_arity(f), args = new Array(len);
          for (var i = 0; i < len; i++)
            args[i] = arguments[i];
          return caml_callback(f, args);
        };
      }
      function caml_ba_kind(ba) {
        return ba.kind;
      }
      function caml_alloc_dummy_infix() {
        return function f(x2) {
          return caml_call_gen(f.fun, [x2]);
        };
      }
      function caml_js_strict_equals(x2, y) {
        return +(x2 === y);
      }
      function caml_js_fun_call(f, a) {
        switch (a.length) {
          case 1:
            return f();
          case 2:
            return f(a[1]);
          case 3:
            return f(a[1], a[2]);
          case 4:
            return f(a[1], a[2], a[3]);
          case 5:
            return f(a[1], a[2], a[3], a[4]);
          case 6:
            return f(a[1], a[2], a[3], a[4], a[5]);
          case 7:
            return f(a[1], a[2], a[3], a[4], a[5], a[6]);
          case 8:
            return f(a[1], a[2], a[3], a[4], a[5], a[6], a[7]);
        }
        return f.apply(null, caml_js_from_array(a));
      }
      function caml_gc_major_slice(work) {
        return 0;
      }
      function caml_js_pure_expr(f) {
        return caml_callback(f, [0]);
      }
      function compare_digits_nat(nat1, ofs1, nat2, ofs2) {
        if (nat1.data[ofs1] > nat2.data[ofs2])
          return 1;
        if (nat1.data[ofs1] < nat2.data[ofs2])
          return -1;
        return 0;
      }
      function caml_ml_input(chanid, b, i, l) {
        var ba = caml_uint8_array_of_bytes(b);
        return caml_ml_input_block(chanid, ba, i, l);
      }
      function caml_gr_wait_event(_evl) {
        caml_failwith("caml_gr_wait_event not Implemented: use Graphics_js instead");
      }
      function caml_gr_sigio_handler() {
        return 0;
      }
      function caml_memprof_discard(t) {
        return 0;
      }
      function caml_hash_mix_bigstring(h, bs) {
        return caml_hash_mix_bytes_arr(h, bs.data);
      }
      function caml_record_backtrace(b) {
        caml_record_backtrace_flag = b;
        return 0;
      }
      function caml_unix_cleanup() {
      }
      function caml_sys_get_config() {
        return [0, caml_string_of_jsbytes(os_type), 32, 0];
      }
      function caml_sys_const_backend_type() {
        return [0, caml_string_of_jsbytes("js_of_ocaml")];
      }
      function caml_obj_is_shared(x2) {
        return 1;
      }
      function caml_ml_out_channels_list() {
        var l = 0;
        for (var c = 0; c < caml_ml_channels.length; c++)
          if (caml_ml_channels[c] && caml_ml_channels[c].opened && caml_ml_channels[c].out)
            l = [0, caml_ml_channels[c].fd, l];
        return l;
      }
      function caml_asinh_float(x2) {
        return Math.asinh(x2);
      }
      function caml_pos_out(chanid) {
        var chan = caml_ml_channels[chanid];
        return chan.offset + chan.buffer_curr;
      }
      function bigstring_of_array_buffer(ab) {
        var ta = new Uint8Array(ab);
        return caml_ba_create_unsafe(12, 0, [ta.length], ta);
      }
      function caml_mod(x2, y) {
        if (y == 0)
          caml_raise_zero_divide();
        return x2 % y;
      }
      function caml_ba_init() {
        return 0;
      }
      function caml_unix_filedescr_of_fd(x2) {
        return x2;
      }
      function re_string_match(re, s2, pos) {
        if (pos < 0 || pos > caml_ml_string_length(s2))
          caml_invalid_argument("Str.string_match");
        var res = re_match(re, s2, pos, 0);
        return res ? res : [0];
      }
      function BigStringReader(bs, i) {
        this.s = bs;
        this.i = i;
      }
      BigStringReader.prototype = {
        read8u: function() {
          return caml_ba_get_1(this.s, this.i++);
        },
        read8s: function() {
          return caml_ba_get_1(this.s, this.i++) << 24 >> 24;
        },
        read16u: function() {
          var s2 = this.s, i = this.i;
          this.i = i + 2;
          return caml_ba_get_1(s2, i) << 8 | caml_ba_get_1(s2, i + 1);
        },
        read16s: function() {
          var s2 = this.s, i = this.i;
          this.i = i + 2;
          return caml_ba_get_1(s2, i) << 24 >> 16 | caml_ba_get_1(s2, i + 1);
        },
        read32u: function() {
          var s2 = this.s, i = this.i;
          this.i = i + 4;
          return (caml_ba_get_1(s2, i) << 24 | caml_ba_get_1(s2, i + 1) << 16 | caml_ba_get_1(s2, i + 2) << 8 | caml_ba_get_1(s2, i + 3)) >>> 0;
        },
        read32s: function() {
          var s2 = this.s, i = this.i;
          this.i = i + 4;
          return caml_ba_get_1(s2, i) << 24 | caml_ba_get_1(s2, i + 1) << 16 | caml_ba_get_1(s2, i + 2) << 8 | caml_ba_get_1(s2, i + 3);
        },
        readstr: function(len) {
          var i = this.i, arr = new Array(len);
          for (var j = 0; j < len; j++)
            arr[j] = caml_ba_get_1(this.s, i + j);
          this.i = i + len;
          return caml_string_of_array(arr);
        },
        readuint8array: function(len) {
          var i = this.i, offset = this.offset(i);
          this.i = i + len;
          return this.s.data.subarray(offset, offset + len);
        }
      };
      function caml_gr_dump_image(im) {
        var data = [0];
        for (var i = 0; i < im.height; i++) {
          data[i + 1] = [0];
          for (var j = 0; j < im.width; j++) {
            var o = i * (im.width * 4) + j * 4, r = im.data[o + 0], g = im.data[o + 1], b = im.data[o + 2];
            data[i + 1][j + 1] = (r << 16) + (g << 8) + b;
          }
        }
        return data;
      }
      function caml_ba_get_generic(ba, i) {
        var ofs = ba.offset(caml_js_from_array(i));
        return ba.get(ofs);
      }
      function caml_unix_startup() {
      }
      function caml_get_exception_backtrace() {
        return 0;
      }
      function caml_format_float(fmt, x2) {
        function toFixed(x3, dp) {
          if (Math.abs(x3) < 1)
            return x3.toFixed(dp);
          else {
            var e = parseInt(x3.toString().split("+")[1]);
            if (e > 20) {
              e -= 20;
              x3 /= Math.pow(10, e);
              x3 += new Array(e + 1).join("0");
              if (dp > 0)
                x3 = x3 + "." + new Array(dp + 1).join("0");
              return x3;
            } else
              return x3.toFixed(dp);
          }
        }
        var s2, f = caml_parse_format(fmt), prec = f.prec < 0 ? 6 : f.prec;
        if (x2 < 0 || x2 == 0 && 1 / x2 == -Infinity) {
          f.sign = -1;
          x2 = -x2;
        }
        if (isNaN(x2)) {
          s2 = "nan";
          f.filler = " ";
        } else if (!isFinite(x2)) {
          s2 = "inf";
          f.filler = " ";
        } else
          switch (f.conv) {
            case "e":
              var s2 = x2.toExponential(prec), i = s2.length;
              if (s2.charAt(i - 3) == "e")
                s2 = s2.slice(0, i - 1) + "0" + s2.slice(i - 1);
              break;
            case "f":
              s2 = toFixed(x2, prec);
              break;
            case "g":
              prec = prec ? prec : 1;
              s2 = x2.toExponential(prec - 1);
              var j = s2.indexOf("e"), exp = +s2.slice(j + 1);
              if (exp < -4 || x2 >= 1e21 || x2.toFixed(0).length > prec) {
                var i = j - 1;
                while (s2.charAt(i) == "0")
                  i--;
                if (s2.charAt(i) == ".")
                  i--;
                s2 = s2.slice(0, i + 1) + s2.slice(j);
                i = s2.length;
                if (s2.charAt(i - 3) == "e")
                  s2 = s2.slice(0, i - 1) + "0" + s2.slice(i - 1);
                break;
              } else {
                var p = prec;
                if (exp < 0) {
                  p -= exp + 1;
                  s2 = x2.toFixed(p);
                } else
                  while (s2 = x2.toFixed(p), s2.length > prec + 1)
                    p--;
                if (p) {
                  var i = s2.length - 1;
                  while (s2.charAt(i) == "0")
                    i--;
                  if (s2.charAt(i) == ".")
                    i--;
                  s2 = s2.slice(0, i + 1);
                }
              }
              break;
          }
        return caml_finish_formatting(f, s2);
      }
      function caml_mount_autoload(name, f) {
        var path = caml_make_path(name), name = caml_trailing_slash(path.join("/"));
        jsoo_mount_point.push({ path: name, device: new MlFakeDevice(name, f) });
        return 0;
      }
      function caml_string_lessthan(s1, s2) {
        return s1 < s2 ? 1 : 0;
      }
      function caml_string_greaterthan(s1, s2) {
        return caml_string_lessthan(s2, s1);
      }
      function caml_div(x2, y) {
        if (y == 0)
          caml_raise_zero_divide();
        return x2 / y | 0;
      }
      function caml_obj_dup(x2) {
        var l = x2.length, a = new Array(l);
        for (var i = 0; i < l; i++)
          a[i] = x2[i];
        return a;
      }
      function caml_ephe_get_data_copy(x2) {
        return x2[caml_ephe_data_offset] === void 0 ? 0 : [0, caml_obj_dup(x2[caml_ephe_data_offset])];
      }
      function caml_memprof_start(rate, stack_size, tracker) {
        return 0;
      }
      function caml_sys_get_argv(a) {
        return [0, caml_argv[1], caml_argv];
      }
      function caml_ml_domain_set_name(_name) {
        return 0;
      }
      function caml_js_to_bool(x2) {
        return +x2;
      }
      function caml_gr_create_image(x2, y) {
        var s2 = caml_gr_state_get();
        return s2.context.createImageData(x2, y);
      }
      function caml_ephe_get_key_copy(x2, i) {
        if (i < 0 || caml_ephe_key_offset + i >= x2.length)
          caml_invalid_argument("Weak.get_copy");
        var y = caml_ephe_get_key(x2, i);
        if (y === 0)
          return y;
        var z = y[1];
        if (z instanceof Array)
          return [0, caml_obj_dup(z)];
        return y;
      }
      function caml_lessthan(x2, y) {
        return +(caml_compare_val(x2, y, false) < 0);
      }
      function caml_raw_backtrace_next_slot() {
        return 0;
      }
      function caml_build_symbols(symb) {
        var r = {};
        if (symb)
          for (var i = 1; i < symb.length; i++)
            r[caml_jsstring_of_string(symb[i][1])] = symb[i][2];
        return r;
      }
      function caml_register_global(n, v, name_opt) {
        if (name_opt) {
          var name = name_opt;
          if (globalThis.toplevelReloc)
            n = caml_callback(globalThis.toplevelReloc, [name]);
          else if (caml_global_data.symbols) {
            if (!caml_global_data.symidx)
              caml_global_data.symidx = caml_build_symbols(caml_global_data.symbols);
            var nid = caml_global_data.symidx[name];
            if (nid >= 0)
              n = nid;
            else
              caml_failwith("caml_register_global: cannot locate " + name);
          }
        }
        caml_global_data[n + 1] = v;
        if (name_opt)
          caml_global_data[name_opt] = v;
      }
      function mult_nat(nat1, ofs1, len1, nat2, ofs2, len2, nat3, ofs3, len3) {
        var carry = 0;
        for (var i = 0; i < len3; i++)
          carry += mult_digit_nat(nat1, ofs1 + i, len1 - i, nat2, ofs2, len2, nat3, ofs3 + i);
        return carry;
      }
      function square_nat(nat1, ofs1, len1, nat2, ofs2, len2) {
        var carry = 0;
        carry += add_nat(nat1, ofs1, len1, nat1, ofs1, len1, 0);
        carry += mult_nat(nat1, ofs1, len1, nat2, ofs2, len2, nat2, ofs2, len2);
        return carry;
      }
      function caml_js_from_float(x2) {
        return x2;
      }
      function caml_floatarray_create(len) {
        if (len < 0)
          caml_array_bound_error();
        var len = len + 1 | 0, b = new Array(len);
        b[0] = 254;
        for (var i = 1; i < len; i++)
          b[i] = 0;
        return b;
      }
      function caml_gc_stat() {
        return caml_gc_quick_stat();
      }
      function caml_get_major_credit(n) {
        return 0;
      }
      function caml_ml_open_descriptor_in(fd) {
        var file = caml_sys_fds[fd];
        if (file.flags.wronly)
          caml_raise_sys_error("fd " + fd + " is writeonly");
        var refill = null, channel = {
          file,
          offset: file.flags.append ? file.length() : 0,
          fd,
          opened: true,
          out: false,
          buffer_curr: 0,
          buffer_max: 0,
          buffer: new Uint8Array(65536),
          refill
        };
        caml_ml_channels[channel.fd] = channel;
        return channel.fd;
      }
      function caml_ml_open_descriptor_in_with_flags(fd, flags) {
        return caml_ml_open_descriptor_in(fd);
      }
      function caml_sys_modify_argv(arg) {
        caml_argv = arg;
        return 0;
      }
      var caml_method_cache = [];
      function caml_get_public_method(obj, tag, cacheid) {
        var meths = obj[1], ofs = caml_method_cache[cacheid];
        if (ofs === void 0)
          for (var i = caml_method_cache.length; i < cacheid; i++)
            caml_method_cache[i] = 0;
        else if (meths[ofs] === tag)
          return meths[ofs - 1];
        var li = 3, hi = meths[1] * 2 + 1, mi;
        while (li < hi) {
          mi = li + hi >> 1 | 1;
          if (tag < meths[mi + 1])
            hi = mi - 2;
          else
            li = mi;
        }
        caml_method_cache[cacheid] = li + 1;
        return tag == meths[li + 1] ? meths[li] : 0;
      }
      function caml_js_get_console() {
        var c = console, m = [
          "log",
          "debug",
          "info",
          "warn",
          "error",
          "assert",
          "dir",
          "dirxml",
          "trace",
          "group",
          "groupCollapsed",
          "groupEnd",
          "time",
          "timeEnd"
        ];
        function f() {
        }
        for (var i = 0; i < m.length; i++)
          if (!c[m[i]])
            c[m[i]] = f;
        return c;
      }
      function caml_sys_unsafe_getenv(name) {
        return caml_sys_getenv(name);
      }
      function bigstring_of_typed_array(ba) {
        var ta = new Uint8Array(ba.buffer, ba.byteOffset, ba.length * ba.BYTES_PER_ELEMENT);
        return caml_ba_create_unsafe(12, 0, [ta.length], ta);
      }
      function caml_round_float(x2) {
        if (x2 >= 0) {
          var y = Math.floor(x2);
          return x2 - y >= 0.5 ? y + 1 : y;
        } else {
          var y = Math.ceil(x2);
          return y - x2 >= 0.5 ? y - 1 : y;
        }
      }
      function caml_ojs_new_arr(c, a) {
        switch (a.length) {
          case 0:
            return new c();
          case 1:
            return new c(a[0]);
          case 2:
            return new c(a[0], a[1]);
          case 3:
            return new c(a[0], a[1], a[2]);
          case 4:
            return new c(a[0], a[1], a[2], a[3]);
          case 5:
            return new c(a[0], a[1], a[2], a[3], a[4]);
          case 6:
            return new c(a[0], a[1], a[2], a[3], a[4], a[5]);
          case 7:
            return new c(a[0], a[1], a[2], a[3], a[4], a[5], a[6]);
        }
        function F() {
          return c.apply(this, a);
        }
        F.prototype = c.prototype;
        return new F();
      }
      function complement_nat(nat, ofs, len) {
        for (var i = 0; i < len; i++)
          nat.data[ofs + i] = (-1 >>> 0) - (nat.data[ofs + i] >>> 0);
      }
      var caml_domain_dls = [0];
      function caml_domain_dls_set(a) {
        caml_domain_dls = a;
      }
      function caml_obj_tag(x2) {
        if (x2 instanceof Array && x2[0] == x2[0] >>> 0)
          return x2[0];
        else if (caml_is_ml_bytes(x2))
          return 252;
        else if (caml_is_ml_string(x2))
          return 252;
        else if (x2 instanceof Function || typeof x2 == "function")
          return 247;
        else if (x2 && x2.caml_custom)
          return 255;
        else
          return 1e3;
      }
      function caml_lazy_read_result(o) {
        return caml_obj_tag(o) == 250 ? o[1] : o;
      }
      var caml_js_regexps = { amp: /&/g, lt: /</g, quot: /\"/g, all: /[&<\"]/ };
      function caml_js_html_escape(s2) {
        if (!caml_js_regexps.all.test(s2))
          return s2;
        return s2.replace(caml_js_regexps.amp, "&amp;").replace(caml_js_regexps.lt, "&lt;").replace(caml_js_regexps.quot, "&quot;");
      }
      function caml_ba_dim_2(ba) {
        return caml_ba_dim(ba, 1);
      }
      function caml_js_wrap_meth_callback_arguments(f) {
        return function() {
          var len = arguments.length, args = new Array(len);
          for (var i = 0; i < len; i++)
            args[i] = arguments[i];
          return caml_callback(f, [this, args]);
        };
      }
      function caml_sinh_float(x2) {
        return Math.sinh(x2);
      }
      function caml_ldexp_float(x2, exp) {
        exp |= 0;
        if (exp > 1023) {
          exp -= 1023;
          x2 *= Math.pow(2, 1023);
          if (exp > 1023) {
            exp -= 1023;
            x2 *= Math.pow(2, 1023);
          }
        }
        if (exp < -1023) {
          exp += 1023;
          x2 *= Math.pow(2, -1023);
        }
        x2 *= Math.pow(2, exp);
        return x2;
      }
      function caml_gr_state_set(ctx) {
        caml_gr_state = ctx;
        caml_gr_state_init();
        return 0;
      }
      function caml_js_wrap_callback_strict(arity, f) {
        return function() {
          var n = arguments.length, args = new Array(arity), len = Math.min(arguments.length, arity);
          for (var i = 0; i < len; i++)
            args[i] = arguments[i];
          return caml_callback(f, args);
        };
      }
      function caml_gc_minor_words(unit) {
        return 0;
      }
      function caml_get_current_callstack() {
        return [0];
      }
      function land_digit_nat(nat1, ofs1, nat2, ofs2) {
        nat1.data[ofs1] &= nat2.data[ofs2];
        return 0;
      }
      function caml_int64_mod(x2, y) {
        return x2.mod(y);
      }
      function caml_obj_set_tag(x2, tag) {
        x2[0] = tag;
        return 0;
      }
      function caml_int32_bswap(x2) {
        return (x2 & 255) << 24 | (x2 & 65280) << 8 | (x2 & 16711680) >>> 8 | (x2 & 4278190080) >>> 24;
      }
      function caml_ba_set_3(ba, i0, i1, i2, v) {
        ba.set(ba.offset([i0, i1, i2]), v);
        return 0;
      }
      function caml_js_instanceof(o, c) {
        return o instanceof c ? 1 : 0;
      }
      function caml_get_major_bucket(n) {
        return 0;
      }
      function nth_digit_nat_native(nat, ofs) {
        return nat.data[ofs];
      }
      function set_digit_nat_native(nat, ofs, digit) {
        nat.data[ofs] = digit;
        return 0;
      }
      function caml_string_set64(s2, i, i64) {
        caml_failwith("caml_string_set64");
      }
      function caml_gr_state_create(canvas, w, h) {
        var context = canvas.getContext("2d");
        return {
          context,
          canvas,
          x: 0,
          y: 0,
          width: w,
          height: h,
          line_width: 1,
          font: caml_string_of_jsbytes("fixed"),
          text_size: 26,
          color: 0,
          title: caml_string_of_jsbytes("")
        };
      }
      function caml_gr_draw_arc(x2, y, rx, ry, a1, a2) {
        var s2 = caml_gr_state_get();
        s2.context.beginPath();
        caml_gr_arc_aux(s2.context, x2, s2.height - y, rx, ry, a1, a2);
        s2.context.stroke();
        return 0;
      }
      function caml_ba_map_file(vfd, kind, layout, shared, dims, pos) {
        caml_failwith("caml_ba_map_file not implemented");
      }
      function caml_ba_map_file_bytecode(argv, argn) {
        return caml_ba_map_file(argv[0], argv[1], argv[2], argv[3], argv[4], argv[5]);
      }
      function caml_ba_create_from(data1, data2, jstyp, kind, layout, dims) {
        if (data2 || caml_ba_get_size_per_element(kind) == 2)
          caml_invalid_argument("caml_ba_create_from: use return caml_ba_create_unsafe");
        return caml_ba_create_unsafe(kind, layout, dims, data1);
      }
      function caml_tanh_float(x2) {
        return Math.tanh(x2);
      }
      function caml_gr_draw_str(str) {
        var s2 = caml_gr_state_get(), m = s2.context.measureText(str), dx = m.width;
        s2.context.fillText(str, s2.x, s2.height - s2.y);
        s2.x += dx | 0;
        return 0;
      }
      function caml_gr_draw_string(str) {
        caml_gr_draw_str(caml_jsstring_of_string(str));
        return 0;
      }
      function caml_gr_draw_char(c) {
        caml_gr_draw_str(String.fromCharCode(c));
        return 0;
      }
      function caml_unmount(name) {
        var path = caml_make_path(name), name = caml_trailing_slash(path.join("/")), idx = -1;
        for (var i = 0; i < jsoo_mount_point.length; i++)
          if (jsoo_mount_point[i].path == name)
            idx = i;
        if (idx > -1)
          jsoo_mount_point.splice(idx, 1);
        return 0;
      }
      function caml_bigstring_blit_ba_to_ba(ba1, pos1, ba2, pos2, len) {
        if (12 != ba1.kind)
          caml_invalid_argument("caml_bigstring_blit_ba_to_ba: kind mismatch");
        if (12 != ba2.kind)
          caml_invalid_argument("caml_bigstring_blit_ba_to_ba: kind mismatch");
        if (len == 0)
          return 0;
        var ofs1 = ba1.offset(pos1), ofs2 = ba2.offset(pos2);
        if (ofs1 + len > ba1.data.length)
          caml_array_bound_error();
        if (ofs2 + len > ba2.data.length)
          caml_array_bound_error();
        var slice = ba1.data.subarray(ofs1, ofs1 + len);
        ba2.data.set(slice, pos2);
        return 0;
      }
      function caml_input_value_from_string(s2, ofs) {
        var reader = new MlStringReader(s2, typeof ofs == "number" ? ofs : ofs[0]);
        return caml_input_value_from_reader(reader, ofs);
      }
      function caml_ml_pos_in_64(chanid) {
        return caml_int64_of_float(caml_pos_in(chanid));
      }
      function caml_gr_draw_image(im, x2, y) {
        var s2 = caml_gr_state_get();
        if (!im.image) {
          var canvas = document.createElement("canvas");
          canvas.width = s2.width;
          canvas.height = s2.height;
          canvas.getContext("2d").putImageData(im, 0, 0);
          var image = new globalThis.Image();
          image.onload = function() {
            s2.context.drawImage(image, x2, s2.height - im.height - y);
            im.image = image;
          };
          image.src = canvas.toDataURL("image/png");
        } else
          s2.context.drawImage(im.image, x2, s2.height - im.height - y);
        return 0;
      }
      function caml_register_channel_for_spacetime(_channel) {
        return 0;
      }
      function caml_string_set(s2, i, c) {
        caml_failwith("caml_string_set");
      }
      function caml_sys_rmdir(name) {
        var root = resolve_fs_device(name);
        root.device.rmdir(root.rest);
        return 0;
      }
      function caml_unix_symlink(to_dir, src, dst) {
        var src_root = resolve_fs_device(src), dst_root = resolve_fs_device(dst);
        if (src_root.device != dst_root.device)
          caml_failwith("caml_unix_symlink: cannot symlink between two filesystems");
        if (!src_root.device.symlink)
          caml_failwith("caml_unix_symlink: not implemented");
        return src_root.device.symlink(to_dir, src_root.rest, dst_root.rest, true);
      }
      function caml_ml_pos_out(chanid) {
        return caml_pos_out(chanid);
      }
      function caml_spacetime_enabled(_unit) {
        return 0;
      }
      function caml_bytes_notequal(s1, s2) {
        return 1 - caml_bytes_equal(s1, s2);
      }
      function caml_runtime_parameters(_unit) {
        return caml_string_of_jsbytes("");
      }
      function caml_js_object(a) {
        var o = {};
        for (var i = 1; i < a.length; i++) {
          var p = a[i];
          o[caml_jsstring_of_string(p[1])] = p[2];
        }
        return o;
      }
      function caml_ba_create(kind, layout, dims_ml) {
        var dims = caml_js_from_array(dims_ml), data = caml_ba_create_buffer(kind, caml_ba_get_size(dims));
        return caml_ba_create_unsafe(kind, layout, dims, data);
      }
      function caml_gr_remember_mode() {
        caml_failwith("caml_gr_remember_mode not Implemented");
      }
      function caml_fma_float(x2, y, z) {
        var SPLIT = Math.pow(2, 27) + 1, MIN_VALUE = Math.pow(2, -1022), EPSILON = Math.pow(2, -52), C = 416, A = Math.pow(2, +C), B = Math.pow(2, -C);
        function multiply(a, b) {
          var at = SPLIT * a, ahi = at - (at - a), alo = a - ahi, bt = SPLIT * b, bhi = bt - (bt - b), blo = b - bhi, p = a * b, e = ahi * bhi - p + ahi * blo + alo * bhi + alo * blo;
          return { p, e };
        }
        function add(a, b) {
          var s3 = a + b, v = s3 - a, e = a - (s3 - v) + (b - v);
          return { s: s3, e };
        }
        function adjust(x3, y2) {
          return x3 !== 0 && y2 !== 0 && SPLIT * x3 - (SPLIT * x3 - x3) === x3 ? x3 * (1 + (x3 < 0 ? -1 : 1) * (y2 < 0 ? -1 : 1) * EPSILON) : x3;
        }
        if (x2 === 0 || x2 !== x2 || x2 === +(1 / 0) || x2 === -(1 / 0) || y === 0 || y !== y || y === +(1 / 0) || y === -(1 / 0))
          return x2 * y + z;
        if (z === 0)
          return x2 * y;
        if (z !== z || z === +(1 / 0) || z === -(1 / 0))
          return z;
        var scale = 1;
        while (Math.abs(x2) > A) {
          scale *= A;
          x2 *= B;
        }
        while (Math.abs(y) > A) {
          scale *= A;
          y *= B;
        }
        if (scale === 1 / 0)
          return x2 * y * scale;
        while (Math.abs(x2) < B) {
          scale *= B;
          x2 *= A;
        }
        while (Math.abs(y) < B) {
          scale *= B;
          y *= A;
        }
        if (scale === 0)
          return z;
        var xs = x2, ys = y, zs = z / scale;
        if (Math.abs(zs) > Math.abs(xs * ys) * 4 / EPSILON)
          return z;
        if (Math.abs(zs) < Math.abs(xs * ys) * EPSILON / 4 * EPSILON / 4)
          zs = (z < 0 ? -1 : 1) * MIN_VALUE;
        var xy = multiply(xs, ys), s2 = add(xy.p, zs), u = add(xy.e, s2.e), i = add(s2.s, u.s), f = i.s + adjust(i.e, u.e);
        if (f === 0)
          return f;
        var fs = f * scale;
        if (Math.abs(fs) > MIN_VALUE)
          return fs;
        return fs + adjust(f - fs / scale, i.e) * scale;
      }
      function caml_recommended_domain_count(unit) {
        return 1;
      }
      function caml_bswap16(x2) {
        return (x2 & 255) << 8 | (x2 & 65280) >> 8;
      }
      function caml_ml_set_binary_mode(chanid, mode) {
        var chan = caml_ml_channels[chanid];
        chan.file.flags.text = !mode;
        chan.file.flags.binary = mode;
        return 0;
      }
      function caml_final_register() {
        return 0;
      }
      function caml_gr_draw_rect(x2, y, w, h) {
        var s2 = caml_gr_state_get();
        s2.context.strokeRect(x2, s2.height - y, w, -h);
        return 0;
      }
      function caml_string_get16(s2, i) {
        if (i >>> 0 >= caml_ml_string_length(s2) - 1)
          caml_string_bound_error();
        var b1 = caml_string_unsafe_get(s2, i), b2 = caml_string_unsafe_get(s2, i + 1);
        return b2 << 8 | b1;
      }
      function caml_js_to_int32(x2) {
        return x2 | 0;
      }
      function caml_output_value(chanid, v, flags) {
        var s2 = caml_output_value_to_string(v, flags);
        caml_ml_output(chanid, s2, 0, caml_ml_string_length(s2));
        return 0;
      }
      function caml_ml_output_bigarray(chanid, buffer, offset, len) {
        var buffer = caml_ba_to_typed_array(buffer);
        return caml_ml_output_ta(chanid, buffer, offset, len);
      }
      function caml_ba_get_3(ba, i0, i1, i2) {
        return ba.get(ba.offset([i0, i1, i2]));
      }
      function caml_ml_runtime_events_pause() {
        return 0;
      }
      function caml_ephe_blit_key(a1, i1, a2, i2, len) {
        caml_array_blit(
          a1,
          caml_ephe_key_offset + i1 - 1,
          a2,
          caml_ephe_key_offset + i2 - 1,
          len
        );
        return 0;
      }
      var caml_initial_time = (/* @__PURE__ */ new Date()).getTime() * 1e-3;
      function caml_sys_time() {
        var now = (/* @__PURE__ */ new Date()).getTime();
        return now * 1e-3 - caml_initial_time;
      }
      function caml_sys_time_include_children(b) {
        return caml_sys_time();
      }
      function caml_check_bound(array, index) {
        if (index >>> 0 >= array.length - 1)
          caml_array_bound_error();
        return array;
      }
      function caml_unix_getpwuid(unit) {
        caml_raise_not_found();
      }
      function caml_hash(count, limit, seed, obj) {
        var queue, rd, wr, sz, num, h, v, i, len;
        sz = limit;
        if (sz < 0 || sz > 256)
          sz = 256;
        num = count;
        h = seed;
        queue = [obj];
        rd = 0;
        wr = 1;
        while (rd < wr && num > 0) {
          v = queue[rd++];
          if (v && v.caml_custom) {
            if (caml_custom_ops[v.caml_custom] && caml_custom_ops[v.caml_custom].hash) {
              var hh = caml_custom_ops[v.caml_custom].hash(v);
              h = caml_hash_mix_int(h, hh);
              num--;
            }
          } else if (v instanceof Array && v[0] === (v[0] | 0))
            switch (v[0]) {
              case 248:
                h = caml_hash_mix_int(h, v[2]);
                num--;
                break;
              case 250:
                queue[--rd] = v[1];
                break;
              default:
                if (caml_is_continuation_tag(v[0]))
                  break;
                var tag = v.length - 1 << 10 | v[0];
                h = caml_hash_mix_int(h, tag);
                for (i = 1, len = v.length; i < len; i++) {
                  if (wr >= sz)
                    break;
                  queue[wr++] = v[i];
                }
                break;
            }
          else if (caml_is_ml_bytes(v)) {
            h = caml_hash_mix_bytes(h, v);
            num--;
          } else if (caml_is_ml_string(v)) {
            h = caml_hash_mix_string(h, v);
            num--;
          } else if (typeof v === "string") {
            h = caml_hash_mix_jsbytes(h, v);
            num--;
          } else if (v === (v | 0)) {
            h = caml_hash_mix_int(h, v + v + 1);
            num--;
          } else if (typeof v === "number") {
            h = caml_hash_mix_float(h, v);
            num--;
          }
        }
        h = caml_hash_mix_final(h);
        return h & 1073741823;
      }
      function caml_domain_dls_get(unit) {
        return caml_domain_dls;
      }
      function caml_bytes_get32(s2, i) {
        if (i >>> 0 >= s2.l - 3)
          caml_bytes_bound_error();
        var b1 = caml_bytes_unsafe_get(s2, i), b2 = caml_bytes_unsafe_get(s2, i + 1), b3 = caml_bytes_unsafe_get(s2, i + 2), b4 = caml_bytes_unsafe_get(s2, i + 3);
        return b4 << 24 | b3 << 16 | b2 << 8 | b1;
      }
      function caml_frexp_float(x2) {
        if (x2 == 0 || !isFinite(x2))
          return [0, x2, 0];
        var neg = x2 < 0;
        if (neg)
          x2 = -x2;
        var exp = Math.max(-1023, jsoo_floor_log2(x2) + 1);
        x2 *= Math.pow(2, -exp);
        while (x2 < 0.5) {
          x2 *= 2;
          exp--;
        }
        while (x2 >= 1) {
          x2 *= 0.5;
          exp++;
        }
        if (neg)
          x2 = -x2;
        return [0, x2, exp];
      }
      function caml_string_get64(s2, i) {
        if (i >>> 0 >= caml_ml_string_length(s2) - 7)
          caml_string_bound_error();
        var a = new Array(8);
        for (var j = 0; j < 8; j++)
          a[7 - j] = caml_string_unsafe_get(s2, i + j);
        return caml_int64_of_bytes(a);
      }
      function caml_js_error_option_of_exception(exn) {
        if (exn.js_error)
          return [0, exn.js_error];
        return 0;
      }
      function caml_ml_pos_out_64(chanid) {
        return caml_int64_of_float(caml_pos_out(chanid));
      }
      function caml_unix_findclose(dir_handle) {
        return caml_unix_closedir(dir_handle);
      }
      function caml_gr_close_subwindow(a) {
        caml_failwith("caml_gr_close_subwindow not Implemented");
      }
      function caml_floatarray_blit(a1, i1, a2, i2, len) {
        if (i2 <= i1)
          for (var j = 1; j <= len; j++)
            a2[i2 + j] = a1[i1 + j];
        else
          for (var j = len; j >= 1; j--)
            a2[i2 + j] = a1[i1 + j];
        return 0;
      }
      function caml_get_minor_free(unit) {
        return 0;
      }
      function caml_set_static_env(k, v) {
        if (!globalThis.jsoo_static_env)
          globalThis.jsoo_static_env = {};
        globalThis.jsoo_static_env[k] = v;
        return 0;
      }
      function caml_ba_change_layout(ba, layout) {
        if (ba.layout == layout)
          return ba;
        var new_dims = [];
        for (var i = 0; i < ba.dims.length; i++)
          new_dims[i] = ba.dims[ba.dims.length - i - 1];
        return caml_ba_create_unsafe(ba.kind, layout, new_dims, ba.data);
      }
      function caml_js_new(c, a) {
        switch (a.length) {
          case 1:
            return new c();
          case 2:
            return new c(a[1]);
          case 3:
            return new c(a[1], a[2]);
          case 4:
            return new c(a[1], a[2], a[3]);
          case 5:
            return new c(a[1], a[2], a[3], a[4]);
          case 6:
            return new c(a[1], a[2], a[3], a[4], a[5]);
          case 7:
            return new c(a[1], a[2], a[3], a[4], a[5], a[6]);
          case 8:
            return new c(a[1], a[2], a[3], a[4], a[5], a[6], a[7]);
        }
        function F() {
          return c.apply(this, caml_js_from_array(a));
        }
        F.prototype = c.prototype;
        return new F();
      }
      function caml_ml_open_descriptor_out(fd) {
        var file = caml_sys_fds[fd];
        if (file.flags.rdonly)
          caml_raise_sys_error("fd " + fd + " is readonly");
        var buffered = file.flags.buffered !== void 0 ? file.flags.buffered : 1, channel = {
          file,
          offset: file.flags.append ? file.length() : 0,
          fd,
          opened: true,
          out: true,
          buffer_curr: 0,
          buffer: new Uint8Array(65536),
          buffered
        };
        caml_ml_channels[channel.fd] = channel;
        return channel.fd;
      }
      function caml_ml_open_descriptor_out_with_flags(fd, flags) {
        return caml_ml_open_descriptor_out(fd);
      }
      function caml_gr_current_y() {
        var s2 = caml_gr_state_get();
        return s2.y;
      }
      function caml_format_int(fmt, i) {
        if (caml_jsbytes_of_string(fmt) == "%d")
          return caml_string_of_jsbytes("" + i);
        var f = caml_parse_format(fmt);
        if (i < 0)
          if (f.signedconv) {
            f.sign = -1;
            i = -i;
          } else
            i >>>= 0;
        var s2 = i.toString(f.base);
        if (f.prec >= 0) {
          f.filler = " ";
          var n = f.prec - s2.length;
          if (n > 0)
            s2 = caml_str_repeat(n, "0") + s2;
        }
        return caml_finish_formatting(f, s2);
      }
      function jsoo_effect_not_supported() {
        caml_failwith("Effect handlers are not supported");
      }
      var caml_ml_domain_unique_token_ = [0];
      function caml_ml_domain_unique_token(unit) {
        return caml_ml_domain_unique_token_;
      }
      function caml_continuation_use_and_update_handler_noexc(cont, hval, hexn, heff) {
        var stack = caml_continuation_use_noexc(cont);
        stack[3] = [0, hval, hexn, heff];
        return stack;
      }
      function caml_obj_truncate(x2, s2) {
        if (s2 <= 0 || s2 + 1 > x2.length)
          caml_invalid_argument("Obj.truncate");
        if (x2.length != s2 + 1)
          x2.length = s2 + 1;
        return 0;
      }
      function caml_js_to_string(s2) {
        return caml_string_of_jsstring(s2);
      }
      function is_digit_odd(nat, ofs) {
        if (nat.data[ofs] & 1)
          return 1;
        return 0;
      }
      function caml_runtime_variant(_unit) {
        return caml_string_of_jsbytes("");
      }
      function caml_array_concat(l) {
        var a = [0];
        while (l !== 0) {
          var b = l[1];
          for (var i = 1; i < b.length; i++)
            a.push(b[i]);
          l = l[2];
        }
        return a;
      }
      function caml_gr_open_graph(info) {
        var info = caml_jsstring_of_string(info);
        function get(name) {
          var res = info.match("(^|,) *" + name + " *= *([a-zA-Z0-9_]+) *(,|$)");
          if (res)
            return res[2];
        }
        var specs = [];
        if (!(info == ""))
          specs.push(info);
        var target = get("target");
        if (!target)
          target = "";
        var status = get("status");
        if (!status)
          specs.push("status=1");
        var w = get("width");
        w = w ? parseInt(w) : 200;
        specs.push("width=" + w);
        var h = get("height");
        h = h ? parseInt(h) : 200;
        specs.push("height=" + h);
        var win = globalThis.open("about:blank", target, specs.join(","));
        if (!win)
          caml_failwith("Graphics.open_graph: cannot open the window");
        var doc = win.document, canvas = doc.createElement("canvas");
        canvas.width = w;
        canvas.height = h;
        var ctx = caml_gr_state_create(canvas, w, h);
        ctx.set_title = function(title) {
          doc.title = title;
        };
        caml_gr_state_set(ctx);
        var body = doc.body;
        body.style.margin = "0px";
        body.appendChild(canvas);
        return 0;
      }
      function caml_make_float_vect(len) {
        if (len < 0)
          caml_array_bound_error();
        var len = len + 1 | 0, b = new Array(len);
        b[0] = 254;
        for (var i = 1; i < len; i++)
          b[i] = 0;
        return b;
      }
      function caml_cbrt_float(x2) {
        return Math.cbrt(x2);
      }
      function caml_eventlog_pause(unit) {
        return 0;
      }
      function caml_memprof_stop(unit) {
        return 0;
      }
      function caml_greaterequal(x2, y) {
        return +(caml_compare_val(x2, y, false) >= 0);
      }
      function caml_get_exception_raw_backtrace() {
        return [0];
      }
      function caml_log1p_float(x2) {
        return Math.log1p(x2);
      }
      function caml_runtime_events_free_cursor(cursor) {
        return 0;
      }
      function caml_lazy_make_forward(v) {
        return [250, v];
      }
      function lor_digit_nat(nat1, ofs1, nat2, ofs2) {
        nat1.data[ofs1] |= nat2.data[ofs2];
        return 0;
      }
      function caml_gr_blit_image(im, x2, y) {
        var s2 = caml_gr_state_get(), im2 = s2.context.getImageData(x2, s2.height - im.height - y, im.width, im.height);
        for (var i = 0; i < im2.data.length; i += 4) {
          im.data[i] = im2.data[i];
          im.data[i + 1] = im2.data[i + 1];
          im.data[i + 2] = im2.data[i + 2];
          im.data[i + 3] = im2.data[i + 3];
        }
        return 0;
      }
      function caml_gr_window_id(a) {
        caml_failwith("caml_gr_window_id not Implemented");
      }
      function caml_atomic_make_contended(a) {
        return [0, a];
      }
      function caml_js_on_ie() {
        var ua = globalThis.navigator && globalThis.navigator.userAgent ? globalThis.navigator.userAgent : "";
        return ua.indexOf("MSIE") != -1 && ua.indexOf("Opera") != 0;
      }
      function caml_int64_shift_right(x2, s2) {
        return x2.shift_right(s2);
      }
      function caml_ba_layout(ba) {
        return ba.layout;
      }
      function caml_convert_raw_backtrace() {
        return [0];
      }
      function caml_array_set(array, index, newval) {
        if (index < 0 || index >= array.length - 1)
          caml_array_bound_error();
        array[index + 1] = newval;
        return 0;
      }
      function caml_alloc_stack(hv, hx, hf) {
        return 0;
      }
      function caml_bytes_greaterequal(s1, s2) {
        return caml_bytes_lessequal(s2, s1);
      }
      function set_digit_nat(nat, ofs, digit) {
        nat.data[ofs] = digit;
        return 0;
      }
      function caml_bytes_set16(s2, i, i16) {
        if (i >>> 0 >= s2.l - 1)
          caml_bytes_bound_error();
        var b2 = 255 & i16 >> 8, b1 = 255 & i16;
        caml_bytes_unsafe_set(s2, i + 0, b1);
        caml_bytes_unsafe_set(s2, i + 1, b2);
        return 0;
      }
      function caml_gr_doc_of_state(state) {
        if (state.canvas.ownerDocument)
          return state.canvas.ownerDocument;
      }
      function caml_ml_output_int(chanid, i) {
        var arr = [i >> 24 & 255, i >> 16 & 255, i >> 8 & 255, i & 255], s2 = caml_string_of_array(arr);
        caml_ml_output(chanid, s2, 0, 4);
        return 0;
      }
      function caml_obj_with_tag(tag, x2) {
        var l = x2.length, a = new Array(l);
        a[0] = tag;
        for (var i = 1; i < l; i++)
          a[i] = x2[i];
        return a;
      }
      function caml_ml_channel_size(chanid) {
        var chan = caml_ml_channels[chanid];
        return chan.file.length();
      }
      function caml_raw_backtrace_slot() {
        caml_invalid_argument("Printexc.get_raw_backtrace_slot: index out of bounds");
      }
      function caml_hexstring_of_float(x2, prec, style) {
        if (!isFinite(x2)) {
          if (isNaN(x2))
            return caml_string_of_jsstring("nan");
          return caml_string_of_jsstring(x2 > 0 ? "infinity" : "-infinity");
        }
        var sign = x2 == 0 && 1 / x2 == -Infinity ? 1 : x2 >= 0 ? 0 : 1;
        if (sign)
          x2 = -x2;
        var exp = 0;
        if (x2 == 0)
          ;
        else if (x2 < 1)
          while (x2 < 1 && exp > -1022) {
            x2 *= 2;
            exp--;
          }
        else
          while (x2 >= 2) {
            x2 /= 2;
            exp++;
          }
        var exp_sign = exp < 0 ? "" : "+", sign_str = "";
        if (sign)
          sign_str = "-";
        else
          switch (style) {
            case 43:
              sign_str = "+";
              break;
            case 32:
              sign_str = " ";
              break;
            default:
              break;
          }
        if (prec >= 0 && prec < 13) {
          var cst = Math.pow(2, prec * 4);
          x2 = Math.round(x2 * cst) / cst;
        }
        var x_str = x2.toString(16);
        if (prec >= 0) {
          var idx = x_str.indexOf(".");
          if (idx < 0)
            x_str += "." + caml_str_repeat(prec, "0");
          else {
            var size = idx + 1 + prec;
            if (x_str.length < size)
              x_str += caml_str_repeat(size - x_str.length, "0");
            else
              x_str = x_str.substr(0, size);
          }
        }
        return caml_string_of_jsstring(sign_str + "0x" + x_str + "p" + exp_sign + exp.toString(10));
      }
      function caml_runtime_events_user_write(event, event_content) {
        return 0;
      }
      function caml_js_wrap_meth_callback_strict(arity, f) {
        return function() {
          var args = new Array(arity + 1), len = Math.min(arguments.length, arity);
          args[0] = this;
          for (var i = 0; i < len; i++)
            args[i + 1] = arguments[i];
          return caml_callback(f, args);
        };
      }
      function caml_unix_readlink(name) {
        var root = resolve_fs_device(name);
        if (!root.device.readlink)
          caml_failwith("caml_unix_readlink: not implemented");
        return root.device.readlink(root.rest, true);
      }
      function caml_backtrace_status(_unit) {
        return caml_record_backtrace_flag ? 1 : 0;
      }
      function caml_install_signal_handler() {
        return 0;
      }
      function caml_sys_argv(a) {
        return caml_argv;
      }
      function caml_ba_fill(ba, v) {
        ba.fill(v);
        return 0;
      }
      function caml_modf_float(x2) {
        if (isFinite(x2)) {
          var neg = 1 / x2 < 0;
          x2 = Math.abs(x2);
          var i = Math.floor(x2), f = x2 - i;
          if (neg) {
            i = -i;
            f = -f;
          }
          return [0, f, i];
        }
        if (isNaN(x2))
          return [0, NaN, NaN];
        return [0, 1 / x2, x2];
      }
      function caml_gc_get() {
        return [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      }
      function caml_float_compare(x2, y) {
        if (x2 === y)
          return 0;
        if (x2 < y)
          return -1;
        if (x2 > y)
          return 1;
        if (x2 === x2)
          return 1;
        if (y === y)
          return -1;
        return 0;
      }
      function caml_string_set32(s2, i, i32) {
        caml_failwith("caml_string_set32");
      }
      function caml_parse_engine(tables, env, cmd, arg) {
        var ERRCODE = 256, loop = 6, testshift = 7, shift = 8, shift_recover = 9, reduce = 10, READ_TOKEN = 0, RAISE_PARSE_ERROR = 1, GROW_STACKS_1 = 2, GROW_STACKS_2 = 3, COMPUTE_SEMANTIC_ACTION = 4, CALL_ERROR_FUNCTION = 5, env_s_stack = 1, env_v_stack = 2, env_symb_start_stack = 3, env_symb_end_stack = 4, env_stacksize = 5, env_stackbase = 6, env_curr_char = 7, env_lval = 8, env_symb_start = 9, env_symb_end = 10, env_asp = 11, env_rule_len = 12, env_rule_number = 13, env_sp = 14, env_state = 15, env_errflag = 16, tbl_transl_const = 2, tbl_transl_block = 3, tbl_lhs = 4, tbl_len = 5, tbl_defred = 6, tbl_dgoto = 7, tbl_sindex = 8, tbl_rindex = 9, tbl_gindex = 10, tbl_tablesize = 11, tbl_table = 12, tbl_check = 13, tbl_names_const = 15, tbl_names_block = 16;
        function log(x2) {
          var s2 = caml_string_of_jsbytes(x2 + "\n");
          caml_ml_output(2, s2, 0, caml_ml_string_length(s2));
        }
        function token_name(names, number) {
          var str = caml_jsstring_of_string(names);
          if (str[0] == "\0")
            return "<unknown token>";
          return str.split("\0")[number];
        }
        function print_token(state2, tok) {
          var token, kind;
          if (tok instanceof Array) {
            token = token_name(tables[tbl_names_block], tok[0]);
            if (typeof tok[1] == "number")
              kind = "" + tok[1];
            else if (typeof tok[1] == "string")
              kind = tok[1];
            else if (tok[1] instanceof MlBytes)
              kind = caml_jsbytes_of_string(tok[1]);
            else
              kind = "_";
            log("State " + state2 + ": read token " + token + "(" + kind + ")");
          } else {
            token = token_name(tables[tbl_names_const], tok);
            log("State " + state2 + ": read token " + token);
          }
        }
        if (!tables.dgoto) {
          tables.defred = caml_lex_array(tables[tbl_defred]);
          tables.sindex = caml_lex_array(tables[tbl_sindex]);
          tables.check = caml_lex_array(tables[tbl_check]);
          tables.rindex = caml_lex_array(tables[tbl_rindex]);
          tables.table = caml_lex_array(tables[tbl_table]);
          tables.len = caml_lex_array(tables[tbl_len]);
          tables.lhs = caml_lex_array(tables[tbl_lhs]);
          tables.gindex = caml_lex_array(tables[tbl_gindex]);
          tables.dgoto = caml_lex_array(tables[tbl_dgoto]);
        }
        var res = 0, n, n1, n2, state1, sp = env[env_sp], state = env[env_state], errflag = env[env_errflag];
        exit:
          for (; ; )
            next:
              switch (cmd) {
                case 0:
                  state = 0;
                  errflag = 0;
                case 6:
                  n = tables.defred[state];
                  if (n != 0) {
                    cmd = reduce;
                    break;
                  }
                  if (env[env_curr_char] >= 0) {
                    cmd = testshift;
                    break;
                  }
                  res = READ_TOKEN;
                  break exit;
                case 1:
                  if (arg instanceof Array) {
                    env[env_curr_char] = tables[tbl_transl_block][arg[0] + 1];
                    env[env_lval] = arg[1];
                  } else {
                    env[env_curr_char] = tables[tbl_transl_const][arg + 1];
                    env[env_lval] = 0;
                  }
                  if (caml_parser_trace)
                    print_token(state, arg);
                case 7:
                  n1 = tables.sindex[state];
                  n2 = n1 + env[env_curr_char];
                  if (n1 != 0 && n2 >= 0 && n2 <= tables[tbl_tablesize] && tables.check[n2] == env[env_curr_char]) {
                    cmd = shift;
                    break;
                  }
                  n1 = tables.rindex[state];
                  n2 = n1 + env[env_curr_char];
                  if (n1 != 0 && n2 >= 0 && n2 <= tables[tbl_tablesize] && tables.check[n2] == env[env_curr_char]) {
                    n = tables.table[n2];
                    cmd = reduce;
                    break;
                  }
                  if (errflag <= 0) {
                    res = CALL_ERROR_FUNCTION;
                    break exit;
                  }
                case 5:
                  if (errflag < 3) {
                    errflag = 3;
                    for (; ; ) {
                      state1 = env[env_s_stack][sp + 1];
                      n1 = tables.sindex[state1];
                      n2 = n1 + ERRCODE;
                      if (n1 != 0 && n2 >= 0 && n2 <= tables[tbl_tablesize] && tables.check[n2] == ERRCODE) {
                        if (caml_parser_trace)
                          log("Recovering in state " + state1);
                        cmd = shift_recover;
                        break next;
                      } else {
                        if (caml_parser_trace)
                          log("Discarding state " + state1);
                        if (sp <= env[env_stackbase]) {
                          if (caml_parser_trace)
                            log("No more states to discard");
                          return RAISE_PARSE_ERROR;
                        }
                        sp--;
                      }
                    }
                  } else {
                    if (env[env_curr_char] == 0)
                      return RAISE_PARSE_ERROR;
                    if (caml_parser_trace)
                      log("Discarding last token read");
                    env[env_curr_char] = -1;
                    cmd = loop;
                    break;
                  }
                case 8:
                  env[env_curr_char] = -1;
                  if (errflag > 0)
                    errflag--;
                case 9:
                  if (caml_parser_trace)
                    log("State " + state + ": shift to state " + tables.table[n2]);
                  state = tables.table[n2];
                  sp++;
                  if (sp >= env[env_stacksize]) {
                    res = GROW_STACKS_1;
                    break exit;
                  }
                case 2:
                  env[env_s_stack][sp + 1] = state;
                  env[env_v_stack][sp + 1] = env[env_lval];
                  env[env_symb_start_stack][sp + 1] = env[env_symb_start];
                  env[env_symb_end_stack][sp + 1] = env[env_symb_end];
                  cmd = loop;
                  break;
                case 10:
                  if (caml_parser_trace)
                    log("State " + state + ": reduce by rule " + n);
                  var m = tables.len[n];
                  env[env_asp] = sp;
                  env[env_rule_number] = n;
                  env[env_rule_len] = m;
                  sp = sp - m + 1;
                  m = tables.lhs[n];
                  state1 = env[env_s_stack][sp];
                  n1 = tables.gindex[m];
                  n2 = n1 + state1;
                  if (n1 != 0 && n2 >= 0 && n2 <= tables[tbl_tablesize] && tables.check[n2] == state1)
                    state = tables.table[n2];
                  else
                    state = tables.dgoto[m];
                  if (sp >= env[env_stacksize]) {
                    res = GROW_STACKS_2;
                    break exit;
                  }
                case 3:
                  res = COMPUTE_SEMANTIC_ACTION;
                  break exit;
                case 4:
                  env[env_s_stack][sp + 1] = state;
                  env[env_v_stack][sp + 1] = arg;
                  var asp = env[env_asp];
                  env[env_symb_end_stack][sp + 1] = env[env_symb_end_stack][asp + 1];
                  if (sp > asp)
                    env[env_symb_start_stack][sp + 1] = env[env_symb_end_stack][asp + 1];
                  cmd = loop;
                  break;
                default:
                  return RAISE_PARSE_ERROR;
              }
        env[env_sp] = sp;
        env[env_state] = state;
        env[env_errflag] = errflag;
        return res;
      }
      function caml_ml_runtime_events_start() {
        return 0;
      }
      function caml_jsoo_flags_effects(unit) {
        return 0;
      }
      function caml_update_dummy(x2, y) {
        if (y.fun) {
          x2.fun = y.fun;
          return 0;
        }
        if (typeof y === "function") {
          x2.fun = y;
          return 0;
        }
        var i = y.length;
        while (i--)
          x2[i] = y[i];
        return 0;
      }
      function caml_array_fill(array, ofs, len, v) {
        for (var i = 0; i < len; i++)
          array[ofs + i + 1] = v;
        return 0;
      }
      function caml_sys_mkdir(name, perm) {
        var root = resolve_fs_device(name);
        root.device.mkdir(root.rest, perm);
        return 0;
      }
      function caml_string_notequal(s1, s2) {
        return 1 - caml_string_equal(s1, s2);
      }
      function caml_bytes_greaterthan(s1, s2) {
        return caml_bytes_lessthan(s2, s1);
      }
      function caml_gr_make_image(arr) {
        var s2 = caml_gr_state_get(), h = arr.length - 1, w = arr[1].length - 1, im = s2.context.createImageData(w, h);
        for (var i = 0; i < h; i++)
          for (var j = 0; j < w; j++) {
            var c = arr[i + 1][j + 1], o = i * (w * 4) + j * 4;
            if (c == -1) {
              im.data[o + 0] = 0;
              im.data[o + 1] = 0;
              im.data[o + 2] = 0;
              im.data[o + 3] = 0;
            } else {
              im.data[o + 0] = c >> 16 & 255;
              im.data[o + 1] = c >> 8 & 255;
              im.data[o + 2] = c >> 0 & 255;
              im.data[o + 3] = 255;
            }
          }
        return im;
      }
      function caml_ml_set_channel_output(chanid, f) {
        var chan = caml_ml_channels[chanid];
        chan.output = function(s2) {
          f(s2);
        };
        return 0;
      }
      function caml_read_file_content(name) {
        var name = typeof name == "string" ? caml_string_of_jsbytes(name) : name, root = resolve_fs_device(name);
        if (root.device.exists(root.rest)) {
          var file = root.device.open(root.rest, { rdonly: 1 }), len = file.length(), buf = new Uint8Array(len);
          file.read(0, buf, 0, len);
          return caml_string_of_array(buf);
        }
        caml_raise_no_such_file(caml_jsbytes_of_string(name));
      }
      function caml_js_to_float(x2) {
        return x2;
      }
      function caml_setup_uncaught_exception_handler() {
        var process = globalThis.process;
        if (process && process.on)
          process.on(
            "uncaughtException",
            function(err, origin) {
              caml_fatal_uncaught_exception(err);
              process.exit(2);
            }
          );
        else if (globalThis.addEventListener)
          globalThis.addEventListener(
            "error",
            function(event) {
              if (event.error)
                caml_fatal_uncaught_exception(event.error);
            }
          );
      }
      caml_setup_uncaught_exception_handler();
      globalThis.jsoo_runtime = {
        caml_runtime_events_read_poll,
        caml_runtime_events_free_cursor,
        caml_runtime_events_create_cursor,
        caml_ml_runtime_events_resume,
        caml_ml_runtime_events_pause,
        caml_ml_runtime_events_start,
        caml_runtime_events_user_resolve,
        caml_runtime_events_user_write,
        caml_runtime_events_user_register,
        caml_custom_event_index,
        caml_zstd_initialize,
        caml_decompress_input,
        zstd_decompress,
        jsoo_effect_not_supported,
        caml_ml_condition_signal,
        caml_ml_condition_broadcast,
        caml_ml_condition_wait,
        caml_ml_condition_new,
        caml_get_continuation_callstack,
        caml_continuation_use_and_update_handler_noexc,
        caml_continuation_use_noexc,
        caml_alloc_stack,
        caml_ml_mutex_unlock,
        caml_ml_mutex_try_lock,
        caml_ml_mutex_lock,
        caml_ml_mutex_new,
        MlMutex,
        caml_lxm_next,
        caml_ml_domain_cpu_relax,
        caml_ml_domain_id,
        caml_domain_spawn,
        caml_domain_id,
        caml_recommended_domain_count,
        caml_ml_domain_set_name,
        caml_ml_domain_unique_token,
        caml_atomic_make_contended,
        caml_atomic_exchange,
        caml_atomic_fetch_add,
        caml_atomic_cas,
        caml_atomic_load,
        caml_domain_dls_get,
        caml_domain_dls_set,
        caml_domain_dls,
        caml_ephe_check_data,
        caml_ephe_unset_data,
        caml_ephe_set_data,
        caml_ephe_get_data_copy,
        caml_ephe_get_data,
        caml_ephe_blit_data,
        caml_ephe_blit_key,
        caml_ephe_check_key,
        caml_ephe_get_key_copy,
        caml_ephe_get_key,
        caml_weak_set,
        caml_weak_create,
        caml_ephe_create,
        caml_ephe_unset_key,
        caml_ephe_set_key,
        caml_ephe_data_offset,
        caml_ephe_key_offset,
        caml_unix_inet_addr_of_string,
        caml_unix_findclose,
        caml_unix_findnext,
        caml_unix_findfirst,
        caml_unix_rewinddir,
        caml_unix_closedir,
        caml_unix_readdir,
        caml_unix_opendir,
        caml_unix_has_symlink,
        caml_unix_getpwuid,
        caml_unix_getuid,
        caml_unix_unlink,
        caml_unix_readlink,
        caml_unix_symlink,
        caml_unix_rmdir,
        caml_unix_mkdir,
        caml_unix_lstat_64,
        caml_unix_lstat,
        caml_unix_stat_64,
        caml_unix_stat,
        make_unix_err_args,
        caml_unix_isatty,
        caml_unix_filedescr_of_fd,
        caml_unix_cleanup,
        caml_unix_startup,
        caml_unix_mktime,
        caml_unix_localtime,
        caml_unix_gmtime,
        caml_unix_time,
        caml_unix_gettimeofday,
        caml_str_initialize,
        re_replacement_text,
        re_partial_match,
        re_string_match,
        re_search_backward,
        re_search_forward,
        re_match,
        caml_sys_is_regular_file,
        caml_spacetime_only_works_for_native_code,
        caml_register_channel_for_spacetime,
        caml_sys_const_naked_pointers_checked,
        caml_spacetime_enabled,
        caml_ml_runtime_warnings_enabled,
        caml_ml_enable_runtime_warnings,
        caml_runtime_warnings,
        caml_install_signal_handler,
        caml_runtime_parameters,
        caml_runtime_variant,
        caml_sys_isatty,
        caml_sys_get_config,
        os_type,
        caml_sys_const_backend_type,
        caml_sys_const_ostype_cygwin,
        caml_sys_const_ostype_win32,
        caml_sys_const_ostype_unix,
        caml_sys_const_max_wosize,
        caml_sys_const_int_size,
        caml_sys_const_word_size,
        caml_sys_const_big_endian,
        caml_sys_random_seed,
        caml_sys_time_include_children,
        caml_sys_time,
        caml_sys_system_command,
        caml_sys_executable_name,
        caml_sys_modify_argv,
        caml_sys_argv,
        caml_sys_get_argv,
        caml_executable_name,
        caml_argv,
        caml_sys_unsafe_getenv,
        caml_sys_getenv,
        jsoo_sys_getenv,
        caml_set_static_env,
        caml_fatal_uncaught_exception,
        caml_format_exception,
        caml_is_special_exception,
        caml_sys_exit,
        caml_raise_sys_error,
        caml_maybe_print_stats,
        caml_is_printable,
        caml_get_global_data,
        caml_register_global,
        caml_build_symbols,
        caml_global_data,
        caml_named_value,
        caml_register_named_value,
        caml_named_values,
        caml_call_gen,
        caml_set_parser_trace,
        caml_parse_engine,
        caml_parser_trace,
        caml_is_continuation_tag,
        caml_lazy_read_result,
        caml_lazy_reset_to_lazy,
        caml_lazy_update_to_forward,
        caml_lazy_update_to_forcing,
        caml_obj_update_tag,
        caml_obj_add_offset,
        caml_obj_reachable_words,
        caml_obj_set_raw_field,
        caml_obj_raw_field,
        caml_fresh_oo_id,
        caml_set_oo_id,
        caml_oo_last_id,
        caml_get_public_method,
        caml_lazy_make_forward,
        caml_obj_is_shared,
        caml_obj_compare_and_swap,
        caml_obj_make_forward,
        caml_obj_truncate,
        caml_obj_dup,
        caml_obj_with_tag,
        caml_obj_block,
        caml_obj_set_tag,
        caml_obj_tag,
        caml_obj_is_block,
        caml_alloc_dummy_infix,
        caml_update_dummy,
        deserialize_nat,
        serialize_nat,
        lxor_digit_nat,
        lor_digit_nat,
        land_digit_nat,
        compare_nat_real,
        compare_nat,
        compare_digits_nat,
        shift_right_nat,
        div_nat,
        div_digit_nat,
        div_helper,
        shift_left_nat,
        square_nat,
        mult_nat,
        mult_digit_nat,
        sub_nat,
        decr_nat,
        complement_nat,
        add_nat,
        incr_nat,
        is_digit_odd,
        is_digit_zero,
        is_digit_int,
        num_leading_zero_bits_in_digit,
        num_digits_nat,
        nth_digit_nat_native,
        set_digit_nat_native,
        nth_digit_nat,
        set_digit_nat,
        blit_nat,
        set_to_zero_nat,
        create_nat,
        nat_of_array,
        length_nat,
        caml_hash_nat,
        MlNat,
        initialize_nat,
        caml_array_of_bytes,
        caml_array_of_string,
        caml_js_to_string,
        caml_to_js_string,
        caml_js_from_string,
        caml_new_string,
        caml_js_to_byte_string,
        caml_is_ml_string,
        caml_ml_bytes_content,
        caml_is_ml_bytes,
        caml_bytes_of_jsbytes,
        caml_string_of_jsstring,
        caml_jsstring_of_string,
        caml_jsbytes_of_string,
        caml_string_of_jsbytes,
        caml_bytes_of_string,
        caml_string_of_bytes,
        caml_string_lessthan,
        caml_string_lessequal,
        caml_string_equal,
        caml_string_compare,
        caml_ml_string_length,
        caml_string_unsafe_set,
        caml_string_unsafe_get,
        caml_ml_bytes_length,
        caml_blit_string,
        caml_blit_bytes,
        caml_fill_bytes,
        caml_bytes_greaterthan,
        caml_string_greaterthan,
        caml_bytes_greaterequal,
        caml_string_greaterequal,
        caml_bytes_lessthan,
        caml_bytes_lessequal,
        caml_bytes_notequal,
        caml_string_notequal,
        caml_bytes_equal,
        caml_bytes_compare,
        caml_bytes_of_array,
        caml_string_of_array,
        caml_create_bytes,
        caml_create_string,
        caml_uint8_array_of_string,
        caml_uint8_array_of_bytes,
        caml_convert_bytes_to_array,
        caml_convert_string_to_bytes,
        MlBytes,
        caml_bytes_of_utf16_jsstring,
        caml_bytes_set,
        caml_string_set64,
        caml_bytes_set64,
        caml_string_set32,
        caml_bytes_set32,
        caml_string_set16,
        caml_bytes_set16,
        caml_string_set,
        caml_bytes_get,
        caml_bytes_get64,
        caml_string_get64,
        caml_bytes_get32,
        caml_string_get32,
        caml_bytes_get16,
        caml_string_get16,
        caml_string_get,
        caml_bytes_bound_error,
        caml_string_bound_error,
        caml_bytes_unsafe_set,
        caml_bytes_unsafe_get,
        jsoo_is_ascii,
        caml_utf16_of_utf8,
        caml_utf8_of_utf16,
        caml_subarray_to_jsbytes,
        caml_str_repeat,
        caml_md5_bytes,
        caml_MD5Final,
        caml_MD5Update,
        caml_MD5Init,
        caml_MD5Transform,
        caml_md5_string,
        caml_md5_chan,
        caml_output_value_to_buffer,
        caml_output_value_to_bytes,
        caml_output_value_to_string,
        caml_output_val,
        MlObjectTable,
        caml_marshal_data_size,
        caml_marshal_header_size,
        caml_input_value_from_reader,
        caml_custom_ops,
        caml_nativeint_unmarshal,
        caml_int32_unmarshal,
        caml_int64_marshal,
        caml_int64_unmarshal,
        caml_input_value_from_bytes,
        caml_input_value_from_string,
        caml_float_of_bytes,
        BigStringReader,
        MlStringReader,
        UInt8ArrayReader,
        caml_marshal_constants,
        caml_new_lex_engine,
        caml_lex_engine,
        caml_lex_array,
        caml_js_error_of_exception,
        caml_xmlhttprequest_create,
        caml_js_get_console,
        caml_js_html_entities,
        caml_js_html_escape,
        caml_js_on_ie,
        caml_js_object,
        caml_pure_js_expr,
        caml_js_expr,
        caml_js_eval_string,
        caml_js_strict_equals,
        caml_js_equals,
        caml_js_function_arity,
        caml_js_wrap_meth_callback_unsafe,
        caml_js_wrap_meth_callback_strict,
        caml_js_wrap_meth_callback_arguments,
        caml_js_wrap_meth_callback,
        caml_js_wrap_callback_unsafe,
        caml_js_wrap_callback_strict,
        caml_js_wrap_callback_arguments,
        caml_js_wrap_callback,
        caml_ojs_new_arr,
        caml_js_new,
        caml_js_meth_call,
        caml_js_fun_call,
        caml_js_call,
        caml_js_var,
        caml_list_to_js_array,
        caml_list_of_js_array,
        caml_js_to_array,
        caml_js_from_array,
        caml_js_to_int32,
        caml_js_to_float,
        caml_js_from_float,
        caml_js_to_bool,
        caml_js_from_bool,
        caml_js_error_option_of_exception,
        caml_exn_with_js_backtrace,
        caml_maybe_attach_backtrace,
        caml_wrap_exception,
        caml_jsoo_flags_effects,
        caml_jsoo_flags_use_js_string,
        caml_is_js,
        caml_callback,
        caml_trampoline_return,
        caml_trampoline,
        caml_js_typeof,
        caml_js_instanceof,
        caml_js_delete,
        caml_js_get,
        caml_js_set,
        caml_js_pure_expr,
        caml_ml_set_buffered,
        caml_ml_is_buffered,
        caml_ml_output_int,
        caml_ml_pos_out_64,
        caml_ml_pos_out,
        caml_pos_out,
        caml_ml_seek_out_64,
        caml_ml_seek_out,
        caml_seek_out,
        caml_output_value,
        caml_ml_output_char,
        caml_ml_output,
        caml_ml_output_bigarray,
        caml_ml_output_bytes,
        caml_ml_output_ta,
        caml_ml_flush,
        caml_ml_input_scan_line,
        caml_ml_pos_in_64,
        caml_ml_pos_in,
        caml_pos_in,
        caml_ml_seek_in_64,
        caml_ml_seek_in,
        caml_seek_in,
        caml_ml_input_int,
        caml_ml_input_char,
        caml_input_value_to_outside_heap,
        caml_input_value,
        caml_ml_input_block,
        caml_ml_input_bigarray,
        caml_ml_input,
        caml_refill,
        caml_ml_set_channel_refill,
        caml_ml_set_channel_output,
        caml_ml_channel_size_64,
        caml_ml_channel_size,
        caml_ml_close_channel,
        caml_ml_set_binary_mode,
        caml_channel_descriptor,
        caml_ml_open_descriptor_out_with_flags,
        caml_ml_open_descriptor_in_with_flags,
        caml_ml_open_descriptor_in,
        caml_ml_open_descriptor_out,
        caml_ml_out_channels_list,
        caml_ml_channels,
        caml_ml_set_channel_name,
        caml_sys_open,
        caml_sys_close,
        caml_sys_fds,
        caml_int64_bswap,
        caml_int32_bswap,
        caml_bswap16,
        caml_mod,
        caml_div,
        caml_mul,
        caml_int_of_string,
        caml_parse_digit,
        caml_parse_sign_and_base,
        caml_format_int,
        caml_int64_hash,
        caml_int64_to_bytes,
        caml_int64_of_bytes,
        caml_int64_hi32,
        caml_int64_lo32,
        caml_int64_create_lo_hi,
        caml_int64_create_lo_mi_hi,
        caml_int64_of_string,
        caml_int64_format,
        caml_int64_of_float,
        caml_int64_to_float,
        caml_int64_to_int32,
        caml_int64_of_int32,
        caml_int64_mod,
        caml_int64_div,
        caml_int64_shift_right,
        caml_int64_shift_right_unsigned,
        caml_int64_shift_left,
        caml_int64_xor,
        caml_int64_or,
        caml_int64_and,
        caml_int64_is_negative,
        caml_int64_is_zero,
        caml_int64_mul,
        caml_int64_sub,
        caml_int64_add,
        caml_int64_neg,
        caml_int64_compare,
        caml_int64_ult,
        MlInt64,
        caml_int64_offset,
        caml_float_of_string,
        caml_format_float,
        caml_fma_float,
        caml_erfc_float,
        caml_erf_float,
        caml_cbrt_float,
        caml_round_float,
        caml_atanh_float,
        caml_tanh_float,
        caml_asinh_float,
        caml_sinh_float,
        caml_acosh_float,
        caml_cosh_float,
        caml_log10_float,
        caml_hypot_float,
        caml_log2_float,
        caml_log1p_float,
        caml_exp2_float,
        caml_expm1_float,
        caml_signbit_float,
        caml_copysign_float,
        caml_float_compare,
        caml_frexp_float,
        caml_ldexp_float,
        caml_modf_float,
        caml_classify_float,
        caml_int32_float_of_bits,
        caml_trunc_float,
        caml_nextafter_float,
        caml_int64_float_of_bits,
        caml_hexstring_of_float,
        caml_int32_bits_of_float,
        caml_int64_bits_of_float,
        jsoo_floor_log2,
        caml_string_hash,
        caml_hash,
        caml_hash_mix_string,
        caml_hash_mix_bytes,
        caml_hash_mix_bytes_arr,
        caml_hash_mix_jsbytes,
        caml_hash_mix_int64,
        caml_hash_mix_float,
        caml_hash_mix_final,
        caml_hash_mix_int,
        caml_gr_close_subwindow,
        caml_gr_open_subwindow,
        caml_gr_window_id,
        caml_gr_display_mode,
        caml_gr_remember_mode,
        caml_gr_synchronize,
        caml_gr_wait_event,
        caml_gr_sigio_signal,
        caml_gr_sigio_handler,
        caml_gr_blit_image,
        caml_gr_create_image,
        caml_gr_draw_image,
        caml_gr_dump_image,
        caml_gr_make_image,
        caml_gr_text_size,
        caml_gr_set_text_size,
        caml_gr_set_font,
        caml_gr_draw_string,
        caml_gr_draw_char,
        caml_gr_draw_str,
        caml_gr_fill_arc,
        caml_gr_fill_poly,
        caml_gr_fill_rect,
        caml_gr_set_line_width,
        caml_gr_draw_arc,
        caml_gr_arc_aux,
        caml_gr_draw_rect,
        caml_gr_lineto,
        caml_gr_current_y,
        caml_gr_current_x,
        caml_gr_moveto,
        caml_gr_point_color,
        caml_gr_plot,
        caml_gr_set_color,
        caml_gr_size_y,
        caml_gr_size_x,
        caml_gr_clear_graph,
        caml_gr_resize_window,
        caml_gr_set_window_title,
        caml_gr_close_graph,
        caml_gr_doc_of_state,
        caml_gr_state_create,
        caml_gr_state_init,
        caml_gr_open_graph,
        caml_gr_state_set,
        caml_gr_state_get,
        caml_gr_state,
        caml_get_major_credit,
        caml_get_major_bucket,
        caml_get_minor_free,
        caml_gc_minor_words,
        caml_gc_major_slice,
        caml_gc_huge_fallback_count,
        caml_eventlog_pause,
        caml_eventlog_resume,
        caml_memprof_discard,
        caml_memprof_stop,
        caml_memprof_start,
        caml_final_release,
        caml_final_register_called_without_value,
        caml_final_register,
        caml_memprof_set,
        caml_gc_get,
        caml_gc_set,
        caml_gc_stat,
        caml_gc_quick_stat,
        caml_gc_counters,
        caml_gc_compaction,
        caml_gc_full_major,
        caml_gc_major,
        caml_gc_minor,
        caml_sys_open_for_node,
        MlNodeFd,
        MlNodeDevice,
        fs_node_supported,
        MlFakeFd,
        MlFakeFd_out,
        MlFakeFile,
        MlFakeDevice,
        caml_read_file_content,
        jsoo_create_file,
        caml_create_file,
        caml_fs_init,
        jsoo_create_file_extern,
        caml_ba_map_file_bytecode,
        caml_ba_map_file,
        caml_sys_rmdir,
        caml_sys_mkdir,
        caml_sys_rename,
        caml_sys_is_directory,
        caml_sys_remove,
        caml_sys_read_directory,
        caml_sys_file_exists,
        caml_raise_not_a_dir,
        caml_raise_no_such_file,
        caml_sys_chdir,
        caml_sys_getcwd,
        caml_unmount,
        caml_mount_autoload,
        resolve_fs_device,
        caml_list_mount_point,
        jsoo_mount_point,
        caml_make_path,
        path_is_absolute,
        MlFile,
        caml_root,
        caml_get_root,
        caml_current_dir,
        caml_trailing_slash,
        caml_finish_formatting,
        caml_parse_format,
        caml_array_bound_error,
        caml_raise_not_found,
        caml_raise_zero_divide,
        caml_raise_end_of_file,
        caml_invalid_argument,
        caml_failwith,
        caml_raise_with_string,
        caml_raise_with_args,
        caml_raise_with_arg,
        caml_raise_constant,
        caml_lessthan,
        caml_lessequal,
        caml_greaterthan,
        caml_greaterequal,
        caml_notequal,
        caml_equal,
        caml_int_compare,
        caml_compare,
        caml_compare_val,
        caml_compare_val_number_custom,
        caml_compare_val_get_custom,
        caml_compare_val_tag,
        caml_bigstring_blit_ba_to_bytes,
        caml_bigstring_blit_bytes_to_ba,
        caml_bigstring_blit_string_to_ba,
        caml_bigstring_blit_ba_to_ba,
        caml_bigstring_memcmp,
        bigstring_of_typed_array,
        bigstring_of_array_buffer,
        bigstring_to_typed_array,
        bigstring_to_array_buffer,
        caml_hash_mix_bigstring,
        caml_ba_from_typed_array,
        caml_ba_kind_of_typed_array,
        caml_ba_to_typed_array,
        caml_ba_hash,
        caml_ba_create_from,
        caml_ba_deserialize,
        caml_ba_serialize,
        caml_ba_reshape,
        caml_ba_slice,
        caml_ba_sub,
        caml_ba_blit,
        caml_ba_fill,
        caml_ba_set_3,
        caml_ba_set_2,
        caml_ba_set_1,
        caml_ba_uint8_set64,
        caml_ba_uint8_set32,
        caml_ba_uint8_set16,
        caml_ba_set_generic,
        caml_ba_get_3,
        caml_ba_get_2,
        caml_ba_get_1,
        caml_ba_uint8_get64,
        caml_ba_uint8_get32,
        caml_ba_uint8_get16,
        caml_ba_get_generic,
        caml_ba_dim_3,
        caml_ba_dim_2,
        caml_ba_dim_1,
        caml_ba_dim,
        caml_ba_num_dims,
        caml_ba_layout,
        caml_ba_kind,
        caml_ba_change_layout,
        caml_ba_create,
        caml_ba_create_unsafe,
        caml_ba_compare,
        Ml_Bigarray_c_1_1,
        Ml_Bigarray,
        caml_ba_custom_name,
        caml_ba_create_buffer,
        caml_ba_get_size_per_element,
        caml_ba_get_size,
        caml_ba_init,
        caml_convert_raw_backtrace_slot,
        caml_get_current_callstack,
        caml_restore_raw_backtrace,
        caml_raw_backtrace_slot,
        caml_raw_backtrace_next_slot,
        caml_raw_backtrace_length,
        caml_convert_raw_backtrace,
        caml_record_backtrace,
        caml_get_exception_raw_backtrace,
        caml_get_exception_backtrace,
        caml_backtrace_status,
        caml_ml_debug_info_status,
        caml_record_backtrace_flag,
        caml_floatarray_create,
        caml_make_float_vect,
        caml_make_vect,
        caml_check_bound,
        caml_array_fill,
        caml_array_get,
        caml_array_set,
        caml_floatarray_blit,
        caml_array_blit,
        caml_array_concat,
        caml_array_append,
        caml_array_sub
      };
      var cst_Assert_failure = "Assert_failure", cst_Division_by_zero = "Division_by_zero", cst_End_of_file = "End_of_file", cst_Failure = "Failure", cst_Invalid_argument = "Invalid_argument", cst_Match_failure = "Match_failure", cst_Not_found = "Not_found", cst_Out_of_memory = "Out_of_memory", cst_Stack_overflow = "Stack_overflow", cst_Sys_blocked_io = "Sys_blocked_io", cst_Sys_error = "Sys_error", cst_Undefined_recursive_module = "Undefined_recursive_module";
      caml_fs_init();
      caml_register_global(0, [248, cst_Out_of_memory, -1], cst_Out_of_memory);
      caml_register_global(1, [248, cst_Sys_error, -2], cst_Sys_error);
      caml_register_global(2, [248, cst_Failure, -3], cst_Failure);
      caml_register_global(3, [248, cst_Invalid_argument, -4], cst_Invalid_argument);
      caml_register_global(4, [248, cst_End_of_file, -5], cst_End_of_file);
      caml_register_global(5, [248, cst_Division_by_zero, -6], cst_Division_by_zero);
      caml_register_global(6, [248, cst_Not_found, -7], cst_Not_found);
      caml_register_global(7, [248, cst_Match_failure, -8], cst_Match_failure);
      caml_register_global(8, [248, cst_Stack_overflow, -9], cst_Stack_overflow);
      caml_register_global(9, [248, cst_Sys_blocked_io, -10], cst_Sys_blocked_io);
      caml_register_global(10, [248, cst_Assert_failure, -11], cst_Assert_failure);
      caml_register_global(
        11,
        [248, cst_Undefined_recursive_module, -12],
        cst_Undefined_recursive_module
      );
      return;
    })(globalThis);
    (function(a) {
      "use strict";
      var bk = "Stdlib__Obj", w = "Stdlib__Gc", bj = 129, bA = "Stdlib__Random", v = 116, ai = "Js_of_ocaml__PerformanceObserver", a1 = "Stdlib__Either", P = "Stdlib__Map", bz = "Js_of_ocaml__Intl", bi = "Stdlib__Domain", by = "Stdlib__Array", ah = "Assert_failure", u = "Stdlib__Lazy", bw = "Js_of_ocaml__Lib_version", bx = "Jsoo_runtime__", O = "Stdlib__Format", aI = "Stdlib__In_channel", bU = "Js_of_ocaml__EventSource", ag = "Stdlib__BytesLabels", a0 = "Yojson__Raw", bT = "Stdlib__Bytes", N = "End_of_file", bS = "Stdlib__Condition", af = "Stdlib__Marshal", bv = "Js_of_ocaml__CSS", bu = 122, bR = "Out_of_memory", bh = "Parsing__Monad", ae = "Js_of_ocaml__Url", aZ = "Not_found", bQ = "Failure", bg = "Yojson", bt = "Jsoo_runtime__Runtime_version", t = 121, bs = "Stdlib__String", bP = "Stdlib__Printf", aH = "Stdlib", bf = "Stdlib__Callback", aG = "Stdlib__Filename", be = "Stdlib__Hashtbl", br = "Js_of_ocaml__Geolocation", ad = 124, aF = "Yojson__Safe", s2 = "Invalid_argument", bd = "Yojson__Basic", bO = "Stdlib__Mutex", M = "Stdlib__Option", bN = "Stdlib__ListLabels", ac = 120, bq = "Js_of_ocaml__Dom_html", ab = "Js_of_ocaml__Js", ba = "Js_of_ocaml__IntersectionObserver", bb = 125, bc = "Stdlib__MoreLabels", aE = "Js_of_ocaml", r = "Std_exit", L = "Result", a$ = "Js_of_ocaml__Jstable", q = "Typing", bL = "Match_failure", bM = "Stdlib__Semaphore", p = "Stdlib__StringLabels", a_ = "Js_of_ocaml__File", aY = "Js_of_ocaml__Regexp", bJ = 109, bK = "Yojson__Lexer_utils", o = 112, bp = "Stdlib__Complex", aD = "Stdlib__Int64", bI = "Parsing", aa = 118, bo = "Stdlib__Sys", K = "Js_of_ocaml__Dom_svg", aX = "CamlinternalLazy", n = "Stdlib__Scanf", aW = "Parsing__Parser", $ = "Js_of_ocaml__Worker", bH = "Stdlib__Digest", _ = "Stdlib__Char", aV = "Ppx_deriving_yojson_runtime", Z = "Stdlib__Int32", J = "Sys_error", bG = "Stdlib__Type", aC = 107, bn = "Stdlib__Unit", bF = "Stdlib__Nativeint", aU = 126, bE = "Stdlib__Stack", I = "CamlinternalFormat", Y = "Stack_overflow", aT = "Stdlib__ArrayLabels", a9 = "Stdlib__Printexc", m = 108, H = "Js_of_ocaml__WebSockets", X = "Stdlib__Arg", aS = "Js_of_ocaml__", a8 = "Js_of_ocaml__Form", W = "Js_of_ocaml__Dom_events", aB = "Undefined_recursive_module", G = "Js_of_ocaml__ResizeObserver", az = "CamlinternalFormatBasics", aA = "Js_of_ocaml__WebGL", ay = "Stdlib__Queue", l = "Stdlib__Bool", F = "Jsoo_runtime", a7 = "Division_by_zero", k = "Js_of_ocaml__Dom", ax = "CamlinternalMod", aw = 114, av = "Stdlib__Parsing", a5 = 119, a6 = "Stdlib__Weak", E = 110, au = 113, at = "Stdlib__Effect", a4 = 101, j = "Stdlib__Int", C = "Stdlib__StdLabels", D = 128, bD = "Js_of_ocaml__Typed_array", i = "Stdlib__Oo", ar = "Stdlib__Bigarray", as = "Stdlib__List", aR = "Stdlib__Ephemeron", h = 130, bm = "Yojson__Common", aq = "Js_of_ocaml__MutationObserver", a3 = 100, g = 106, ap = 111, aQ = "Stdlib__Fun", f = 117, V = "Stdlib__Lexing", B = 102, ao = "Js_of_ocaml__Json", bC = "Stdlib__Atomic", aP = "Stdlib__Result", e = "Js_of_ocaml__XmlHttpRequest", an = "Stdlib__Set", am = 123, aO = "Stdlib__Buffer", a2 = "Js_of_ocaml__Import", bl = "Yojson__", U = "Dune__exe__Main", A = "Typing__Typexpr", aN = "Stdlib__Out_channel", bB = "Ppx_deriving_runtime", z = "Stdlib__Seq", d = 103, T = 115, al = 127, ak = "Sys_blocked_io", S = "Stdlib__Float", aj = "Stdlib__Uchar", aM = 105, y = "CamlinternalOO", R = "Parsing__Syntax", aL = "Yojson__Codec", Q = 104, x2 = "Js_of_ocaml__Firebug", aJ = "Js_of_ocaml__Sys_js", aK = "Yojson__T", c = a.jsoo_runtime, b = c.caml_get_global_data();
      b.prim_count = 864;
      b.tocjs = [0, [0, aK, 88], [0, aF, 87], [0, a0, 86], [0, bK, 84], [0, bm, 83], [0, aL, 82], [0, bd, 85], [0, bl, 81], [0, bg, 89], [0, aB, 11], [0, A, D], [0, q, al], [0, J, 10], [0, ak, 9], [0, a6, 59], [0, bn, 31], [0, aj, 26], [0, bG, 17], [0, bo, 15], [0, p, 72], [0, bs, 30], [0, C, 74], [0, bE, 42], [0, an, 40], [0, z, 21], [0, bM, 47], [0, n, 61], [0, aP, 23], [0, bA, 57], [0, ay, 43], [0, bP, 50], [0, a9, 52], [0, av, 39], [0, aN, 76], [0, M, 22], [0, i, 64], [0, bk, 16], [0, bF, 37], [0, bO, 45], [0, bc, 73], [0, af, 32], [0, P, 41], [0, bN, 70], [0, as, 27], [0, V, 38], [0, u, 20], [0, aD, 36], [0, Z, 35], [0, j, 28], [0, aI, 75], [0, be, 58], [0, w, 54], [0, aQ, 53], [0, O, 60], [0, S, 34], [0, aG, 67], [0, aR, 66], [0, a1, 14], [0, at, 77], [0, bi, 48], [0, bH, 55], [0, bS, 46], [0, bp, 68], [0, _, 25], [0, bf, 62], [0, ag, 71], [0, bT, 29], [0, aO, 44], [0, l, 24], [0, ar, 56], [0, bC, 18], [0, aT, 69], [0, by, 33], [0, X, 51], [0, aH, 13], [0, r, h], [0, Y, 8], [0, L, 78], [0, aV, 80], [0, bB, 79], [0, R, ad], [0, aW, aU], [0, bh, bb], [0, bI, am], [0, bR, 7], [0, aZ, 6], [0, bL, 5], [0, bt, 91], [0, bx, 90], [0, F, 92], [0, e, a4], [0, $, B], [0, H, d], [0, aA, Q], [0, ae, g], [0, bD, 97], [0, aJ, m], [0, G, bJ], [0, aY, aM], [0, ai, E], [0, aq, ap], [0, bw, aC], [0, a$, o], [0, ao, au], [0, ab, 95], [0, bz, t], [0, ba, ac], [0, a2, 94], [0, br, a5], [0, a8, a3], [0, x2, aa], [0, a_, 98], [0, bU, f], [0, K, v], [0, bq, 99], [0, W, T], [0, k, 96], [0, bv, aw], [0, aS, 93], [0, aE, bu], [0, s2, 4], [0, bQ, 3], [0, N, 2], [0, U, bj], [0, a7, 1], [0, y, 63], [0, ax, 65], [0, aX, 19], [0, az, 12], [0, I, 49], [0, ah, 0]];
      var bV = [2, bU], bW = [2, bz], bX = [2, ao], bY = [2, A], bZ = [2, aK];
      b.toc = [0, [0, 131, [0, [0, [0, [0, [0, [0, [0, 0, [2, ah], 0, [0, 0, [2, I], 49, 0, 1], 2], [2, az], 12, 0, 3], [2, aX], 19, [0, [0, [0, 0, [2, ax], 65, 0, 1], [2, y], 63, 0, 2], [2, a7], 1, [0, [0, 0, [2, U], bj, 0, 1], [2, N], 2, 0, 2], 3], 4], [2, bQ], 3, [0, [0, [0, 0, [2, s2], 4, [0, 0, [2, aE], bu, 0, 1], 2], [2, aS], 93, [0, 0, [2, bv], aw, 0, 1], 3], [2, k], 96, [0, [0, [0, 0, [2, W], T, 0, 1], [2, bq], 99, [0, 0, [2, K], v, [0, 0, bV, f, 0, 1], 2], 3], [2, a_], 98, [0, [0, 0, [2, x2], aa, 0, 1], [2, a8], a3, [0, 0, [2, br], a5, 0, 1], 2], 4], 5], 6], [2, a2], 94, [0, [0, [0, [0, [0, 0, [2, ba], ac, [0, 0, bW, t, 0, 1], 2], [2, ab], 95, [0, [0, 0, bX, au, 0, 1], [2, a$], o, 0, 2], 3], [2, bw], aC, [0, [0, 0, [2, aq], ap, 0, 1], [2, ai], E, 0, 2], 4], [2, aY], aM, [0, [0, 0, [2, G], bJ, 0, 1], [2, aJ], m, 0, 2], 5], [2, bD], 97, [0, [0, [0, [0, 0, [2, ae], g, 0, 1], [2, aA], Q, 0, 2], [2, H], d, 0, 3], [2, $], B, [0, 0, [2, e], a4, 0, 1], 4], 6], 7], [2, F], 92, [0, [0, [0, [0, 0, [2, bx], 90, [0, 0, [2, bt], 91, 0, 1], 2], [2, bL], 5, [0, 0, [2, aZ], 6, 0, 1], 3], [2, bR], 7, [0, [0, [0, 0, [2, bI], am, 0, 1], [2, bh], bb, [0, [0, 0, [2, aW], aU, 0, 1], [2, R], ad, 0, 2], 3], [2, bB], 79, [0, [0, 0, [2, aV], 80, 0, 1], [2, L], 78, [0, 0, [2, Y], 8, [0, 0, [2, r], h, 0, 1], 2], 3], 4], 5], [2, aH], 13, [0, [0, [0, [0, 0, [2, X], 51, 0, 1], [2, by], 33, [0, 0, [2, aT], 69, 0, 1], 2], [2, bC], 18, [0, 0, [2, ar], 56, 0, 1], 3], [2, l], 24, [0, [0, [0, 0, [2, aO], 44, 0, 1], [2, bT], 29, [0, [0, 0, [2, ag], 71, 0, 1], [2, bf], 62, 0, 2], 3], [2, _], 25, [0, [0, 0, [2, bp], 68, 0, 1], [2, bS], 46, [0, [0, 0, [2, bH], 55, 0, 1], [2, bi], 48, [0, 0, [2, at], 77, 0, 1], 2], 3], 4], 5], 6], 8], [2, a1], 14, [0, [0, [0, [0, [0, [0, 0, [2, aR], 66, [0, 0, [2, aG], 67, 0, 1], 2], [2, S], 34, [0, 0, [2, O], 60, 0, 1], 3], [2, aQ], 53, [0, 0, [2, w], 54, [0, 0, [2, be], 58, [0, 0, [2, aI], 75, 0, 1], 2], 3], 4], [2, j], 28, [0, 0, [2, Z], 35, [0, 0, [2, aD], 36, 0, 1], 2], 5], [2, u], 20, [0, [0, [0, 0, [2, V], 38, 0, 1], [2, as], 27, [0, [0, 0, [2, bN], 70, 0, 1], [2, P], 41, 0, 2], 3], [2, af], 32, [0, [0, [0, 0, [2, bc], 73, 0, 1], [2, bO], 45, 0, 2], [2, bF], 37, 0, 3], 4], 6], [2, bk], 16, [0, [0, [0, [0, [0, [0, 0, [2, i], 64, 0, 1], [2, M], 22, [0, 0, [2, aN], 76, 0, 1], 2], [2, av], 39, [0, [0, 0, [2, a9], 52, 0, 1], [2, bP], 50, 0, 2], 3], [2, ay], 43, [0, [0, 0, [2, bA], 57, 0, 1], [2, aP], 23, [0, [0, 0, [2, n], 61, 0, 1], [2, bM], 47, 0, 2], 3], 4], [2, z], 21, [0, [0, 0, [2, an], 40, [0, 0, [2, bE], 42, [0, 0, [2, C], 74, 0, 1], 2], 3], [2, bs], 30, [0, 0, [2, p], 72, 0, 1], 4], 5], [2, bo], 15, [0, [0, [0, 0, [2, bG], 17, 0, 1], [2, aj], 26, [0, 0, [2, bn], 31, [0, 0, [2, a6], 59, 0, 1], 2], 3], [2, ak], 9, [0, [0, [0, 0, [2, J], 10, [0, 0, [2, q], al, [0, 0, bY, D, 0, 1], 2], 3], [2, aB], 11, [0, [0, 0, [2, bg], 89, 0, 1], [2, bl], 81, [0, 0, [2, bd], 85, 0, 1], 2], 4], [2, aL], 82, [0, [0, 0, [2, bm], 83, 0, 1], [2, bK], 84, [0, 0, [2, a0], 86, [0, 0, [2, aF], 87, [0, 0, bZ, 88, 0, 1], 2], 3], 4], 5], 6], 7], 8], 9]], 0, c.caml_list_of_js_array(["%caml_format_int_special", "%direct_int_div", "%direct_int_mod", "%direct_int_mul", "%direct_obj_tag", "%identity", "%int_add", "%int_and", "%int_asr", "%int_div", "%int_lsl", "%int_lsr", "%int_mod", "%int_mul", "%int_neg", "%int_or", "%int_sub", "%int_xor", "BigStringReader", "MlBytes", "MlFakeDevice", "MlFakeFd", "MlFakeFd_out", "MlFakeFile", "MlFile", "MlInt64", "MlMutex", "MlNat", "MlNodeDevice", "MlNodeFd", "MlObjectTable", "MlStringReader", "Ml_Bigarray", "Ml_Bigarray_c_1_1", "UInt8ArrayReader", "add_nat", "bigstring_of_array_buffer", "bigstring_of_typed_array", "bigstring_to_array_buffer", "bigstring_to_typed_array", "blit_nat", "caml_MD5Final", "caml_MD5Init", "caml_MD5Transform", "caml_MD5Update", "caml_abs_float", "caml_acos_float", "caml_acosh_float", "caml_add_float", "caml_alloc_dummy", "caml_alloc_dummy_float", "caml_alloc_dummy_infix", "caml_alloc_stack", "caml_argv", "caml_array_append", "caml_array_blit", "caml_array_bound_error", "caml_array_concat", "caml_array_fill", "caml_array_get", "caml_array_get_addr", "caml_array_get_float", "caml_array_of_bytes", "caml_array_of_string", "caml_array_set", "caml_array_set_addr", "caml_array_set_float", "caml_array_sub", "caml_array_unsafe_get", "caml_array_unsafe_get_float", "caml_array_unsafe_set", "caml_array_unsafe_set_float", "caml_asin_float", "caml_asinh_float", "caml_atan2_float", "caml_atan_float", "caml_atanh_float", "caml_atomic_cas", "caml_atomic_exchange", "caml_atomic_fetch_add", "caml_atomic_load", "caml_atomic_make_contended", "caml_ba_blit", "caml_ba_change_layout", "caml_ba_compare", "caml_ba_create", "caml_ba_create_buffer", "caml_ba_create_from", "caml_ba_create_unsafe", "caml_ba_custom_name", "caml_ba_deserialize", "caml_ba_dim", "caml_ba_dim_1", "caml_ba_dim_2", "caml_ba_dim_3", "caml_ba_fill", "caml_ba_from_typed_array", "caml_ba_get_1", "caml_ba_get_2", "caml_ba_get_3", "caml_ba_get_generic", "caml_ba_get_size", "caml_ba_get_size_per_element", "caml_ba_hash", "caml_ba_init", "caml_ba_kind", "caml_ba_kind_of_typed_array", "caml_ba_layout", "caml_ba_map_file", "caml_ba_map_file_bytecode", "caml_ba_num_dims", "caml_ba_reshape", "caml_ba_serialize", "caml_ba_set_1", "caml_ba_set_2", "caml_ba_set_3", "caml_ba_set_generic", "caml_ba_slice", "caml_ba_sub", "caml_ba_to_typed_array", "caml_ba_uint8_get16", "caml_ba_uint8_get32", "caml_ba_uint8_get64", "caml_ba_uint8_set16", "caml_ba_uint8_set32", "caml_ba_uint8_set64", "caml_backtrace_status", "caml_bigstring_blit_ba_to_ba", "caml_bigstring_blit_ba_to_bytes", "caml_bigstring_blit_bytes_to_ba", "caml_bigstring_blit_string_to_ba", "caml_bigstring_memcmp", "caml_blit_bytes", "caml_blit_string", "caml_bswap16", "caml_build_symbols", "caml_bytes_bound_error", "caml_bytes_compare", "caml_bytes_equal", "caml_bytes_get", "caml_bytes_get16", "caml_bytes_get32", "caml_bytes_get64", "caml_bytes_greaterequal", "caml_bytes_greaterthan", "caml_bytes_lessequal", "caml_bytes_lessthan", "caml_bytes_notequal", "caml_bytes_of_array", "caml_bytes_of_jsbytes", "caml_bytes_of_string", "caml_bytes_of_utf16_jsstring", "caml_bytes_set", "caml_bytes_set16", "caml_bytes_set32", "caml_bytes_set64", "caml_bytes_unsafe_get", "caml_bytes_unsafe_set", "caml_call_gen", "caml_callback", "caml_cbrt_float", "caml_ceil_float", "caml_channel_descriptor", "caml_check_bound", "caml_classify_float", "caml_compare", "caml_compare_val", "caml_compare_val_get_custom", "caml_compare_val_number_custom", "caml_compare_val_tag", "caml_continuation_use_and_update_handler_noexc", "caml_continuation_use_noexc", "caml_convert_bytes_to_array", "caml_convert_raw_backtrace", "caml_convert_raw_backtrace_slot", "caml_convert_string_to_bytes", "caml_copysign_float", "caml_cos_float", "caml_cosh_float", "caml_create_bytes", "caml_create_file", "caml_create_string", "caml_current_dir", "caml_custom_event_index", "caml_custom_ops", "caml_decompress_input", "caml_div", "caml_div_float", "caml_domain_dls", "caml_domain_dls_get", "caml_domain_dls_set", "caml_domain_id", "caml_domain_spawn", "caml_ensure_stack_capacity", "caml_ephe_blit_data", "caml_ephe_blit_key", "caml_ephe_check_data", "caml_ephe_check_key", "caml_ephe_create", "caml_ephe_data_offset", "caml_ephe_get_data", "caml_ephe_get_data_copy", "caml_ephe_get_key", "caml_ephe_get_key_copy", "caml_ephe_key_offset", "caml_ephe_set_data", "caml_ephe_set_key", "caml_ephe_unset_data", "caml_ephe_unset_key", "caml_eq_float", "caml_equal", "caml_erf_float", "caml_erfc_float", "caml_eventlog_pause", "caml_eventlog_resume", "caml_executable_name", "caml_exn_with_js_backtrace", "caml_exp2_float", "caml_exp_float", "caml_expm1_float", "caml_failwith", "caml_fatal_uncaught_exception", "caml_fill_bytes", "caml_fill_string", "caml_final_register", "caml_final_register_called_without_value", "caml_final_release", "caml_finish_formatting", "caml_float_compare", "caml_float_of_bytes", "caml_float_of_int", "caml_float_of_string", "caml_floatarray_blit", "caml_floatarray_create", "caml_floatarray_get", "caml_floatarray_set", "caml_floatarray_unsafe_get", "caml_floatarray_unsafe_set", "caml_floor_float", "caml_fma_float", "caml_fmod_float", "caml_format_exception", "caml_format_float", "caml_format_int", "caml_fresh_oo_id", "caml_frexp_float", "caml_fs_init", "caml_gc_compaction", "caml_gc_counters", "caml_gc_full_major", "caml_gc_get", "caml_gc_huge_fallback_count", "caml_gc_major", "caml_gc_major_slice", "caml_gc_minor", "caml_gc_minor_words", "caml_gc_quick_stat", "caml_gc_set", "caml_gc_stat", "caml_ge_float", "caml_get_continuation_callstack", "caml_get_current_callstack", "caml_get_exception_backtrace", "caml_get_exception_raw_backtrace", "caml_get_global_data", "caml_get_major_bucket", "caml_get_major_credit", "caml_get_minor_free", "caml_get_public_method", "caml_get_root", "caml_global_data", "caml_gr_arc_aux", "caml_gr_blit_image", "caml_gr_clear_graph", "caml_gr_close_graph", "caml_gr_close_subwindow", "caml_gr_create_image", "caml_gr_current_x", "caml_gr_current_y", "caml_gr_display_mode", "caml_gr_doc_of_state", "caml_gr_draw_arc", "caml_gr_draw_char", "caml_gr_draw_image", "caml_gr_draw_rect", "caml_gr_draw_str", "caml_gr_draw_string", "caml_gr_dump_image", "caml_gr_fill_arc", "caml_gr_fill_poly", "caml_gr_fill_rect", "caml_gr_lineto", "caml_gr_make_image", "caml_gr_moveto", "caml_gr_open_graph", "caml_gr_open_subwindow", "caml_gr_plot", "caml_gr_point_color", "caml_gr_remember_mode", "caml_gr_resize_window", "caml_gr_set_color", "caml_gr_set_font", "caml_gr_set_line_width", "caml_gr_set_text_size", "caml_gr_set_window_title", "caml_gr_sigio_handler", "caml_gr_sigio_signal", "caml_gr_size_x", "caml_gr_size_y", "caml_gr_state", "caml_gr_state_create", "caml_gr_state_get", "caml_gr_state_init", "caml_gr_state_set", "caml_gr_synchronize", "caml_gr_text_size", "caml_gr_wait_event", "caml_gr_window_id", "caml_greaterequal", "caml_greaterthan", "caml_gt_float", "caml_hash", "caml_hash_mix_bigstring", "caml_hash_mix_bytes", "caml_hash_mix_bytes_arr", "caml_hash_mix_final", "caml_hash_mix_float", "caml_hash_mix_int", "caml_hash_mix_int64", "caml_hash_mix_jsbytes", "caml_hash_mix_string", "caml_hash_nat", "caml_hexstring_of_float", "caml_hypot_float", "caml_input_value", "caml_input_value_from_bytes", "caml_input_value_from_reader", "caml_input_value_from_string", "caml_input_value_to_outside_heap", "caml_install_signal_handler", "caml_int32_add", "caml_int32_and", "caml_int32_bits_of_float", "caml_int32_bswap", "caml_int32_compare", "caml_int32_div", "caml_int32_float_of_bits", "caml_int32_format", "caml_int32_mod", "caml_int32_mul", "caml_int32_neg", "caml_int32_of_float", "caml_int32_of_int", "caml_int32_of_string", "caml_int32_or", "caml_int32_shift_left", "caml_int32_shift_right", "caml_int32_shift_right_unsigned", "caml_int32_sub", "caml_int32_to_float", "caml_int32_to_int", "caml_int32_unmarshal", "caml_int32_xor", "caml_int64_add", "caml_int64_and", "caml_int64_bits_of_float", "caml_int64_bswap", "caml_int64_compare", "caml_int64_create_lo_hi", "caml_int64_create_lo_mi_hi", "caml_int64_div", "caml_int64_float_of_bits", "caml_int64_format", "caml_int64_hash", "caml_int64_hi32", "caml_int64_is_negative", "caml_int64_is_zero", "caml_int64_lo32", "caml_int64_marshal", "caml_int64_mod", "caml_int64_mul", "caml_int64_neg", "caml_int64_of_bytes", "caml_int64_of_float", "caml_int64_of_int", "caml_int64_of_int32", "caml_int64_of_nativeint", "caml_int64_of_string", "caml_int64_offset", "caml_int64_or", "caml_int64_shift_left", "caml_int64_shift_right", "caml_int64_shift_right_unsigned", "caml_int64_sub", "caml_int64_to_bytes", "caml_int64_to_float", "caml_int64_to_int", "caml_int64_to_int32", "caml_int64_to_nativeint", "caml_int64_ult", "caml_int64_unmarshal", "caml_int64_xor", "caml_int_compare", "caml_int_of_float", "caml_int_of_string", "caml_invalid_argument", "caml_is_continuation_tag", "caml_is_js", "caml_is_ml_bytes", "caml_is_ml_string", "caml_is_printable", "caml_is_special_exception", "caml_js_call", "caml_js_delete", "caml_js_equals", "caml_js_error_of_exception", "caml_js_error_option_of_exception", "caml_js_eval_string", "caml_js_expr", "caml_js_from_array", "caml_js_from_bool", "caml_js_from_float", "caml_js_from_int32", "caml_js_from_nativeint", "caml_js_from_string", "caml_js_fun_call", "caml_js_function_arity", "caml_js_get", "caml_js_get_console", "caml_js_html_entities", "caml_js_html_escape", "caml_js_instanceof", "caml_js_meth_call", "caml_js_new", "caml_js_object", "caml_js_on_ie", "caml_js_pure_expr", "caml_js_set", "caml_js_strict_equals", "caml_js_to_array", "caml_js_to_bool", "caml_js_to_byte_string", "caml_js_to_float", "caml_js_to_int32", "caml_js_to_nativeint", "caml_js_to_string", "caml_js_typeof", "caml_js_var", "caml_js_wrap_callback", "caml_js_wrap_callback_arguments", "caml_js_wrap_callback_strict", "caml_js_wrap_callback_unsafe", "caml_js_wrap_meth_callback", "caml_js_wrap_meth_callback_arguments", "caml_js_wrap_meth_callback_strict", "caml_js_wrap_meth_callback_unsafe", "caml_jsbytes_of_string", "caml_jsoo_flags_effects", "caml_jsoo_flags_use_js_string", "caml_jsstring_of_string", "caml_lazy_make_forward", "caml_lazy_read_result", "caml_lazy_reset_to_lazy", "caml_lazy_update_to_forcing", "caml_lazy_update_to_forward", "caml_ldexp_float", "caml_le_float", "caml_lessequal", "caml_lessthan", "caml_lex_array", "caml_lex_engine", "caml_list_mount_point", "caml_list_of_js_array", "caml_list_to_js_array", "caml_log10_float", "caml_log1p_float", "caml_log2_float", "caml_log_float", "caml_lt_float", "caml_lxm_next", "caml_make_array", "caml_make_float_vect", "caml_make_path", "caml_make_vect", "caml_marshal_constants", "caml_marshal_data_size", "caml_marshal_header_size", "caml_maybe_attach_backtrace", "caml_maybe_print_stats", "caml_md5_bytes", "caml_md5_chan", "caml_md5_string", "caml_memprof_discard", "caml_memprof_set", "caml_memprof_start", "caml_memprof_stop", "caml_ml_bytes_content", "caml_ml_bytes_length", "caml_ml_channel_size", "caml_ml_channel_size_64", "caml_ml_channels", "caml_ml_close_channel", "caml_ml_condition_broadcast", "caml_ml_condition_new", "caml_ml_condition_signal", "caml_ml_condition_wait", "caml_ml_debug_info_status", "caml_ml_domain_cpu_relax", "caml_ml_domain_id", "caml_ml_domain_set_name", "caml_ml_domain_unique_token", "caml_ml_enable_runtime_warnings", "caml_ml_flush", "caml_ml_input", "caml_ml_input_bigarray", "caml_ml_input_block", "caml_ml_input_char", "caml_ml_input_int", "caml_ml_input_scan_line", "caml_ml_is_buffered", "caml_ml_mutex_lock", "caml_ml_mutex_new", "caml_ml_mutex_try_lock", "caml_ml_mutex_unlock", "caml_ml_open_descriptor_in", "caml_ml_open_descriptor_in_with_flags", "caml_ml_open_descriptor_out", "caml_ml_open_descriptor_out_with_flags", "caml_ml_out_channels_list", "caml_ml_output", "caml_ml_output_bigarray", "caml_ml_output_bytes", "caml_ml_output_char", "caml_ml_output_int", "caml_ml_output_ta", "caml_ml_pos_in", "caml_ml_pos_in_64", "caml_ml_pos_out", "caml_ml_pos_out_64", "caml_ml_runtime_events_pause", "caml_ml_runtime_events_resume", "caml_ml_runtime_events_start", "caml_ml_runtime_warnings_enabled", "caml_ml_seek_in", "caml_ml_seek_in_64", "caml_ml_seek_out", "caml_ml_seek_out_64", "caml_ml_set_binary_mode", "caml_ml_set_buffered", "caml_ml_set_channel_name", "caml_ml_set_channel_output", "caml_ml_set_channel_refill", "caml_ml_string_length", "caml_mod", "caml_modf_float", "caml_mount_autoload", "caml_mul", "caml_mul_float", "caml_named_value", "caml_named_values", "caml_nativeint_add", "caml_nativeint_and", "caml_nativeint_bswap", "caml_nativeint_compare", "caml_nativeint_div", "caml_nativeint_format", "caml_nativeint_mod", "caml_nativeint_mul", "caml_nativeint_neg", "caml_nativeint_of_float", "caml_nativeint_of_int", "caml_nativeint_of_int32", "caml_nativeint_of_string", "caml_nativeint_or", "caml_nativeint_shift_left", "caml_nativeint_shift_right", "caml_nativeint_shift_right_unsigned", "caml_nativeint_sub", "caml_nativeint_to_float", "caml_nativeint_to_int", "caml_nativeint_to_int32", "caml_nativeint_unmarshal", "caml_nativeint_xor", "caml_neg_float", "caml_neq_float", "caml_new_lex_engine", "caml_new_string", "caml_nextafter_float", "caml_notequal", "caml_obj_add_offset", "caml_obj_block", "caml_obj_compare_and_swap", "caml_obj_dup", "caml_obj_is_block", "caml_obj_is_shared", "caml_obj_make_forward", "caml_obj_raw_field", "caml_obj_reachable_words", "caml_obj_set_raw_field", "caml_obj_set_tag", "caml_obj_tag", "caml_obj_truncate", "caml_obj_update_tag", "caml_obj_with_tag", "caml_ojs_new_arr", "caml_oo_last_id", "caml_output_val", "caml_output_value", "caml_output_value_to_buffer", "caml_output_value_to_bytes", "caml_output_value_to_string", "caml_parse_digit", "caml_parse_engine", "caml_parse_format", "caml_parse_sign_and_base", "caml_parser_trace", "caml_pos_in", "caml_pos_out", "caml_power_float", "caml_pure_js_expr", "caml_raise_constant", "caml_raise_end_of_file", "caml_raise_no_such_file", "caml_raise_not_a_dir", "caml_raise_not_found", "caml_raise_sys_error", "caml_raise_with_arg", "caml_raise_with_args", "caml_raise_with_string", "caml_raise_zero_divide", "caml_raw_backtrace_length", "caml_raw_backtrace_next_slot", "caml_raw_backtrace_slot", "caml_read_file_content", "caml_recommended_domain_count", "caml_record_backtrace", "caml_record_backtrace_flag", "caml_refill", "caml_register_channel_for_spacetime", "caml_register_global", "caml_register_named_value", "caml_restore_raw_backtrace", "caml_root", "caml_round_float", "caml_runtime_events_create_cursor", "caml_runtime_events_free_cursor", "caml_runtime_events_pause", "caml_runtime_events_read_poll", "caml_runtime_events_resume", "caml_runtime_events_start", "caml_runtime_events_user_register", "caml_runtime_events_user_resolve", "caml_runtime_events_user_write", "caml_runtime_parameters", "caml_runtime_variant", "caml_runtime_warnings", "caml_seek_in", "caml_seek_out", "caml_set_oo_id", "caml_set_parser_trace", "caml_set_static_env", "caml_signbit_float", "caml_sin_float", "caml_sinh_float", "caml_spacetime_enabled", "caml_spacetime_only_works_for_native_code", "caml_sqrt_float", "caml_str_initialize", "caml_str_repeat", "caml_string_bound_error", "caml_string_compare", "caml_string_equal", "caml_string_get", "caml_string_get16", "caml_string_get32", "caml_string_get64", "caml_string_greaterequal", "caml_string_greaterthan", "caml_string_hash", "caml_string_lessequal", "caml_string_lessthan", "caml_string_notequal", "caml_string_of_array", "caml_string_of_bytes", "caml_string_of_jsbytes", "caml_string_of_jsstring", "caml_string_set", "caml_string_set16", "caml_string_set32", "caml_string_set64", "caml_string_unsafe_get", "caml_string_unsafe_set", "caml_sub_float", "caml_subarray_to_jsbytes", "caml_sys_argv", "caml_sys_chdir", "caml_sys_close", "caml_sys_const_backend_type", "caml_sys_const_big_endian", "caml_sys_const_int_size", "caml_sys_const_max_wosize", "caml_sys_const_naked_pointers_checked", "caml_sys_const_ostype_cygwin", "caml_sys_const_ostype_unix", "caml_sys_const_ostype_win32", "caml_sys_const_word_size", "caml_sys_executable_name", "caml_sys_exit", "caml_sys_fds", "caml_sys_file_exists", "caml_sys_get_argv", "caml_sys_get_config", "caml_sys_getcwd", "caml_sys_getenv", "caml_sys_is_directory", "caml_sys_is_regular_file", "caml_sys_isatty", "caml_sys_mkdir", "caml_sys_modify_argv", "caml_sys_open", "caml_sys_open_for_node", "caml_sys_random_seed", "caml_sys_read_directory", "caml_sys_remove", "caml_sys_rename", "caml_sys_rmdir", "caml_sys_system_command", "caml_sys_time", "caml_sys_time_include_children", "caml_sys_unsafe_getenv", "caml_tan_float", "caml_tanh_float", "caml_to_js_string", "caml_trailing_slash", "caml_trampoline", "caml_trampoline_return", "caml_trunc_float", "caml_uint8_array_of_bytes", "caml_uint8_array_of_string", "caml_unix_cleanup", "caml_unix_closedir", "caml_unix_filedescr_of_fd", "caml_unix_findclose", "caml_unix_findfirst", "caml_unix_findnext", "caml_unix_getpwuid", "caml_unix_gettimeofday", "caml_unix_getuid", "caml_unix_gmtime", "caml_unix_has_symlink", "caml_unix_inet_addr_of_string", "caml_unix_isatty", "caml_unix_localtime", "caml_unix_lstat", "caml_unix_lstat_64", "caml_unix_mkdir", "caml_unix_mktime", "caml_unix_opendir", "caml_unix_readdir", "caml_unix_readlink", "caml_unix_rewinddir", "caml_unix_rmdir", "caml_unix_startup", "caml_unix_stat", "caml_unix_stat_64", "caml_unix_symlink", "caml_unix_time", "caml_unix_unlink", "caml_unmount", "caml_update_dummy", "caml_utf16_of_utf8", "caml_utf8_of_utf16", "caml_weak_blit", "caml_weak_check", "caml_weak_create", "caml_weak_get", "caml_weak_get_copy", "caml_weak_set", "caml_wrap_exception", "caml_xmlhttprequest_create", "caml_zstd_initialize", "compare_digits_nat", "compare_nat", "compare_nat_real", "complement_nat", "create_nat", "decr_nat", "deserialize_nat", "div_digit_nat", "div_helper", "div_nat", "fs_node_supported", "incr_nat", "initialize_nat", "is_digit_int", "is_digit_odd", "is_digit_zero", "jsoo_create_file", "jsoo_create_file_extern", "jsoo_effect_not_supported", "jsoo_floor_log2", "jsoo_is_ascii", "jsoo_mount_point", "jsoo_sys_getenv", "land_digit_nat", "length_nat", "lor_digit_nat", "lxor_digit_nat", "make_unix_err_args", "mult_digit_nat", "mult_nat", "nat_of_array", "nth_digit_nat", "nth_digit_nat_native", "num_digits_nat", "num_leading_zero_bits_in_digit", "os_type", "path_is_absolute", "re_match", "re_partial_match", "re_replacement_text", "re_search_backward", "re_search_forward", "re_string_match", "resolve_fs_device", "serialize_nat", "set_digit_nat", "set_digit_nat_native", "set_to_zero_nat", "shift_left_nat", "shift_right_nat", "square_nat", "sub_nat", "unix_closedir", "unix_getpwuid", "unix_gettimeofday", "unix_getuid", "unix_gmtime", "unix_has_symlink", "unix_inet_addr_of_string", "unix_isatty", "unix_localtime", "unix_lstat", "unix_lstat_64", "unix_mkdir", "unix_mktime", "unix_opendir", "unix_readdir", "unix_readlink", "unix_rewinddir", "unix_rmdir", "unix_stat", "unix_stat_64", "unix_symlink", "unix_time", "unix_unlink", "win_cleanup", "win_filedescr_of_channel", "win_findclose", "win_findfirst", "win_findnext", "win_handle_fd", "win_startup", "zstd_decompress"]), 0];
      return;
    })(globalThis);
    (function(globalThis2) {
      "use strict";
      var runtime = globalThis2.jsoo_runtime;
      function erase_rel(param) {
        if (typeof param === "number")
          return 0;
        switch (param[0]) {
          case 0:
            var rest = param[1];
            return [0, erase_rel(rest)];
          case 1:
            var rest$0 = param[1];
            return [1, erase_rel(rest$0)];
          case 2:
            var rest$1 = param[1];
            return [2, erase_rel(rest$1)];
          case 3:
            var rest$2 = param[1];
            return [3, erase_rel(rest$2)];
          case 4:
            var rest$3 = param[1];
            return [4, erase_rel(rest$3)];
          case 5:
            var rest$4 = param[1];
            return [5, erase_rel(rest$4)];
          case 6:
            var rest$5 = param[1];
            return [6, erase_rel(rest$5)];
          case 7:
            var rest$6 = param[1];
            return [7, erase_rel(rest$6)];
          case 8:
            var rest$7 = param[2], ty = param[1];
            return [8, ty, erase_rel(rest$7)];
          case 9:
            var rest$8 = param[3], ty1 = param[1];
            return [9, ty1, ty1, erase_rel(rest$8)];
          case 10:
            var rest$9 = param[1];
            return [10, erase_rel(rest$9)];
          case 11:
            var rest$10 = param[1];
            return [11, erase_rel(rest$10)];
          case 12:
            var rest$11 = param[1];
            return [12, erase_rel(rest$11)];
          case 13:
            var rest$12 = param[1];
            return [13, erase_rel(rest$12)];
          default:
            var rest$13 = param[1];
            return [14, erase_rel(rest$13)];
        }
      }
      function concat_fmtty(fmtty1, fmtty2) {
        if (typeof fmtty1 === "number")
          return fmtty2;
        switch (fmtty1[0]) {
          case 0:
            var rest = fmtty1[1];
            return [0, concat_fmtty(rest, fmtty2)];
          case 1:
            var rest$0 = fmtty1[1];
            return [1, concat_fmtty(rest$0, fmtty2)];
          case 2:
            var rest$1 = fmtty1[1];
            return [2, concat_fmtty(rest$1, fmtty2)];
          case 3:
            var rest$2 = fmtty1[1];
            return [3, concat_fmtty(rest$2, fmtty2)];
          case 4:
            var rest$3 = fmtty1[1];
            return [4, concat_fmtty(rest$3, fmtty2)];
          case 5:
            var rest$4 = fmtty1[1];
            return [5, concat_fmtty(rest$4, fmtty2)];
          case 6:
            var rest$5 = fmtty1[1];
            return [6, concat_fmtty(rest$5, fmtty2)];
          case 7:
            var rest$6 = fmtty1[1];
            return [7, concat_fmtty(rest$6, fmtty2)];
          case 8:
            var rest$7 = fmtty1[2], ty = fmtty1[1];
            return [8, ty, concat_fmtty(rest$7, fmtty2)];
          case 9:
            var rest$8 = fmtty1[3], ty2 = fmtty1[2], ty1 = fmtty1[1];
            return [9, ty1, ty2, concat_fmtty(rest$8, fmtty2)];
          case 10:
            var rest$9 = fmtty1[1];
            return [10, concat_fmtty(rest$9, fmtty2)];
          case 11:
            var rest$10 = fmtty1[1];
            return [11, concat_fmtty(rest$10, fmtty2)];
          case 12:
            var rest$11 = fmtty1[1];
            return [12, concat_fmtty(rest$11, fmtty2)];
          case 13:
            var rest$12 = fmtty1[1];
            return [13, concat_fmtty(rest$12, fmtty2)];
          default:
            var rest$13 = fmtty1[1];
            return [14, concat_fmtty(rest$13, fmtty2)];
        }
      }
      function concat_fmt(fmt1, fmt2) {
        if (typeof fmt1 === "number")
          return fmt2;
        switch (fmt1[0]) {
          case 0:
            var rest = fmt1[1];
            return [0, concat_fmt(rest, fmt2)];
          case 1:
            var rest$0 = fmt1[1];
            return [1, concat_fmt(rest$0, fmt2)];
          case 2:
            var rest$1 = fmt1[2], pad = fmt1[1];
            return [2, pad, concat_fmt(rest$1, fmt2)];
          case 3:
            var rest$2 = fmt1[2], pad$0 = fmt1[1];
            return [3, pad$0, concat_fmt(rest$2, fmt2)];
          case 4:
            var rest$3 = fmt1[4], prec = fmt1[3], pad$1 = fmt1[2], iconv = fmt1[1];
            return [4, iconv, pad$1, prec, concat_fmt(rest$3, fmt2)];
          case 5:
            var rest$4 = fmt1[4], prec$0 = fmt1[3], pad$2 = fmt1[2], iconv$0 = fmt1[1];
            return [5, iconv$0, pad$2, prec$0, concat_fmt(rest$4, fmt2)];
          case 6:
            var rest$5 = fmt1[4], prec$1 = fmt1[3], pad$3 = fmt1[2], iconv$1 = fmt1[1];
            return [6, iconv$1, pad$3, prec$1, concat_fmt(rest$5, fmt2)];
          case 7:
            var rest$6 = fmt1[4], prec$2 = fmt1[3], pad$4 = fmt1[2], iconv$2 = fmt1[1];
            return [7, iconv$2, pad$4, prec$2, concat_fmt(rest$6, fmt2)];
          case 8:
            var rest$7 = fmt1[4], prec$3 = fmt1[3], pad$5 = fmt1[2], fconv = fmt1[1];
            return [8, fconv, pad$5, prec$3, concat_fmt(rest$7, fmt2)];
          case 9:
            var rest$8 = fmt1[2], pad$6 = fmt1[1];
            return [9, pad$6, concat_fmt(rest$8, fmt2)];
          case 10:
            var rest$9 = fmt1[1];
            return [10, concat_fmt(rest$9, fmt2)];
          case 11:
            var rest$10 = fmt1[2], str = fmt1[1];
            return [11, str, concat_fmt(rest$10, fmt2)];
          case 12:
            var rest$11 = fmt1[2], chr = fmt1[1];
            return [12, chr, concat_fmt(rest$11, fmt2)];
          case 13:
            var rest$12 = fmt1[3], fmtty = fmt1[2], pad$7 = fmt1[1];
            return [13, pad$7, fmtty, concat_fmt(rest$12, fmt2)];
          case 14:
            var rest$13 = fmt1[3], fmtty$0 = fmt1[2], pad$8 = fmt1[1];
            return [14, pad$8, fmtty$0, concat_fmt(rest$13, fmt2)];
          case 15:
            var rest$14 = fmt1[1];
            return [15, concat_fmt(rest$14, fmt2)];
          case 16:
            var rest$15 = fmt1[1];
            return [16, concat_fmt(rest$15, fmt2)];
          case 17:
            var rest$16 = fmt1[2], fmting_lit = fmt1[1];
            return [17, fmting_lit, concat_fmt(rest$16, fmt2)];
          case 18:
            var rest$17 = fmt1[2], fmting_gen = fmt1[1];
            return [18, fmting_gen, concat_fmt(rest$17, fmt2)];
          case 19:
            var rest$18 = fmt1[1];
            return [19, concat_fmt(rest$18, fmt2)];
          case 20:
            var rest$19 = fmt1[3], char_set = fmt1[2], width_opt = fmt1[1];
            return [20, width_opt, char_set, concat_fmt(rest$19, fmt2)];
          case 21:
            var rest$20 = fmt1[2], counter = fmt1[1];
            return [21, counter, concat_fmt(rest$20, fmt2)];
          case 22:
            var rest$21 = fmt1[1];
            return [22, concat_fmt(rest$21, fmt2)];
          case 23:
            var rest$22 = fmt1[2], ign = fmt1[1];
            return [23, ign, concat_fmt(rest$22, fmt2)];
          default:
            var rest$23 = fmt1[3], f = fmt1[2], arity = fmt1[1];
            return [24, arity, f, concat_fmt(rest$23, fmt2)];
        }
      }
      var CamlinternalFormatBasics = [0, concat_fmtty, erase_rel, concat_fmt];
      runtime.caml_register_global(0, CamlinternalFormatBasics, "CamlinternalFormatBasics");
      return;
    })(globalThis);
    (function(globalThis2) {
      "use strict";
      var runtime = globalThis2.jsoo_runtime, cst_false$0 = "false", cst_true$0 = "true", caml_atomic_cas2 = runtime.caml_atomic_cas, caml_atomic_load2 = runtime.caml_atomic_load, caml_blit_string2 = runtime.caml_blit_string, caml_create_bytes2 = runtime.caml_create_bytes, caml_float_of_string2 = runtime.caml_float_of_string, caml_int64_float_of_bits2 = runtime.caml_int64_float_of_bits, caml_int_of_string2 = runtime.caml_int_of_string, caml_maybe_attach_backtrace2 = runtime.caml_maybe_attach_backtrace, caml_ml_bytes_length2 = runtime.caml_ml_bytes_length, caml_ml_channel_size2 = runtime.caml_ml_channel_size, caml_ml_channel_size_642 = runtime.caml_ml_channel_size_64, caml_ml_close_channel2 = runtime.caml_ml_close_channel, caml_ml_flush2 = runtime.caml_ml_flush, caml_ml_input2 = runtime.caml_ml_input, caml_ml_input_char2 = runtime.caml_ml_input_char, caml_ml_open_descriptor_in2 = runtime.caml_ml_open_descriptor_in, caml_ml_open_descriptor_out2 = runtime.caml_ml_open_descriptor_out, caml_ml_output2 = runtime.caml_ml_output, caml_ml_output_bytes2 = runtime.caml_ml_output_bytes, caml_ml_output_char2 = runtime.caml_ml_output_char, caml_ml_set_binary_mode2 = runtime.caml_ml_set_binary_mode, caml_ml_set_channel_name2 = runtime.caml_ml_set_channel_name, caml_ml_string_length2 = runtime.caml_ml_string_length, caml_string_notequal2 = runtime.caml_string_notequal, caml_string_of_bytes2 = runtime.caml_string_of_bytes, caml_sys_open2 = runtime.caml_sys_open, caml_wrap_exception2 = runtime.caml_wrap_exception;
      function caml_call1(f, a0) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 1 ? f(a0) : runtime.caml_call_gen(f, [a0]);
      }
      function caml_call2(f, a0, a1) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 2 ? f(a0, a1) : runtime.caml_call_gen(f, [a0, a1]);
      }
      var global_data = runtime.caml_get_global_data(), cst$0 = "%,", cst = ".", CamlinternalFormatBasics = global_data.CamlinternalFormatBasics, Invalid_argument = global_data.Invalid_argument, Failure = global_data.Failure, Match_failure = global_data.Match_failure, Assert_failure = global_data.Assert_failure, Not_found = global_data.Not_found, Out_of_memory = global_data.Out_of_memory, Stack_overflow = global_data.Stack_overflow, Sys_error = global_data.Sys_error, End_of_file = global_data.End_of_file, Division_by_zero = global_data.Division_by_zero, Sys_blocked_io = global_data.Sys_blocked_io, Undefined_recursive_module = global_data.Undefined_recursive_module;
      function failwith(s2) {
        throw caml_maybe_attach_backtrace2([0, Failure, s2], 1);
      }
      function invalid_arg(s2) {
        throw caml_maybe_attach_backtrace2([0, Invalid_argument, s2], 1);
      }
      var Exit = [248, "Stdlib.Exit", runtime.caml_fresh_oo_id(0)];
      function min(x2, y) {
        return runtime.caml_lessequal(x2, y) ? x2 : y;
      }
      function max(x2, y) {
        return runtime.caml_greaterequal(x2, y) ? x2 : y;
      }
      function abs(x2) {
        return 0 <= x2 ? x2 : -x2 | 0;
      }
      function lnot(x2) {
        return x2 ^ -1;
      }
      var infinity = caml_int64_float_of_bits2(runtime.caml_int64_create_lo_mi_hi(0, 0, 32752)), neg_infinity = caml_int64_float_of_bits2(runtime.caml_int64_create_lo_mi_hi(0, 0, 65520)), nan = caml_int64_float_of_bits2(runtime.caml_int64_create_lo_mi_hi(1, 0, 32760)), max_float = caml_int64_float_of_bits2(runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 32751)), min_float = caml_int64_float_of_bits2(runtime.caml_int64_create_lo_mi_hi(0, 0, 16)), epsilon_float = caml_int64_float_of_bits2(runtime.caml_int64_create_lo_mi_hi(0, 0, 15536)), cst_char_of_int = "char_of_int", cst_true = cst_true$0, cst_false = cst_false$0, cst_bool_of_string = "bool_of_string", _a_ = [0, 1], _b_ = [0, 0];
      function symbol(s1, s2) {
        var l1 = caml_ml_string_length2(s1), l2 = caml_ml_string_length2(s2), s3 = caml_create_bytes2(l1 + l2 | 0);
        caml_blit_string2(s1, 0, s3, 0, l1);
        caml_blit_string2(s2, 0, s3, l1, l2);
        return caml_string_of_bytes2(s3);
      }
      function char_of_int(n) {
        if (0 <= n && 255 >= n)
          return n;
        return invalid_arg(cst_char_of_int);
      }
      function string_of_bool(b) {
        return b ? cst_true : cst_false;
      }
      function bool_of_string(param) {
        return caml_string_notequal2(param, cst_false$0) ? caml_string_notequal2(param, cst_true$0) ? invalid_arg(cst_bool_of_string) : 1 : 0;
      }
      function bool_of_string_opt(param) {
        return caml_string_notequal2(param, cst_false$0) ? caml_string_notequal2(param, cst_true$0) ? 0 : _a_ : _b_;
      }
      function string_of_int(n) {
        return "" + n;
      }
      function int_of_string_opt(s2) {
        try {
          var _x_ = [0, caml_int_of_string2(s2)];
          return _x_;
        } catch (_y_) {
          var _w_ = caml_wrap_exception2(_y_);
          if (_w_[1] === Failure)
            return 0;
          throw caml_maybe_attach_backtrace2(_w_, 0);
        }
      }
      function valid_float_lexem(s2) {
        var l = caml_ml_string_length2(s2), i = 0;
        for (; ; ) {
          if (l <= i)
            return symbol(s2, cst);
          var match = runtime.caml_string_get(s2, i);
          a: {
            if (48 <= match) {
              if (58 > match)
                break a;
            } else if (45 === match)
              break a;
            return s2;
          }
          var i$0 = i + 1 | 0, i = i$0;
        }
      }
      function string_of_float(f) {
        return valid_float_lexem(runtime.caml_format_float("%.12g", f));
      }
      function float_of_string_opt(s2) {
        try {
          var _u_ = [0, caml_float_of_string2(s2)];
          return _u_;
        } catch (_v_) {
          var _t_ = caml_wrap_exception2(_v_);
          if (_t_[1] === Failure)
            return 0;
          throw caml_maybe_attach_backtrace2(_t_, 0);
        }
      }
      function symbol$0(l1, l2) {
        if (!l1)
          return l2;
        var _r_ = l1[2], h1 = l1[1];
        if (!_r_)
          return [0, h1, l2];
        var match = _r_[2], h2 = _r_[1];
        if (!match)
          return [0, h1, [0, h2, l2]];
        var tl = match[2], h3 = match[1], block = [0, h3, 24029], dst = block, offset = 1, l1$0 = tl;
        for (; ; ) {
          if (l1$0) {
            var _s_ = l1$0[2], h1$0 = l1$0[1];
            if (_s_) {
              var match$0 = _s_[2], h2$0 = _s_[1];
              if (match$0) {
                var tl$0 = match$0[2], h3$0 = match$0[1], dst$0 = [0, h3$0, 24029];
                dst[1 + offset] = [0, h1$0, [0, h2$0, dst$0]];
                var dst = dst$0, offset = 1, l1$0 = tl$0;
                continue;
              }
              dst[1 + offset] = [0, h1$0, [0, h2$0, l2]];
            } else
              dst[1 + offset] = [0, h1$0, l2];
          } else
            dst[1 + offset] = l2;
          return [0, h1, [0, h2, block]];
        }
      }
      var stdin = caml_ml_open_descriptor_in2(0), stdout = caml_ml_open_descriptor_out2(1), stderr = caml_ml_open_descriptor_out2(2), _c_ = [0, 1, [0, 3, [0, 4, [0, 7, 0]]]], _d_ = [0, 1, [0, 3, [0, 4, [0, 6, 0]]]], cst_output = "output", cst_output_substring = "output_substring", _e_ = [0, 0, [0, 7, 0]], _f_ = [0, 0, [0, 6, 0]], cst_input = "input", cst_really_input = "really_input";
      function open_out_gen(mode, perm, name) {
        var c = caml_ml_open_descriptor_out2(caml_sys_open2(name, mode, perm));
        caml_ml_set_channel_name2(c, name);
        return c;
      }
      function open_out(name) {
        return open_out_gen(_c_, 438, name);
      }
      function open_out_bin(name) {
        return open_out_gen(_d_, 438, name);
      }
      function flush_all(param) {
        var param$0 = runtime.caml_ml_out_channels_list(0);
        for (; ; ) {
          if (!param$0)
            return 0;
          var l = param$0[2], a = param$0[1];
          try {
            caml_ml_flush2(a);
          } catch (_q_) {
            var _p_ = caml_wrap_exception2(_q_);
            if (_p_[1] !== Sys_error)
              throw caml_maybe_attach_backtrace2(_p_, 0);
          }
          var param$0 = l;
        }
      }
      function output_bytes(oc, s2) {
        return caml_ml_output_bytes2(oc, s2, 0, caml_ml_bytes_length2(s2));
      }
      function output_string(oc, s2) {
        return caml_ml_output2(oc, s2, 0, caml_ml_string_length2(s2));
      }
      function output(oc, s2, ofs, len) {
        if (0 <= ofs && 0 <= len && (caml_ml_bytes_length2(s2) - len | 0) >= ofs)
          return caml_ml_output_bytes2(oc, s2, ofs, len);
        return invalid_arg(cst_output);
      }
      function output_substring(oc, s2, ofs, len) {
        if (0 <= ofs && 0 <= len && (caml_ml_string_length2(s2) - len | 0) >= ofs)
          return caml_ml_output2(oc, s2, ofs, len);
        return invalid_arg(cst_output_substring);
      }
      function output_value(chan, v) {
        return runtime.caml_output_value(chan, v, 0);
      }
      function close_out(oc) {
        caml_ml_flush2(oc);
        return caml_ml_close_channel2(oc);
      }
      function close_out_noerr(oc) {
        try {
          caml_ml_flush2(oc);
        } catch (_o_) {
        }
        try {
          var _m_ = caml_ml_close_channel2(oc);
          return _m_;
        } catch (_n_) {
          return 0;
        }
      }
      function open_in_gen(mode, perm, name) {
        var c = caml_ml_open_descriptor_in2(caml_sys_open2(name, mode, perm));
        caml_ml_set_channel_name2(c, name);
        return c;
      }
      function open_in(name) {
        return open_in_gen(_e_, 0, name);
      }
      function open_in_bin(name) {
        return open_in_gen(_f_, 0, name);
      }
      function input(ic, s2, ofs, len) {
        if (0 <= ofs && 0 <= len && (caml_ml_bytes_length2(s2) - len | 0) >= ofs)
          return caml_ml_input2(ic, s2, ofs, len);
        return invalid_arg(cst_input);
      }
      function unsafe_really_input(ic, s2, ofs, len) {
        var ofs$0 = ofs, len$0 = len;
        for (; ; ) {
          if (0 >= len$0)
            return 0;
          var r = caml_ml_input2(ic, s2, ofs$0, len$0);
          if (0 === r)
            throw caml_maybe_attach_backtrace2(End_of_file, 1);
          var len$1 = len$0 - r | 0, ofs$1 = ofs$0 + r | 0, ofs$0 = ofs$1, len$0 = len$1;
        }
      }
      function really_input(ic, s2, ofs, len) {
        if (0 <= ofs && 0 <= len && (caml_ml_bytes_length2(s2) - len | 0) >= ofs)
          return unsafe_really_input(ic, s2, ofs, len);
        return invalid_arg(cst_really_input);
      }
      function really_input_string(ic, len) {
        var s2 = caml_create_bytes2(len);
        really_input(ic, s2, 0, len);
        return caml_string_of_bytes2(s2);
      }
      function input_line(chan) {
        function build_result(buf, pos, param) {
          var pos$0 = pos, param$0 = param;
          for (; ; ) {
            if (!param$0)
              return buf;
            var tl = param$0[2], hd = param$0[1], len2 = caml_ml_bytes_length2(hd);
            runtime.caml_blit_bytes(hd, 0, buf, pos$0 - len2 | 0, len2);
            var pos$1 = pos$0 - len2 | 0, pos$0 = pos$1, param$0 = tl;
          }
        }
        var accu = 0, len = 0;
        for (; ; ) {
          var n = runtime.caml_ml_input_scan_line(chan);
          if (0 === n) {
            if (!accu)
              throw caml_maybe_attach_backtrace2(End_of_file, 1);
            var _l_ = build_result(caml_create_bytes2(len), len, accu);
          } else {
            if (0 >= n) {
              var beg = caml_create_bytes2(-n | 0);
              caml_ml_input2(chan, beg, 0, -n | 0);
              var len$1 = len - n | 0, accu$0 = [0, beg, accu], accu = accu$0, len = len$1;
              continue;
            }
            var res = caml_create_bytes2(n - 1 | 0);
            caml_ml_input2(chan, res, 0, n - 1 | 0);
            caml_ml_input_char2(chan);
            if (accu)
              var len$0 = (len + n | 0) - 1 | 0, _l_ = build_result(caml_create_bytes2(len$0), len$0, [0, res, accu]);
            else
              var _l_ = res;
          }
          return caml_string_of_bytes2(_l_);
        }
      }
      function close_in_noerr(ic) {
        try {
          var _j_ = caml_ml_close_channel2(ic);
          return _j_;
        } catch (_k_) {
          return 0;
        }
      }
      function print_char(c) {
        return caml_ml_output_char2(stdout, c);
      }
      function print_string(s2) {
        return output_string(stdout, s2);
      }
      function print_bytes(s2) {
        return output_bytes(stdout, s2);
      }
      function print_int(i) {
        return output_string(stdout, "" + i);
      }
      function print_float(f) {
        return output_string(stdout, string_of_float(f));
      }
      function print_endline(s2) {
        output_string(stdout, s2);
        caml_ml_output_char2(stdout, 10);
        return caml_ml_flush2(stdout);
      }
      function print_newline(param) {
        caml_ml_output_char2(stdout, 10);
        return caml_ml_flush2(stdout);
      }
      function prerr_char(c) {
        return caml_ml_output_char2(stderr, c);
      }
      function prerr_string(s2) {
        return output_string(stderr, s2);
      }
      function prerr_bytes(s2) {
        return output_bytes(stderr, s2);
      }
      function prerr_int(i) {
        return output_string(stderr, "" + i);
      }
      function prerr_float(f) {
        return output_string(stderr, string_of_float(f));
      }
      function prerr_endline(s2) {
        output_string(stderr, s2);
        caml_ml_output_char2(stderr, 10);
        return caml_ml_flush2(stderr);
      }
      function prerr_newline(param) {
        caml_ml_output_char2(stderr, 10);
        return caml_ml_flush2(stderr);
      }
      function read_line(param) {
        caml_ml_flush2(stdout);
        return input_line(stdin);
      }
      function read_int(param) {
        return caml_int_of_string2(read_line(0));
      }
      function read_int_opt(param) {
        return int_of_string_opt(read_line(0));
      }
      function read_float(param) {
        return caml_float_of_string2(read_line(0));
      }
      function read_float_opt(param) {
        return float_of_string_opt(read_line(0));
      }
      function string_of_format(param) {
        var str = param[2];
        return str;
      }
      function symbol$1(param, _h_) {
        var str2 = _h_[2], fmt2 = _h_[1], str1 = param[2], fmt1 = param[1], _i_ = symbol(str1, symbol(cst$0, str2));
        return [0, caml_call2(CamlinternalFormatBasics[3], fmt1, fmt2), _i_];
      }
      var exit_function = [0, flush_all];
      function at_exit(f) {
        for (; ; ) {
          var f_yet_to_run = [0, 1], old_exit = caml_atomic_load2(exit_function);
          let f_yet_to_run$0 = f_yet_to_run, old_exit$0 = old_exit;
          var new_exit = function(param) {
            if (caml_atomic_cas2(f_yet_to_run$0, 1, 0))
              caml_call1(f, 0);
            return caml_call1(old_exit$0, 0);
          }, success = caml_atomic_cas2(exit_function, old_exit, new_exit), _g_ = 1 - success;
          if (!_g_)
            return _g_;
        }
      }
      var do_domain_local_at_exit = [0, function(param) {
        return 0;
      }];
      function do_at_exit(param) {
        caml_call1(do_domain_local_at_exit[1], 0);
        return caml_call1(caml_atomic_load2(exit_function), 0);
      }
      function exit(retcode) {
        do_at_exit(0);
        return runtime.caml_sys_exit(retcode);
      }
      runtime.caml_register_named_value("Pervasives.do_at_exit", do_at_exit);
      var Stdlib = [
        0,
        invalid_arg,
        failwith,
        Exit,
        Match_failure,
        Assert_failure,
        Invalid_argument,
        Failure,
        Not_found,
        Out_of_memory,
        Stack_overflow,
        Sys_error,
        End_of_file,
        Division_by_zero,
        Sys_blocked_io,
        Undefined_recursive_module,
        min,
        max,
        abs,
        2147483647,
        -2147483648,
        lnot,
        infinity,
        neg_infinity,
        nan,
        max_float,
        min_float,
        epsilon_float,
        symbol,
        char_of_int,
        string_of_bool,
        bool_of_string_opt,
        bool_of_string,
        string_of_int,
        int_of_string_opt,
        string_of_float,
        float_of_string_opt,
        symbol$0,
        stdin,
        stdout,
        stderr,
        print_char,
        print_string,
        print_bytes,
        print_int,
        print_float,
        print_endline,
        print_newline,
        prerr_char,
        prerr_string,
        prerr_bytes,
        prerr_int,
        prerr_float,
        prerr_endline,
        prerr_newline,
        read_line,
        read_int_opt,
        read_int,
        read_float_opt,
        read_float,
        open_out,
        open_out_bin,
        open_out_gen,
        caml_ml_flush2,
        flush_all,
        caml_ml_output_char2,
        output_string,
        output_bytes,
        output,
        output_substring,
        caml_ml_output_char2,
        runtime.caml_ml_output_int,
        output_value,
        runtime.caml_ml_seek_out,
        runtime.caml_ml_pos_out,
        caml_ml_channel_size2,
        close_out,
        close_out_noerr,
        caml_ml_set_binary_mode2,
        open_in,
        open_in_bin,
        open_in_gen,
        caml_ml_input_char2,
        input_line,
        input,
        really_input,
        really_input_string,
        caml_ml_input_char2,
        runtime.caml_ml_input_int,
        runtime.caml_input_value,
        runtime.caml_ml_seek_in,
        runtime.caml_ml_pos_in,
        caml_ml_channel_size2,
        caml_ml_close_channel2,
        close_in_noerr,
        caml_ml_set_binary_mode2,
        [
          0,
          runtime.caml_ml_seek_out_64,
          runtime.caml_ml_pos_out_64,
          caml_ml_channel_size_642,
          runtime.caml_ml_seek_in_64,
          runtime.caml_ml_pos_in_64,
          caml_ml_channel_size_642
        ],
        string_of_format,
        symbol$1,
        exit,
        at_exit,
        valid_float_lexem,
        unsafe_really_input,
        do_at_exit,
        do_domain_local_at_exit
      ];
      runtime.caml_register_global(45, Stdlib, "Stdlib");
      return;
    })(globalThis);
    (function(globalThis2) {
      "use strict";
      var runtime = globalThis2.jsoo_runtime, caml_maybe_attach_backtrace2 = runtime.caml_maybe_attach_backtrace, caml_wrap_exception2 = runtime.caml_wrap_exception, global_data = runtime.caml_get_global_data(), ocaml_version = "5.1.1", ocaml_release = [0, 5, 1, 1, 0], Stdlib = global_data.Stdlib, executable_name = runtime.caml_sys_executable_name(0), os_type2 = runtime.caml_sys_get_config(0)[1], backend_type = [0, "js_of_ocaml"], unix = runtime.caml_sys_const_ostype_unix(0), win32 = runtime.caml_sys_const_ostype_win32(0), cygwin = runtime.caml_sys_const_ostype_cygwin(0), max_array_length = runtime.caml_sys_const_max_wosize(0), max_floatarray_length = max_array_length / 2 | 0, max_string_length = (4 * max_array_length | 0) - 1 | 0;
      function getenv_opt(s2) {
        try {
          var _d_ = [0, runtime.caml_sys_getenv(s2)];
          return _d_;
        } catch (_e_) {
          var _c_ = caml_wrap_exception2(_e_);
          if (_c_ === Stdlib[8])
            return 0;
          throw caml_maybe_attach_backtrace2(_c_, 0);
        }
      }
      var interactive = [0, 0];
      function set_signal(sig_num, sig_beh) {
        return 0;
      }
      var Break = [248, "Stdlib.Sys.Break", runtime.caml_fresh_oo_id(0)];
      function catch_break(on) {
        return on ? 0 : 0;
      }
      function Make(_b_, _a_) {
        return [0, 1];
      }
      var Immediate64 = [0, Make], Stdlib_Sys = [
        0,
        executable_name,
        getenv_opt,
        interactive,
        os_type2,
        backend_type,
        unix,
        win32,
        cygwin,
        32,
        32,
        0,
        max_string_length,
        max_array_length,
        max_floatarray_length,
        set_signal,
        -1,
        -2,
        -3,
        -4,
        -5,
        -6,
        -7,
        -8,
        -9,
        -10,
        -11,
        -12,
        -13,
        -14,
        -15,
        -16,
        -17,
        -18,
        -19,
        -20,
        -21,
        -22,
        -23,
        -24,
        -25,
        -26,
        -27,
        -28,
        Break,
        catch_break,
        ocaml_version,
        0,
        ocaml_release,
        runtime.caml_ml_enable_runtime_warnings,
        runtime.caml_ml_runtime_warnings_enabled,
        Immediate64
      ];
      runtime.caml_register_global(4, Stdlib_Sys, "Stdlib__Sys");
      return;
    })(globalThis);
    (function(globalThis2) {
      "use strict";
      var runtime = globalThis2.jsoo_runtime, cst_Obj_extension_constructor$1 = "Obj.extension_constructor", caml_maybe_attach_backtrace2 = runtime.caml_maybe_attach_backtrace, caml_obj_tag2 = runtime.caml_obj_tag;
      function caml_call1(f, a0) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 1 ? f(a0) : runtime.caml_call_gen(f, [a0]);
      }
      var global_data = runtime.caml_get_global_data(), Stdlib = global_data.Stdlib, Assert_failure = global_data.Assert_failure, Stdlib_Sys = global_data.Stdlib__Sys;
      function is_block(a) {
        return 1 - (typeof a === "number" ? 1 : 0);
      }
      var double_field = runtime.caml_array_get, set_double_field = runtime.caml_array_set, _a_ = [0, "obj.ml", 94, 4], cst_Obj_extension_constructor = cst_Obj_extension_constructor$1, cst_Obj_extension_constructor$0 = cst_Obj_extension_constructor$1;
      function info(obj) {
        if (caml_obj_tag2(obj) !== 247)
          throw caml_maybe_attach_backtrace2([0, Assert_failure, _a_], 1);
        var info2 = runtime.caml_obj_raw_field(obj, 1), arity = 64 === Stdlib_Sys[9] ? info2 >> 56 : info2 >> 24, start_env = info2 << 8 >>> 9 | 0;
        return [0, arity, start_env];
      }
      function of_val(x2) {
        a: {
          if (is_block(x2) && caml_obj_tag2(x2) !== 248 && 1 <= x2.length - 1) {
            var slot = x2[1];
            break a;
          }
          var slot = x2;
        }
        a: {
          if (is_block(slot) && caml_obj_tag2(slot) === 248) {
            var name2 = slot[1];
            break a;
          }
          var name2 = caml_call1(Stdlib[1], cst_Obj_extension_constructor$0);
        }
        return caml_obj_tag2(name2) === 252 ? slot : caml_call1(Stdlib[1], cst_Obj_extension_constructor);
      }
      function name(slot) {
        return slot[1];
      }
      function id(slot) {
        return slot[2];
      }
      var Extension_constructor = [0, of_val, name, id], max_ephe_length = Stdlib_Sys[13] - 2 | 0, cst_Obj_Ephemeron_create = "Obj.Ephemeron.create", cst_Obj_Ephemeron_get_key = "Obj.Ephemeron.get_key", cst_Obj_Ephemeron_get_key_copy = "Obj.Ephemeron.get_key_copy", cst_Obj_Ephemeron_set_key = "Obj.Ephemeron.set_key", cst_Obj_Ephemeron_unset_key = "Obj.Ephemeron.unset_key", cst_Obj_Ephemeron_check_key = "Obj.Ephemeron.check_key", cst_Obj_Ephemeron_blit_key = "Obj.Ephemeron.blit_key";
      function create(l) {
        var _g_ = 0 <= l ? 1 : 0, _h_ = _g_ ? l <= max_ephe_length ? 1 : 0 : _g_;
        if (1 - _h_)
          caml_call1(Stdlib[1], cst_Obj_Ephemeron_create);
        return runtime.caml_ephe_create(l);
      }
      function length(x2) {
        return x2.length - 1 - 2 | 0;
      }
      function raise_if_invalid_offset(e, o, msg) {
        var _d_ = 0 <= o ? 1 : 0, _e_ = _d_ ? o < length(e) ? 1 : 0 : _d_, _f_ = 1 - _e_;
        return _f_ ? caml_call1(Stdlib[1], msg) : _f_;
      }
      function get_key(e, o) {
        raise_if_invalid_offset(e, o, cst_Obj_Ephemeron_get_key);
        return runtime.caml_ephe_get_key(e, o);
      }
      function get_key_copy(e, o) {
        raise_if_invalid_offset(e, o, cst_Obj_Ephemeron_get_key_copy);
        return runtime.caml_ephe_get_key_copy(e, o);
      }
      function set_key(e, o, x2) {
        raise_if_invalid_offset(e, o, cst_Obj_Ephemeron_set_key);
        return runtime.caml_ephe_set_key(e, o, x2);
      }
      function unset_key(e, o) {
        raise_if_invalid_offset(e, o, cst_Obj_Ephemeron_unset_key);
        return runtime.caml_ephe_unset_key(e, o);
      }
      function check_key(e, o) {
        raise_if_invalid_offset(e, o, cst_Obj_Ephemeron_check_key);
        return runtime.caml_ephe_check_key(e, o);
      }
      function blit_key(e1, o1, e2, o2, l) {
        if (0 <= l && 0 <= o1 && (length(e1) - l | 0) >= o1 && 0 <= o2 && (length(e2) - l | 0) >= o2) {
          var _b_ = 0 !== l ? 1 : 0, _c_ = _b_ ? runtime.caml_ephe_blit_key(e1, o1, e2, o2, l) : _b_;
          return _c_;
        }
        return caml_call1(Stdlib[1], cst_Obj_Ephemeron_blit_key);
      }
      var Stdlib_Obj = [
        0,
        is_block,
        double_field,
        set_double_field,
        0,
        243,
        244,
        245,
        246,
        247,
        248,
        249,
        250,
        251,
        251,
        252,
        253,
        254,
        255,
        1e3,
        1001,
        1002,
        [0, info],
        Extension_constructor,
        [
          0,
          create,
          length,
          get_key,
          get_key_copy,
          set_key,
          unset_key,
          check_key,
          blit_key,
          runtime.caml_ephe_get_data,
          runtime.caml_ephe_get_data_copy,
          runtime.caml_ephe_set_data,
          runtime.caml_ephe_unset_data,
          runtime.caml_ephe_check_data,
          runtime.caml_ephe_blit_data,
          max_ephe_length
        ]
      ];
      runtime.caml_register_global(13, Stdlib_Obj, "Stdlib__Obj");
      return;
    })(globalThis);
    (function(globalThis2) {
      "use strict";
      var runtime = globalThis2.jsoo_runtime, caml_atomic_exchange2 = runtime.caml_atomic_exchange, caml_atomic_fetch_add2 = runtime.caml_atomic_fetch_add;
      function set(r, x2) {
        caml_atomic_exchange2(r, x2);
        return 0;
      }
      function incr(r) {
        caml_atomic_fetch_add2(r, 1);
        return 0;
      }
      function decr(r) {
        caml_atomic_fetch_add2(r, -1);
        return 0;
      }
      var Stdlib_Atomic = [
        0,
        function(_a_) {
          return [0, _a_];
        },
        runtime.caml_atomic_load,
        set,
        caml_atomic_exchange2,
        runtime.caml_atomic_cas,
        caml_atomic_fetch_add2,
        incr,
        decr
      ];
      runtime.caml_register_global(0, Stdlib_Atomic, "Stdlib__Atomic");
      return;
    })(globalThis);
    (function(globalThis2) {
      "use strict";
      var runtime = globalThis2.jsoo_runtime, caml_lazy_update_to_forward2 = runtime.caml_lazy_update_to_forward, caml_maybe_attach_backtrace2 = runtime.caml_maybe_attach_backtrace, caml_wrap_exception2 = runtime.caml_wrap_exception;
      function caml_call1(f, a0) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 1 ? f(a0) : runtime.caml_call_gen(f, [a0]);
      }
      var global_data = runtime.caml_get_global_data(), Stdlib_Obj = global_data.Stdlib__Obj, Undefined = [248, "CamlinternalLazy.Undefined", runtime.caml_fresh_oo_id(0)];
      function force_gen_lazy_block(only_val, blk) {
        if (0 !== runtime.caml_lazy_update_to_forcing(blk))
          throw caml_maybe_attach_backtrace2(Undefined, 1);
        if (only_val) {
          var closure$0 = blk[1];
          blk[1] = 0;
          var result$0 = caml_call1(closure$0, 0);
          blk[1] = result$0;
          caml_lazy_update_to_forward2(blk);
          return result$0;
        }
        var closure = blk[1];
        blk[1] = 0;
        try {
          var result = caml_call1(closure, 0);
          blk[1] = result;
          caml_lazy_update_to_forward2(blk);
          return result;
        } catch (e$0) {
          var e = caml_wrap_exception2(e$0);
          blk[1] = function(param) {
            throw caml_maybe_attach_backtrace2(e, 0);
          };
          runtime.caml_lazy_reset_to_lazy(blk);
          throw caml_maybe_attach_backtrace2(e, 0);
        }
      }
      function force_lazy_block(blk) {
        return force_gen_lazy_block(0, blk);
      }
      function force_gen(only_val, lzv) {
        var t = runtime.caml_obj_tag(lzv);
        if (t === Stdlib_Obj[12])
          return lzv[1];
        if (t === Stdlib_Obj[6])
          throw caml_maybe_attach_backtrace2(Undefined, 1);
        return t !== Stdlib_Obj[8] ? lzv : force_gen_lazy_block(only_val, lzv);
      }
      var CamlinternalLazy = [0, Undefined, force_lazy_block, force_gen];
      runtime.caml_register_global(2, CamlinternalLazy, "CamlinternalLazy");
      return;
    })(globalThis);
    (function(globalThis2) {
      "use strict";
      var runtime = globalThis2.jsoo_runtime, caml_obj_tag2 = runtime.caml_obj_tag;
      function caml_call1(f, a0) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 1 ? f(a0) : runtime.caml_call_gen(f, [a0]);
      }
      function caml_call2(f, a0, a1) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 2 ? f(a0, a1) : runtime.caml_call_gen(f, [a0, a1]);
      }
      var global_data = runtime.caml_get_global_data(), CamlinternalLazy = global_data.CamlinternalLazy, Stdlib_Obj = global_data.Stdlib__Obj, Undefined = CamlinternalLazy[1];
      function force_val(l) {
        return caml_call2(CamlinternalLazy[3], 1, l);
      }
      function from_fun(f) {
        var x2 = runtime.caml_obj_block(Stdlib_Obj[8], 1);
        x2[1] = f;
        return x2;
      }
      function from_val(v) {
        var t = caml_obj_tag2(v);
        if (t !== Stdlib_Obj[12] && t !== Stdlib_Obj[8] && t !== Stdlib_Obj[6] && t !== Stdlib_Obj[16])
          return v;
        return runtime.caml_lazy_make_forward(v);
      }
      function is_val(l) {
        var _i_ = Stdlib_Obj[8];
        return caml_obj_tag2(l) !== _i_ ? 1 : 0;
      }
      function map(f, x2) {
        return [
          246,
          function(_f_) {
            var _g_ = caml_obj_tag2(x2);
            a:
              if (250 === _g_)
                var _h_ = x2[1];
              else {
                if (246 !== _g_ && 244 !== _g_) {
                  var _h_ = x2;
                  break a;
                }
                var _h_ = caml_call1(CamlinternalLazy[2], x2);
              }
            return caml_call1(f, _h_);
          }
        ];
      }
      function map_val(f, x2) {
        if (!is_val(x2))
          return [
            246,
            function(_c_) {
              var _d_ = caml_obj_tag2(x2);
              a:
                if (250 === _d_)
                  var _e_ = x2[1];
                else {
                  if (246 !== _d_ && 244 !== _d_) {
                    var _e_ = x2;
                    break a;
                  }
                  var _e_ = caml_call1(CamlinternalLazy[2], x2);
                }
              return caml_call1(f, _e_);
            }
          ];
        var _a_ = caml_obj_tag2(x2);
        a:
          if (250 === _a_)
            var _b_ = x2[1];
          else {
            if (246 !== _a_ && 244 !== _a_) {
              var _b_ = x2;
              break a;
            }
            var _b_ = caml_call1(CamlinternalLazy[2], x2);
          }
        return from_val(caml_call1(f, _b_));
      }
      var Stdlib_Lazy = [0, Undefined, map, is_val, from_val, map_val, from_fun, force_val];
      runtime.caml_register_global(2, Stdlib_Lazy, "Stdlib__Lazy");
      return;
    })(globalThis);
    (function(globalThis2) {
      "use strict";
      var runtime = globalThis2.jsoo_runtime, caml_maybe_attach_backtrace2 = runtime.caml_maybe_attach_backtrace;
      function caml_call1(f, a0) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 1 ? f(a0) : runtime.caml_call_gen(f, [a0]);
      }
      function caml_call2(f, a0, a1) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 2 ? f(a0, a1) : runtime.caml_call_gen(f, [a0, a1]);
      }
      function caml_call3(f, a0, a1, a2) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 3 ? f(a0, a1, a2) : runtime.caml_call_gen(f, [a0, a1, a2]);
      }
      var global_data = runtime.caml_get_global_data(), Assert_failure = global_data.Assert_failure, Stdlib_Atomic = global_data.Stdlib__Atomic, CamlinternalLazy = global_data.CamlinternalLazy, Stdlib = global_data.Stdlib, Stdlib_Lazy = global_data.Stdlib__Lazy, cst_Seq_init = "Seq.init", cst_Seq_take = "Seq.take", cst_Seq_drop = "Seq.drop";
      function empty(param) {
        return 0;
      }
      function return$0(x2, param) {
        return [0, x2, empty];
      }
      function cons(x2, next, param) {
        return [0, x2, next];
      }
      function append(seq1, seq2, param) {
        var match = caml_call1(seq1, 0);
        if (!match)
          return caml_call1(seq2, 0);
        var next = match[2], x2 = match[1];
        return [0, x2, function(_ay_) {
          return append(next, seq2, _ay_);
        }];
      }
      function map(f, seq, param) {
        var match = caml_call1(seq, 0);
        if (!match)
          return 0;
        var next = match[2], x2 = match[1];
        return [0, caml_call1(f, x2), function(_ax_) {
          return map(f, next, _ax_);
        }];
      }
      function filter_map(f, seq, param) {
        var seq$0 = seq;
        for (; ; ) {
          var match = caml_call1(seq$0, 0);
          if (!match)
            return 0;
          var next = match[2], x2 = match[1], match$0 = caml_call1(f, x2);
          if (match$0) {
            var y = match$0[1];
            return [0, y, function(_aw_) {
              return filter_map(f, next, _aw_);
            }];
          }
          var seq$0 = next;
        }
      }
      function filter(f, seq, param) {
        var seq$0 = seq;
        for (; ; ) {
          var match = caml_call1(seq$0, 0);
          if (!match)
            return 0;
          var next = match[2], x2 = match[1];
          if (caml_call1(f, x2))
            return [0, x2, function(_av_) {
              return filter(f, next, _av_);
            }];
          var seq$0 = next;
        }
      }
      function concat(seq, param) {
        var match = caml_call1(seq, 0);
        if (!match)
          return 0;
        var next = match[2], x2 = match[1];
        return append(x2, function(_au_) {
          return concat(next, _au_);
        }, 0);
      }
      function flat_map(f, seq, param) {
        var match = caml_call1(seq, 0);
        if (!match)
          return 0;
        var next = match[2], x2 = match[1];
        return append(
          caml_call1(f, x2),
          function(_at_) {
            return flat_map(f, next, _at_);
          },
          0
        );
      }
      function fold_left(f, acc, seq) {
        var acc$0 = acc, seq$0 = seq;
        for (; ; ) {
          var match = caml_call1(seq$0, 0);
          if (!match)
            return acc$0;
          var next = match[2], x2 = match[1], acc$1 = caml_call2(f, acc$0, x2), acc$0 = acc$1, seq$0 = next;
        }
      }
      function iter(f, seq) {
        var seq$0 = seq;
        for (; ; ) {
          var match = caml_call1(seq$0, 0);
          if (!match)
            return 0;
          var next = match[2], x2 = match[1];
          caml_call1(f, x2);
          var seq$0 = next;
        }
      }
      function unfold(f, u, param) {
        var match = caml_call1(f, u);
        if (!match)
          return 0;
        var match$0 = match[1], u$0 = match$0[2], x2 = match$0[1];
        return [0, x2, function(_as_) {
          return unfold(f, u$0, _as_);
        }];
      }
      function is_empty(xs) {
        return caml_call1(xs, 0) ? 0 : 1;
      }
      function uncons(xs) {
        var match = caml_call1(xs, 0);
        if (!match)
          return 0;
        var xs$0 = match[2], x2 = match[1];
        return [0, [0, x2, xs$0]];
      }
      function length(xs$1) {
        var accu = 0, xs = xs$1;
        for (; ; ) {
          var match = caml_call1(xs, 0);
          if (!match)
            return accu;
          var xs$0 = match[2], accu$0 = accu + 1 | 0, accu = accu$0, xs = xs$0;
        }
      }
      function iteri(f, xs$1) {
        var i = 0, xs = xs$1;
        for (; ; ) {
          var match = caml_call1(xs, 0);
          if (!match)
            return 0;
          var xs$0 = match[2], x2 = match[1];
          caml_call2(f, i, x2);
          var i$0 = i + 1 | 0, i = i$0, xs = xs$0;
        }
      }
      function fold_lefti(f, accu$1, xs$1) {
        var accu = accu$1, i = 0, xs = xs$1;
        for (; ; ) {
          var match = caml_call1(xs, 0);
          if (!match)
            return accu;
          var xs$0 = match[2], x2 = match[1], accu$0 = caml_call3(f, accu, i, x2), i$0 = i + 1 | 0, accu = accu$0, i = i$0, xs = xs$0;
        }
      }
      function for_all(p, xs) {
        var xs$0 = xs;
        for (; ; ) {
          var match = caml_call1(xs$0, 0);
          if (!match)
            return 1;
          var xs$1 = match[2], x2 = match[1], _ar_ = caml_call1(p, x2);
          if (!_ar_)
            return _ar_;
          var xs$0 = xs$1;
        }
      }
      function exists(p, xs) {
        var xs$0 = xs;
        for (; ; ) {
          var match = caml_call1(xs$0, 0);
          if (!match)
            return 0;
          var xs$1 = match[2], x2 = match[1], _aq_ = caml_call1(p, x2);
          if (_aq_)
            return _aq_;
          var xs$0 = xs$1;
        }
      }
      function find(p, xs) {
        var xs$0 = xs;
        for (; ; ) {
          var match = caml_call1(xs$0, 0);
          if (!match)
            return 0;
          var xs$1 = match[2], x2 = match[1];
          if (caml_call1(p, x2))
            return [0, x2];
          var xs$0 = xs$1;
        }
      }
      function find_index(p, xs) {
        var i = 0, xs$0 = xs;
        for (; ; ) {
          var match = caml_call1(xs$0, 0);
          if (!match)
            return 0;
          var xs$1 = match[2], x2 = match[1];
          if (caml_call1(p, x2))
            return [0, i];
          var i$0 = i + 1 | 0, i = i$0, xs$0 = xs$1;
        }
      }
      function find_map(f, xs) {
        var xs$0 = xs;
        for (; ; ) {
          var match = caml_call1(xs$0, 0);
          if (!match)
            return 0;
          var xs$1 = match[2], x2 = match[1], result = caml_call1(f, x2);
          if (result)
            return result;
          var xs$0 = xs$1;
        }
      }
      function find_mapi(f, xs) {
        var i = 0, xs$0 = xs;
        for (; ; ) {
          var match = caml_call1(xs$0, 0);
          if (!match)
            return 0;
          var xs$1 = match[2], x2 = match[1], result = caml_call2(f, i, x2);
          if (result)
            return result;
          var i$0 = i + 1 | 0, i = i$0, xs$0 = xs$1;
        }
      }
      function iter2(f, xs, ys) {
        var xs$0 = xs, ys$0 = ys;
        for (; ; ) {
          var match = caml_call1(xs$0, 0);
          if (!match)
            return 0;
          var xs$1 = match[2], x2 = match[1], match$0 = caml_call1(ys$0, 0);
          if (!match$0)
            return 0;
          var ys$1 = match$0[2], y = match$0[1];
          caml_call2(f, x2, y);
          var xs$0 = xs$1, ys$0 = ys$1;
        }
      }
      function fold_left2(f, accu, xs, ys) {
        var accu$0 = accu, xs$0 = xs, ys$0 = ys;
        for (; ; ) {
          var match = caml_call1(xs$0, 0);
          if (!match)
            return accu$0;
          var xs$1 = match[2], x2 = match[1], match$0 = caml_call1(ys$0, 0);
          if (!match$0)
            return accu$0;
          var ys$1 = match$0[2], y = match$0[1], accu$1 = caml_call3(f, accu$0, x2, y), accu$0 = accu$1, xs$0 = xs$1, ys$0 = ys$1;
        }
      }
      function for_all2(f, xs, ys) {
        var xs$0 = xs, ys$0 = ys;
        for (; ; ) {
          var match = caml_call1(xs$0, 0);
          if (!match)
            return 1;
          var xs$1 = match[2], x2 = match[1], match$0 = caml_call1(ys$0, 0);
          if (!match$0)
            return 1;
          var ys$1 = match$0[2], y = match$0[1], _ap_ = caml_call2(f, x2, y);
          if (!_ap_)
            return _ap_;
          var xs$0 = xs$1, ys$0 = ys$1;
        }
      }
      function exists2(f, xs, ys) {
        var xs$0 = xs, ys$0 = ys;
        for (; ; ) {
          var match = caml_call1(xs$0, 0);
          if (!match)
            return 0;
          var xs$1 = match[2], x2 = match[1], match$0 = caml_call1(ys$0, 0);
          if (!match$0)
            return 0;
          var ys$1 = match$0[2], y = match$0[1], _ao_ = caml_call2(f, x2, y);
          if (_ao_)
            return _ao_;
          var xs$0 = xs$1, ys$0 = ys$1;
        }
      }
      function equal(eq, xs, ys) {
        var xs$0 = xs, ys$0 = ys;
        for (; ; ) {
          var match = caml_call1(xs$0, 0), match$0 = caml_call1(ys$0, 0);
          if (match) {
            if (match$0) {
              var ys$1 = match$0[2], y = match$0[1], xs$1 = match[2], x2 = match[1], _an_ = caml_call2(eq, x2, y);
              if (!_an_)
                return _an_;
              var xs$0 = xs$1, ys$0 = ys$1;
              continue;
            }
          } else if (!match$0)
            return 1;
          return 0;
        }
      }
      function compare(cmp, xs, ys) {
        var xs$0 = xs, ys$0 = ys;
        for (; ; ) {
          var match = caml_call1(xs$0, 0), match$0 = caml_call1(ys$0, 0);
          if (!match)
            return match$0 ? -1 : 0;
          var xs$1 = match[2], x2 = match[1];
          if (!match$0)
            return 1;
          var ys$1 = match$0[2], y = match$0[1], c = caml_call2(cmp, x2, y);
          if (0 !== c)
            return c;
          var xs$0 = xs$1, ys$0 = ys$1;
        }
      }
      function init_aux(f, i, j, param) {
        if (i >= j)
          return 0;
        var _al_ = i + 1 | 0;
        return [
          0,
          caml_call1(f, i),
          function(_am_) {
            return init_aux(f, _al_, j, _am_);
          }
        ];
      }
      function init(n, f) {
        if (0 > n)
          return caml_call1(Stdlib[1], cst_Seq_init);
        var _aj_ = 0;
        return function(_ak_) {
          return init_aux(f, _aj_, n, _ak_);
        };
      }
      function repeat(x2, param) {
        return [0, x2, function(_ai_) {
          return repeat(x2, _ai_);
        }];
      }
      function forever(f, param) {
        return [0, caml_call1(f, 0), function(_ah_) {
          return forever(f, _ah_);
        }];
      }
      function cycle_nonempty(xs, param) {
        return append(xs, function(_ag_) {
          return cycle_nonempty(xs, _ag_);
        }, 0);
      }
      function cycle(xs, param) {
        var match = caml_call1(xs, 0);
        if (!match)
          return 0;
        var xs$0 = match[2], x2 = match[1];
        function _ad_(_af_) {
          return cycle_nonempty(xs, _af_);
        }
        return [0, x2, function(_ae_) {
          return append(xs$0, _ad_, _ae_);
        }];
      }
      function iterate1(f, x2, param) {
        var y = caml_call1(f, x2);
        return [0, y, function(_ac_) {
          return iterate1(f, y, _ac_);
        }];
      }
      function iterate(f, x2) {
        function _$_(_ab_) {
          return iterate1(f, x2, _ab_);
        }
        return function(_aa_) {
          return [0, x2, _$_];
        };
      }
      function mapi_aux(f, i, xs, param) {
        var match = caml_call1(xs, 0);
        if (!match)
          return 0;
        var xs$0 = match[2], x2 = match[1], _Z_ = i + 1 | 0;
        return [
          0,
          caml_call2(f, i, x2),
          function(___) {
            return mapi_aux(f, _Z_, xs$0, ___);
          }
        ];
      }
      function mapi(f, xs) {
        var _X_ = 0;
        return function(_Y_) {
          return mapi_aux(f, _X_, xs, _Y_);
        };
      }
      function tail_scan(f, s2, xs, param) {
        var match = caml_call1(xs, 0);
        if (!match)
          return 0;
        var xs$0 = match[2], x2 = match[1], s$0 = caml_call2(f, s2, x2);
        return [0, s$0, function(_W_) {
          return tail_scan(f, s$0, xs$0, _W_);
        }];
      }
      function scan(f, s2, xs) {
        function _T_2(_V_) {
          return tail_scan(f, s2, xs, _V_);
        }
        return function(_U_) {
          return [0, s2, _T_2];
        };
      }
      function take_aux(n, xs) {
        return 0 === n ? empty : function(param) {
          var match = caml_call1(xs, 0);
          if (!match)
            return 0;
          var xs$0 = match[2], x2 = match[1];
          return [0, x2, take_aux(n - 1 | 0, xs$0)];
        };
      }
      function take(n, xs) {
        if (n < 0)
          caml_call1(Stdlib[1], cst_Seq_take);
        return take_aux(n, xs);
      }
      function drop(n, xs) {
        return 0 <= n ? 0 === n ? xs : function(param) {
          var n$0 = n, xs$0 = xs;
          for (; ; ) {
            var match = caml_call1(xs$0, 0);
            if (!match)
              return 0;
            var xs$1 = match[2], n$1 = n$0 - 1 | 0;
            if (0 === n$1)
              return caml_call1(xs$1, 0);
            var n$0 = n$1, xs$0 = xs$1;
          }
        } : caml_call1(Stdlib[1], cst_Seq_drop);
      }
      function take_while(p, xs, param) {
        var match = caml_call1(xs, 0);
        if (!match)
          return 0;
        var xs$0 = match[2], x2 = match[1];
        return caml_call1(p, x2) ? [0, x2, function(_S_) {
          return take_while(p, xs$0, _S_);
        }] : 0;
      }
      function drop_while(p, xs, param) {
        var xs$0 = xs;
        for (; ; ) {
          var node = caml_call1(xs$0, 0);
          if (!node)
            return 0;
          var xs$1 = node[2], x2 = node[1];
          if (!caml_call1(p, x2))
            return node;
          var xs$0 = xs$1;
        }
      }
      function group(eq, xs, param) {
        var match = caml_call1(xs, 0);
        if (!match)
          return 0;
        var xs$0 = match[2], x2 = match[1], _K_ = caml_call1(eq, x2);
        function _L_(_R_) {
          return drop_while(_K_, xs$0, _R_);
        }
        var _M_ = caml_call1(eq, x2);
        function _N_(_Q_) {
          return take_while(_M_, xs$0, _Q_);
        }
        return [
          0,
          function(_P_) {
            return [0, x2, _N_];
          },
          function(_O_) {
            return group(eq, _L_, _O_);
          }
        ];
      }
      var Forced_twice = [248, "Stdlib.Seq.Forced_twice", runtime.caml_fresh_oo_id(0)], to_lazy = Stdlib_Lazy[6], _a_ = [0, "seq.ml", 616, 4];
      function failure(param) {
        throw caml_maybe_attach_backtrace2(Forced_twice, 1);
      }
      function memoize(xs) {
        function s$0(param) {
          var match = caml_call1(xs, 0);
          if (!match)
            return 0;
          var xs$0 = match[2], x2 = match[1];
          return [0, x2, memoize(xs$0)];
        }
        var s2 = caml_call1(to_lazy, s$0);
        return function(_J_) {
          var _I_ = runtime.caml_obj_tag(s2);
          if (250 === _I_)
            return s2[1];
          if (246 !== _I_ && 244 !== _I_)
            return s2;
          return caml_call1(CamlinternalLazy[2], s2);
        };
      }
      function once(xs) {
        function f(param) {
          var match = caml_call1(xs, 0);
          if (!match)
            return 0;
          var xs$0 = match[2], x2 = match[1];
          return [0, x2, once(xs$0)];
        }
        var action = caml_call1(Stdlib_Atomic[1], f);
        return function(param) {
          var f2 = caml_call2(Stdlib_Atomic[4], action, failure);
          return caml_call1(f2, 0);
        };
      }
      function zip(xs, ys, param) {
        var match = caml_call1(xs, 0);
        if (!match)
          return 0;
        var xs$0 = match[2], x2 = match[1], match$0 = caml_call1(ys, 0);
        if (!match$0)
          return 0;
        var ys$0 = match$0[2], y = match$0[1];
        return [0, [0, x2, y], function(_H_) {
          return zip(xs$0, ys$0, _H_);
        }];
      }
      function map2(f, xs, ys, param) {
        var match = caml_call1(xs, 0);
        if (!match)
          return 0;
        var xs$0 = match[2], x2 = match[1], match$0 = caml_call1(ys, 0);
        if (!match$0)
          return 0;
        var ys$0 = match$0[2], y = match$0[1];
        return [
          0,
          caml_call2(f, x2, y),
          function(_G_) {
            return map2(f, xs$0, ys$0, _G_);
          }
        ];
      }
      function interleave(xs, ys, param) {
        var match = caml_call1(xs, 0);
        if (!match)
          return caml_call1(ys, 0);
        var xs$0 = match[2], x2 = match[1];
        return [0, x2, function(_F_) {
          return interleave(ys, xs$0, _F_);
        }];
      }
      function sorted_merge1(cmp, x2, xs, y, ys) {
        return 0 < caml_call2(cmp, x2, y) ? [
          0,
          y,
          function(_D_) {
            var match = caml_call1(ys, 0);
            if (!match)
              return [0, x2, xs];
            var ys$0 = match[2], y2 = match[1];
            return sorted_merge1(cmp, x2, xs, y2, ys$0);
          }
        ] : [
          0,
          x2,
          function(_E_) {
            var match = caml_call1(xs, 0);
            if (!match)
              return [0, y, ys];
            var xs$0 = match[2], x3 = match[1];
            return sorted_merge1(cmp, x3, xs$0, y, ys);
          }
        ];
      }
      function sorted_merge(cmp, xs, ys, param) {
        var match = caml_call1(xs, 0), match$0 = caml_call1(ys, 0);
        if (match) {
          if (match$0) {
            var ys$0 = match$0[2], y = match$0[1], xs$0 = match[2], x2 = match[1];
            return sorted_merge1(cmp, x2, xs$0, y, ys$0);
          }
          var c = match;
        } else {
          if (!match$0)
            return 0;
          var c = match$0;
        }
        return c;
      }
      function map_fst(xys, param) {
        var match = caml_call1(xys, 0);
        if (!match)
          return 0;
        var xys$0 = match[2], x2 = match[1][1];
        return [0, x2, function(_C_) {
          return map_fst(xys$0, _C_);
        }];
      }
      function map_snd(xys, param) {
        var match = caml_call1(xys, 0);
        if (!match)
          return 0;
        var xys$0 = match[2], y = match[1][2];
        return [0, y, function(_B_) {
          return map_snd(xys$0, _B_);
        }];
      }
      function unzip(xys) {
        return [
          0,
          function(_A_) {
            return map_fst(xys, _A_);
          },
          function(_z_) {
            return map_snd(xys, _z_);
          }
        ];
      }
      function filter_map_find_left_map(f, xs, param) {
        var xs$0 = xs;
        for (; ; ) {
          var match = caml_call1(xs$0, 0);
          if (!match)
            return 0;
          var xs$1 = match[2], x2 = match[1], match$0 = caml_call1(f, x2);
          if (0 === match$0[0]) {
            var y = match$0[1];
            return [
              0,
              y,
              function(_y_) {
                return filter_map_find_left_map(f, xs$1, _y_);
              }
            ];
          }
          var xs$0 = xs$1;
        }
      }
      function filter_map_find_right_map(f, xs, param) {
        var xs$0 = xs;
        for (; ; ) {
          var match = caml_call1(xs$0, 0);
          if (!match)
            return 0;
          var xs$1 = match[2], x2 = match[1], match$0 = caml_call1(f, x2);
          if (0 !== match$0[0]) {
            var z = match$0[1];
            return [
              0,
              z,
              function(_x_) {
                return filter_map_find_right_map(f, xs$1, _x_);
              }
            ];
          }
          var xs$0 = xs$1;
        }
      }
      function partition_map(f, xs) {
        return [
          0,
          function(_w_) {
            return filter_map_find_left_map(f, xs, _w_);
          },
          function(_v_) {
            return filter_map_find_right_map(f, xs, _v_);
          }
        ];
      }
      function partition(p, xs) {
        function _s_(x2) {
          return 1 - caml_call1(p, x2);
        }
        return [
          0,
          function(_u_) {
            return filter(p, xs, _u_);
          },
          function(_t_) {
            return filter(_s_, xs, _t_);
          }
        ];
      }
      function peel(xss) {
        return unzip(function(_r_) {
          return filter_map(uncons, xss, _r_);
        });
      }
      function transpose(xss, param) {
        var match = peel(xss), tails = match[2], heads = match[1];
        if (!is_empty(heads))
          return [0, heads, function(_q_) {
            return transpose(tails, _q_);
          }];
        if (is_empty(tails))
          return 0;
        throw caml_maybe_attach_backtrace2([0, Assert_failure, _a_], 1);
      }
      function _b_(remainders, xss, param) {
        var match = caml_call1(xss, 0);
        if (!match)
          return transpose(remainders, 0);
        var xss$0 = match[2], xs = match[1], match$0 = caml_call1(xs, 0);
        if (match$0) {
          var xs$0 = match$0[2], x2 = match$0[1], match$1 = peel(remainders), tails = match$1[2], heads = match$1[1], _l_ = function(_p_) {
            return [0, xs$0, tails];
          };
          return [
            0,
            function(_o_) {
              return [0, x2, heads];
            },
            function(_n_) {
              return _b_(_l_, xss$0, _n_);
            }
          ];
        }
        var match$2 = peel(remainders), tails$0 = match$2[2], heads$0 = match$2[1];
        return [0, heads$0, function(_m_) {
          return _b_(tails$0, xss$0, _m_);
        }];
      }
      function map_product(f, xs, ys) {
        function _f_(x2) {
          function _j_(y) {
            return caml_call2(f, x2, y);
          }
          return function(_k_) {
            return map(_j_, ys, _k_);
          };
        }
        function xss(_i_) {
          return map(_f_, xs, _i_);
        }
        function _e_(_h_) {
          return _b_(empty, xss, _h_);
        }
        return function(_g_) {
          return concat(_e_, _g_);
        };
      }
      function product(xs, ys) {
        return map_product(function(x2, y) {
          return [0, x2, y];
        }, xs, ys);
      }
      function of_dispenser(it) {
        function c(param) {
          var match = caml_call1(it, 0);
          if (!match)
            return 0;
          var x2 = match[1];
          return [0, x2, c];
        }
        return c;
      }
      function to_dispenser(xs) {
        var s2 = [0, xs];
        return function(param) {
          var match = caml_call1(s2[1], 0);
          if (!match)
            return 0;
          var xs2 = match[2], x2 = match[1];
          s2[1] = xs2;
          return [0, x2];
        };
      }
      function ints(i, param) {
        var _c_ = i + 1 | 0;
        return [0, i, function(_d_) {
          return ints(_c_, _d_);
        }];
      }
      var Stdlib_Seq = [
        0,
        is_empty,
        uncons,
        length,
        iter,
        fold_left,
        iteri,
        fold_lefti,
        for_all,
        exists,
        find,
        find_index,
        find_map,
        find_mapi,
        iter2,
        fold_left2,
        for_all2,
        exists2,
        equal,
        compare,
        empty,
        return$0,
        cons,
        init,
        unfold,
        repeat,
        forever,
        cycle,
        iterate,
        map,
        mapi,
        filter,
        filter_map,
        scan,
        take,
        drop,
        take_while,
        drop_while,
        group,
        memoize,
        Forced_twice,
        once,
        transpose,
        append,
        concat,
        flat_map,
        flat_map,
        zip,
        map2,
        interleave,
        sorted_merge,
        product,
        map_product,
        unzip,
        unzip,
        partition_map,
        partition,
        of_dispenser,
        to_dispenser,
        ints
      ];
      runtime.caml_register_global(10, Stdlib_Seq, "Stdlib__Seq");
      return;
    })(globalThis);
    (function(globalThis2) {
      "use strict";
      var runtime = globalThis2.jsoo_runtime;
      function caml_call1(f, a0) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 1 ? f(a0) : runtime.caml_call_gen(f, [a0]);
      }
      function caml_call2(f, a0, a1) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 2 ? f(a0, a1) : runtime.caml_call_gen(f, [a0, a1]);
      }
      var global_data = runtime.caml_get_global_data(), Stdlib_Seq = global_data.Stdlib__Seq, Stdlib = global_data.Stdlib, cst_option_is_None = "option is None";
      function some(v) {
        return [0, v];
      }
      function value(o, default$0) {
        if (!o)
          return default$0;
        var v = o[1];
        return v;
      }
      function get(param) {
        if (!param)
          return caml_call1(Stdlib[1], cst_option_is_None);
        var v = param[1];
        return v;
      }
      function bind(o, f) {
        if (!o)
          return 0;
        var v = o[1];
        return caml_call1(f, v);
      }
      function join(param) {
        if (!param)
          return 0;
        var o = param[1];
        return o;
      }
      function map(f, o) {
        if (!o)
          return 0;
        var v = o[1];
        return [0, caml_call1(f, v)];
      }
      function fold(none, some2, param) {
        if (!param)
          return none;
        var v = param[1];
        return caml_call1(some2, v);
      }
      function iter(f, param) {
        if (!param)
          return 0;
        var v = param[1];
        return caml_call1(f, v);
      }
      function is_none(param) {
        return param ? 0 : 1;
      }
      function is_some(param) {
        return param ? 1 : 0;
      }
      function equal(eq, o0, o1) {
        if (o0) {
          if (o1) {
            var v1 = o1[1], v0 = o0[1];
            return caml_call2(eq, v0, v1);
          }
        } else if (!o1)
          return 1;
        return 0;
      }
      function compare(cmp, o0, o1) {
        if (!o0)
          return o1 ? -1 : 0;
        var v0 = o0[1];
        if (!o1)
          return 1;
        var v1 = o1[1];
        return caml_call2(cmp, v0, v1);
      }
      function to_result(none, param) {
        if (!param)
          return [1, none];
        var v = param[1];
        return [0, v];
      }
      function to_list(param) {
        if (!param)
          return 0;
        var v = param[1];
        return [0, v, 0];
      }
      function to_seq(param) {
        if (!param)
          return Stdlib_Seq[20];
        var v = param[1];
        return caml_call1(Stdlib_Seq[21], v);
      }
      var Stdlib_Option = [
        0,
        0,
        some,
        value,
        get,
        bind,
        join,
        map,
        fold,
        iter,
        is_none,
        is_some,
        equal,
        compare,
        to_result,
        to_list,
        to_seq
      ];
      runtime.caml_register_global(3, Stdlib_Option, "Stdlib__Option");
      return;
    })(globalThis);
    (function(globalThis2) {
      "use strict";
      var runtime = globalThis2.jsoo_runtime;
      function caml_call1(f, a0) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 1 ? f(a0) : runtime.caml_call_gen(f, [a0]);
      }
      function caml_call2(f, a0, a1) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 2 ? f(a0, a1) : runtime.caml_call_gen(f, [a0, a1]);
      }
      var global_data = runtime.caml_get_global_data(), Stdlib_Seq = global_data.Stdlib__Seq, Stdlib = global_data.Stdlib, cst_result_is_Error = "result is Error _", cst_result_is_Ok = "result is Ok _";
      function ok(v) {
        return [0, v];
      }
      function error(e) {
        return [1, e];
      }
      function value(r, default$0) {
        if (0 !== r[0])
          return default$0;
        var v = r[1];
        return v;
      }
      function get_ok(param) {
        if (0 !== param[0])
          return caml_call1(Stdlib[1], cst_result_is_Error);
        var v = param[1];
        return v;
      }
      function get_error(param) {
        if (0 === param[0])
          return caml_call1(Stdlib[1], cst_result_is_Ok);
        var e = param[1];
        return e;
      }
      function bind(r, f) {
        if (0 !== r[0])
          return r;
        var v = r[1];
        return caml_call1(f, v);
      }
      function join(e) {
        if (0 !== e[0])
          return e;
        var r = e[1];
        return r;
      }
      function map(f, e) {
        if (0 !== e[0])
          return e;
        var v = e[1];
        return [0, caml_call1(f, v)];
      }
      function map_error(f, v) {
        if (0 === v[0])
          return v;
        var e = v[1];
        return [1, caml_call1(f, e)];
      }
      function fold(ok2, error2, param) {
        if (0 === param[0]) {
          var v = param[1];
          return caml_call1(ok2, v);
        }
        var e = param[1];
        return caml_call1(error2, e);
      }
      function iter(f, param) {
        if (0 !== param[0])
          return 0;
        var v = param[1];
        return caml_call1(f, v);
      }
      function iter_error(f, param) {
        if (0 === param[0])
          return 0;
        var e = param[1];
        return caml_call1(f, e);
      }
      function is_ok(param) {
        return 0 === param[0] ? 1 : 0;
      }
      function is_error(param) {
        return 0 === param[0] ? 0 : 1;
      }
      function equal(ok2, error2, r0, r1) {
        if (0 === r0[0]) {
          var v0 = r0[1];
          if (0 === r1[0]) {
            var v1 = r1[1];
            return caml_call2(ok2, v0, v1);
          }
        } else {
          var e0 = r0[1];
          if (0 !== r1[0]) {
            var e1 = r1[1];
            return caml_call2(error2, e0, e1);
          }
        }
        return 0;
      }
      function compare(ok2, error2, r0, r1) {
        if (0 === r0[0]) {
          var v0 = r0[1];
          if (0 !== r1[0])
            return -1;
          var v1 = r1[1];
          return caml_call2(ok2, v0, v1);
        }
        var e0 = r0[1];
        if (0 === r1[0])
          return 1;
        var e1 = r1[1];
        return caml_call2(error2, e0, e1);
      }
      function to_option(param) {
        if (0 !== param[0])
          return 0;
        var v = param[1];
        return [0, v];
      }
      function to_list(param) {
        if (0 !== param[0])
          return 0;
        var v = param[1];
        return [0, v, 0];
      }
      function to_seq(param) {
        if (0 !== param[0])
          return Stdlib_Seq[20];
        var v = param[1];
        return caml_call1(Stdlib_Seq[21], v);
      }
      var Stdlib_Result = [
        0,
        ok,
        error,
        value,
        get_ok,
        get_error,
        bind,
        join,
        map,
        map_error,
        fold,
        iter,
        iter_error,
        is_ok,
        is_error,
        equal,
        compare,
        to_option,
        to_list,
        to_seq
      ];
      runtime.caml_register_global(4, Stdlib_Result, "Stdlib__Result");
      return;
    })(globalThis);
    (function(globalThis2) {
      "use strict";
      var runtime = globalThis2.jsoo_runtime, caml_bytes_unsafe_set2 = runtime.caml_bytes_unsafe_set, caml_create_bytes2 = runtime.caml_create_bytes, caml_hash2 = runtime.caml_hash, caml_string_of_bytes2 = runtime.caml_string_of_bytes;
      function caml_call1(f, a0) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 1 ? f(a0) : runtime.caml_call_gen(f, [a0]);
      }
      var global_data = runtime.caml_get_global_data(), cst = "\\\\", cst$0 = "\\'", Stdlib = global_data.Stdlib, cst_Char_chr = "Char.chr", cst_b = "\\b", cst_t = "\\t", cst_n = "\\n", cst_r = "\\r";
      function chr(n) {
        if (0 <= n && 255 >= n)
          return n;
        return caml_call1(Stdlib[1], cst_Char_chr);
      }
      function escaped(c) {
        a: {
          if (40 <= c) {
            if (92 === c)
              return cst;
            if (127 > c)
              break a;
          } else {
            if (32 <= c) {
              if (39 <= c)
                return cst$0;
              break a;
            }
            if (14 > c)
              switch (c) {
                case 8:
                  return cst_b;
                case 9:
                  return cst_t;
                case 10:
                  return cst_n;
                case 13:
                  return cst_r;
              }
          }
          var s2 = caml_create_bytes2(4);
          caml_bytes_unsafe_set2(s2, 0, 92);
          caml_bytes_unsafe_set2(s2, 1, 48 + (c / 100 | 0) | 0);
          caml_bytes_unsafe_set2(s2, 2, 48 + ((c / 10 | 0) % 10 | 0) | 0);
          caml_bytes_unsafe_set2(s2, 3, 48 + (c % 10 | 0) | 0);
          return caml_string_of_bytes2(s2);
        }
        var s$0 = caml_create_bytes2(1);
        caml_bytes_unsafe_set2(s$0, 0, c);
        return caml_string_of_bytes2(s$0);
      }
      function lowercase_ascii(c) {
        return 25 < c - 65 >>> 0 ? c : c + 32 | 0;
      }
      function uppercase_ascii(c) {
        return 25 < c - 97 >>> 0 ? c : c - 32 | 0;
      }
      function compare(c1, c2) {
        return c1 - c2 | 0;
      }
      function equal(c1, c2) {
        return 0 === (c1 - c2 | 0) ? 1 : 0;
      }
      function seeded_hash(seed, x2) {
        return caml_hash2(10, 100, seed, x2);
      }
      function hash(x2) {
        return caml_hash2(10, 100, 0, x2);
      }
      var Stdlib_Char = [
        0,
        chr,
        escaped,
        lowercase_ascii,
        uppercase_ascii,
        compare,
        equal,
        seeded_hash,
        hash
      ];
      runtime.caml_register_global(8, Stdlib_Char, "Stdlib__Char");
      return;
    })(globalThis);
    (function(globalThis2) {
      "use strict";
      var runtime = globalThis2.jsoo_runtime, cst_uchar_ml = "uchar.ml", caml_format_int2 = runtime.caml_format_int, caml_maybe_attach_backtrace2 = runtime.caml_maybe_attach_backtrace;
      function caml_call1(f, a0) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 1 ? f(a0) : runtime.caml_call_gen(f, [a0]);
      }
      function caml_call2(f, a0, a1) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 2 ? f(a0, a1) : runtime.caml_call_gen(f, [a0, a1]);
      }
      var global_data = runtime.caml_get_global_data(), err_no_pred = "U+0000 has no predecessor", err_no_succ = "U+10FFFF has no successor", Assert_failure = global_data.Assert_failure, Stdlib = global_data.Stdlib, cst_is_not_an_Unicode_scalar_v = " is not an Unicode scalar value", cst_is_not_a_latin1_character = " is not a latin1 character", cst_U = "U+", lo_bound = 55295, hi_bound = 57344;
      function succ(u) {
        return u === 55295 ? hi_bound : u === 1114111 ? caml_call1(Stdlib[1], err_no_succ) : u + 1 | 0;
      }
      function pred(u) {
        return u === 57344 ? lo_bound : u === 0 ? caml_call1(Stdlib[1], err_no_pred) : u - 1 | 0;
      }
      function is_valid(i) {
        var _n_ = 0 <= i ? 1 : 0, _o_ = _n_ ? i <= 55295 ? 1 : 0 : _n_;
        if (_o_)
          var _p_ = _o_;
        else
          var _q_ = 57344 <= i ? 1 : 0, _p_ = _q_ ? i <= 1114111 ? 1 : 0 : _q_;
        return _p_;
      }
      function of_int(i) {
        if (is_valid(i))
          return i;
        var _m_ = caml_call2(Stdlib[28], caml_format_int2("%X", i), cst_is_not_an_Unicode_scalar_v);
        return caml_call1(Stdlib[1], _m_);
      }
      function is_char(u) {
        return u < 256 ? 1 : 0;
      }
      function of_char(c) {
        return c;
      }
      function to_char(u) {
        if (255 >= u)
          return u;
        var _k_ = caml_call2(
          Stdlib[28],
          caml_format_int2("%04X", u),
          cst_is_not_a_latin1_character
        ), _l_ = caml_call2(Stdlib[28], cst_U, _k_);
        return caml_call1(Stdlib[1], _l_);
      }
      function unsafe_to_char(_j_) {
        return _j_;
      }
      function equal(_i_, _h_) {
        return _i_ === _h_ ? 1 : 0;
      }
      var compare = runtime.caml_int_compare, _a_ = [0, cst_uchar_ml, 85, 7], _b_ = [0, cst_uchar_ml, 80, 18], _c_ = [0, cst_uchar_ml, 91, 7], _d_ = [0, cst_uchar_ml, 88, 18];
      function hash(_g_) {
        return _g_;
      }
      function utf_decode_is_valid(d) {
        return 1 === (d >>> 27 | 0) ? 1 : 0;
      }
      function utf_decode_length(d) {
        return (d >>> 24 | 0) & 7;
      }
      function utf_decode_uchar(d) {
        return d & 16777215;
      }
      function utf_decode(n, u) {
        return (8 | n) << 24 | u;
      }
      function utf_decode_invalid(n) {
        return n << 24 | 65533;
      }
      function utf_8_byte_length(u) {
        if (0 > u)
          throw caml_maybe_attach_backtrace2([0, Assert_failure, _b_], 1);
        if (127 >= u)
          return 1;
        if (2047 >= u)
          return 2;
        if (65535 >= u)
          return 3;
        if (1114111 < u)
          throw caml_maybe_attach_backtrace2([0, Assert_failure, _a_], 1);
        return 4;
      }
      function utf_16_byte_length(u) {
        if (0 > u)
          throw caml_maybe_attach_backtrace2([0, Assert_failure, _d_], 1);
        if (65535 >= u)
          return 2;
        if (1114111 < u)
          throw caml_maybe_attach_backtrace2([0, Assert_failure, _c_], 1);
        return 4;
      }
      var Stdlib_Uchar = [
        0,
        0,
        1114111,
        65279,
        65533,
        succ,
        pred,
        is_valid,
        of_int,
        function(_f_) {
          return _f_;
        },
        function(_e_) {
          return _e_;
        },
        is_char,
        of_char,
        to_char,
        unsafe_to_char,
        equal,
        compare,
        hash,
        utf_decode_is_valid,
        utf_decode_uchar,
        utf_decode_length,
        utf_decode,
        utf_decode_invalid,
        utf_8_byte_length,
        utf_16_byte_length
      ];
      runtime.caml_register_global(13, Stdlib_Uchar, "Stdlib__Uchar");
      return;
    })(globalThis);
    (function(globalThis2) {
      "use strict";
      var runtime = globalThis2.jsoo_runtime, cst_List_map2$1 = "List.map2", cst_List_nth$1 = "List.nth", caml_compare2 = runtime.caml_compare, caml_maybe_attach_backtrace2 = runtime.caml_maybe_attach_backtrace;
      function caml_call1(f, a0) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 1 ? f(a0) : runtime.caml_call_gen(f, [a0]);
      }
      function caml_call2(f, a0, a1) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 2 ? f(a0, a1) : runtime.caml_call_gen(f, [a0, a1]);
      }
      function caml_call3(f, a0, a1, a2) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 3 ? f(a0, a1, a2) : runtime.caml_call_gen(f, [a0, a1, a2]);
      }
      var global_data = runtime.caml_get_global_data(), Stdlib = global_data.Stdlib, cst_hd = "hd", cst_tl = "tl", cst_nth = "nth", cst_List_nth = cst_List_nth$1, cst_List_nth$0 = cst_List_nth$1;
      function length(l$0) {
        var len = 0, param = l$0;
        for (; ; ) {
          if (!param)
            return len;
          var l = param[2], len$0 = len + 1 | 0, len = len$0, param = l;
        }
      }
      function cons(a, l) {
        return [0, a, l];
      }
      function hd(param) {
        if (!param)
          return caml_call1(Stdlib[2], cst_hd);
        var a = param[1];
        return a;
      }
      function tl(param) {
        if (!param)
          return caml_call1(Stdlib[2], cst_tl);
        var l = param[2];
        return l;
      }
      function nth(l, n) {
        if (0 > n)
          return caml_call1(Stdlib[1], cst_List_nth);
        var l$0 = l, n$0 = n;
        for (; ; ) {
          if (!l$0)
            return caml_call1(Stdlib[2], cst_nth);
          var l$1 = l$0[2], a = l$0[1];
          if (0 === n$0)
            return a;
          var n$1 = n$0 - 1 | 0, l$0 = l$1, n$0 = n$1;
        }
      }
      function nth_opt(l, n) {
        if (0 > n)
          return caml_call1(Stdlib[1], cst_List_nth$0);
        var l$0 = l, n$0 = n;
        for (; ; ) {
          if (!l$0)
            return 0;
          var l$1 = l$0[2], a = l$0[1];
          if (0 === n$0)
            return [0, a];
          var n$1 = n$0 - 1 | 0, l$0 = l$1, n$0 = n$1;
        }
      }
      var append = Stdlib[37], cst_List_init = "List.init", cst_List_map2 = cst_List_map2$1, cst_List_map2$0 = cst_List_map2$1, cst_List_rev_map2 = "List.rev_map2", cst_List_iter2 = "List.iter2", cst_List_fold_left2 = "List.fold_left2", cst_List_fold_right2 = "List.fold_right2", cst_List_for_all2 = "List.for_all2", cst_List_exists2 = "List.exists2", _a_ = [0, 0, 0], cst_List_combine = "List.combine";
      function rev_append(l1, l2) {
        var l1$0 = l1, l2$0 = l2;
        for (; ; ) {
          if (!l1$0)
            return l2$0;
          var l1$1 = l1$0[2], a = l1$0[1], l2$1 = [0, a, l2$0], l1$0 = l1$1, l2$0 = l2$1;
        }
      }
      function rev(l) {
        return rev_append(l, 0);
      }
      function init(len, f) {
        if (0 > len)
          return caml_call1(Stdlib[1], cst_List_init);
        var last = len - 1 | 0, i$1 = 0;
        if (last < 0)
          return 0;
        if (0 === last)
          return [0, caml_call1(f, i$1), 0];
        var r1 = caml_call1(f, i$1), r2 = caml_call1(f, 1), block = [0, r2, 24029], dst = block, offset = 1, i = 2;
        for (; ; ) {
          if (last < i)
            dst[1 + offset] = 0;
          else {
            if (i !== last) {
              var r1$0 = caml_call1(f, i), r2$0 = caml_call1(f, i + 1 | 0), dst$0 = [0, r2$0, 24029];
              dst[1 + offset] = [0, r1$0, dst$0];
              var i$0 = i + 2 | 0, dst = dst$0, offset = 1, i = i$0;
              continue;
            }
            dst[1 + offset] = [0, caml_call1(f, i), 0];
          }
          return [0, r1, block];
        }
      }
      function flatten(param) {
        if (!param)
          return 0;
        var r = param[2], l = param[1], _I_ = flatten(r);
        return caml_call2(Stdlib[37], l, _I_);
      }
      function map(f, param) {
        if (!param)
          return 0;
        var match = param[2], a1 = param[1];
        if (!match) {
          var r1$0 = caml_call1(f, a1);
          return [0, r1$0, 0];
        }
        var l = match[2], a2 = match[1], r1 = caml_call1(f, a1), r2 = caml_call1(f, a2), block = [0, r2, 24029], dst = block, offset = 1, param$0 = l;
        for (; ; ) {
          if (param$0) {
            var match$0 = param$0[2], a1$0 = param$0[1];
            if (match$0) {
              var l$0 = match$0[2], a2$0 = match$0[1], r1$1 = caml_call1(f, a1$0), r2$0 = caml_call1(f, a2$0), dst$0 = [0, r2$0, 24029];
              dst[1 + offset] = [0, r1$1, dst$0];
              var dst = dst$0, offset = 1, param$0 = l$0;
              continue;
            }
            var r1$2 = caml_call1(f, a1$0);
            dst[1 + offset] = [0, r1$2, 0];
          } else
            dst[1 + offset] = 0;
          return [0, r1, block];
        }
      }
      function mapi(f, l$1) {
        var i$1 = 0;
        if (!l$1)
          return 0;
        var match = l$1[2], a1 = l$1[1];
        if (!match) {
          var r1$0 = caml_call2(f, i$1, a1);
          return [0, r1$0, 0];
        }
        var l = match[2], a2 = match[1], r1 = caml_call2(f, i$1, a1), r2 = caml_call2(f, 1, a2), block = [0, r2, 24029], dst = block, offset = 1, i = 2, param = l;
        for (; ; ) {
          if (param) {
            var match$0 = param[2], a1$0 = param[1];
            if (match$0) {
              var l$0 = match$0[2], a2$0 = match$0[1], r1$1 = caml_call2(f, i, a1$0), r2$0 = caml_call2(f, i + 1 | 0, a2$0), dst$0 = [0, r2$0, 24029];
              dst[1 + offset] = [0, r1$1, dst$0];
              var i$0 = i + 2 | 0, dst = dst$0, offset = 1, i = i$0, param = l$0;
              continue;
            }
            var r1$2 = caml_call2(f, i, a1$0);
            dst[1 + offset] = [0, r1$2, 0];
          } else
            dst[1 + offset] = 0;
          return [0, r1, block];
        }
      }
      function rev_map(f, l) {
        var accu = 0, param = l;
        for (; ; ) {
          if (!param)
            return accu;
          var l$0 = param[2], a = param[1], accu$0 = [0, caml_call1(f, a), accu], accu = accu$0, param = l$0;
        }
      }
      function iter(f, param) {
        var param$0 = param;
        for (; ; ) {
          if (!param$0)
            return 0;
          var l = param$0[2], a = param$0[1];
          caml_call1(f, a);
          var param$0 = l;
        }
      }
      function iteri(f, l$0) {
        var i = 0, param = l$0;
        for (; ; ) {
          if (!param)
            return 0;
          var l = param[2], a = param[1];
          caml_call2(f, i, a);
          var i$0 = i + 1 | 0, i = i$0, param = l;
        }
      }
      function fold_left(f, accu, l) {
        var accu$0 = accu, l$0 = l;
        for (; ; ) {
          if (!l$0)
            return accu$0;
          var l$1 = l$0[2], a = l$0[1], accu$1 = caml_call2(f, accu$0, a), accu$0 = accu$1, l$0 = l$1;
        }
      }
      function fold_right(f, l, accu) {
        if (!l)
          return accu;
        var l$0 = l[2], a = l[1];
        return caml_call2(f, a, fold_right(f, l$0, accu));
      }
      function map2(f, l1, l2) {
        if (l1) {
          var _G_ = l1[2], a1 = l1[1];
          if (_G_) {
            if (l2) {
              var match = l2[2];
              if (match) {
                var l2$0 = match[2], b2 = match[1], b1 = l2[1], l1$0 = _G_[2], a2 = _G_[1], r1 = caml_call2(f, a1, b1), r2 = caml_call2(f, a2, b2), block = [0, r2, 24029], dst = block, offset = 1, l1$1 = l1$0, l2$1 = l2$0;
                for (; ; ) {
                  a: {
                    if (l1$1) {
                      var _H_ = l1$1[2], a1$0 = l1$1[1];
                      if (_H_) {
                        if (l2$1) {
                          var match$0 = l2$1[2];
                          if (match$0) {
                            var l2$2 = match$0[2], b2$0 = match$0[1], b1$1 = l2$1[1], l1$2 = _H_[2], a2$0 = _H_[1], r1$1 = caml_call2(f, a1$0, b1$1), r2$0 = caml_call2(f, a2$0, b2$0), dst$0 = [0, r2$0, 24029];
                            dst[1 + offset] = [0, r1$1, dst$0];
                            var dst = dst$0, offset = 1, l1$1 = l1$2, l2$1 = l2$2;
                            continue;
                          }
                        }
                      } else if (l2$1 && !l2$1[2]) {
                        var b1$2 = l2$1[1], r1$2 = caml_call2(f, a1$0, b1$2);
                        dst[1 + offset] = [0, r1$2, 0];
                        break a;
                      }
                    } else if (!l2$1) {
                      dst[1 + offset] = 0;
                      break a;
                    }
                    dst[1 + offset] = caml_call1(Stdlib[1], cst_List_map2$0);
                  }
                  return [0, r1, block];
                }
              }
            }
          } else if (l2 && !l2[2]) {
            var b1$0 = l2[1], r1$0 = caml_call2(f, a1, b1$0);
            return [0, r1$0, 0];
          }
        } else if (!l2)
          return 0;
        return caml_call1(Stdlib[1], cst_List_map2);
      }
      function rev_map2(f, l1, l2) {
        var accu = 0, l1$0 = l1, l2$0 = l2;
        for (; ; ) {
          if (l1$0) {
            if (l2$0) {
              var l2$1 = l2$0[2], a2 = l2$0[1], l1$1 = l1$0[2], a1 = l1$0[1], accu$0 = [0, caml_call2(f, a1, a2), accu], accu = accu$0, l1$0 = l1$1, l2$0 = l2$1;
              continue;
            }
          } else if (!l2$0)
            return accu;
          return caml_call1(Stdlib[1], cst_List_rev_map2);
        }
      }
      function iter2(f, l1, l2) {
        var l1$0 = l1, l2$0 = l2;
        for (; ; ) {
          if (l1$0) {
            if (l2$0) {
              var l2$1 = l2$0[2], a2 = l2$0[1], l1$1 = l1$0[2], a1 = l1$0[1];
              caml_call2(f, a1, a2);
              var l1$0 = l1$1, l2$0 = l2$1;
              continue;
            }
          } else if (!l2$0)
            return 0;
          return caml_call1(Stdlib[1], cst_List_iter2);
        }
      }
      function fold_left2(f, accu, l1, l2) {
        var accu$0 = accu, l1$0 = l1, l2$0 = l2;
        for (; ; ) {
          if (l1$0) {
            if (l2$0) {
              var l2$1 = l2$0[2], a2 = l2$0[1], l1$1 = l1$0[2], a1 = l1$0[1], accu$1 = caml_call3(f, accu$0, a1, a2), accu$0 = accu$1, l1$0 = l1$1, l2$0 = l2$1;
              continue;
            }
          } else if (!l2$0)
            return accu$0;
          return caml_call1(Stdlib[1], cst_List_fold_left2);
        }
      }
      function fold_right2(f, l1, l2, accu) {
        if (l1) {
          if (l2) {
            var l2$0 = l2[2], a2 = l2[1], l1$0 = l1[2], a1 = l1[1];
            return caml_call3(f, a1, a2, fold_right2(f, l1$0, l2$0, accu));
          }
        } else if (!l2)
          return accu;
        return caml_call1(Stdlib[1], cst_List_fold_right2);
      }
      function for_all(p, param) {
        var param$0 = param;
        for (; ; ) {
          if (!param$0)
            return 1;
          var l = param$0[2], a = param$0[1], _F_ = caml_call1(p, a);
          if (!_F_)
            return _F_;
          var param$0 = l;
        }
      }
      function exists(p, param) {
        var param$0 = param;
        for (; ; ) {
          if (!param$0)
            return 0;
          var l = param$0[2], a = param$0[1], _E_ = caml_call1(p, a);
          if (_E_)
            return _E_;
          var param$0 = l;
        }
      }
      function for_all2(p, l1, l2) {
        var l1$0 = l1, l2$0 = l2;
        for (; ; ) {
          if (l1$0) {
            if (l2$0) {
              var l2$1 = l2$0[2], a2 = l2$0[1], l1$1 = l1$0[2], a1 = l1$0[1], _D_ = caml_call2(p, a1, a2);
              if (!_D_)
                return _D_;
              var l1$0 = l1$1, l2$0 = l2$1;
              continue;
            }
          } else if (!l2$0)
            return 1;
          return caml_call1(Stdlib[1], cst_List_for_all2);
        }
      }
      function exists2(p, l1, l2) {
        var l1$0 = l1, l2$0 = l2;
        for (; ; ) {
          if (l1$0) {
            if (l2$0) {
              var l2$1 = l2$0[2], a2 = l2$0[1], l1$1 = l1$0[2], a1 = l1$0[1], _C_ = caml_call2(p, a1, a2);
              if (_C_)
                return _C_;
              var l1$0 = l1$1, l2$0 = l2$1;
              continue;
            }
          } else if (!l2$0)
            return 0;
          return caml_call1(Stdlib[1], cst_List_exists2);
        }
      }
      function mem(x2, param) {
        var param$0 = param;
        for (; ; ) {
          if (!param$0)
            return 0;
          var l = param$0[2], a = param$0[1], _B_ = 0 === caml_compare2(a, x2) ? 1 : 0;
          if (_B_)
            return _B_;
          var param$0 = l;
        }
      }
      function memq(x2, param) {
        var param$0 = param;
        for (; ; ) {
          if (!param$0)
            return 0;
          var l = param$0[2], a = param$0[1], _A_ = a === x2 ? 1 : 0;
          if (_A_)
            return _A_;
          var param$0 = l;
        }
      }
      function assoc(x2, param) {
        var param$0 = param;
        for (; ; ) {
          if (!param$0)
            throw caml_maybe_attach_backtrace2(Stdlib[8], 1);
          var l = param$0[2], match = param$0[1], b = match[2], a = match[1];
          if (0 === caml_compare2(a, x2))
            return b;
          var param$0 = l;
        }
      }
      function assoc_opt(x2, param) {
        var param$0 = param;
        for (; ; ) {
          if (!param$0)
            return 0;
          var l = param$0[2], match = param$0[1], b = match[2], a = match[1];
          if (0 === caml_compare2(a, x2))
            return [0, b];
          var param$0 = l;
        }
      }
      function assq(x2, param) {
        var param$0 = param;
        for (; ; ) {
          if (!param$0)
            throw caml_maybe_attach_backtrace2(Stdlib[8], 1);
          var l = param$0[2], match = param$0[1], b = match[2], a = match[1];
          if (a === x2)
            return b;
          var param$0 = l;
        }
      }
      function assq_opt(x2, param) {
        var param$0 = param;
        for (; ; ) {
          if (!param$0)
            return 0;
          var l = param$0[2], match = param$0[1], b = match[2], a = match[1];
          if (a === x2)
            return [0, b];
          var param$0 = l;
        }
      }
      function mem_assoc(x2, param) {
        var param$0 = param;
        for (; ; ) {
          if (!param$0)
            return 0;
          var l = param$0[2], a = param$0[1][1], _z_ = 0 === caml_compare2(a, x2) ? 1 : 0;
          if (_z_)
            return _z_;
          var param$0 = l;
        }
      }
      function mem_assq(x2, param) {
        var param$0 = param;
        for (; ; ) {
          if (!param$0)
            return 0;
          var l = param$0[2], a = param$0[1][1], _y_ = a === x2 ? 1 : 0;
          if (_y_)
            return _y_;
          var param$0 = l;
        }
      }
      function remove_assoc(x2, param) {
        if (!param)
          return 0;
        var l = param[2], pair = param[1], a = pair[1];
        return 0 === caml_compare2(a, x2) ? l : [0, pair, remove_assoc(x2, l)];
      }
      function remove_assq(x2, param) {
        if (!param)
          return 0;
        var l = param[2], pair = param[1], a = pair[1];
        return a === x2 ? l : [0, pair, remove_assq(x2, l)];
      }
      function find(p, param) {
        var param$0 = param;
        for (; ; ) {
          if (!param$0)
            throw caml_maybe_attach_backtrace2(Stdlib[8], 1);
          var l = param$0[2], x2 = param$0[1];
          if (caml_call1(p, x2))
            return x2;
          var param$0 = l;
        }
      }
      function find_opt(p, param) {
        var param$0 = param;
        for (; ; ) {
          if (!param$0)
            return 0;
          var l = param$0[2], x2 = param$0[1];
          if (caml_call1(p, x2))
            return [0, x2];
          var param$0 = l;
        }
      }
      function find_index(p) {
        var i = 0;
        return function(param$0) {
          var i$0 = i, param = param$0;
          for (; ; ) {
            if (!param)
              return 0;
            var l = param[2], a = param[1];
            if (caml_call1(p, a))
              return [0, i$0];
            var i$1 = i$0 + 1 | 0, i$0 = i$1, param = l;
          }
        };
      }
      function find_map(f, param) {
        var param$0 = param;
        for (; ; ) {
          if (!param$0)
            return 0;
          var l = param$0[2], x2 = param$0[1], result = caml_call1(f, x2);
          if (result)
            return result;
          var param$0 = l;
        }
      }
      function find_mapi(f) {
        var i = 0;
        return function(param$0) {
          var i$0 = i, param = param$0;
          for (; ; ) {
            if (!param)
              return 0;
            var l = param[2], x2 = param[1], result = caml_call2(f, i$0, x2);
            if (result)
              return result;
            var i$1 = i$0 + 1 | 0, i$0 = i$1, param = l;
          }
        };
      }
      function find_all(p, param) {
        var param$0 = param;
        for (; ; ) {
          if (!param$0)
            return 0;
          var l = param$0[2], x2 = param$0[1];
          if (caml_call1(p, x2)) {
            var block = [0, x2, 24029], dst = block, offset = 1, param$1 = l;
            for (; ; ) {
              if (!param$1) {
                dst[1 + offset] = 0;
                return block;
              }
              var l$0 = param$1[2], x$0 = param$1[1];
              if (caml_call1(p, x$0)) {
                var dst$0 = [0, x$0, 24029];
                dst[1 + offset] = dst$0;
                var dst = dst$0, offset = 1, param$1 = l$0;
              } else
                var param$1 = l$0;
            }
          } else
            var param$0 = l;
        }
      }
      function filteri(p, l$1) {
        var i = 0, param = l$1;
        for (; ; ) {
          if (!param)
            return 0;
          var l = param[2], x2 = param[1], i$0 = i + 1 | 0;
          if (caml_call2(p, i, x2))
            break;
          var i = i$0, param = l;
        }
        var block = [0, x2, 24029], dst = block, offset = 1, i$1 = i$0, param$0 = l;
        for (; ; ) {
          if (!param$0) {
            dst[1 + offset] = 0;
            return block;
          }
          var l$0 = param$0[2], x$0 = param$0[1], i$2 = i$1 + 1 | 0;
          if (caml_call2(p, i$1, x$0)) {
            var dst$0 = [0, x$0, 24029];
            dst[1 + offset] = dst$0;
            var dst = dst$0, offset = 1, i$1 = i$2, param$0 = l$0;
          } else
            var i$1 = i$2, param$0 = l$0;
        }
      }
      function filter_map(f, param) {
        var param$0 = param;
        for (; ; ) {
          if (!param$0)
            return 0;
          var l = param$0[2], x2 = param$0[1], match = caml_call1(f, x2);
          if (match) {
            var v = match[1], block = [0, v, 24029], dst = block, offset = 1, param$1 = l;
            for (; ; ) {
              if (!param$1) {
                dst[1 + offset] = 0;
                return block;
              }
              var l$0 = param$1[2], x$0 = param$1[1], match$0 = caml_call1(f, x$0);
              if (match$0) {
                var v$0 = match$0[1], dst$0 = [0, v$0, 24029];
                dst[1 + offset] = dst$0;
                var dst = dst$0, offset = 1, param$1 = l$0;
              } else
                var param$1 = l$0;
            }
          } else
            var param$0 = l;
        }
      }
      function concat_map(f, param) {
        var param$0 = param;
        for (; ; ) {
          if (!param$0)
            return 0;
          var xs = param$0[2], x2 = param$0[1], ys = caml_call1(f, x2);
          if (ys) {
            var ys$1 = ys[2], y = ys[1], block = [0, y, 24029], dst = block, offset = 1, ys$2 = ys$1, xs$1 = xs;
            for (; ; )
              if (ys$2) {
                var ys$3 = ys$2[2], y$0 = ys$2[1], dst$0 = [0, y$0, 24029];
                dst[1 + offset] = dst$0;
                var dst = dst$0, offset = 1, ys$2 = ys$3;
              } else {
                if (!xs$1) {
                  dst[1 + offset] = 0;
                  return block;
                }
                var xs$0 = xs$1[2], x$0 = xs$1[1], ys$0 = caml_call1(f, x$0), ys$2 = ys$0, xs$1 = xs$0;
              }
          } else
            var param$0 = xs;
        }
      }
      function fold_left_map(f, accu, l) {
        var accu$0 = accu, l_accu = 0, param = l;
        for (; ; ) {
          if (!param)
            return [0, accu$0, rev(l_accu)];
          var l$0 = param[2], x2 = param[1], match = caml_call2(f, accu$0, x2), x$0 = match[2], accu$1 = match[1], l_accu$0 = [0, x$0, l_accu], accu$0 = accu$1, l_accu = l_accu$0, param = l$0;
        }
      }
      function partition(p, l) {
        var yes = 0, no = 0, param = l;
        for (; ; ) {
          if (!param) {
            var _x_ = rev(no);
            return [0, rev(yes), _x_];
          }
          var l$0 = param[2], x2 = param[1];
          if (caml_call1(p, x2))
            var yes$0 = [0, x2, yes], yes = yes$0, param = l$0;
          else
            var no$0 = [0, x2, no], no = no$0, param = l$0;
        }
      }
      function partition_map(p, l) {
        var left = 0, right = 0, param = l;
        for (; ; ) {
          if (!param) {
            var _w_ = rev(right);
            return [0, rev(left), _w_];
          }
          var l$0 = param[2], x2 = param[1], match = caml_call1(p, x2);
          if (0 === match[0])
            var v = match[1], left$0 = [0, v, left], left = left$0, param = l$0;
          else
            var v$0 = match[1], right$0 = [0, v$0, right], right = right$0, param = l$0;
        }
      }
      function split(param) {
        if (!param)
          return _a_;
        var l = param[2], match = param[1], y = match[2], x2 = match[1], match$0 = split(l), ry = match$0[2], rx = match$0[1];
        return [0, [0, x2, rx], [0, y, ry]];
      }
      function combine(l1, l2) {
        if (l1) {
          if (l2) {
            var l2$0 = l2[2], a2 = l2[1], l1$0 = l1[2], a1 = l1[1];
            return [0, [0, a1, a2], combine(l1$0, l2$0)];
          }
        } else if (!l2)
          return 0;
        return caml_call1(Stdlib[1], cst_List_combine);
      }
      function merge(cmp, l1, l2) {
        if (!l1)
          return l2;
        if (!l2)
          return l1;
        var t2 = l2[2], h2 = l2[1], t1 = l1[2], h1 = l1[1];
        return 0 < caml_call2(cmp, h1, h2) ? [0, h2, merge(cmp, l1, t2)] : [0, h1, merge(cmp, t1, l2)];
      }
      function stable_sort(cmp, l) {
        function sort(n, l2) {
          if (2 === n) {
            if (l2) {
              var match = l2[2];
              if (match) {
                var tl2 = match[2], x2 = match[1], x1 = l2[1], s2 = 0 < caml_call2(cmp, x1, x2) ? [0, x2, [0, x1, 0]] : [0, x1, [0, x2, 0]];
                return [0, s2, tl2];
              }
            }
          } else if (3 === n && l2) {
            var _v_ = l2[2];
            if (_v_) {
              var match$2 = _v_[2];
              if (match$2) {
                var tl$1 = match$2[2], x3 = match$2[1], x2$0 = _v_[1], x1$0 = l2[1], s$0 = 0 < caml_call2(cmp, x1$0, x2$0) ? 0 < caml_call2(cmp, x1$0, x3) ? 0 < caml_call2(cmp, x2$0, x3) ? [0, x3, [0, x2$0, [0, x1$0, 0]]] : [0, x2$0, [0, x3, [0, x1$0, 0]]] : [0, x2$0, [0, x1$0, [0, x3, 0]]] : 0 < caml_call2(cmp, x2$0, x3) ? 0 < caml_call2(cmp, x1$0, x3) ? [0, x3, [0, x1$0, [0, x2$0, 0]]] : [0, x1$0, [0, x3, [0, x2$0, 0]]] : [0, x1$0, [0, x2$0, [0, x3, 0]]];
                return [0, s$0, tl$1];
              }
            }
          }
          var n1 = n >> 1, n2 = n - n1 | 0, match$0 = rev_sort(n1, l2), l2$0 = match$0[2], s1 = match$0[1], match$1 = rev_sort(n2, l2$0), tl$0 = match$1[2], s22 = match$1[1], l1 = s1, l22 = s22, accu = 0;
          for (; ; ) {
            if (l1) {
              if (l22) {
                var t2 = l22[2], h2 = l22[1], t1 = l1[2], h1 = l1[1];
                if (0 < caml_call2(cmp, h1, h2)) {
                  var accu$0 = [0, h1, accu], l1 = t1, accu = accu$0;
                  continue;
                }
                var accu$1 = [0, h2, accu], l22 = t2, accu = accu$1;
                continue;
              }
              var _u_ = rev_append(l1, accu);
            } else
              var _u_ = rev_append(l22, accu);
            return [0, _u_, tl$0];
          }
        }
        function rev_sort(n, l2) {
          if (2 === n) {
            if (l2) {
              var match = l2[2];
              if (match) {
                var tl2 = match[2], x2 = match[1], x1 = l2[1], s2 = 0 < caml_call2(cmp, x1, x2) ? [0, x1, [0, x2, 0]] : [0, x2, [0, x1, 0]];
                return [0, s2, tl2];
              }
            }
          } else if (3 === n && l2) {
            var _t_ = l2[2];
            if (_t_) {
              var match$2 = _t_[2];
              if (match$2) {
                var tl$1 = match$2[2], x3 = match$2[1], x2$0 = _t_[1], x1$0 = l2[1], s$0 = 0 < caml_call2(cmp, x1$0, x2$0) ? 0 < caml_call2(cmp, x2$0, x3) ? [0, x1$0, [0, x2$0, [0, x3, 0]]] : 0 < caml_call2(cmp, x1$0, x3) ? [0, x1$0, [0, x3, [0, x2$0, 0]]] : [0, x3, [0, x1$0, [0, x2$0, 0]]] : 0 < caml_call2(cmp, x1$0, x3) ? [0, x2$0, [0, x1$0, [0, x3, 0]]] : 0 < caml_call2(cmp, x2$0, x3) ? [0, x2$0, [0, x3, [0, x1$0, 0]]] : [0, x3, [0, x2$0, [0, x1$0, 0]]];
                return [0, s$0, tl$1];
              }
            }
          }
          var n1 = n >> 1, n2 = n - n1 | 0, match$0 = sort(n1, l2), l2$0 = match$0[2], s1 = match$0[1], match$1 = sort(n2, l2$0), tl$0 = match$1[2], s22 = match$1[1], l1 = s1, l22 = s22, accu = 0;
          for (; ; ) {
            if (l1) {
              if (l22) {
                var t2 = l22[2], h2 = l22[1], t1 = l1[2], h1 = l1[1];
                if (0 < caml_call2(cmp, h1, h2)) {
                  var accu$0 = [0, h2, accu], l22 = t2, accu = accu$0;
                  continue;
                }
                var accu$1 = [0, h1, accu], l1 = t1, accu = accu$1;
                continue;
              }
              var _s_ = rev_append(l1, accu);
            } else
              var _s_ = rev_append(l22, accu);
            return [0, _s_, tl$0];
          }
        }
        var len = length(l);
        return 2 <= len ? sort(len, l)[1] : l;
      }
      function sort_uniq(cmp, l) {
        function sort(n, l2) {
          if (2 === n) {
            if (l2) {
              var match = l2[2];
              if (match) {
                var tl2 = match[2], x2 = match[1], x1 = l2[1], c$0 = caml_call2(cmp, x1, x2), s2 = 0 === c$0 ? [0, x1, 0] : 0 <= c$0 ? [0, x2, [0, x1, 0]] : [0, x1, [0, x2, 0]];
                return [0, s2, tl2];
              }
            }
          } else if (3 === n && l2) {
            var _m_ = l2[2];
            if (_m_) {
              var match$2 = _m_[2];
              if (match$2) {
                var tl$1 = match$2[2], x3 = match$2[1], x2$0 = _m_[1], x1$0 = l2[1], c$1 = caml_call2(cmp, x1$0, x2$0);
                if (0 === c$1)
                  var c$2 = caml_call2(cmp, x2$0, x3), _n_ = 0 === c$2 ? [0, x2$0, 0] : 0 <= c$2 ? [0, x3, [0, x2$0, 0]] : [0, x2$0, [0, x3, 0]], s$0 = _n_;
                else if (0 <= c$1) {
                  var c$3 = caml_call2(cmp, x1$0, x3);
                  if (0 === c$3)
                    var _o_ = [0, x2$0, [0, x1$0, 0]];
                  else if (0 <= c$3)
                    var c$4 = caml_call2(cmp, x2$0, x3), _p_ = 0 === c$4 ? [0, x2$0, [0, x1$0, 0]] : 0 <= c$4 ? [0, x3, [0, x2$0, [0, x1$0, 0]]] : [0, x2$0, [0, x3, [0, x1$0, 0]]], _o_ = _p_;
                  else
                    var _o_ = [0, x2$0, [0, x1$0, [0, x3, 0]]];
                  var s$0 = _o_;
                } else {
                  var c$5 = caml_call2(cmp, x2$0, x3);
                  if (0 === c$5)
                    var _q_ = [0, x1$0, [0, x2$0, 0]];
                  else if (0 <= c$5)
                    var c$6 = caml_call2(cmp, x1$0, x3), _r_ = 0 === c$6 ? [0, x1$0, [0, x2$0, 0]] : 0 <= c$6 ? [0, x3, [0, x1$0, [0, x2$0, 0]]] : [0, x1$0, [0, x3, [0, x2$0, 0]]], _q_ = _r_;
                  else
                    var _q_ = [0, x1$0, [0, x2$0, [0, x3, 0]]];
                  var s$0 = _q_;
                }
                return [0, s$0, tl$1];
              }
            }
          }
          var n1 = n >> 1, n2 = n - n1 | 0, match$0 = rev_sort(n1, l2), l2$0 = match$0[2], s1 = match$0[1], match$1 = rev_sort(n2, l2$0), tl$0 = match$1[2], s22 = match$1[1], l1 = s1, l22 = s22, accu = 0;
          for (; ; ) {
            if (l1) {
              if (l22) {
                var t2 = l22[2], h2 = l22[1], t1 = l1[2], h1 = l1[1], c = caml_call2(cmp, h1, h2);
                if (0 === c) {
                  var accu$0 = [0, h1, accu], l1 = t1, l22 = t2, accu = accu$0;
                  continue;
                }
                if (0 < c) {
                  var accu$1 = [0, h1, accu], l1 = t1, accu = accu$1;
                  continue;
                }
                var accu$2 = [0, h2, accu], l22 = t2, accu = accu$2;
                continue;
              }
              var _l_ = rev_append(l1, accu);
            } else
              var _l_ = rev_append(l22, accu);
            return [0, _l_, tl$0];
          }
        }
        function rev_sort(n, l2) {
          if (2 === n) {
            if (l2) {
              var match = l2[2];
              if (match) {
                var tl2 = match[2], x2 = match[1], x1 = l2[1], c$0 = caml_call2(cmp, x1, x2), s2 = 0 === c$0 ? [0, x1, 0] : 0 < c$0 ? [0, x1, [0, x2, 0]] : [0, x2, [0, x1, 0]];
                return [0, s2, tl2];
              }
            }
          } else if (3 === n && l2) {
            var _f_ = l2[2];
            if (_f_) {
              var match$2 = _f_[2];
              if (match$2) {
                var tl$1 = match$2[2], x3 = match$2[1], x2$0 = _f_[1], x1$0 = l2[1], c$1 = caml_call2(cmp, x1$0, x2$0);
                if (0 === c$1)
                  var c$2 = caml_call2(cmp, x2$0, x3), _g_ = 0 === c$2 ? [0, x2$0, 0] : 0 < c$2 ? [0, x2$0, [0, x3, 0]] : [0, x3, [0, x2$0, 0]], s$0 = _g_;
                else if (0 < c$1) {
                  var c$3 = caml_call2(cmp, x2$0, x3);
                  if (0 === c$3)
                    var _h_ = [0, x1$0, [0, x2$0, 0]];
                  else if (0 < c$3)
                    var _h_ = [0, x1$0, [0, x2$0, [0, x3, 0]]];
                  else
                    var c$4 = caml_call2(cmp, x1$0, x3), _i_ = 0 === c$4 ? [0, x1$0, [0, x2$0, 0]] : 0 < c$4 ? [0, x1$0, [0, x3, [0, x2$0, 0]]] : [0, x3, [0, x1$0, [0, x2$0, 0]]], _h_ = _i_;
                  var s$0 = _h_;
                } else {
                  var c$5 = caml_call2(cmp, x1$0, x3);
                  if (0 === c$5)
                    var _j_ = [0, x2$0, [0, x1$0, 0]];
                  else if (0 < c$5)
                    var _j_ = [0, x2$0, [0, x1$0, [0, x3, 0]]];
                  else
                    var c$6 = caml_call2(cmp, x2$0, x3), _k_ = 0 === c$6 ? [0, x2$0, [0, x1$0, 0]] : 0 < c$6 ? [0, x2$0, [0, x3, [0, x1$0, 0]]] : [0, x3, [0, x2$0, [0, x1$0, 0]]], _j_ = _k_;
                  var s$0 = _j_;
                }
                return [0, s$0, tl$1];
              }
            }
          }
          var n1 = n >> 1, n2 = n - n1 | 0, match$0 = sort(n1, l2), l2$0 = match$0[2], s1 = match$0[1], match$1 = sort(n2, l2$0), tl$0 = match$1[2], s22 = match$1[1], l1 = s1, l22 = s22, accu = 0;
          for (; ; ) {
            if (l1) {
              if (l22) {
                var t2 = l22[2], h2 = l22[1], t1 = l1[2], h1 = l1[1], c = caml_call2(cmp, h1, h2);
                if (0 === c) {
                  var accu$0 = [0, h1, accu], l1 = t1, l22 = t2, accu = accu$0;
                  continue;
                }
                if (0 <= c) {
                  var accu$1 = [0, h2, accu], l22 = t2, accu = accu$1;
                  continue;
                }
                var accu$2 = [0, h1, accu], l1 = t1, accu = accu$2;
                continue;
              }
              var _e_ = rev_append(l1, accu);
            } else
              var _e_ = rev_append(l22, accu);
            return [0, _e_, tl$0];
          }
        }
        var len = length(l);
        return 2 <= len ? sort(len, l)[1] : l;
      }
      function compare_lengths(l1, l2) {
        var l1$0 = l1, l2$0 = l2;
        for (; ; ) {
          if (!l1$0)
            return l2$0 ? -1 : 0;
          if (!l2$0)
            return 1;
          var l2$1 = l2$0[2], l1$1 = l1$0[2], l1$0 = l1$1, l2$0 = l2$1;
        }
      }
      function compare_length_with(l, n) {
        var l$0 = l, n$0 = n;
        for (; ; ) {
          if (!l$0)
            return 0 === n$0 ? 0 : 0 < n$0 ? -1 : 1;
          var l$1 = l$0[2];
          if (0 >= n$0)
            return 1;
          var n$1 = n$0 - 1 | 0, l$0 = l$1, n$0 = n$1;
        }
      }
      function is_empty(param) {
        return param ? 0 : 1;
      }
      function equal(eq, l1, l2) {
        var l1$0 = l1, l2$0 = l2;
        for (; ; ) {
          if (l1$0) {
            if (l2$0) {
              var l2$1 = l2$0[2], a2 = l2$0[1], l1$1 = l1$0[2], a1 = l1$0[1], _d_ = caml_call2(eq, a1, a2);
              if (!_d_)
                return _d_;
              var l1$0 = l1$1, l2$0 = l2$1;
              continue;
            }
          } else if (!l2$0)
            return 1;
          return 0;
        }
      }
      function compare(cmp, l1, l2) {
        var l1$0 = l1, l2$0 = l2;
        for (; ; ) {
          if (!l1$0)
            return l2$0 ? -1 : 0;
          var l1$1 = l1$0[2], a1 = l1$0[1];
          if (!l2$0)
            return 1;
          var l2$1 = l2$0[2], a2 = l2$0[1], c = caml_call2(cmp, a1, a2);
          if (0 !== c)
            return c;
          var l1$0 = l1$1, l2$0 = l2$1;
        }
      }
      function to_seq(l) {
        function aux(l2, param) {
          if (!l2)
            return 0;
          var tail = l2[2], x2 = l2[1];
          return [0, x2, function(_c_) {
            return aux(tail, _c_);
          }];
        }
        return function(_b_) {
          return aux(l, _b_);
        };
      }
      function of_seq(seq) {
        var match = caml_call1(seq, 0);
        if (!match)
          return 0;
        var seq$0 = match[2], x1 = match[1], match$0 = caml_call1(seq$0, 0);
        if (!match$0)
          return [0, x1, 0];
        var seq$1 = match$0[2], x2 = match$0[1], block = [0, x2, 24029], dst = block, offset = 1, seq$2 = seq$1;
        for (; ; ) {
          var match$1 = caml_call1(seq$2, 0);
          if (match$1) {
            var seq$3 = match$1[2], x1$0 = match$1[1], match$2 = caml_call1(seq$3, 0);
            if (match$2) {
              var seq$4 = match$2[2], x2$0 = match$2[1], dst$0 = [0, x2$0, 24029];
              dst[1 + offset] = [0, x1$0, dst$0];
              var dst = dst$0, offset = 1, seq$2 = seq$4;
              continue;
            }
            dst[1 + offset] = [0, x1$0, 0];
          } else
            dst[1 + offset] = 0;
          return [0, x1, block];
        }
      }
      var Stdlib_List = [
        0,
        length,
        compare_lengths,
        compare_length_with,
        is_empty,
        cons,
        hd,
        tl,
        nth,
        nth_opt,
        rev,
        init,
        append,
        rev_append,
        flatten,
        flatten,
        equal,
        compare,
        iter,
        iteri,
        map,
        mapi,
        rev_map,
        filter_map,
        concat_map,
        fold_left_map,
        fold_left,
        fold_right,
        iter2,
        map2,
        rev_map2,
        fold_left2,
        fold_right2,
        for_all,
        exists,
        for_all2,
        exists2,
        mem,
        memq,
        find,
        find_opt,
        find_index,
        find_map,
        find_mapi,
        find_all,
        find_all,
        filteri,
        partition,
        partition_map,
        assoc,
        assoc_opt,
        assq,
        assq_opt,
        mem_assoc,
        mem_assq,
        remove_assoc,
        remove_assq,
        split,
        combine,
        stable_sort,
        stable_sort,
        stable_sort,
        sort_uniq,
        merge,
        to_seq,
        of_seq
      ];
      runtime.caml_register_global(17, Stdlib_List, "Stdlib__List");
      return;
    })(globalThis);
    (function(globalThis2) {
      "use strict";
      var runtime = globalThis2.jsoo_runtime, caml_hash2 = runtime.caml_hash;
      function abs(x2) {
        return 0 <= x2 ? x2 : -x2 | 0;
      }
      function lognot(x2) {
        return x2 ^ -1;
      }
      function equal(_b_, _a_) {
        return _b_ === _a_ ? 1 : 0;
      }
      var compare = runtime.caml_int_compare;
      function min(x2, y) {
        return x2 <= y ? x2 : y;
      }
      function max(x2, y) {
        return y <= x2 ? x2 : y;
      }
      function to_string(x2) {
        return "" + x2;
      }
      function seeded_hash(seed, x2) {
        return caml_hash2(10, 100, seed, x2);
      }
      function hash(x2) {
        return caml_hash2(10, 100, 0, x2);
      }
      var Stdlib_Int = [
        0,
        0,
        1,
        -1,
        abs,
        2147483647,
        -2147483648,
        lognot,
        equal,
        compare,
        min,
        max,
        to_string,
        seeded_hash,
        hash
      ];
      runtime.caml_register_global(1, Stdlib_Int, "Stdlib__Int");
      return;
    })(globalThis);
    (function(globalThis2) {
      "use strict";
      var runtime = globalThis2.jsoo_runtime, cst_bytes_ml = "bytes.ml", cst_index_out_of_bounds$3 = "index out of bounds", caml_blit_bytes2 = runtime.caml_blit_bytes, caml_bswap162 = runtime.caml_bswap16, caml_bytes_get2 = runtime.caml_bytes_get, caml_bytes_get162 = runtime.caml_bytes_get16, caml_bytes_get322 = runtime.caml_bytes_get32, caml_bytes_get642 = runtime.caml_bytes_get64, caml_bytes_of_string2 = runtime.caml_bytes_of_string, caml_bytes_set2 = runtime.caml_bytes_set, caml_bytes_set162 = runtime.caml_bytes_set16, caml_bytes_set322 = runtime.caml_bytes_set32, caml_bytes_set642 = runtime.caml_bytes_set64, caml_bytes_unsafe_get2 = runtime.caml_bytes_unsafe_get, caml_bytes_unsafe_set2 = runtime.caml_bytes_unsafe_set, caml_create_bytes2 = runtime.caml_create_bytes, caml_fill_bytes2 = runtime.caml_fill_bytes, caml_int32_bswap2 = runtime.caml_int32_bswap, caml_int64_bswap2 = runtime.caml_int64_bswap, caml_maybe_attach_backtrace2 = runtime.caml_maybe_attach_backtrace, caml_ml_bytes_length2 = runtime.caml_ml_bytes_length, caml_string_of_bytes2 = runtime.caml_string_of_bytes, caml_wrap_exception2 = runtime.caml_wrap_exception;
      function caml_call1(f, a0) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 1 ? f(a0) : runtime.caml_call_gen(f, [a0]);
      }
      function caml_call2(f, a0, a1) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 2 ? f(a0, a1) : runtime.caml_call_gen(f, [a0, a1]);
      }
      var undef = void 0, global_data = runtime.caml_get_global_data(), Stdlib = global_data.Stdlib, Stdlib_Uchar = global_data.Stdlib__Uchar, Assert_failure = global_data.Assert_failure, Stdlib_Sys = global_data.Stdlib__Sys, Stdlib_Int = global_data.Stdlib__Int, Stdlib_Seq = global_data.Stdlib__Seq, Stdlib_Char = global_data.Stdlib__Char;
      function make(n, c) {
        var s2 = caml_create_bytes2(n);
        caml_fill_bytes2(s2, 0, n, c);
        return s2;
      }
      function init(n, f) {
        var s2 = caml_create_bytes2(n), _ap_ = n - 1 | 0, _ao_ = 0;
        if (_ap_ >= 0) {
          var i = _ao_;
          for (; ; ) {
            caml_bytes_unsafe_set2(s2, i, caml_call1(f, i));
            var _aq_ = i + 1 | 0;
            if (_ap_ === i)
              break;
            var i = _aq_;
          }
        }
        return s2;
      }
      var empty = caml_create_bytes2(0), cst_String_sub_Bytes_sub = "String.sub / Bytes.sub", cst_Bytes_extend = "Bytes.extend", cst_String_fill_Bytes_fill = "String.fill / Bytes.fill", cst_Bytes_blit = "Bytes.blit", cst_String_blit_Bytes_blit_str = "String.blit / Bytes.blit_string", cst_Bytes_concat = "Bytes.concat", cst_String_index_from_Bytes_in = "String.index_from / Bytes.index_from", cst_String_index_from_opt_Byte = "String.index_from_opt / Bytes.index_from_opt", cst_String_rindex_from_Bytes_r = "String.rindex_from / Bytes.rindex_from", cst_String_rindex_from_opt_Byt = "String.rindex_from_opt / Bytes.rindex_from_opt", cst_String_contains_from_Bytes = "String.contains_from / Bytes.contains_from", cst_String_rcontains_from_Byte = "String.rcontains_from / Bytes.rcontains_from";
      function copy(s2) {
        var len = caml_ml_bytes_length2(s2), r = caml_create_bytes2(len);
        caml_blit_bytes2(s2, 0, r, 0, len);
        return r;
      }
      function to_string(b) {
        return caml_string_of_bytes2(copy(b));
      }
      function of_string(s2) {
        return copy(caml_bytes_of_string2(s2));
      }
      function sub(s2, ofs, len) {
        if (0 <= ofs && 0 <= len && (caml_ml_bytes_length2(s2) - len | 0) >= ofs) {
          var r = caml_create_bytes2(len);
          caml_blit_bytes2(s2, ofs, r, 0, len);
          return r;
        }
        return caml_call1(Stdlib[1], cst_String_sub_Bytes_sub);
      }
      function sub_string(b, ofs, len) {
        return caml_string_of_bytes2(sub(b, ofs, len));
      }
      function symbol(a, b) {
        var c = a + b | 0, _an_ = b < 0 ? 1 : 0, match = c < 0 ? 1 : 0;
        a: {
          if (a < 0) {
            if (_an_ && !match)
              break a;
          } else if (!_an_ && match)
            break a;
          return c;
        }
        return caml_call1(Stdlib[1], cst_Bytes_extend);
      }
      function extend(s2, left, right) {
        var len = symbol(symbol(caml_ml_bytes_length2(s2), left), right), r = caml_create_bytes2(len);
        if (0 <= left)
          var dstoff = left, srcoff = 0;
        else
          var dstoff = 0, srcoff = -left | 0;
        var cpylen = caml_call2(
          Stdlib_Int[10],
          caml_ml_bytes_length2(s2) - srcoff | 0,
          len - dstoff | 0
        );
        if (0 < cpylen)
          caml_blit_bytes2(s2, srcoff, r, dstoff, cpylen);
        return r;
      }
      function fill(s2, ofs, len, c) {
        if (0 <= ofs && 0 <= len && (caml_ml_bytes_length2(s2) - len | 0) >= ofs)
          return caml_fill_bytes2(s2, ofs, len, c);
        return caml_call1(Stdlib[1], cst_String_fill_Bytes_fill);
      }
      function blit(s1, ofs1, s2, ofs2, len) {
        if (0 <= len && 0 <= ofs1 && (caml_ml_bytes_length2(s1) - len | 0) >= ofs1 && 0 <= ofs2 && (caml_ml_bytes_length2(s2) - len | 0) >= ofs2)
          return caml_blit_bytes2(s1, ofs1, s2, ofs2, len);
        return caml_call1(Stdlib[1], cst_Bytes_blit);
      }
      function blit_string(s1, ofs1, s2, ofs2, len) {
        if (0 <= len && 0 <= ofs1 && (runtime.caml_ml_string_length(s1) - len | 0) >= ofs1 && 0 <= ofs2 && (caml_ml_bytes_length2(s2) - len | 0) >= ofs2)
          return runtime.caml_blit_string(s1, ofs1, s2, ofs2, len);
        return caml_call1(Stdlib[1], cst_String_blit_Bytes_blit_str);
      }
      function iter(f, a) {
        var _al_ = caml_ml_bytes_length2(a) - 1 | 0, _ak_ = 0;
        if (_al_ >= 0) {
          var i = _ak_;
          for (; ; ) {
            caml_call1(f, caml_bytes_unsafe_get2(a, i));
            var _am_ = i + 1 | 0;
            if (_al_ === i)
              break;
            var i = _am_;
          }
        }
        return 0;
      }
      function iteri(f, a) {
        var _ai_ = caml_ml_bytes_length2(a) - 1 | 0, _ah_ = 0;
        if (_ai_ >= 0) {
          var i = _ah_;
          for (; ; ) {
            caml_call2(f, i, caml_bytes_unsafe_get2(a, i));
            var _aj_ = i + 1 | 0;
            if (_ai_ === i)
              break;
            var i = _aj_;
          }
        }
        return 0;
      }
      function concat(sep, l) {
        if (!l)
          return empty;
        var seplen = caml_ml_bytes_length2(sep);
        a: {
          b: {
            var acc = 0, param = l, pos$1 = 0;
            for (; ; ) {
              if (!param)
                break;
              var hd = param[1];
              if (!param[2])
                break b;
              var tl = param[2], x2 = (caml_ml_bytes_length2(hd) + seplen | 0) + acc | 0, acc$0 = acc <= x2 ? x2 : caml_call1(Stdlib[1], cst_Bytes_concat), acc = acc$0, param = tl;
            }
            var _ag_ = acc;
            break a;
          }
          var _ag_ = caml_ml_bytes_length2(hd) + acc | 0;
        }
        var dst = caml_create_bytes2(_ag_), pos = pos$1, param$0 = l;
        for (; ; ) {
          if (!param$0)
            return dst;
          var hd$0 = param$0[1];
          if (!param$0[2]) {
            caml_blit_bytes2(hd$0, 0, dst, pos, caml_ml_bytes_length2(hd$0));
            return dst;
          }
          var tl$0 = param$0[2];
          caml_blit_bytes2(hd$0, 0, dst, pos, caml_ml_bytes_length2(hd$0));
          caml_blit_bytes2(sep, 0, dst, pos + caml_ml_bytes_length2(hd$0) | 0, seplen);
          var pos$0 = (pos + caml_ml_bytes_length2(hd$0) | 0) + seplen | 0, pos = pos$0, param$0 = tl$0;
        }
      }
      function cat(s1, s2) {
        var l1 = caml_ml_bytes_length2(s1), l2 = caml_ml_bytes_length2(s2), r = caml_create_bytes2(l1 + l2 | 0);
        caml_blit_bytes2(s1, 0, r, 0, l1);
        caml_blit_bytes2(s2, 0, r, l1, l2);
        return r;
      }
      function is_space(param) {
        var _af_ = param - 9 | 0;
        a: {
          if (4 < _af_ >>> 0) {
            if (23 !== _af_)
              break a;
          } else if (2 === _af_)
            break a;
          return 1;
        }
        return 0;
      }
      function trim(s2) {
        var len = caml_ml_bytes_length2(s2), i = [0, 0];
        for (; ; ) {
          if (i[1] >= len)
            break;
          if (!is_space(caml_bytes_unsafe_get2(s2, i[1])))
            break;
          i[1]++;
        }
        var j = [0, len - 1 | 0];
        for (; ; ) {
          if (i[1] <= j[1] && is_space(caml_bytes_unsafe_get2(s2, j[1]))) {
            j[1] += -1;
            continue;
          }
          return i[1] <= j[1] ? sub(s2, i[1], (j[1] - i[1] | 0) + 1 | 0) : empty;
        }
      }
      function unsafe_escape(s2) {
        var n = [0, 0], ___ = caml_ml_bytes_length2(s2) - 1 | 0, _Z_ = 0;
        if (___ >= 0) {
          var i$0 = _Z_;
          for (; ; ) {
            var match = caml_bytes_unsafe_get2(s2, i$0);
            a: {
              b: {
                c: {
                  if (32 <= match) {
                    var _ac_ = match - 34 | 0;
                    if (58 < _ac_ >>> 0) {
                      if (93 <= _ac_)
                        break c;
                    } else if (56 < _ac_ - 1 >>> 0)
                      break b;
                    var _ad_ = 1;
                    break a;
                  }
                  if (11 <= match) {
                    if (13 === match)
                      break b;
                  } else if (8 <= match)
                    break b;
                }
                var _ad_ = 4;
                break a;
              }
              var _ad_ = 2;
            }
            n[1] = n[1] + _ad_ | 0;
            var _ae_ = i$0 + 1 | 0;
            if (___ === i$0)
              break;
            var i$0 = _ae_;
          }
        }
        if (n[1] === caml_ml_bytes_length2(s2))
          return s2;
        var s$0 = caml_create_bytes2(n[1]);
        n[1] = 0;
        var _aa_ = caml_ml_bytes_length2(s2) - 1 | 0, _$_ = 0;
        if (_aa_ >= 0) {
          var i = _$_;
          for (; ; ) {
            var c = caml_bytes_unsafe_get2(s2, i);
            a: {
              b: {
                c: {
                  if (35 <= c) {
                    if (92 !== c) {
                      if (127 <= c)
                        break c;
                      break b;
                    }
                  } else {
                    if (32 > c) {
                      if (14 <= c)
                        break c;
                      switch (c) {
                        case 8:
                          caml_bytes_unsafe_set2(s$0, n[1], 92);
                          n[1]++;
                          caml_bytes_unsafe_set2(s$0, n[1], 98);
                          break a;
                        case 9:
                          caml_bytes_unsafe_set2(s$0, n[1], 92);
                          n[1]++;
                          caml_bytes_unsafe_set2(s$0, n[1], 116);
                          break a;
                        case 10:
                          caml_bytes_unsafe_set2(s$0, n[1], 92);
                          n[1]++;
                          caml_bytes_unsafe_set2(s$0, n[1], 110);
                          break a;
                        case 13:
                          caml_bytes_unsafe_set2(s$0, n[1], 92);
                          n[1]++;
                          caml_bytes_unsafe_set2(s$0, n[1], 114);
                          break a;
                        default:
                          break c;
                      }
                    }
                    if (34 > c)
                      break b;
                  }
                  caml_bytes_unsafe_set2(s$0, n[1], 92);
                  n[1]++;
                  caml_bytes_unsafe_set2(s$0, n[1], c);
                  break a;
                }
                caml_bytes_unsafe_set2(s$0, n[1], 92);
                n[1]++;
                caml_bytes_unsafe_set2(s$0, n[1], 48 + (c / 100 | 0) | 0);
                n[1]++;
                caml_bytes_unsafe_set2(s$0, n[1], 48 + ((c / 10 | 0) % 10 | 0) | 0);
                n[1]++;
                caml_bytes_unsafe_set2(s$0, n[1], 48 + (c % 10 | 0) | 0);
                break a;
              }
              caml_bytes_unsafe_set2(s$0, n[1], c);
            }
            n[1]++;
            var _ab_ = i + 1 | 0;
            if (_aa_ === i)
              break;
            var i = _ab_;
          }
        }
        return s$0;
      }
      function escaped(b) {
        var b$0 = copy(b);
        return unsafe_escape(b$0);
      }
      function map(f, s2) {
        var l = caml_ml_bytes_length2(s2);
        if (0 === l)
          return s2;
        var r = caml_create_bytes2(l), _X_ = l - 1 | 0, _W_ = 0;
        if (_X_ >= 0) {
          var i = _W_;
          for (; ; ) {
            caml_bytes_unsafe_set2(r, i, caml_call1(f, caml_bytes_unsafe_get2(s2, i)));
            var _Y_ = i + 1 | 0;
            if (_X_ === i)
              break;
            var i = _Y_;
          }
        }
        return r;
      }
      function mapi(f, s2) {
        var l = caml_ml_bytes_length2(s2);
        if (0 === l)
          return s2;
        var r = caml_create_bytes2(l), _U_ = l - 1 | 0, _T_2 = 0;
        if (_U_ >= 0) {
          var i = _T_2;
          for (; ; ) {
            caml_bytes_unsafe_set2(r, i, caml_call2(f, i, caml_bytes_unsafe_get2(s2, i)));
            var _V_ = i + 1 | 0;
            if (_U_ === i)
              break;
            var i = _V_;
          }
        }
        return r;
      }
      function fold_left(f, x2, a) {
        var r = [0, x2], _R_ = caml_ml_bytes_length2(a) - 1 | 0, _Q_ = 0;
        if (_R_ >= 0) {
          var i = _Q_;
          for (; ; ) {
            r[1] = caml_call2(f, r[1], caml_bytes_unsafe_get2(a, i));
            var _S_ = i + 1 | 0;
            if (_R_ === i)
              break;
            var i = _S_;
          }
        }
        return r[1];
      }
      function fold_right(f, a, x2) {
        var r = [0, x2], _O_ = caml_ml_bytes_length2(a) - 1 | 0;
        if (_O_ >= 0) {
          var i = _O_;
          for (; ; ) {
            r[1] = caml_call2(f, caml_bytes_unsafe_get2(a, i), r[1]);
            var _P_ = i - 1 | 0;
            if (0 === i)
              break;
            var i = _P_;
          }
        }
        return r[1];
      }
      function exists(p, s2) {
        var n = caml_ml_bytes_length2(s2), i = 0;
        for (; ; ) {
          if (i === n)
            return 0;
          if (caml_call1(p, caml_bytes_unsafe_get2(s2, i)))
            return 1;
          var i$0 = i + 1 | 0, i = i$0;
        }
      }
      function for_all(p, s2) {
        var n = caml_ml_bytes_length2(s2), i = 0;
        for (; ; ) {
          if (i === n)
            return 1;
          if (!caml_call1(p, caml_bytes_unsafe_get2(s2, i)))
            return 0;
          var i$0 = i + 1 | 0, i = i$0;
        }
      }
      function uppercase_ascii(s2) {
        return map(Stdlib_Char[4], s2);
      }
      function lowercase_ascii(s2) {
        return map(Stdlib_Char[3], s2);
      }
      function apply1(f, s2) {
        if (0 === caml_ml_bytes_length2(s2))
          return s2;
        var r = copy(s2);
        caml_bytes_unsafe_set2(r, 0, caml_call1(f, caml_bytes_unsafe_get2(s2, 0)));
        return r;
      }
      function capitalize_ascii(s2) {
        return apply1(Stdlib_Char[4], s2);
      }
      function uncapitalize_ascii(s2) {
        return apply1(Stdlib_Char[3], s2);
      }
      function starts_with(prefix, s2) {
        var len_s = caml_ml_bytes_length2(s2), len_pre = caml_ml_bytes_length2(prefix), _N_ = len_pre <= len_s ? 1 : 0;
        if (!_N_)
          return _N_;
        var i = 0;
        for (; ; ) {
          if (i === len_pre)
            return 1;
          if (caml_bytes_unsafe_get2(s2, i) !== caml_bytes_unsafe_get2(prefix, i))
            return 0;
          var i$0 = i + 1 | 0, i = i$0;
        }
      }
      function ends_with(suffix, s2) {
        var len_s = caml_ml_bytes_length2(s2), len_suf = caml_ml_bytes_length2(suffix), diff = len_s - len_suf | 0, _M_ = 0 <= diff ? 1 : 0;
        if (!_M_)
          return _M_;
        var i = 0;
        for (; ; ) {
          if (i === len_suf)
            return 1;
          if (caml_bytes_unsafe_get2(s2, diff + i | 0) !== caml_bytes_unsafe_get2(suffix, i))
            return 0;
          var i$0 = i + 1 | 0, i = i$0;
        }
      }
      function index_rec(s2, lim, i, c) {
        var i$0 = i;
        for (; ; ) {
          if (lim <= i$0)
            throw caml_maybe_attach_backtrace2(Stdlib[8], 1);
          if (caml_bytes_unsafe_get2(s2, i$0) === c)
            return i$0;
          var i$1 = i$0 + 1 | 0, i$0 = i$1;
        }
      }
      function index(s2, c) {
        return index_rec(s2, caml_ml_bytes_length2(s2), 0, c);
      }
      function index_rec_opt(s2, lim, i, c) {
        var i$0 = i;
        for (; ; ) {
          if (lim <= i$0)
            return 0;
          if (caml_bytes_unsafe_get2(s2, i$0) === c)
            return [0, i$0];
          var i$1 = i$0 + 1 | 0, i$0 = i$1;
        }
      }
      function index_opt(s2, c) {
        return index_rec_opt(s2, caml_ml_bytes_length2(s2), 0, c);
      }
      function index_from(s2, i, c) {
        var l = caml_ml_bytes_length2(s2);
        if (0 <= i && l >= i)
          return index_rec(s2, l, i, c);
        return caml_call1(Stdlib[1], cst_String_index_from_Bytes_in);
      }
      function index_from_opt(s2, i, c) {
        var l = caml_ml_bytes_length2(s2);
        if (0 <= i && l >= i)
          return index_rec_opt(s2, l, i, c);
        return caml_call1(Stdlib[1], cst_String_index_from_opt_Byte);
      }
      function rindex_rec(s2, i, c) {
        var i$0 = i;
        for (; ; ) {
          if (0 > i$0)
            throw caml_maybe_attach_backtrace2(Stdlib[8], 1);
          if (caml_bytes_unsafe_get2(s2, i$0) === c)
            return i$0;
          var i$1 = i$0 - 1 | 0, i$0 = i$1;
        }
      }
      function rindex(s2, c) {
        return rindex_rec(s2, caml_ml_bytes_length2(s2) - 1 | 0, c);
      }
      function rindex_from(s2, i, c) {
        if (-1 <= i && caml_ml_bytes_length2(s2) > i)
          return rindex_rec(s2, i, c);
        return caml_call1(Stdlib[1], cst_String_rindex_from_Bytes_r);
      }
      function rindex_rec_opt(s2, i, c) {
        var i$0 = i;
        for (; ; ) {
          if (0 > i$0)
            return 0;
          if (caml_bytes_unsafe_get2(s2, i$0) === c)
            return [0, i$0];
          var i$1 = i$0 - 1 | 0, i$0 = i$1;
        }
      }
      function rindex_opt(s2, c) {
        return rindex_rec_opt(s2, caml_ml_bytes_length2(s2) - 1 | 0, c);
      }
      function rindex_from_opt(s2, i, c) {
        if (-1 <= i && caml_ml_bytes_length2(s2) > i)
          return rindex_rec_opt(s2, i, c);
        return caml_call1(Stdlib[1], cst_String_rindex_from_opt_Byt);
      }
      function contains_from(s2, i, c) {
        var l = caml_ml_bytes_length2(s2);
        if (0 <= i && l >= i)
          try {
            index_rec(s2, l, i, c);
            var _K_ = 1;
            return _K_;
          } catch (_L_) {
            var _J_ = caml_wrap_exception2(_L_);
            if (_J_ === Stdlib[8])
              return 0;
            throw caml_maybe_attach_backtrace2(_J_, 0);
          }
        return caml_call1(Stdlib[1], cst_String_contains_from_Bytes);
      }
      function contains(s2, c) {
        return contains_from(s2, 0, c);
      }
      function rcontains_from(s2, i, c) {
        if (0 <= i && caml_ml_bytes_length2(s2) > i)
          try {
            rindex_rec(s2, i, c);
            var _H_ = 1;
            return _H_;
          } catch (_I_) {
            var _G_ = caml_wrap_exception2(_I_);
            if (_G_ === Stdlib[8])
              return 0;
            throw caml_maybe_attach_backtrace2(_G_, 0);
          }
        return caml_call1(Stdlib[1], cst_String_rcontains_from_Byte);
      }
      var compare = runtime.caml_bytes_compare, cst_Bytes_of_seq_cannot_grow_b = "Bytes.of_seq: cannot grow bytes";
      function split_on_char(sep, s2) {
        var r = [0, 0], j = [0, caml_ml_bytes_length2(s2)], _C_ = caml_ml_bytes_length2(s2) - 1 | 0;
        if (_C_ >= 0) {
          var i = _C_;
          for (; ; ) {
            if (caml_bytes_unsafe_get2(s2, i) === sep) {
              var _E_ = r[1];
              r[1] = [0, sub(s2, i + 1 | 0, (j[1] - i | 0) - 1 | 0), _E_];
              j[1] = i;
            }
            var _F_ = i - 1 | 0;
            if (0 === i)
              break;
            var i = _F_;
          }
        }
        var _D_ = r[1];
        return [0, sub(s2, 0, j[1]), _D_];
      }
      function to_seq(s2) {
        function aux(i, param) {
          if (i === caml_ml_bytes_length2(s2))
            return 0;
          var x2 = caml_bytes_get2(s2, i), _A_ = i + 1 | 0;
          return [0, x2, function(_B_) {
            return aux(_A_, _B_);
          }];
        }
        var _y_ = 0;
        return function(_z_) {
          return aux(_y_, _z_);
        };
      }
      function to_seqi(s2) {
        function aux(i, param) {
          if (i === caml_ml_bytes_length2(s2))
            return 0;
          var x2 = caml_bytes_get2(s2, i), _w_ = i + 1 | 0;
          return [0, [0, i, x2], function(_x_) {
            return aux(_w_, _x_);
          }];
        }
        var _u_ = 0;
        return function(_v_) {
          return aux(_u_, _v_);
        };
      }
      function of_seq(i) {
        var n = [0, 0], buf = [0, make(256, 0)];
        caml_call2(
          Stdlib_Seq[4],
          function(c) {
            if (n[1] === caml_ml_bytes_length2(buf[1])) {
              var new_len = caml_call2(
                Stdlib_Int[10],
                2 * caml_ml_bytes_length2(buf[1]) | 0,
                Stdlib_Sys[12]
              );
              if (caml_ml_bytes_length2(buf[1]) === new_len)
                caml_call1(Stdlib[2], cst_Bytes_of_seq_cannot_grow_b);
              var new_buf = make(new_len, 0);
              blit(buf[1], 0, new_buf, 0, n[1]);
              buf[1] = new_buf;
            }
            caml_bytes_set2(buf[1], n[1], c);
            n[1]++;
            return 0;
          },
          i
        );
        return sub(buf[1], 0, n[1]);
      }
      function unsafe_get_uint16_le(b, i) {
        return Stdlib_Sys[11] ? caml_bswap162(caml_bytes_get162(b, i)) : caml_bytes_get162(b, i);
      }
      function unsafe_get_uint16_be(b, i) {
        return Stdlib_Sys[11] ? caml_bytes_get162(b, i) : caml_bswap162(caml_bytes_get162(b, i));
      }
      function get_int8(b, i) {
        var _s_ = Stdlib_Sys[10] - 8 | 0, _t_ = Stdlib_Sys[10] - 8 | 0;
        return caml_bytes_get2(b, i) << _t_ >> _s_;
      }
      function get_uint16_le(b, i) {
        return Stdlib_Sys[11] ? caml_bswap162(caml_bytes_get162(b, i)) : caml_bytes_get162(b, i);
      }
      function get_uint16_be(b, i) {
        return Stdlib_Sys[11] ? caml_bytes_get162(b, i) : caml_bswap162(caml_bytes_get162(b, i));
      }
      function get_int16_ne(b, i) {
        var _q_ = Stdlib_Sys[10] - 16 | 0, _r_ = Stdlib_Sys[10] - 16 | 0;
        return caml_bytes_get162(b, i) << _r_ >> _q_;
      }
      function get_int16_le(b, i) {
        var _o_ = Stdlib_Sys[10] - 16 | 0, _p_ = Stdlib_Sys[10] - 16 | 0;
        return get_uint16_le(b, i) << _p_ >> _o_;
      }
      function get_int16_be(b, i) {
        var _m_ = Stdlib_Sys[10] - 16 | 0, _n_ = Stdlib_Sys[10] - 16 | 0;
        return get_uint16_be(b, i) << _n_ >> _m_;
      }
      function get_int32_le(b, i) {
        return Stdlib_Sys[11] ? caml_int32_bswap2(caml_bytes_get322(b, i)) : caml_bytes_get322(b, i);
      }
      function get_int32_be(b, i) {
        return Stdlib_Sys[11] ? caml_bytes_get322(b, i) : caml_int32_bswap2(caml_bytes_get322(b, i));
      }
      function get_int64_le(b, i) {
        return Stdlib_Sys[11] ? caml_int64_bswap2(caml_bytes_get642(b, i)) : caml_bytes_get642(b, i);
      }
      function get_int64_be(b, i) {
        return Stdlib_Sys[11] ? caml_bytes_get642(b, i) : caml_int64_bswap2(caml_bytes_get642(b, i));
      }
      function unsafe_set_uint16_le(b, i, x2) {
        if (Stdlib_Sys[11]) {
          caml_bytes_set162(b, i, caml_bswap162(x2));
          return;
        }
        caml_bytes_set162(b, i, x2);
        return;
      }
      function unsafe_set_uint16_be(b, i, x2) {
        if (Stdlib_Sys[11]) {
          caml_bytes_set162(b, i, x2);
          return;
        }
        caml_bytes_set162(b, i, caml_bswap162(x2));
        return;
      }
      function set_int16_le(b, i, x2) {
        return Stdlib_Sys[11] ? caml_bytes_set162(b, i, caml_bswap162(x2)) : caml_bytes_set162(b, i, x2);
      }
      function set_int16_be(b, i, x2) {
        return Stdlib_Sys[11] ? caml_bytes_set162(b, i, x2) : caml_bytes_set162(b, i, caml_bswap162(x2));
      }
      function set_int32_le(b, i, x2) {
        return Stdlib_Sys[11] ? caml_bytes_set322(b, i, caml_int32_bswap2(x2)) : caml_bytes_set322(b, i, x2);
      }
      function set_int32_be(b, i, x2) {
        return Stdlib_Sys[11] ? caml_bytes_set322(b, i, x2) : caml_bytes_set322(b, i, caml_int32_bswap2(x2));
      }
      function set_int64_le(b, i, x2) {
        return Stdlib_Sys[11] ? caml_bytes_set642(b, i, caml_int64_bswap2(x2)) : caml_bytes_set642(b, i, x2);
      }
      function set_int64_be(b, i, x2) {
        return Stdlib_Sys[11] ? caml_bytes_set642(b, i, x2) : caml_bytes_set642(b, i, caml_int64_bswap2(x2));
      }
      var set_uint8 = caml_bytes_set2, set_uint16_ne = caml_bytes_set162, dec_invalid = Stdlib_Uchar[22], _a_ = [0, cst_bytes_ml, 679, 9], _b_ = [0, cst_bytes_ml, 654, 20], cst_index_out_of_bounds = cst_index_out_of_bounds$3, cst_index_out_of_bounds$0 = cst_index_out_of_bounds$3, _c_ = [0, cst_bytes_ml, 777, 9], _d_ = [0, cst_bytes_ml, 766, 20], cst_index_out_of_bounds$1 = cst_index_out_of_bounds$3, cst_index_out_of_bounds$2 = cst_index_out_of_bounds$3, _e_ = [0, cst_bytes_ml, 831, 9], _f_ = [0, cst_bytes_ml, 820, 20];
      function dec_ret(n, u) {
        var _l_ = caml_call1(Stdlib_Uchar[9], u);
        return caml_call2(Stdlib_Uchar[21], n, _l_);
      }
      function not_in_x80_to_xBF(b) {
        return 2 !== (b >>> 6 | 0) ? 1 : 0;
      }
      function not_in_xA0_to_xBF(b) {
        return 5 !== (b >>> 5 | 0) ? 1 : 0;
      }
      function not_in_x80_to_x9F(b) {
        return 4 !== (b >>> 5 | 0) ? 1 : 0;
      }
      function not_in_x90_to_xBF(b) {
        var _j_ = b < 144 ? 1 : 0, _k_ = _j_ || (191 < b ? 1 : 0);
        return _k_;
      }
      function not_in_x80_to_x8F(b) {
        return 8 !== (b >>> 4 | 0) ? 1 : 0;
      }
      function utf_8_uchar_3(b0, b1, b2) {
        return (b0 & 15) << 12 | (b1 & 63) << 6 | b2 & 63;
      }
      function utf_8_uchar_4(b0, b1, b2, b3) {
        return (b0 & 7) << 18 | (b1 & 63) << 12 | (b2 & 63) << 6 | b3 & 63;
      }
      function get_utf_8_uchar(b, i) {
        var b0 = caml_bytes_get2(b, i), max = caml_ml_bytes_length2(b) - 1 | 0;
        a: {
          if (224 <= b0) {
            if (237 <= b0) {
              if (245 <= b0)
                break a;
              switch (b0 - 237 | 0) {
                case 0:
                  var i$0 = i + 1 | 0;
                  if (max < i$0)
                    return caml_call1(dec_invalid, 1);
                  var b1 = caml_bytes_unsafe_get2(b, i$0);
                  if (not_in_x80_to_x9F(b1))
                    return caml_call1(dec_invalid, 1);
                  var i$1 = i$0 + 1 | 0;
                  if (max < i$1)
                    return caml_call1(dec_invalid, 2);
                  var b2 = caml_bytes_unsafe_get2(b, i$1);
                  return not_in_x80_to_xBF(b2) ? caml_call1(dec_invalid, 2) : dec_ret(3, utf_8_uchar_3(b0, b1, b2));
                case 3:
                  var i$4 = i + 1 | 0;
                  if (max < i$4)
                    return caml_call1(dec_invalid, 1);
                  var b1$1 = caml_bytes_unsafe_get2(b, i$4);
                  if (not_in_x90_to_xBF(b1$1))
                    return caml_call1(dec_invalid, 1);
                  var i$5 = i$4 + 1 | 0;
                  if (max < i$5)
                    return caml_call1(dec_invalid, 2);
                  var b2$1 = caml_bytes_unsafe_get2(b, i$5);
                  if (not_in_x80_to_xBF(b2$1))
                    return caml_call1(dec_invalid, 2);
                  var i$6 = i$5 + 1 | 0;
                  if (max < i$6)
                    return caml_call1(dec_invalid, 3);
                  var b3 = caml_bytes_unsafe_get2(b, i$6);
                  return not_in_x80_to_xBF(b3) ? caml_call1(dec_invalid, 3) : dec_ret(4, utf_8_uchar_4(b0, b1$1, b2$1, b3));
                case 7:
                  var i$10 = i + 1 | 0;
                  if (max < i$10)
                    return caml_call1(dec_invalid, 1);
                  var b1$3 = caml_bytes_unsafe_get2(b, i$10);
                  if (not_in_x80_to_x8F(b1$3))
                    return caml_call1(dec_invalid, 1);
                  var i$11 = i$10 + 1 | 0;
                  if (max < i$11)
                    return caml_call1(dec_invalid, 2);
                  var b2$3 = caml_bytes_unsafe_get2(b, i$11);
                  if (not_in_x80_to_xBF(b2$3))
                    return caml_call1(dec_invalid, 2);
                  var i$12 = i$11 + 1 | 0;
                  if (max < i$12)
                    return caml_call1(dec_invalid, 3);
                  var b3$1 = caml_bytes_unsafe_get2(b, i$12);
                  return not_in_x80_to_xBF(b3$1) ? caml_call1(dec_invalid, 3) : dec_ret(4, utf_8_uchar_4(b0, b1$3, b2$3, b3$1));
                case 1:
                case 2:
                  break;
                default:
                  var i$7 = i + 1 | 0;
                  if (max < i$7)
                    return caml_call1(dec_invalid, 1);
                  var b1$2 = caml_bytes_unsafe_get2(b, i$7);
                  if (not_in_x80_to_xBF(b1$2))
                    return caml_call1(dec_invalid, 1);
                  var i$8 = i$7 + 1 | 0;
                  if (max < i$8)
                    return caml_call1(dec_invalid, 2);
                  var b2$2 = caml_bytes_unsafe_get2(b, i$8);
                  if (not_in_x80_to_xBF(b2$2))
                    return caml_call1(dec_invalid, 2);
                  var i$9 = i$8 + 1 | 0;
                  if (max < i$9)
                    return caml_call1(dec_invalid, 3);
                  var b3$0 = caml_bytes_unsafe_get2(b, i$9);
                  return not_in_x80_to_xBF(b3$0) ? caml_call1(dec_invalid, 3) : dec_ret(4, utf_8_uchar_4(b0, b1$2, b2$2, b3$0));
              }
            } else if (225 > b0) {
              var i$13 = i + 1 | 0;
              if (max < i$13)
                return caml_call1(dec_invalid, 1);
              var b1$4 = caml_bytes_unsafe_get2(b, i$13);
              if (not_in_xA0_to_xBF(b1$4))
                return caml_call1(dec_invalid, 1);
              var i$14 = i$13 + 1 | 0;
              if (max < i$14)
                return caml_call1(dec_invalid, 2);
              var b2$4 = caml_bytes_unsafe_get2(b, i$14);
              return not_in_x80_to_xBF(b2$4) ? caml_call1(dec_invalid, 2) : dec_ret(3, utf_8_uchar_3(b0, b1$4, b2$4));
            }
            var i$2 = i + 1 | 0;
            if (max < i$2)
              return caml_call1(dec_invalid, 1);
            var b1$0 = caml_bytes_unsafe_get2(b, i$2);
            if (not_in_x80_to_xBF(b1$0))
              return caml_call1(dec_invalid, 1);
            var i$3 = i$2 + 1 | 0;
            if (max < i$3)
              return caml_call1(dec_invalid, 2);
            var b2$0 = caml_bytes_unsafe_get2(b, i$3);
            return not_in_x80_to_xBF(b2$0) ? caml_call1(dec_invalid, 2) : dec_ret(3, utf_8_uchar_3(b0, b1$0, b2$0));
          }
          if (128 > b0)
            return dec_ret(1, b0);
          if (194 <= b0) {
            var i$15 = i + 1 | 0;
            if (max < i$15)
              return caml_call1(dec_invalid, 1);
            var b1$5 = caml_bytes_unsafe_get2(b, i$15);
            return not_in_x80_to_xBF(b1$5) ? caml_call1(dec_invalid, 1) : dec_ret(2, (b0 & 31) << 6 | b1$5 & 63);
          }
        }
        return caml_call1(dec_invalid, 1);
      }
      function set_utf_8_uchar(b, i, u) {
        function set(_i_, _h_, _g_) {
          caml_bytes_unsafe_set2(_i_, _h_, _g_);
          return;
        }
        var max = caml_ml_bytes_length2(b) - 1 | 0, u$0 = caml_call1(Stdlib_Uchar[10], u);
        if (0 > u$0)
          throw caml_maybe_attach_backtrace2([0, Assert_failure, _b_], 1);
        if (127 >= u$0) {
          caml_bytes_set2(b, i, u$0);
          return 1;
        }
        if (2047 >= u$0) {
          var last$1 = i + 1 | 0;
          return max < last$1 ? 0 : (caml_bytes_set2(b, i, 192 | u$0 >>> 6 | 0), set(b, last$1, 128 | u$0 & 63), 2);
        }
        if (65535 >= u$0) {
          var last$0 = i + 2 | 0;
          return max < last$0 ? 0 : (caml_bytes_set2(b, i, 224 | u$0 >>> 12 | 0), set(b, i + 1 | 0, 128 | (u$0 >>> 6 | 0) & 63), set(b, last$0, 128 | u$0 & 63), 3);
        }
        if (1114111 < u$0)
          throw caml_maybe_attach_backtrace2([0, Assert_failure, _a_], 1);
        var last = i + 3 | 0;
        return max < last ? 0 : (caml_bytes_set2(b, i, 240 | u$0 >>> 18 | 0), set(b, i + 1 | 0, 128 | (u$0 >>> 12 | 0) & 63), set(b, i + 2 | 0, 128 | (u$0 >>> 6 | 0) & 63), set(b, last, 128 | u$0 & 63), 4);
      }
      function is_valid_utf_8(b) {
        var max = caml_ml_bytes_length2(b) - 1 | 0, i = 0;
        for (; ; ) {
          if (max < i)
            return 1;
          var match = caml_bytes_unsafe_get2(b, i);
          a: {
            if (224 <= match) {
              if (237 <= match) {
                if (245 <= match)
                  break a;
                switch (match - 237 | 0) {
                  case 0:
                    var last = i + 2 | 0;
                    if (max >= last && !not_in_x80_to_x9F(caml_bytes_unsafe_get2(b, i + 1 | 0)) && !not_in_x80_to_xBF(caml_bytes_unsafe_get2(b, last))) {
                      var i$0 = last + 1 | 0, i = i$0;
                      continue;
                    }
                    return 0;
                  case 3:
                    var last$1 = i + 3 | 0;
                    if (max >= last$1 && !not_in_x90_to_xBF(caml_bytes_unsafe_get2(b, i + 1 | 0)) && !not_in_x80_to_xBF(caml_bytes_unsafe_get2(b, i + 2 | 0)) && !not_in_x80_to_xBF(caml_bytes_unsafe_get2(b, last$1))) {
                      var i$2 = last$1 + 1 | 0, i = i$2;
                      continue;
                    }
                    return 0;
                  case 7:
                    var last$3 = i + 3 | 0;
                    if (max >= last$3 && !not_in_x80_to_x8F(caml_bytes_unsafe_get2(b, i + 1 | 0)) && !not_in_x80_to_xBF(caml_bytes_unsafe_get2(b, i + 2 | 0)) && !not_in_x80_to_xBF(caml_bytes_unsafe_get2(b, last$3))) {
                      var i$4 = last$3 + 1 | 0, i = i$4;
                      continue;
                    }
                    return 0;
                  case 1:
                  case 2:
                    break;
                  default:
                    var last$2 = i + 3 | 0;
                    if (max >= last$2 && !not_in_x80_to_xBF(caml_bytes_unsafe_get2(b, i + 1 | 0)) && !not_in_x80_to_xBF(caml_bytes_unsafe_get2(b, i + 2 | 0)) && !not_in_x80_to_xBF(caml_bytes_unsafe_get2(b, last$2))) {
                      var i$3 = last$2 + 1 | 0, i = i$3;
                      continue;
                    }
                    return 0;
                }
              } else if (225 > match) {
                var last$4 = i + 2 | 0;
                if (max >= last$4 && !not_in_xA0_to_xBF(caml_bytes_unsafe_get2(b, i + 1 | 0)) && !not_in_x80_to_xBF(caml_bytes_unsafe_get2(b, last$4))) {
                  var i$5 = last$4 + 1 | 0, i = i$5;
                  continue;
                }
                return 0;
              }
              var last$0 = i + 2 | 0;
              if (max >= last$0 && !not_in_x80_to_xBF(caml_bytes_unsafe_get2(b, i + 1 | 0)) && !not_in_x80_to_xBF(caml_bytes_unsafe_get2(b, last$0))) {
                var i$1 = last$0 + 1 | 0, i = i$1;
                continue;
              }
              return 0;
            }
            if (128 > match) {
              var i$7 = i + 1 | 0, i = i$7;
              continue;
            }
            if (194 <= match) {
              var last$5 = i + 1 | 0;
              if (max >= last$5 && !not_in_x80_to_xBF(caml_bytes_unsafe_get2(b, last$5))) {
                var i$6 = last$5 + 1 | 0, i = i$6;
                continue;
              }
              return 0;
            }
          }
          return 0;
        }
      }
      function get_utf_16be_uchar(b, i) {
        var max = caml_ml_bytes_length2(b) - 1 | 0;
        if (0 <= i && max >= i) {
          if (i === max)
            return caml_call1(dec_invalid, 1);
          var hi = unsafe_get_uint16_be(b, i);
          if (55296 <= hi && 57343 >= hi) {
            if (56319 < hi)
              return caml_call1(dec_invalid, 2);
            var last = i + 3 | 0;
            if (max < last)
              return caml_call1(dec_invalid, (max - i | 0) + 1 | 0);
            var lo = unsafe_get_uint16_be(b, i + 2 | 0);
            if (56320 <= lo && 57343 >= lo) {
              var u = ((hi & 1023) << 10 | lo & 1023) + 65536 | 0;
              return dec_ret(4, u);
            }
            return caml_call1(dec_invalid, 2);
          }
          return dec_ret(2, hi);
        }
        return caml_call1(Stdlib[1], cst_index_out_of_bounds);
      }
      function set_utf_16be_uchar(b, i, u) {
        var max = caml_ml_bytes_length2(b) - 1 | 0;
        if (0 <= i && max >= i) {
          var u$0 = caml_call1(Stdlib_Uchar[10], u);
          if (0 > u$0)
            throw caml_maybe_attach_backtrace2([0, Assert_failure, _d_], 1);
          if (65535 >= u$0) {
            var last$0 = i + 1 | 0;
            return max < last$0 ? 0 : (unsafe_set_uint16_be(b, i, u$0), 2);
          }
          if (1114111 < u$0)
            throw caml_maybe_attach_backtrace2([0, Assert_failure, _c_], 1);
          var last = i + 3 | 0;
          if (max < last)
            return 0;
          var u$1 = u$0 - 65536 | 0, hi = 55296 | u$1 >>> 10 | 0, lo = 56320 | u$1 & 1023;
          unsafe_set_uint16_be(b, i, hi);
          unsafe_set_uint16_be(b, i + 2 | 0, lo);
          return 4;
        }
        return caml_call1(Stdlib[1], cst_index_out_of_bounds$0);
      }
      function is_valid_utf_16be(b) {
        var max = caml_ml_bytes_length2(b) - 1 | 0, i = 0;
        for (; ; ) {
          if (max < i)
            return 1;
          if (i === max)
            return 0;
          var u = unsafe_get_uint16_be(b, i);
          if (55296 <= u && 57343 >= u) {
            if (56319 < u)
              return 0;
            var last = i + 3 | 0;
            if (max < last)
              return 0;
            var u$0 = unsafe_get_uint16_be(b, i + 2 | 0);
            if (56320 <= u$0 && 57343 >= u$0) {
              var i$1 = i + 4 | 0, i = i$1;
              continue;
            }
            return 0;
          }
          var i$0 = i + 2 | 0, i = i$0;
        }
      }
      function get_utf_16le_uchar(b, i) {
        var max = caml_ml_bytes_length2(b) - 1 | 0;
        if (0 <= i && max >= i) {
          if (i === max)
            return caml_call1(dec_invalid, 1);
          var hi = unsafe_get_uint16_le(b, i);
          if (55296 <= hi && 57343 >= hi) {
            if (56319 < hi)
              return caml_call1(dec_invalid, 2);
            var last = i + 3 | 0;
            if (max < last)
              return caml_call1(dec_invalid, (max - i | 0) + 1 | 0);
            var lo = unsafe_get_uint16_le(b, i + 2 | 0);
            if (56320 <= lo && 57343 >= lo) {
              var u = ((hi & 1023) << 10 | lo & 1023) + 65536 | 0;
              return dec_ret(4, u);
            }
            return caml_call1(dec_invalid, 2);
          }
          return dec_ret(2, hi);
        }
        return caml_call1(Stdlib[1], cst_index_out_of_bounds$1);
      }
      function set_utf_16le_uchar(b, i, u) {
        var max = caml_ml_bytes_length2(b) - 1 | 0;
        if (0 <= i && max >= i) {
          var u$0 = caml_call1(Stdlib_Uchar[10], u);
          if (0 > u$0)
            throw caml_maybe_attach_backtrace2([0, Assert_failure, _f_], 1);
          if (65535 >= u$0) {
            var last$0 = i + 1 | 0;
            return max < last$0 ? 0 : (unsafe_set_uint16_le(b, i, u$0), 2);
          }
          if (1114111 < u$0)
            throw caml_maybe_attach_backtrace2([0, Assert_failure, _e_], 1);
          var last = i + 3 | 0;
          if (max < last)
            return 0;
          var u$1 = u$0 - 65536 | 0, hi = 55296 | u$1 >>> 10 | 0, lo = 56320 | u$1 & 1023;
          unsafe_set_uint16_le(b, i, hi);
          unsafe_set_uint16_le(b, i + 2 | 0, lo);
          return 4;
        }
        return caml_call1(Stdlib[1], cst_index_out_of_bounds$2);
      }
      function is_valid_utf_16le(b) {
        var max = caml_ml_bytes_length2(b) - 1 | 0, i = 0;
        for (; ; ) {
          if (max < i)
            return 1;
          if (i === max)
            return 0;
          var u = unsafe_get_uint16_le(b, i);
          if (55296 <= u && 57343 >= u) {
            if (56319 < u)
              return 0;
            var last = i + 3 | 0;
            if (max < last)
              return 0;
            var u$0 = unsafe_get_uint16_le(b, i + 2 | 0);
            if (56320 <= u$0 && 57343 >= u$0) {
              var i$1 = i + 4 | 0, i = i$1;
              continue;
            }
            return 0;
          }
          var i$0 = i + 2 | 0, i = i$0;
        }
      }
      var Stdlib_Bytes = [
        0,
        make,
        init,
        empty,
        copy,
        of_string,
        to_string,
        sub,
        sub_string,
        extend,
        fill,
        blit,
        blit_string,
        concat,
        cat,
        iter,
        iteri,
        map,
        mapi,
        fold_left,
        fold_right,
        for_all,
        exists,
        trim,
        escaped,
        index,
        index_opt,
        rindex,
        rindex_opt,
        index_from,
        index_from_opt,
        rindex_from,
        rindex_from_opt,
        contains,
        contains_from,
        rcontains_from,
        uppercase_ascii,
        lowercase_ascii,
        capitalize_ascii,
        uncapitalize_ascii,
        compare,
        runtime.caml_bytes_equal,
        starts_with,
        ends_with,
        caml_string_of_bytes2,
        caml_bytes_of_string2,
        split_on_char,
        to_seq,
        to_seqi,
        of_seq,
        get_utf_8_uchar,
        set_utf_8_uchar,
        is_valid_utf_8,
        get_utf_16be_uchar,
        set_utf_16be_uchar,
        is_valid_utf_16be,
        get_utf_16le_uchar,
        set_utf_16le_uchar,
        is_valid_utf_16le,
        caml_bytes_get2,
        get_int8,
        caml_bytes_get162,
        get_uint16_be,
        get_uint16_le,
        get_int16_ne,
        get_int16_be,
        get_int16_le,
        caml_bytes_get322,
        get_int32_be,
        get_int32_le,
        caml_bytes_get642,
        get_int64_be,
        get_int64_le,
        set_uint8,
        caml_bytes_set2,
        set_uint16_ne,
        set_int16_be,
        set_int16_le,
        caml_bytes_set162,
        set_int16_be,
        set_int16_le,
        caml_bytes_set322,
        set_int32_be,
        set_int32_le,
        caml_bytes_set642,
        set_int64_be,
        set_int64_le,
        unsafe_escape
      ];
      runtime.caml_register_global(30, Stdlib_Bytes, "Stdlib__Bytes");
      return;
    })(globalThis);
    (function(globalThis2) {
      "use strict";
      var runtime = globalThis2.jsoo_runtime, cst$0 = "", caml_blit_string2 = runtime.caml_blit_string, caml_maybe_attach_backtrace2 = runtime.caml_maybe_attach_backtrace, caml_ml_string_length2 = runtime.caml_ml_string_length, caml_string_equal2 = runtime.caml_string_equal, caml_string_hash2 = runtime.caml_string_hash, caml_string_unsafe_get2 = runtime.caml_string_unsafe_get, caml_wrap_exception2 = runtime.caml_wrap_exception;
      function caml_call1(f, a0) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 1 ? f(a0) : runtime.caml_call_gen(f, [a0]);
      }
      function caml_call2(f, a0, a1) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 2 ? f(a0, a1) : runtime.caml_call_gen(f, [a0, a1]);
      }
      function caml_call3(f, a0, a1, a2) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 3 ? f(a0, a1, a2) : runtime.caml_call_gen(f, [a0, a1, a2]);
      }
      var global_data = runtime.caml_get_global_data(), cst = cst$0, empty = cst$0, Stdlib = global_data.Stdlib, Stdlib_Bytes = global_data.Stdlib__Bytes, bts = Stdlib_Bytes[44], bos = Stdlib_Bytes[45];
      function make(n, c) {
        return caml_call1(bts, caml_call2(Stdlib_Bytes[1], n, c));
      }
      function init(n, f) {
        return caml_call1(bts, caml_call2(Stdlib_Bytes[2], n, f));
      }
      var of_bytes = Stdlib_Bytes[6], to_bytes = Stdlib_Bytes[5];
      function sub(s2, ofs, len) {
        var _X_ = caml_call1(bos, s2);
        return caml_call1(bts, caml_call3(Stdlib_Bytes[7], _X_, ofs, len));
      }
      var blit = Stdlib_Bytes[12], cst_String_concat = "String.concat";
      function concat(sep, l) {
        if (!l)
          return cst;
        var seplen = caml_ml_string_length2(sep);
        a: {
          b: {
            var acc = 0, param = l, pos$1 = 0;
            for (; ; ) {
              if (!param)
                break;
              var hd = param[1];
              if (!param[2])
                break b;
              var tl = param[2], x2 = (caml_ml_string_length2(hd) + seplen | 0) + acc | 0, acc$0 = acc <= x2 ? x2 : caml_call1(Stdlib[1], cst_String_concat), acc = acc$0, param = tl;
            }
            var _W_ = acc;
            break a;
          }
          var _W_ = caml_ml_string_length2(hd) + acc | 0;
        }
        var dst = runtime.caml_create_bytes(_W_), pos = pos$1, param$0 = l;
        for (; ; ) {
          if (param$0) {
            var hd$0 = param$0[1];
            if (param$0[2]) {
              var tl$0 = param$0[2];
              caml_blit_string2(hd$0, 0, dst, pos, caml_ml_string_length2(hd$0));
              caml_blit_string2(sep, 0, dst, pos + caml_ml_string_length2(hd$0) | 0, seplen);
              var pos$0 = (pos + caml_ml_string_length2(hd$0) | 0) + seplen | 0, pos = pos$0, param$0 = tl$0;
              continue;
            }
            caml_blit_string2(hd$0, 0, dst, pos, caml_ml_string_length2(hd$0));
          }
          return caml_call1(bts, dst);
        }
      }
      var cat = Stdlib[28], cst_String_index_from_Bytes_in = "String.index_from / Bytes.index_from", cst_String_index_from_opt_Byte = "String.index_from_opt / Bytes.index_from_opt", cst_String_rindex_from_Bytes_r = "String.rindex_from / Bytes.rindex_from", cst_String_rindex_from_opt_Byt = "String.rindex_from_opt / Bytes.rindex_from_opt", cst_String_contains_from_Bytes = "String.contains_from / Bytes.contains_from", cst_String_rcontains_from_Byte = "String.rcontains_from / Bytes.rcontains_from";
      function iter(f, s2) {
        var _U_ = caml_ml_string_length2(s2) - 1 | 0, _T_2 = 0;
        if (_U_ >= 0) {
          var i = _T_2;
          for (; ; ) {
            caml_call1(f, caml_string_unsafe_get2(s2, i));
            var _V_ = i + 1 | 0;
            if (_U_ === i)
              break;
            var i = _V_;
          }
        }
        return 0;
      }
      function iteri(f, s2) {
        var _R_ = caml_ml_string_length2(s2) - 1 | 0, _Q_ = 0;
        if (_R_ >= 0) {
          var i = _Q_;
          for (; ; ) {
            caml_call2(f, i, caml_string_unsafe_get2(s2, i));
            var _S_ = i + 1 | 0;
            if (_R_ === i)
              break;
            var i = _S_;
          }
        }
        return 0;
      }
      function map(f, s2) {
        var _P_ = caml_call1(bos, s2);
        return caml_call1(bts, caml_call2(Stdlib_Bytes[17], f, _P_));
      }
      function mapi(f, s2) {
        var _O_ = caml_call1(bos, s2);
        return caml_call1(bts, caml_call2(Stdlib_Bytes[18], f, _O_));
      }
      function fold_right(f, x2, a) {
        var _N_ = caml_call1(bos, x2);
        return caml_call3(Stdlib_Bytes[20], f, _N_, a);
      }
      function fold_left(f, a, x2) {
        var _M_ = caml_call1(bos, x2);
        return caml_call3(Stdlib_Bytes[19], f, a, _M_);
      }
      function exists(f, s2) {
        var _L_ = caml_call1(bos, s2);
        return caml_call2(Stdlib_Bytes[22], f, _L_);
      }
      function for_all(f, s2) {
        var _K_ = caml_call1(bos, s2);
        return caml_call2(Stdlib_Bytes[21], f, _K_);
      }
      function is_space(param) {
        var _J_ = param - 9 | 0;
        a: {
          if (4 < _J_ >>> 0) {
            if (23 !== _J_)
              break a;
          } else if (2 === _J_)
            break a;
          return 1;
        }
        return 0;
      }
      function trim(s2) {
        if (caml_string_equal2(s2, cst$0))
          return s2;
        if (!is_space(caml_string_unsafe_get2(s2, 0)) && !is_space(caml_string_unsafe_get2(s2, caml_ml_string_length2(s2) - 1 | 0)))
          return s2;
        var _I_ = caml_call1(bos, s2);
        return caml_call1(bts, caml_call1(Stdlib_Bytes[23], _I_));
      }
      function escaped(s2) {
        var b = caml_call1(bos, s2);
        return caml_call1(bts, caml_call1(Stdlib_Bytes[87], b));
      }
      function index_rec(s2, lim, i, c) {
        var i$0 = i;
        for (; ; ) {
          if (lim <= i$0)
            throw caml_maybe_attach_backtrace2(Stdlib[8], 1);
          if (caml_string_unsafe_get2(s2, i$0) === c)
            return i$0;
          var i$1 = i$0 + 1 | 0, i$0 = i$1;
        }
      }
      function index(s2, c) {
        return index_rec(s2, caml_ml_string_length2(s2), 0, c);
      }
      function index_rec_opt(s2, lim, i, c) {
        var i$0 = i;
        for (; ; ) {
          if (lim <= i$0)
            return 0;
          if (caml_string_unsafe_get2(s2, i$0) === c)
            return [0, i$0];
          var i$1 = i$0 + 1 | 0, i$0 = i$1;
        }
      }
      function index_opt(s2, c) {
        return index_rec_opt(s2, caml_ml_string_length2(s2), 0, c);
      }
      function index_from(s2, i, c) {
        var l = caml_ml_string_length2(s2);
        if (0 <= i && l >= i)
          return index_rec(s2, l, i, c);
        return caml_call1(Stdlib[1], cst_String_index_from_Bytes_in);
      }
      function index_from_opt(s2, i, c) {
        var l = caml_ml_string_length2(s2);
        if (0 <= i && l >= i)
          return index_rec_opt(s2, l, i, c);
        return caml_call1(Stdlib[1], cst_String_index_from_opt_Byte);
      }
      function rindex_rec(s2, i, c) {
        var i$0 = i;
        for (; ; ) {
          if (0 > i$0)
            throw caml_maybe_attach_backtrace2(Stdlib[8], 1);
          if (caml_string_unsafe_get2(s2, i$0) === c)
            return i$0;
          var i$1 = i$0 - 1 | 0, i$0 = i$1;
        }
      }
      function rindex(s2, c) {
        return rindex_rec(s2, caml_ml_string_length2(s2) - 1 | 0, c);
      }
      function rindex_from(s2, i, c) {
        if (-1 <= i && caml_ml_string_length2(s2) > i)
          return rindex_rec(s2, i, c);
        return caml_call1(Stdlib[1], cst_String_rindex_from_Bytes_r);
      }
      function rindex_rec_opt(s2, i, c) {
        var i$0 = i;
        for (; ; ) {
          if (0 > i$0)
            return 0;
          if (caml_string_unsafe_get2(s2, i$0) === c)
            return [0, i$0];
          var i$1 = i$0 - 1 | 0, i$0 = i$1;
        }
      }
      function rindex_opt(s2, c) {
        return rindex_rec_opt(s2, caml_ml_string_length2(s2) - 1 | 0, c);
      }
      function rindex_from_opt(s2, i, c) {
        if (-1 <= i && caml_ml_string_length2(s2) > i)
          return rindex_rec_opt(s2, i, c);
        return caml_call1(Stdlib[1], cst_String_rindex_from_opt_Byt);
      }
      function contains_from(s2, i, c) {
        var l = caml_ml_string_length2(s2);
        if (0 <= i && l >= i)
          try {
            index_rec(s2, l, i, c);
            var _G_ = 1;
            return _G_;
          } catch (_H_) {
            var _F_ = caml_wrap_exception2(_H_);
            if (_F_ === Stdlib[8])
              return 0;
            throw caml_maybe_attach_backtrace2(_F_, 0);
          }
        return caml_call1(Stdlib[1], cst_String_contains_from_Bytes);
      }
      function contains(s2, c) {
        return contains_from(s2, 0, c);
      }
      function rcontains_from(s2, i, c) {
        if (0 <= i && caml_ml_string_length2(s2) > i)
          try {
            rindex_rec(s2, i, c);
            var _D_ = 1;
            return _D_;
          } catch (_E_) {
            var _C_ = caml_wrap_exception2(_E_);
            if (_C_ === Stdlib[8])
              return 0;
            throw caml_maybe_attach_backtrace2(_C_, 0);
          }
        return caml_call1(Stdlib[1], cst_String_rcontains_from_Byte);
      }
      function uppercase_ascii(s2) {
        var _B_ = caml_call1(bos, s2);
        return caml_call1(bts, caml_call1(Stdlib_Bytes[36], _B_));
      }
      function lowercase_ascii(s2) {
        var _A_ = caml_call1(bos, s2);
        return caml_call1(bts, caml_call1(Stdlib_Bytes[37], _A_));
      }
      function capitalize_ascii(s2) {
        var _z_ = caml_call1(bos, s2);
        return caml_call1(bts, caml_call1(Stdlib_Bytes[38], _z_));
      }
      function uncapitalize_ascii(s2) {
        var _y_ = caml_call1(bos, s2);
        return caml_call1(bts, caml_call1(Stdlib_Bytes[39], _y_));
      }
      function starts_with(prefix, s2) {
        var len_s = caml_ml_string_length2(s2), len_pre = caml_ml_string_length2(prefix), _x_ = len_pre <= len_s ? 1 : 0;
        if (!_x_)
          return _x_;
        var i = 0;
        for (; ; ) {
          if (i === len_pre)
            return 1;
          if (caml_string_unsafe_get2(s2, i) !== caml_string_unsafe_get2(prefix, i))
            return 0;
          var i$0 = i + 1 | 0, i = i$0;
        }
      }
      function ends_with(suffix, s2) {
        var len_s = caml_ml_string_length2(s2), len_suf = caml_ml_string_length2(suffix), diff = len_s - len_suf | 0, _w_ = 0 <= diff ? 1 : 0;
        if (!_w_)
          return _w_;
        var i = 0;
        for (; ; ) {
          if (i === len_suf)
            return 1;
          if (caml_string_unsafe_get2(s2, diff + i | 0) !== caml_string_unsafe_get2(suffix, i))
            return 0;
          var i$0 = i + 1 | 0, i = i$0;
        }
      }
      function hash(x2) {
        return caml_string_hash2(0, x2);
      }
      function split_on_char(sep, s2) {
        var r = [0, 0], j = [0, caml_ml_string_length2(s2)], _s_ = caml_ml_string_length2(s2) - 1 | 0;
        if (_s_ >= 0) {
          var i = _s_;
          for (; ; ) {
            if (caml_string_unsafe_get2(s2, i) === sep) {
              var _u_ = r[1];
              r[1] = [0, sub(s2, i + 1 | 0, (j[1] - i | 0) - 1 | 0), _u_];
              j[1] = i;
            }
            var _v_ = i - 1 | 0;
            if (0 === i)
              break;
            var i = _v_;
          }
        }
        var _t_ = r[1];
        return [0, sub(s2, 0, j[1]), _t_];
      }
      var compare = runtime.caml_string_compare;
      function to_seq(s2) {
        var _r_ = caml_call1(bos, s2);
        return caml_call1(Stdlib_Bytes[47], _r_);
      }
      function to_seqi(s2) {
        var _q_ = caml_call1(bos, s2);
        return caml_call1(Stdlib_Bytes[48], _q_);
      }
      function of_seq(g) {
        return caml_call1(bts, caml_call1(Stdlib_Bytes[49], g));
      }
      function get_utf_8_uchar(s2, i) {
        var _p_ = caml_call1(bos, s2);
        return caml_call2(Stdlib_Bytes[50], _p_, i);
      }
      function is_valid_utf_8(s2) {
        var _o_ = caml_call1(bos, s2);
        return caml_call1(Stdlib_Bytes[52], _o_);
      }
      function get_utf_16be_uchar(s2, i) {
        var _n_ = caml_call1(bos, s2);
        return caml_call2(Stdlib_Bytes[53], _n_, i);
      }
      function is_valid_utf_16be(s2) {
        var _m_ = caml_call1(bos, s2);
        return caml_call1(Stdlib_Bytes[55], _m_);
      }
      function get_utf_16le_uchar(s2, i) {
        var _l_ = caml_call1(bos, s2);
        return caml_call2(Stdlib_Bytes[56], _l_, i);
      }
      function is_valid_utf_16le(s2) {
        var _k_ = caml_call1(bos, s2);
        return caml_call1(Stdlib_Bytes[58], _k_);
      }
      function get_int8(s2, i) {
        var _j_ = caml_call1(bos, s2);
        return caml_call2(Stdlib_Bytes[60], _j_, i);
      }
      function get_uint16_le(s2, i) {
        var _i_ = caml_call1(bos, s2);
        return caml_call2(Stdlib_Bytes[63], _i_, i);
      }
      function get_uint16_be(s2, i) {
        var _h_ = caml_call1(bos, s2);
        return caml_call2(Stdlib_Bytes[62], _h_, i);
      }
      function get_int16_ne(s2, i) {
        var _g_ = caml_call1(bos, s2);
        return caml_call2(Stdlib_Bytes[64], _g_, i);
      }
      function get_int16_le(s2, i) {
        var _f_ = caml_call1(bos, s2);
        return caml_call2(Stdlib_Bytes[66], _f_, i);
      }
      function get_int16_be(s2, i) {
        var _e_ = caml_call1(bos, s2);
        return caml_call2(Stdlib_Bytes[65], _e_, i);
      }
      function get_int32_le(s2, i) {
        var _d_ = caml_call1(bos, s2);
        return caml_call2(Stdlib_Bytes[69], _d_, i);
      }
      function get_int32_be(s2, i) {
        var _c_ = caml_call1(bos, s2);
        return caml_call2(Stdlib_Bytes[68], _c_, i);
      }
      function get_int64_le(s2, i) {
        var _b_ = caml_call1(bos, s2);
        return caml_call2(Stdlib_Bytes[72], _b_, i);
      }
      function get_int64_be(s2, i) {
        var _a_ = caml_call1(bos, s2);
        return caml_call2(Stdlib_Bytes[71], _a_, i);
      }
      var Stdlib_String = [
        0,
        make,
        init,
        empty,
        of_bytes,
        to_bytes,
        blit,
        concat,
        cat,
        caml_string_equal2,
        compare,
        starts_with,
        ends_with,
        contains_from,
        rcontains_from,
        contains,
        sub,
        split_on_char,
        map,
        mapi,
        fold_left,
        fold_right,
        for_all,
        exists,
        trim,
        escaped,
        uppercase_ascii,
        lowercase_ascii,
        capitalize_ascii,
        uncapitalize_ascii,
        iter,
        iteri,
        index_from,
        index_from_opt,
        rindex_from,
        rindex_from_opt,
        index,
        index_opt,
        rindex,
        rindex_opt,
        to_seq,
        to_seqi,
        of_seq,
        get_utf_8_uchar,
        is_valid_utf_8,
        get_utf_16be_uchar,
        is_valid_utf_16be,
        get_utf_16le_uchar,
        is_valid_utf_16le,
        runtime.caml_string_get,
        get_int8,
        runtime.caml_string_get16,
        get_uint16_be,
        get_uint16_le,
        get_int16_ne,
        get_int16_be,
        get_int16_le,
        runtime.caml_string_get32,
        hash,
        caml_string_hash2,
        get_int32_be,
        get_int32_le,
        runtime.caml_string_get64,
        get_int64_be,
        get_int64_le
      ];
      runtime.caml_register_global(12, Stdlib_String, "Stdlib__String");
      return;
    })(globalThis);
    (function(globalThis2) {
      "use strict";
      var runtime = globalThis2.jsoo_runtime, caml_array_sub2 = runtime.caml_array_sub, caml_check_bound2 = runtime.caml_check_bound, caml_make_vect2 = runtime.caml_make_vect, caml_maybe_attach_backtrace2 = runtime.caml_maybe_attach_backtrace, caml_wrap_exception2 = runtime.caml_wrap_exception;
      function caml_call1(f, a0) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 1 ? f(a0) : runtime.caml_call_gen(f, [a0]);
      }
      function caml_call2(f, a0, a1) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 2 ? f(a0, a1) : runtime.caml_call_gen(f, [a0, a1]);
      }
      function caml_call3(f, a0, a1, a2) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 3 ? f(a0, a1, a2) : runtime.caml_call_gen(f, [a0, a1, a2]);
      }
      var global_data = runtime.caml_get_global_data(), Stdlib_Seq = global_data.Stdlib__Seq, Assert_failure = global_data.Assert_failure, Stdlib = global_data.Stdlib, Floatarray = [0], cst_Array_init = "Array.init", cst_Array_sub = "Array.sub", cst_Array_fill = "Array.fill", cst_Array_blit = "Array.blit", cst_Array_iter2_arrays_must_ha = "Array.iter2: arrays must have the same length", cst_Array_map2_arrays_must_hav = "Array.map2: arrays must have the same length", cst_Array_for_all2 = "Array.for_all2", cst_Array_exists2 = "Array.exists2", cst_Array_combine = "Array.combine";
      function init(l, f) {
        if (0 === l)
          return [0];
        if (0 > l)
          return caml_call1(Stdlib[1], cst_Array_init);
        var res = caml_make_vect2(l, caml_call1(f, 0)), _aw_ = l - 1 | 0, _av_ = 1;
        if (_aw_ >= 1) {
          var i = _av_;
          for (; ; ) {
            res[1 + i] = caml_call1(f, i);
            var _ax_ = i + 1 | 0;
            if (_aw_ === i)
              break;
            var i = _ax_;
          }
        }
        return res;
      }
      function make_matrix(sx, sy, init2) {
        var res = caml_make_vect2(sx, [0]), _at_ = sx - 1 | 0, _as_ = 0;
        if (_at_ >= 0) {
          var x2 = _as_;
          for (; ; ) {
            res[1 + x2] = caml_make_vect2(sy, init2);
            var _au_ = x2 + 1 | 0;
            if (_at_ === x2)
              break;
            var x2 = _au_;
          }
        }
        return res;
      }
      function copy(a) {
        var l = a.length - 1;
        return 0 === l ? [0] : caml_array_sub2(a, 0, l);
      }
      function append(a1, a2) {
        var l1 = a1.length - 1;
        return 0 === l1 ? copy(a2) : 0 === a2.length - 1 ? caml_array_sub2(a1, 0, l1) : runtime.caml_array_append(a1, a2);
      }
      function sub(a, ofs, len) {
        if (0 <= ofs && 0 <= len && (a.length - 1 - len | 0) >= ofs)
          return caml_array_sub2(a, ofs, len);
        return caml_call1(Stdlib[1], cst_Array_sub);
      }
      function fill(a, ofs, len, v) {
        if (0 <= ofs && 0 <= len && (a.length - 1 - len | 0) >= ofs)
          return runtime.caml_array_fill(a, ofs, len, v);
        return caml_call1(Stdlib[1], cst_Array_fill);
      }
      function blit(a1, ofs1, a2, ofs2, len) {
        if (0 <= len && 0 <= ofs1 && (a1.length - 1 - len | 0) >= ofs1 && 0 <= ofs2 && (a2.length - 1 - len | 0) >= ofs2)
          return runtime.caml_array_blit(a1, ofs1, a2, ofs2, len);
        return caml_call1(Stdlib[1], cst_Array_blit);
      }
      function iter(f, a) {
        var _aq_ = a.length - 1 - 1 | 0, _ap_ = 0;
        if (_aq_ >= 0) {
          var i = _ap_;
          for (; ; ) {
            caml_call1(f, a[1 + i]);
            var _ar_ = i + 1 | 0;
            if (_aq_ === i)
              break;
            var i = _ar_;
          }
        }
        return 0;
      }
      function iter2(f, a, b) {
        if (a.length - 1 !== b.length - 1)
          return caml_call1(Stdlib[1], cst_Array_iter2_arrays_must_ha);
        var _an_ = a.length - 1 - 1 | 0, _am_ = 0;
        if (_an_ >= 0) {
          var i = _am_;
          for (; ; ) {
            caml_call2(f, a[1 + i], b[1 + i]);
            var _ao_ = i + 1 | 0;
            if (_an_ === i)
              break;
            var i = _ao_;
          }
        }
        return 0;
      }
      function map(f, a) {
        var l = a.length - 1;
        if (0 === l)
          return [0];
        var r = caml_make_vect2(l, caml_call1(f, a[1])), _ak_ = l - 1 | 0, _aj_ = 1;
        if (_ak_ >= 1) {
          var i = _aj_;
          for (; ; ) {
            r[1 + i] = caml_call1(f, a[1 + i]);
            var _al_ = i + 1 | 0;
            if (_ak_ === i)
              break;
            var i = _al_;
          }
        }
        return r;
      }
      function map_inplace(f, a) {
        var _ah_ = a.length - 1 - 1 | 0, _ag_ = 0;
        if (_ah_ >= 0) {
          var i = _ag_;
          for (; ; ) {
            a[1 + i] = caml_call1(f, a[1 + i]);
            var _ai_ = i + 1 | 0;
            if (_ah_ === i)
              break;
            var i = _ai_;
          }
        }
        return 0;
      }
      function mapi_inplace(f, a) {
        var _ae_ = a.length - 1 - 1 | 0, _ad_ = 0;
        if (_ae_ >= 0) {
          var i = _ad_;
          for (; ; ) {
            a[1 + i] = caml_call2(f, i, a[1 + i]);
            var _af_ = i + 1 | 0;
            if (_ae_ === i)
              break;
            var i = _af_;
          }
        }
        return 0;
      }
      function map2(f, a, b) {
        var la = a.length - 1, lb = b.length - 1;
        if (la !== lb)
          return caml_call1(Stdlib[1], cst_Array_map2_arrays_must_hav);
        if (0 === la)
          return [0];
        var r = caml_make_vect2(la, caml_call2(f, a[1], b[1])), _ab_ = la - 1 | 0, _aa_ = 1;
        if (_ab_ >= 1) {
          var i = _aa_;
          for (; ; ) {
            r[1 + i] = caml_call2(f, a[1 + i], b[1 + i]);
            var _ac_ = i + 1 | 0;
            if (_ab_ === i)
              break;
            var i = _ac_;
          }
        }
        return r;
      }
      function iteri(f, a) {
        var ___ = a.length - 1 - 1 | 0, _Z_ = 0;
        if (___ >= 0) {
          var i = _Z_;
          for (; ; ) {
            caml_call2(f, i, a[1 + i]);
            var _$_ = i + 1 | 0;
            if (___ === i)
              break;
            var i = _$_;
          }
        }
        return 0;
      }
      function mapi(f, a) {
        var l = a.length - 1;
        if (0 === l)
          return [0];
        var r = caml_make_vect2(l, caml_call2(f, 0, a[1])), _X_ = l - 1 | 0, _W_ = 1;
        if (_X_ >= 1) {
          var i = _W_;
          for (; ; ) {
            r[1 + i] = caml_call2(f, i, a[1 + i]);
            var _Y_ = i + 1 | 0;
            if (_X_ === i)
              break;
            var i = _Y_;
          }
        }
        return r;
      }
      function to_list(a) {
        var i$1 = a.length - 1 - 1 | 0, i = i$1, res = 0;
        for (; ; ) {
          if (0 > i)
            return res;
          var res$0 = [0, a[1 + i], res], i$0 = i - 1 | 0, i = i$0, res = res$0;
        }
      }
      function list_length(accu, param) {
        var accu$0 = accu, param$0 = param;
        for (; ; ) {
          if (!param$0)
            return accu$0;
          var t = param$0[2], accu$1 = accu$0 + 1 | 0, accu$0 = accu$1, param$0 = t;
        }
      }
      function of_list(l) {
        if (!l)
          return [0];
        var tl = l[2], hd = l[1], a = caml_make_vect2(list_length(0, l), hd), i = 1, param = tl;
        for (; ; ) {
          if (!param)
            return a;
          var tl$0 = param[2], hd$0 = param[1];
          a[1 + i] = hd$0;
          var i$0 = i + 1 | 0, i = i$0, param = tl$0;
        }
      }
      function fold_left(f, x2, a) {
        var r = [0, x2], _U_ = a.length - 1 - 1 | 0, _T_2 = 0;
        if (_U_ >= 0) {
          var i = _T_2;
          for (; ; ) {
            r[1] = caml_call2(f, r[1], a[1 + i]);
            var _V_ = i + 1 | 0;
            if (_U_ === i)
              break;
            var i = _V_;
          }
        }
        return r[1];
      }
      function fold_left_map(f, acc, input_array) {
        var len = input_array.length - 1;
        if (0 === len)
          return [0, acc, [0]];
        var match = caml_call2(f, acc, input_array[1]), elt = match[2], acc$0 = match[1], output_array = caml_make_vect2(len, elt), acc$1 = [0, acc$0], _R_ = len - 1 | 0, _Q_ = 1;
        if (_R_ >= 1) {
          var i = _Q_;
          for (; ; ) {
            var match$0 = caml_call2(f, acc$1[1], input_array[1 + i]), elt$0 = match$0[2], acc$2 = match$0[1];
            acc$1[1] = acc$2;
            output_array[1 + i] = elt$0;
            var _S_ = i + 1 | 0;
            if (_R_ === i)
              break;
            var i = _S_;
          }
        }
        return [0, acc$1[1], output_array];
      }
      function fold_right(f, a, x2) {
        var r = [0, x2], _O_ = a.length - 1 - 1 | 0;
        if (_O_ >= 0) {
          var i = _O_;
          for (; ; ) {
            r[1] = caml_call2(f, a[1 + i], r[1]);
            var _P_ = i - 1 | 0;
            if (0 === i)
              break;
            var i = _P_;
          }
        }
        return r[1];
      }
      function exists(p, a) {
        var n = a.length - 1, i = 0;
        for (; ; ) {
          if (i === n)
            return 0;
          if (caml_call1(p, a[1 + i]))
            return 1;
          var i$0 = i + 1 | 0, i = i$0;
        }
      }
      function for_all(p, a) {
        var n = a.length - 1, i = 0;
        for (; ; ) {
          if (i === n)
            return 1;
          if (!caml_call1(p, a[1 + i]))
            return 0;
          var i$0 = i + 1 | 0, i = i$0;
        }
      }
      function for_all2(p, l1, l2) {
        var n1 = l1.length - 1, n2 = l2.length - 1;
        if (n1 !== n2)
          return caml_call1(Stdlib[1], cst_Array_for_all2);
        var i = 0;
        for (; ; ) {
          if (i === n1)
            return 1;
          if (!caml_call2(p, l1[1 + i], l2[1 + i]))
            return 0;
          var i$0 = i + 1 | 0, i = i$0;
        }
      }
      function exists2(p, l1, l2) {
        var n1 = l1.length - 1, n2 = l2.length - 1;
        if (n1 !== n2)
          return caml_call1(Stdlib[1], cst_Array_exists2);
        var i = 0;
        for (; ; ) {
          if (i === n1)
            return 0;
          if (caml_call2(p, l1[1 + i], l2[1 + i]))
            return 1;
          var i$0 = i + 1 | 0, i = i$0;
        }
      }
      function mem(x2, a) {
        var n = a.length - 1, i = 0;
        for (; ; ) {
          if (i === n)
            return 0;
          if (0 === runtime.caml_compare(a[1 + i], x2))
            return 1;
          var i$0 = i + 1 | 0, i = i$0;
        }
      }
      function memq(x2, a) {
        var n = a.length - 1, i = 0;
        for (; ; ) {
          if (i === n)
            return 0;
          if (x2 === a[1 + i])
            return 1;
          var i$0 = i + 1 | 0, i = i$0;
        }
      }
      function find_opt(p, a) {
        var n = a.length - 1, i = 0;
        for (; ; ) {
          if (i === n)
            return 0;
          var x2 = a[1 + i];
          if (caml_call1(p, x2))
            return [0, x2];
          var i$0 = i + 1 | 0, i = i$0;
        }
      }
      function find_index(p, a) {
        var n = a.length - 1, i = 0;
        for (; ; ) {
          if (i === n)
            return 0;
          if (caml_call1(p, a[1 + i]))
            return [0, i];
          var i$0 = i + 1 | 0, i = i$0;
        }
      }
      function find_map(f, a) {
        var n = a.length - 1, i = 0;
        for (; ; ) {
          if (i === n)
            return 0;
          var r = caml_call1(f, a[1 + i]);
          if (r)
            return r;
          var i$0 = i + 1 | 0, i = i$0;
        }
      }
      function find_mapi(f, a) {
        var n = a.length - 1, i = 0;
        for (; ; ) {
          if (i === n)
            return 0;
          var r = caml_call2(f, i, a[1 + i]);
          if (r)
            return r;
          var i$0 = i + 1 | 0, i = i$0;
        }
      }
      function split(x2) {
        if (runtime.caml_equal(x2, [0]))
          return [0, [0], [0]];
        var match = x2[1], b0 = match[2], a0 = match[1], n = x2.length - 1, a = caml_make_vect2(n, a0), b = caml_make_vect2(n, b0), _M_ = n - 1 | 0, _L_ = 1;
        if (_M_ >= 1) {
          var i = _L_;
          for (; ; ) {
            var match$0 = x2[1 + i], bi = match$0[2], ai = match$0[1];
            a[1 + i] = ai;
            b[1 + i] = bi;
            var _N_ = i + 1 | 0;
            if (_M_ === i)
              break;
            var i = _N_;
          }
        }
        return [0, a, b];
      }
      function combine(a, b) {
        var na = a.length - 1, nb = b.length - 1;
        if (na !== nb)
          caml_call1(Stdlib[1], cst_Array_combine);
        if (0 === na)
          return [0];
        var x2 = caml_make_vect2(na, [0, a[1], b[1]]), _J_ = na - 1 | 0, _I_ = 1;
        if (_J_ >= 1) {
          var i = _I_;
          for (; ; ) {
            x2[1 + i] = [0, a[1 + i], b[1 + i]];
            var _K_ = i + 1 | 0;
            if (_J_ === i)
              break;
            var i = _K_;
          }
        }
        return x2;
      }
      var Bottom = [248, "Stdlib.Array.Bottom", runtime.caml_fresh_oo_id(0)], _a_ = [0, "array.ml", 348, 4];
      function sort(cmp, a) {
        function maxson(l2, i2) {
          var i31 = ((i2 + i2 | 0) + i2 | 0) + 1 | 0, x2 = [0, i31];
          if ((i31 + 2 | 0) < l2) {
            var _B_ = i31 + 1 | 0, _C_ = caml_check_bound2(a, _B_)[1 + _B_];
            if (caml_call2(cmp, caml_check_bound2(a, i31)[1 + i31], _C_) < 0)
              x2[1] = i31 + 1 | 0;
            var _D_ = i31 + 2 | 0, _E_ = caml_check_bound2(a, _D_)[1 + _D_], _F_ = x2[1];
            if (caml_call2(cmp, caml_check_bound2(a, _F_)[1 + _F_], _E_) < 0)
              x2[1] = i31 + 2 | 0;
            return x2[1];
          }
          if ((i31 + 1 | 0) < l2) {
            var _G_ = i31 + 1 | 0, _H_ = caml_check_bound2(a, _G_)[1 + _G_];
            if (0 > caml_call2(cmp, caml_check_bound2(a, i31)[1 + i31], _H_))
              return i31 + 1 | 0;
          }
          if (i31 < l2)
            return i31;
          throw caml_maybe_attach_backtrace2([0, Bottom, i2], 1);
        }
        var l = a.length - 1, _v_ = ((l + 1 | 0) / 3 | 0) - 1 | 0;
        if (_v_ >= 0) {
          var i$6 = _v_;
          for (; ; ) {
            var e$1 = caml_check_bound2(a, i$6)[1 + i$6];
            try {
              var i = i$6;
              for (; ; ) {
                var j = maxson(l, i);
                if (0 >= caml_call2(cmp, caml_check_bound2(a, j)[1 + j], e$1))
                  break;
                var _s_ = caml_check_bound2(a, j)[1 + j];
                caml_check_bound2(a, i)[1 + i] = _s_;
                var i = j;
              }
              caml_check_bound2(a, i)[1 + i] = e$1;
            } catch (exn$02) {
              var exn = caml_wrap_exception2(exn$02);
              if (exn[1] !== Bottom)
                throw caml_maybe_attach_backtrace2(exn, 0);
              var i$0 = exn[2];
              caml_check_bound2(a, i$0)[1 + i$0] = e$1;
            }
            var _A_ = i$6 - 1 | 0;
            if (0 === i$6)
              break;
            var i$6 = _A_;
          }
        }
        var _w_ = l - 1 | 0;
        if (_w_ >= 2) {
          var i$4 = _w_;
          for (; ; ) {
            var e$0 = caml_check_bound2(a, i$4)[1 + i$4];
            a[1 + i$4] = caml_check_bound2(a, 0)[1];
            var i$5 = 0;
            try {
              var i$1 = i$5;
              for (; ; ) {
                var j$0 = maxson(i$4, i$1), _t_ = caml_check_bound2(a, j$0)[1 + j$0];
                caml_check_bound2(a, i$1)[1 + i$1] = _t_;
                var i$1 = j$0;
              }
            } catch (exn2) {
              var exn$0 = caml_wrap_exception2(exn2);
              if (exn$0[1] !== Bottom)
                throw caml_maybe_attach_backtrace2(exn$0, 0);
              var i$2 = exn$0[2];
              a: {
                b: {
                  var i$3 = i$2;
                  for (; ; ) {
                    var father = (i$3 - 1 | 0) / 3 | 0;
                    if (i$3 === father)
                      throw caml_maybe_attach_backtrace2([0, Assert_failure, _a_], 1);
                    if (0 <= caml_call2(cmp, caml_check_bound2(a, father)[1 + father], e$0))
                      break;
                    var _u_ = caml_check_bound2(a, father)[1 + father];
                    caml_check_bound2(a, i$3)[1 + i$3] = _u_;
                    if (0 >= father)
                      break b;
                    var i$3 = father;
                  }
                  caml_check_bound2(a, i$3)[1 + i$3] = e$0;
                  break a;
                }
                caml_check_bound2(a, 0)[1] = e$0;
              }
              var _z_ = i$4 - 1 | 0;
              if (2 === i$4)
                break;
              var i$4 = _z_;
            }
          }
        }
        var _x_ = 1 < l ? 1 : 0;
        if (_x_) {
          var e = caml_check_bound2(a, 1)[2];
          a[2] = caml_check_bound2(a, 0)[1];
          a[1] = e;
          var _y_ = 0;
        } else
          var _y_ = _x_;
        return _y_;
      }
      function stable_sort(cmp, a) {
        function merge(src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs) {
          var src1r = src1ofs + src1len | 0, src2r = src2ofs + src2len | 0, s2$1 = caml_check_bound2(src2, src2ofs)[1 + src2ofs], s1$1 = caml_check_bound2(a, src1ofs)[1 + src1ofs], i1 = src1ofs, s1 = s1$1, i2 = src2ofs, s2 = s2$1, d = dstofs;
          for (; ; )
            if (0 < caml_call2(cmp, s1, s2)) {
              caml_check_bound2(dst, d)[1 + d] = s2;
              var i2$0 = i2 + 1 | 0;
              if (i2$0 >= src2r)
                return blit(a, i1, dst, d + 1 | 0, src1r - i1 | 0);
              var d$0 = d + 1 | 0, s2$0 = caml_check_bound2(src2, i2$0)[1 + i2$0], i2 = i2$0, s2 = s2$0, d = d$0;
            } else {
              caml_check_bound2(dst, d)[1 + d] = s1;
              var i1$0 = i1 + 1 | 0;
              if (i1$0 >= src1r)
                return blit(src2, i2, dst, d + 1 | 0, src2r - i2 | 0);
              var d$1 = d + 1 | 0, s1$0 = caml_check_bound2(a, i1$0)[1 + i1$0], i1 = i1$0, s1 = s1$0, d = d$1;
            }
        }
        function isortto(srcofs, dst, dstofs, len) {
          var _k_ = len - 1 | 0, _j_ = 0;
          if (_k_ >= 0) {
            var i = _j_;
            for (; ; ) {
              var _l_ = srcofs + i | 0, e = caml_check_bound2(a, _l_)[1 + _l_], j = [0, (dstofs + i | 0) - 1 | 0];
              for (; ; ) {
                if (dstofs > j[1])
                  break;
                var _m_ = j[1];
                if (0 >= caml_call2(cmp, caml_check_bound2(dst, _m_)[1 + _m_], e))
                  break;
                var _n_ = j[1], _o_ = caml_check_bound2(dst, _n_)[1 + _n_], _p_ = j[1] + 1 | 0;
                caml_check_bound2(dst, _p_)[1 + _p_] = _o_;
                j[1] += -1;
              }
              var _q_ = j[1] + 1 | 0;
              caml_check_bound2(dst, _q_)[1 + _q_] = e;
              var _r_ = i + 1 | 0;
              if (_k_ === i)
                break;
              var i = _r_;
            }
          }
          return 0;
        }
        function sortto(srcofs, dst, dstofs, len) {
          if (len <= 5)
            return isortto(srcofs, dst, dstofs, len);
          var l12 = len / 2 | 0, l22 = len - l12 | 0;
          sortto(srcofs + l12 | 0, dst, dstofs + l12 | 0, l22);
          sortto(srcofs, a, srcofs + l22 | 0, l12);
          return merge(srcofs + l22 | 0, l12, dst, dstofs + l12 | 0, l22, dst, dstofs);
        }
        var l = a.length - 1;
        if (l <= 5)
          return isortto(0, a, 0, l);
        var l1 = l / 2 | 0, l2 = l - l1 | 0, t = caml_make_vect2(l2, caml_check_bound2(a, 0)[1]);
        sortto(l1, t, 0, l2);
        sortto(0, a, l2, l1);
        return merge(l2, l1, t, 0, l2, a, 0);
      }
      function to_seq(a) {
        function aux(i, param) {
          if (i >= a.length - 1)
            return 0;
          var x2 = a[1 + i], _h_ = i + 1 | 0;
          return [0, x2, function(_i_) {
            return aux(_h_, _i_);
          }];
        }
        var _f_ = 0;
        return function(_g_) {
          return aux(_f_, _g_);
        };
      }
      function to_seqi(a) {
        function aux(i, param) {
          if (i >= a.length - 1)
            return 0;
          var x2 = a[1 + i], _d_ = i + 1 | 0;
          return [0, [0, i, x2], function(_e_) {
            return aux(_d_, _e_);
          }];
        }
        var _b_ = 0;
        return function(_c_) {
          return aux(_b_, _c_);
        };
      }
      function of_seq(i$2) {
        var l = caml_call3(Stdlib_Seq[5], function(acc, x2) {
          return [0, x2, acc];
        }, 0, i$2);
        if (!l)
          return [0];
        var tl = l[2], hd = l[1], len = list_length(0, l), a = caml_make_vect2(len, hd), i$1 = len - 2 | 0, i = i$1, param = tl;
        for (; ; ) {
          if (!param)
            return a;
          var tl$0 = param[2], hd$0 = param[1];
          a[1 + i] = hd$0;
          var i$0 = i - 1 | 0, i = i$0, param = tl$0;
        }
      }
      var Stdlib_Array = [
        0,
        init,
        make_matrix,
        append,
        runtime.caml_array_concat,
        sub,
        copy,
        fill,
        blit,
        to_list,
        of_list,
        iter,
        iteri,
        map,
        map_inplace,
        mapi,
        mapi_inplace,
        fold_left,
        fold_left_map,
        fold_right,
        iter2,
        map2,
        for_all,
        exists,
        for_all2,
        exists2,
        mem,
        memq,
        find_opt,
        find_index,
        find_map,
        find_mapi,
        split,
        combine,
        sort,
        stable_sort,
        stable_sort,
        to_seq,
        to_seqi,
        of_seq,
        Floatarray
      ];
      runtime.caml_register_global(14, Stdlib_Array, "Stdlib__Array");
      return;
    })(globalThis);
    (function(globalThis2) {
      "use strict";
      var runtime = globalThis2.jsoo_runtime, caml_greaterequal2 = runtime.caml_greaterequal, caml_hash2 = runtime.caml_hash, caml_int_compare2 = runtime.caml_int_compare, caml_maybe_attach_backtrace2 = runtime.caml_maybe_attach_backtrace, caml_mul2 = runtime.caml_mul, caml_wrap_exception2 = runtime.caml_wrap_exception, global_data = runtime.caml_get_global_data(), Stdlib = global_data.Stdlib, Stdlib_Sys = global_data.Stdlib__Sys, Assert_failure = global_data.Assert_failure, zero = 0, one = 1;
      function succ(n) {
        return n + 1 | 0;
      }
      function pred(n) {
        return n - 1 | 0;
      }
      function abs(n) {
        return caml_greaterequal2(n, 0) ? n : -n | 0;
      }
      function lognot(n) {
        return n ^ -1;
      }
      var _a_ = Stdlib_Sys[9], _b_ = [0, "int32.ml", 69, 6], minus_one = -1, min_int = -2147483648, max_int = 2147483647;
      if (32 === _a_)
        var max_int$0 = Stdlib[19], unsigned_to_int = function(n) {
          if (0 >= caml_int_compare2(0, n) && 0 >= caml_int_compare2(n, max_int$0))
            return [0, n];
          return 0;
        };
      else {
        if (64 !== _a_)
          throw caml_maybe_attach_backtrace2([0, Assert_failure, _b_], 1);
        var unsigned_to_int = function(n) {
          return [0, n & -1];
        };
      }
      function to_string(n) {
        return runtime.caml_format_int("%d", n);
      }
      function of_string_opt(s2) {
        try {
          var _d_ = [0, runtime.caml_int_of_string(s2)];
          return _d_;
        } catch (_e_) {
          var _c_ = caml_wrap_exception2(_e_);
          if (_c_[1] === Stdlib[7])
            return 0;
          throw caml_maybe_attach_backtrace2(_c_, 0);
        }
      }
      var compare = caml_int_compare2;
      function equal(x2, y) {
        return 0 === caml_int_compare2(x2, y) ? 1 : 0;
      }
      function unsigned_compare(n, m) {
        return caml_int_compare2(n + 2147483648 | 0, m + 2147483648 | 0);
      }
      function min(x2, y) {
        return runtime.caml_lessequal(x2, y) ? x2 : y;
      }
      function max(x2, y) {
        return caml_greaterequal2(x2, y) ? x2 : y;
      }
      function unsigned_div(n, d) {
        if (runtime.caml_lessthan(d, 0))
          return 0 <= unsigned_compare(n, d) ? one : zero;
        var q = runtime.caml_div(n >>> 1 | 0, d) << 1, r = n - caml_mul2(q, d) | 0;
        return 0 <= unsigned_compare(r, d) ? q + 1 | 0 : q;
      }
      function unsigned_rem(n, d) {
        return n - caml_mul2(unsigned_div(n, d), d) | 0;
      }
      function seeded_hash(seed, x2) {
        return caml_hash2(10, 100, seed, x2);
      }
      function hash(x2) {
        return caml_hash2(10, 100, 0, x2);
      }
      var Stdlib_Int32 = [
        0,
        zero,
        one,
        minus_one,
        unsigned_div,
        unsigned_rem,
        succ,
        pred,
        abs,
        max_int,
        min_int,
        lognot,
        unsigned_to_int,
        of_string_opt,
        to_string,
        compare,
        unsigned_compare,
        equal,
        min,
        max,
        seeded_hash,
        hash
      ];
      runtime.caml_register_global(14, Stdlib_Int32, "Stdlib__Int32");
      return;
    })(globalThis);
    (function(globalThis2) {
      "use strict";
      var runtime = globalThis2.jsoo_runtime, caml_greaterequal2 = runtime.caml_greaterequal, caml_hash2 = runtime.caml_hash, caml_int64_compare2 = runtime.caml_int64_compare, caml_int64_mul2 = runtime.caml_int64_mul, caml_int64_sub2 = runtime.caml_int64_sub, caml_maybe_attach_backtrace2 = runtime.caml_maybe_attach_backtrace, caml_wrap_exception2 = runtime.caml_wrap_exception, global_data = runtime.caml_get_global_data(), zero = runtime.caml_int64_create_lo_mi_hi(0, 0, 0), one = runtime.caml_int64_create_lo_mi_hi(1, 0, 0), minus_one = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 65535), min_int = runtime.caml_int64_create_lo_mi_hi(0, 0, 32768), max_int = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 32767), Stdlib = global_data.Stdlib, _a_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0), _b_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0), _c_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0), _d_ = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 65535);
      function succ(n) {
        return runtime.caml_int64_add(n, _a_);
      }
      function pred(n) {
        return caml_int64_sub2(n, _b_);
      }
      function abs(n) {
        return caml_greaterequal2(n, _c_) ? n : runtime.caml_int64_neg(n);
      }
      function lognot(n) {
        return runtime.caml_int64_xor(n, _d_);
      }
      var max_int$0 = runtime.caml_int64_of_int32(Stdlib[19]);
      function unsigned_to_int(n) {
        if (0 >= caml_int64_compare2(zero, n) && 0 >= caml_int64_compare2(n, max_int$0))
          return [0, runtime.caml_int64_to_int32(n)];
        return 0;
      }
      function to_string(n) {
        return runtime.caml_int64_format("%d", n);
      }
      function of_string_opt(s2) {
        try {
          var _f_ = [0, runtime.caml_int64_of_string(s2)];
          return _f_;
        } catch (_g_) {
          var _e_ = caml_wrap_exception2(_g_);
          if (_e_[1] === Stdlib[7])
            return 0;
          throw caml_maybe_attach_backtrace2(_e_, 0);
        }
      }
      function compare(x2, y) {
        return caml_int64_compare2(x2, y);
      }
      function equal(x2, y) {
        return 0 === caml_int64_compare2(x2, y) ? 1 : 0;
      }
      function unsigned_compare(n, m) {
        return caml_int64_compare2(caml_int64_sub2(n, min_int), caml_int64_sub2(m, min_int));
      }
      function min(x2, y) {
        return runtime.caml_lessequal(x2, y) ? x2 : y;
      }
      function max(x2, y) {
        return caml_greaterequal2(x2, y) ? x2 : y;
      }
      function unsigned_div(n, d) {
        if (runtime.caml_lessthan(d, zero))
          return 0 <= unsigned_compare(n, d) ? one : zero;
        var q = runtime.caml_int64_shift_left(
          runtime.caml_int64_div(runtime.caml_int64_shift_right_unsigned(n, 1), d),
          1
        ), r = caml_int64_sub2(n, caml_int64_mul2(q, d));
        return 0 <= unsigned_compare(r, d) ? succ(q) : q;
      }
      function unsigned_rem(n, d) {
        return caml_int64_sub2(n, caml_int64_mul2(unsigned_div(n, d), d));
      }
      function seeded_hash(seed, x2) {
        return caml_hash2(10, 100, seed, x2);
      }
      function hash(x2) {
        return caml_hash2(10, 100, 0, x2);
      }
      var Stdlib_Int64 = [
        0,
        zero,
        one,
        minus_one,
        unsigned_div,
        unsigned_rem,
        succ,
        pred,
        abs,
        max_int,
        min_int,
        lognot,
        unsigned_to_int,
        of_string_opt,
        to_string,
        compare,
        unsigned_compare,
        equal,
        min,
        max,
        seeded_hash,
        hash
      ];
      runtime.caml_register_global(11, Stdlib_Int64, "Stdlib__Int64");
      return;
    })(globalThis);
    (function(globalThis2) {
      "use strict";
      var runtime = globalThis2.jsoo_runtime, caml_greaterequal2 = runtime.caml_greaterequal, caml_hash2 = runtime.caml_hash, caml_int_compare2 = runtime.caml_int_compare, caml_maybe_attach_backtrace2 = runtime.caml_maybe_attach_backtrace, caml_mul2 = runtime.caml_mul, caml_wrap_exception2 = runtime.caml_wrap_exception, global_data = runtime.caml_get_global_data(), Stdlib = global_data.Stdlib, Stdlib_Sys = global_data.Stdlib__Sys, zero = 0, one = 1;
      function succ(n) {
        return n + 1 | 0;
      }
      function pred(n) {
        return n - 1 | 0;
      }
      function abs(n) {
        return caml_greaterequal2(n, 0) ? n : -n | 0;
      }
      var size = Stdlib_Sys[9], min_int = 1 << (size - 1 | 0), max_int = min_int - 1 | 0;
      function lognot(n) {
        return n ^ -1;
      }
      var max_int$0 = Stdlib[19];
      function unsigned_to_int(n) {
        if (0 >= caml_int_compare2(0, n) && 0 >= caml_int_compare2(n, max_int$0))
          return [0, n];
        return 0;
      }
      function to_string(n) {
        return runtime.caml_format_int("%d", n);
      }
      function of_string_opt(s2) {
        try {
          var _b_ = [0, runtime.caml_int_of_string(s2)];
          return _b_;
        } catch (_c_) {
          var _a_ = caml_wrap_exception2(_c_);
          if (_a_[1] === Stdlib[7])
            return 0;
          throw caml_maybe_attach_backtrace2(_a_, 0);
        }
      }
      var compare = caml_int_compare2;
      function equal(x2, y) {
        return 0 === caml_int_compare2(x2, y) ? 1 : 0;
      }
      function unsigned_compare(n, m) {
        return caml_int_compare2(n - min_int | 0, m - min_int | 0);
      }
      function min(x2, y) {
        return runtime.caml_lessequal(x2, y) ? x2 : y;
      }
      function max(x2, y) {
        return caml_greaterequal2(x2, y) ? x2 : y;
      }
      function unsigned_div(n, d) {
        if (runtime.caml_lessthan(d, 0))
          return 0 <= unsigned_compare(n, d) ? one : zero;
        var q = runtime.caml_div(n >>> 1 | 0, d) << 1, r = n - caml_mul2(q, d) | 0;
        return 0 <= unsigned_compare(r, d) ? q + 1 | 0 : q;
      }
      function unsigned_rem(n, d) {
        return n - caml_mul2(unsigned_div(n, d), d) | 0;
      }
      function seeded_hash(seed, x2) {
        return caml_hash2(10, 100, seed, x2);
      }
      function hash(x2) {
        return caml_hash2(10, 100, 0, x2);
      }
      var Stdlib_Nativeint = [
        0,
        zero,
        one,
        -1,
        unsigned_div,
        unsigned_rem,
        succ,
        pred,
        abs,
        size,
        max_int,
        min_int,
        lognot,
        unsigned_to_int,
        of_string_opt,
        to_string,
        compare,
        unsigned_compare,
        equal,
        min,
        max,
        seeded_hash,
        hash
      ];
      runtime.caml_register_global(12, Stdlib_Nativeint, "Stdlib__Nativeint");
      return;
    })(globalThis);
    (function(globalThis2) {
      "use strict";
      var runtime = globalThis2.jsoo_runtime, cst = "", caml_bytes_get2 = runtime.caml_bytes_get, caml_check_bound2 = runtime.caml_check_bound, caml_create_bytes2 = runtime.caml_create_bytes, caml_ml_bytes_length2 = runtime.caml_ml_bytes_length;
      function caml_call1(f, a0) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 1 ? f(a0) : runtime.caml_call_gen(f, [a0]);
      }
      function caml_call2(f, a0, a1) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 2 ? f(a0, a1) : runtime.caml_call_gen(f, [a0, a1]);
      }
      function caml_call3(f, a0, a1, a2) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 3 ? f(a0, a1, a2) : runtime.caml_call_gen(f, [a0, a1, a2]);
      }
      function caml_call4(f, a0, a1, a2, a3) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 4 ? f(a0, a1, a2, a3) : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
      }
      function caml_call5(f, a0, a1, a2, a3, a4) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 5 ? f(a0, a1, a2, a3, a4) : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
      }
      var global_data = runtime.caml_get_global_data(), dummy_pos = [0, cst, 0, 0, -1], zero_pos = [0, cst, 1, 0, 0], Stdlib_Bytes = global_data.Stdlib__Bytes, Stdlib = global_data.Stdlib, Stdlib_Sys = global_data.Stdlib__Sys, Stdlib_Int = global_data.Stdlib__Int, cst_Lexing_lex_refill_cannot_g = "Lexing.lex_refill: cannot grow buffer";
      function engine(tbl, state, buf) {
        var result = runtime.caml_lex_engine(tbl, state, buf), _n_ = 0 <= result ? 1 : 0, _o_ = _n_ ? buf[12] !== dummy_pos ? 1 : 0 : _n_;
        if (_o_) {
          buf[11] = buf[12];
          var _p_ = buf[12];
          buf[12] = [0, _p_[1], _p_[2], _p_[3], buf[4] + buf[6] | 0];
        }
        return result;
      }
      function new_engine(tbl, state, buf) {
        var result = runtime.caml_new_lex_engine(tbl, state, buf), _k_ = 0 <= result ? 1 : 0, _l_ = _k_ ? buf[12] !== dummy_pos ? 1 : 0 : _k_;
        if (_l_) {
          buf[11] = buf[12];
          var _m_ = buf[12];
          buf[12] = [0, _m_[1], _m_[2], _m_[3], buf[4] + buf[6] | 0];
        }
        return result;
      }
      function from_function(opt, read_fun) {
        if (opt)
          var sth = opt[1], with_positions2 = sth;
        else
          var with_positions2 = 1;
        var _f_ = with_positions2 ? zero_pos : dummy_pos, _g_ = with_positions2 ? zero_pos : dummy_pos, aux_buffer = caml_create_bytes2(512);
        return [
          0,
          function(lexbuf) {
            var read = caml_call2(read_fun, aux_buffer, caml_ml_bytes_length2(aux_buffer)), n = 0 < read ? read : (lexbuf[9] = 1, 0);
            if (caml_ml_bytes_length2(lexbuf[2]) < (lexbuf[3] + n | 0)) {
              if (((lexbuf[3] - lexbuf[5] | 0) + n | 0) <= caml_ml_bytes_length2(lexbuf[2]))
                caml_call5(
                  Stdlib_Bytes[11],
                  lexbuf[2],
                  lexbuf[5],
                  lexbuf[2],
                  0,
                  lexbuf[3] - lexbuf[5] | 0
                );
              else {
                var newlen = caml_call2(
                  Stdlib_Int[10],
                  2 * caml_ml_bytes_length2(lexbuf[2]) | 0,
                  Stdlib_Sys[12]
                );
                if (newlen < ((lexbuf[3] - lexbuf[5] | 0) + n | 0))
                  caml_call1(Stdlib[2], cst_Lexing_lex_refill_cannot_g);
                var newbuf = caml_create_bytes2(newlen);
                caml_call5(
                  Stdlib_Bytes[11],
                  lexbuf[2],
                  lexbuf[5],
                  newbuf,
                  0,
                  lexbuf[3] - lexbuf[5] | 0
                );
                lexbuf[2] = newbuf;
              }
              var s2 = lexbuf[5];
              lexbuf[4] = lexbuf[4] + s2 | 0;
              lexbuf[6] = lexbuf[6] - s2 | 0;
              lexbuf[5] = 0;
              lexbuf[7] = lexbuf[7] - s2 | 0;
              lexbuf[3] = lexbuf[3] - s2 | 0;
              var t = lexbuf[10], _i_ = t.length - 1 - 1 | 0, _h_ = 0;
              if (_i_ >= 0) {
                var i = _h_;
                for (; ; ) {
                  var v = caml_check_bound2(t, i)[1 + i];
                  if (0 <= v)
                    caml_check_bound2(t, i)[1 + i] = v - s2 | 0;
                  var _j_ = i + 1 | 0;
                  if (_i_ === i)
                    break;
                  var i = _j_;
                }
              }
            }
            caml_call5(Stdlib_Bytes[11], aux_buffer, 0, lexbuf[2], lexbuf[3], n);
            lexbuf[3] = lexbuf[3] + n | 0;
            return 0;
          },
          caml_create_bytes2(1024),
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          [0],
          _g_,
          _f_
        ];
      }
      function from_channel(with_positions2, ic) {
        return from_function(
          with_positions2,
          function(buf, n) {
            return caml_call4(Stdlib[84], ic, buf, 0, n);
          }
        );
      }
      function from_string(opt, s2) {
        if (opt)
          var sth = opt[1], with_positions2 = sth;
        else
          var with_positions2 = 1;
        var _d_ = with_positions2 ? zero_pos : dummy_pos, _e_ = with_positions2 ? zero_pos : dummy_pos;
        return [
          0,
          function(lexbuf) {
            lexbuf[9] = 1;
            return 0;
          },
          caml_call1(Stdlib_Bytes[5], s2),
          runtime.caml_ml_string_length(s2),
          0,
          0,
          0,
          0,
          0,
          1,
          [0],
          _e_,
          _d_
        ];
      }
      function set_position(lexbuf, position) {
        lexbuf[12] = [0, lexbuf[12][1], position[2], position[3], position[4]];
        lexbuf[4] = position[4];
        return 0;
      }
      function set_filename(lexbuf, fname) {
        var _c_ = lexbuf[12];
        lexbuf[12] = [0, fname, _c_[2], _c_[3], _c_[4]];
        return 0;
      }
      function with_positions(lexbuf) {
        return lexbuf[12] !== dummy_pos ? 1 : 0;
      }
      function lexeme(lexbuf) {
        var len = lexbuf[6] - lexbuf[5] | 0;
        return caml_call3(Stdlib_Bytes[8], lexbuf[2], lexbuf[5], len);
      }
      function sub_lexeme(lexbuf, i1, i2) {
        var len = i2 - i1 | 0;
        return caml_call3(Stdlib_Bytes[8], lexbuf[2], i1, len);
      }
      function sub_lexeme_opt(lexbuf, i1, i2) {
        if (0 > i1)
          return 0;
        var len = i2 - i1 | 0;
        return [0, caml_call3(Stdlib_Bytes[8], lexbuf[2], i1, len)];
      }
      function sub_lexeme_char(lexbuf, i) {
        return caml_bytes_get2(lexbuf[2], i);
      }
      function sub_lexeme_char_opt(lexbuf, i) {
        return 0 <= i ? [0, caml_bytes_get2(lexbuf[2], i)] : 0;
      }
      function lexeme_char(lexbuf, i) {
        return caml_bytes_get2(lexbuf[2], lexbuf[5] + i | 0);
      }
      function lexeme_start(lexbuf) {
        return lexbuf[11][4];
      }
      function lexeme_end(lexbuf) {
        return lexbuf[12][4];
      }
      function lexeme_start_p(lexbuf) {
        return lexbuf[11];
      }
      function lexeme_end_p(lexbuf) {
        return lexbuf[12];
      }
      function new_line(lexbuf) {
        var lcp = lexbuf[12], _a_ = lcp !== dummy_pos ? 1 : 0, _b_ = _a_ ? (lexbuf[12] = [0, lcp[1], lcp[2] + 1 | 0, lcp[4], lcp[4]], 0) : _a_;
        return _b_;
      }
      function flush_input(lb) {
        lb[6] = 0;
        lb[4] = 0;
        var lcp = lb[12];
        if (lcp !== dummy_pos)
          lb[12] = [0, lcp[1], zero_pos[2], zero_pos[3], zero_pos[4]];
        lb[3] = 0;
        return 0;
      }
      var Stdlib_Lexing = [
        0,
        dummy_pos,
        from_channel,
        from_string,
        from_function,
        set_position,
        set_filename,
        with_positions,
        lexeme,
        lexeme_char,
        lexeme_start,
        lexeme_end,
        lexeme_start_p,
        lexeme_end_p,
        new_line,
        flush_input,
        sub_lexeme,
        sub_lexeme_opt,
        sub_lexeme_char,
        sub_lexeme_char_opt,
        engine,
        new_engine
      ];
      runtime.caml_register_global(7, Stdlib_Lexing, "Stdlib__Lexing");
      return;
    })(globalThis);
    (function(globalThis2) {
      "use strict";
      var runtime = globalThis2.jsoo_runtime, cst_Map_bal$3 = "Map.bal", caml_maybe_attach_backtrace2 = runtime.caml_maybe_attach_backtrace;
      function caml_call1(f, a0) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 1 ? f(a0) : runtime.caml_call_gen(f, [a0]);
      }
      function caml_call2(f, a0, a1) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 2 ? f(a0, a1) : runtime.caml_call_gen(f, [a0, a1]);
      }
      function caml_call3(f, a0, a1, a2) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 3 ? f(a0, a1, a2) : runtime.caml_call_gen(f, [a0, a1, a2]);
      }
      var global_data = runtime.caml_get_global_data(), Stdlib = global_data.Stdlib, Assert_failure = global_data.Assert_failure, Stdlib_Seq = global_data.Stdlib__Seq, Stdlib_List = global_data.Stdlib__List, cst_Map_bal = cst_Map_bal$3, cst_Map_bal$0 = cst_Map_bal$3, cst_Map_bal$1 = cst_Map_bal$3, cst_Map_bal$2 = cst_Map_bal$3, cst_Map_remove_min_elt = "Map.remove_min_elt", _a_ = [0, 0, 0, 0], _b_ = [0, "map.ml", 408, 10], _c_ = [0, 0, 0], Stdlib_Map = [
        0,
        function(Ord) {
          function height(param) {
            if (!param)
              return 0;
            var h = param[5];
            return h;
          }
          function create(l, x2, d, r) {
            var hl = height(l), hr = height(r), _K_ = hr <= hl ? hl + 1 | 0 : hr + 1 | 0;
            return [0, l, x2, d, r, _K_];
          }
          function singleton(x2, d) {
            return [0, 0, x2, d, 0, 1];
          }
          function bal(l, x2, d, r) {
            if (l)
              var h = l[5], hl = h;
            else
              var hl = 0;
            if (r)
              var h$0 = r[5], hr = h$0;
            else
              var hr = 0;
            if ((hr + 2 | 0) < hl) {
              if (!l)
                return caml_call1(Stdlib[1], cst_Map_bal$0);
              var lr = l[4], ld = l[3], lv = l[2], ll = l[1], _F_ = height(lr);
              if (_F_ <= height(ll))
                return create(ll, lv, ld, create(lr, x2, d, r));
              if (!lr)
                return caml_call1(Stdlib[1], cst_Map_bal);
              var lrr = lr[4], lrd = lr[3], lrv = lr[2], lrl = lr[1], _G_ = create(lrr, x2, d, r);
              return create(create(ll, lv, ld, lrl), lrv, lrd, _G_);
            }
            if ((hl + 2 | 0) >= hr) {
              var _J_ = hr <= hl ? hl + 1 | 0 : hr + 1 | 0;
              return [0, l, x2, d, r, _J_];
            }
            if (!r)
              return caml_call1(Stdlib[1], cst_Map_bal$2);
            var rr = r[4], rd = r[3], rv = r[2], rl = r[1], _H_ = height(rl);
            if (_H_ <= height(rr))
              return create(create(l, x2, d, rl), rv, rd, rr);
            if (!rl)
              return caml_call1(Stdlib[1], cst_Map_bal$1);
            var rlr = rl[4], rld = rl[3], rlv = rl[2], rll = rl[1], _I_ = create(rlr, rv, rd, rr);
            return create(create(l, x2, d, rll), rlv, rld, _I_);
          }
          var empty = 0;
          function is_empty(param) {
            return param ? 0 : 1;
          }
          function add(x2, data, m) {
            if (!m)
              return [0, 0, x2, data, 0, 1];
            var h = m[5], r = m[4], d = m[3], v = m[2], l = m[1], c = caml_call2(Ord[1], x2, v);
            if (0 === c)
              return d === data ? m : [0, l, x2, data, r, h];
            if (0 <= c) {
              var rr = add(x2, data, r);
              return r === rr ? m : bal(l, v, d, rr);
            }
            var ll = add(x2, data, l);
            return l === ll ? m : bal(ll, v, d, r);
          }
          function find(x2, param) {
            var param$0 = param;
            for (; ; ) {
              if (!param$0)
                throw caml_maybe_attach_backtrace2(Stdlib[8], 1);
              var r = param$0[4], d = param$0[3], v = param$0[2], l = param$0[1], c = caml_call2(Ord[1], x2, v);
              if (0 === c)
                return d;
              var r$0 = 0 <= c ? r : l, param$0 = r$0;
            }
          }
          function find_first(f, param$0) {
            var param$1 = param$0;
            for (; ; ) {
              if (!param$1)
                throw caml_maybe_attach_backtrace2(Stdlib[8], 1);
              var r$0 = param$1[4], d0$1 = param$1[3], v0$1 = param$1[2], l$0 = param$1[1];
              if (caml_call1(f, v0$1)) {
                var v0 = v0$1, d0 = d0$1, param = l$0;
                for (; ; ) {
                  if (!param)
                    return [0, v0, d0];
                  var r = param[4], d0$0 = param[3], v0$0 = param[2], l = param[1];
                  if (caml_call1(f, v0$0))
                    var v0 = v0$0, d0 = d0$0, param = l;
                  else
                    var param = r;
                }
              } else
                var param$1 = r$0;
            }
          }
          function find_first_opt(f, param$0) {
            var param$1 = param$0;
            for (; ; ) {
              if (!param$1)
                return 0;
              var r$0 = param$1[4], d0$1 = param$1[3], v0$1 = param$1[2], l$0 = param$1[1];
              if (caml_call1(f, v0$1)) {
                var v0 = v0$1, d0 = d0$1, param = l$0;
                for (; ; ) {
                  if (!param)
                    return [0, [0, v0, d0]];
                  var r = param[4], d0$0 = param[3], v0$0 = param[2], l = param[1];
                  if (caml_call1(f, v0$0))
                    var v0 = v0$0, d0 = d0$0, param = l;
                  else
                    var param = r;
                }
              } else
                var param$1 = r$0;
            }
          }
          function find_last(f, param$0) {
            var param$1 = param$0;
            for (; ; ) {
              if (!param$1)
                throw caml_maybe_attach_backtrace2(Stdlib[8], 1);
              var r$0 = param$1[4], d0$1 = param$1[3], v0$1 = param$1[2], l$0 = param$1[1];
              if (caml_call1(f, v0$1)) {
                var v0 = v0$1, d0 = d0$1, param = r$0;
                for (; ; ) {
                  if (!param)
                    return [0, v0, d0];
                  var r = param[4], d0$0 = param[3], v0$0 = param[2], l = param[1];
                  if (caml_call1(f, v0$0))
                    var v0 = v0$0, d0 = d0$0, param = r;
                  else
                    var param = l;
                }
              } else
                var param$1 = l$0;
            }
          }
          function find_last_opt(f, param$0) {
            var param$1 = param$0;
            for (; ; ) {
              if (!param$1)
                return 0;
              var r$0 = param$1[4], d0$1 = param$1[3], v0$1 = param$1[2], l$0 = param$1[1];
              if (caml_call1(f, v0$1)) {
                var v0 = v0$1, d0 = d0$1, param = r$0;
                for (; ; ) {
                  if (!param)
                    return [0, [0, v0, d0]];
                  var r = param[4], d0$0 = param[3], v0$0 = param[2], l = param[1];
                  if (caml_call1(f, v0$0))
                    var v0 = v0$0, d0 = d0$0, param = r;
                  else
                    var param = l;
                }
              } else
                var param$1 = l$0;
            }
          }
          function find_opt(x2, param) {
            var param$0 = param;
            for (; ; ) {
              if (!param$0)
                return 0;
              var r = param$0[4], d = param$0[3], v = param$0[2], l = param$0[1], c = caml_call2(Ord[1], x2, v);
              if (0 === c)
                return [0, d];
              var r$0 = 0 <= c ? r : l, param$0 = r$0;
            }
          }
          function mem(x2, param) {
            var param$0 = param;
            for (; ; ) {
              if (!param$0)
                return 0;
              var r = param$0[4], v = param$0[2], l = param$0[1], c = caml_call2(Ord[1], x2, v), _E_ = 0 === c ? 1 : 0;
              if (_E_)
                return _E_;
              var r$0 = 0 <= c ? r : l, param$0 = r$0;
            }
          }
          function min_binding(param) {
            var param$0 = param;
            for (; ; ) {
              if (!param$0)
                throw caml_maybe_attach_backtrace2(Stdlib[8], 1);
              var l = param$0[1];
              if (!l) {
                var d = param$0[3], v = param$0[2];
                return [0, v, d];
              }
              var param$0 = l;
            }
          }
          function min_binding_opt(param) {
            var param$0 = param;
            for (; ; ) {
              if (!param$0)
                return 0;
              var l = param$0[1];
              if (!l) {
                var d = param$0[3], v = param$0[2];
                return [0, [0, v, d]];
              }
              var param$0 = l;
            }
          }
          function max_binding(param) {
            var param$0 = param;
            for (; ; ) {
              if (!param$0)
                throw caml_maybe_attach_backtrace2(Stdlib[8], 1);
              if (!param$0[4]) {
                var d = param$0[3], v = param$0[2];
                return [0, v, d];
              }
              var r = param$0[4], param$0 = r;
            }
          }
          function max_binding_opt(param) {
            var param$0 = param;
            for (; ; ) {
              if (!param$0)
                return 0;
              if (!param$0[4]) {
                var d = param$0[3], v = param$0[2];
                return [0, [0, v, d]];
              }
              var r = param$0[4], param$0 = r;
            }
          }
          function remove_min_binding(param) {
            if (!param)
              return caml_call1(Stdlib[1], cst_Map_remove_min_elt);
            var l = param[1];
            if (l) {
              var r = param[4], d = param[3], v = param[2];
              return bal(remove_min_binding(l), v, d, r);
            }
            var r$0 = param[4];
            return r$0;
          }
          function _d_(t1, t2) {
            if (!t1)
              return t2;
            if (!t2)
              return t1;
            var match = min_binding(t2), d = match[2], x2 = match[1];
            return bal(t1, x2, d, remove_min_binding(t2));
          }
          function remove(x2, m) {
            if (!m)
              return 0;
            var r = m[4], d = m[3], v = m[2], l = m[1], c = caml_call2(Ord[1], x2, v);
            if (0 === c)
              return _d_(l, r);
            if (0 <= c) {
              var rr = remove(x2, r);
              return r === rr ? m : bal(l, v, d, rr);
            }
            var ll = remove(x2, l);
            return l === ll ? m : bal(ll, v, d, r);
          }
          function update(x2, f, m) {
            if (!m) {
              var match$0 = caml_call1(f, 0);
              if (!match$0)
                return 0;
              var data$0 = match$0[1];
              return [0, 0, x2, data$0, 0, 1];
            }
            var h = m[5], r = m[4], d = m[3], v = m[2], l = m[1], c = caml_call2(Ord[1], x2, v);
            if (0 === c) {
              var match = caml_call1(f, [0, d]);
              if (!match)
                return _d_(l, r);
              var data = match[1];
              return d === data ? m : [0, l, x2, data, r, h];
            }
            if (0 <= c) {
              var rr = update(x2, f, r);
              return r === rr ? m : bal(l, v, d, rr);
            }
            var ll = update(x2, f, l);
            return l === ll ? m : bal(ll, v, d, r);
          }
          function add_to_list(x2, data, m) {
            function add2(param) {
              if (!param)
                return [0, [0, data, 0]];
              var l = param[1];
              return [0, [0, data, l]];
            }
            return update(x2, add2, m);
          }
          function iter(f, param) {
            var param$0 = param;
            for (; ; ) {
              if (!param$0)
                return 0;
              var r = param$0[4], d = param$0[3], v = param$0[2], l = param$0[1];
              iter(f, l);
              caml_call2(f, v, d);
              var param$0 = r;
            }
          }
          function map(f, param) {
            if (!param)
              return 0;
            var h = param[5], r = param[4], d = param[3], v = param[2], l = param[1], l$0 = map(f, l), d$0 = caml_call1(f, d), r$0 = map(f, r);
            return [0, l$0, v, d$0, r$0, h];
          }
          function mapi(f, param) {
            if (!param)
              return 0;
            var h = param[5], r = param[4], d = param[3], v = param[2], l = param[1], l$0 = mapi(f, l), d$0 = caml_call2(f, v, d), r$0 = mapi(f, r);
            return [0, l$0, v, d$0, r$0, h];
          }
          function fold(f, m, accu) {
            var m$0 = m, accu$0 = accu;
            for (; ; ) {
              if (!m$0)
                return accu$0;
              var r = m$0[4], d = m$0[3], v = m$0[2], l = m$0[1], accu$1 = caml_call3(f, v, d, fold(f, l, accu$0)), m$0 = r, accu$0 = accu$1;
            }
          }
          function for_all(p, param) {
            var param$0 = param;
            for (; ; ) {
              if (!param$0)
                return 1;
              var r = param$0[4], d = param$0[3], v = param$0[2], l = param$0[1], _B_ = caml_call2(p, v, d);
              if (_B_) {
                var _C_ = for_all(p, l);
                if (_C_) {
                  var param$0 = r;
                  continue;
                }
                var _D_ = _C_;
              } else
                var _D_ = _B_;
              return _D_;
            }
          }
          function exists(p, param) {
            var param$0 = param;
            for (; ; ) {
              if (!param$0)
                return 0;
              var r = param$0[4], d = param$0[3], v = param$0[2], l = param$0[1], _y_ = caml_call2(p, v, d);
              if (_y_)
                var _z_ = _y_;
              else {
                var _A_ = exists(p, l);
                if (!_A_) {
                  var param$0 = r;
                  continue;
                }
                var _z_ = _A_;
              }
              return _z_;
            }
          }
          function add_min_binding(k, x2, param) {
            if (!param)
              return singleton(k, x2);
            var r = param[4], d = param[3], v = param[2], l = param[1];
            return bal(add_min_binding(k, x2, l), v, d, r);
          }
          function add_max_binding(k, x2, param) {
            if (!param)
              return singleton(k, x2);
            var r = param[4], d = param[3], v = param[2], l = param[1];
            return bal(l, v, d, add_max_binding(k, x2, r));
          }
          function join(l, v, d, r) {
            if (!l)
              return add_min_binding(v, d, r);
            if (!r)
              return add_max_binding(v, d, l);
            var rh = r[5], rr = r[4], rd = r[3], rv = r[2], rl = r[1], lh = l[5], lr = l[4], ld = l[3], lv = l[2], ll = l[1];
            return (rh + 2 | 0) < lh ? bal(ll, lv, ld, join(lr, v, d, r)) : (lh + 2 | 0) < rh ? bal(join(l, v, d, rl), rv, rd, rr) : create(l, v, d, r);
          }
          function concat(t1, t2) {
            if (!t1)
              return t2;
            if (!t2)
              return t1;
            var match = min_binding(t2), d = match[2], x2 = match[1];
            return join(t1, x2, d, remove_min_binding(t2));
          }
          function concat_or_join(t1, v, d, t2) {
            if (!d)
              return concat(t1, t2);
            var d$0 = d[1];
            return join(t1, v, d$0, t2);
          }
          function split(x2, param) {
            if (!param)
              return _a_;
            var r = param[4], d = param[3], v = param[2], l = param[1], c = caml_call2(Ord[1], x2, v);
            if (0 === c)
              return [0, l, [0, d], r];
            if (0 <= c) {
              var match = split(x2, r), rr = match[3], pres = match[2], lr = match[1];
              return [0, join(l, v, d, lr), pres, rr];
            }
            var match$0 = split(x2, l), rl = match$0[3], pres$0 = match$0[2], ll = match$0[1];
            return [0, ll, pres$0, join(rl, v, d, r)];
          }
          function merge(f, s1, s2) {
            if (s1) {
              var h1 = s1[5], r1 = s1[4], d1 = s1[3], v1 = s1[2], l1 = s1[1];
              if (height(s2) <= h1) {
                var match = split(v1, s2), r2 = match[3], d2 = match[2], l2 = match[1], _u_ = merge(f, r1, r2), _v_ = caml_call3(f, v1, [0, d1], d2);
                return concat_or_join(merge(f, l1, l2), v1, _v_, _u_);
              }
            } else if (!s2)
              return 0;
            if (!s2)
              throw caml_maybe_attach_backtrace2([0, Assert_failure, _b_], 1);
            var r2$0 = s2[4], d2$0 = s2[3], v2 = s2[2], l2$0 = s2[1], match$0 = split(v2, s1), r1$0 = match$0[3], d1$0 = match$0[2], l1$0 = match$0[1], _w_ = merge(f, r1$0, r2$0), _x_ = caml_call3(f, v2, d1$0, [0, d2$0]);
            return concat_or_join(merge(f, l1$0, l2$0), v2, _x_, _w_);
          }
          function union(f, s1, s2) {
            if (s1) {
              if (s2) {
                var h2 = s2[5], r2 = s2[4], d2 = s2[3], v2 = s2[2], l2 = s2[1], h1 = s1[5], r1 = s1[4], d1 = s1[3], v1 = s1[2], l1 = s1[1];
                if (h2 <= h1) {
                  var match = split(v1, s2), r2$0 = match[3], d2$0 = match[2], l2$0 = match[1], l = union(f, l1, l2$0), r = union(f, r1, r2$0);
                  if (!d2$0)
                    return join(l, v1, d1, r);
                  var d2$1 = d2$0[1];
                  return concat_or_join(l, v1, caml_call3(f, v1, d1, d2$1), r);
                }
                var match$0 = split(v2, s1), r1$0 = match$0[3], d1$0 = match$0[2], l1$0 = match$0[1], l$0 = union(f, l1$0, l2), r$0 = union(f, r1$0, r2);
                if (!d1$0)
                  return join(l$0, v2, d2, r$0);
                var d1$1 = d1$0[1];
                return concat_or_join(l$0, v2, caml_call3(f, v2, d1$1, d2), r$0);
              }
              var s3 = s1;
            } else
              var s3 = s2;
            return s3;
          }
          function filter(p, m) {
            if (!m)
              return 0;
            var r = m[4], d = m[3], v = m[2], l = m[1], l$0 = filter(p, l), pvd = caml_call2(p, v, d), r$0 = filter(p, r);
            if (!pvd)
              return concat(l$0, r$0);
            if (l === l$0 && r === r$0)
              return m;
            return join(l$0, v, d, r$0);
          }
          function filter_map(f, param) {
            if (!param)
              return 0;
            var r = param[4], d = param[3], v = param[2], l = param[1], l$0 = filter_map(f, l), fvd = caml_call2(f, v, d), r$0 = filter_map(f, r);
            if (!fvd)
              return concat(l$0, r$0);
            var d$0 = fvd[1];
            return join(l$0, v, d$0, r$0);
          }
          function partition(p, param) {
            if (!param)
              return _c_;
            var r = param[4], d = param[3], v = param[2], l = param[1], match = partition(p, l), lf = match[2], lt = match[1], pvd = caml_call2(p, v, d), match$0 = partition(p, r), rf = match$0[2], rt = match$0[1];
            if (pvd) {
              var _s_ = concat(lf, rf);
              return [0, join(lt, v, d, rt), _s_];
            }
            var _t_ = join(lf, v, d, rf);
            return [0, concat(lt, rt), _t_];
          }
          function cons_enum(m, e) {
            var m$0 = m, e$0 = e;
            for (; ; ) {
              if (!m$0)
                return e$0;
              var r = m$0[4], d = m$0[3], v = m$0[2], l = m$0[1], e$1 = [0, v, d, r, e$0], m$0 = l, e$0 = e$1;
            }
          }
          function compare(cmp, m1, m2) {
            var e2$2 = cons_enum(m2, 0), e1$2 = cons_enum(m1, 0), e1 = e1$2, e2 = e2$2;
            for (; ; ) {
              if (!e1)
                return e2 ? -1 : 0;
              if (!e2)
                return 1;
              var e2$0 = e2[4], r2 = e2[3], d2 = e2[2], v2 = e2[1], e1$0 = e1[4], r1 = e1[3], d1 = e1[2], v1 = e1[1], c = caml_call2(Ord[1], v1, v2);
              if (0 !== c)
                return c;
              var c$0 = caml_call2(cmp, d1, d2);
              if (0 !== c$0)
                return c$0;
              var e2$1 = cons_enum(r2, e2$0), e1$1 = cons_enum(r1, e1$0), e1 = e1$1, e2 = e2$1;
            }
          }
          function equal(cmp, m1, m2) {
            var e2$2 = cons_enum(m2, 0), e1$2 = cons_enum(m1, 0), e1 = e1$2, e2 = e2$2;
            for (; ; ) {
              if (!e1)
                return e2 ? 0 : 1;
              if (!e2)
                return 0;
              var e2$0 = e2[4], r2 = e2[3], d2 = e2[2], v2 = e2[1], e1$0 = e1[4], r1 = e1[3], d1 = e1[2], v1 = e1[1], _p_ = 0 === caml_call2(Ord[1], v1, v2) ? 1 : 0;
              if (_p_) {
                var _q_ = caml_call2(cmp, d1, d2);
                if (_q_) {
                  var e2$1 = cons_enum(r2, e2$0), e1$1 = cons_enum(r1, e1$0), e1 = e1$1, e2 = e2$1;
                  continue;
                }
                var _r_ = _q_;
              } else
                var _r_ = _p_;
              return _r_;
            }
          }
          function cardinal(param) {
            if (!param)
              return 0;
            var r = param[4], l = param[1], _o_ = cardinal(r);
            return (cardinal(l) + 1 | 0) + _o_ | 0;
          }
          function bindings_aux(accu, param) {
            var accu$0 = accu, param$0 = param;
            for (; ; ) {
              if (!param$0)
                return accu$0;
              var r = param$0[4], d = param$0[3], v = param$0[2], l = param$0[1], accu$1 = [0, [0, v, d], bindings_aux(accu$0, r)], accu$0 = accu$1, param$0 = l;
            }
          }
          function bindings(s2) {
            return bindings_aux(0, s2);
          }
          function of_list(bs) {
            return caml_call3(
              Stdlib_List[26],
              function(m, param) {
                var v = param[2], k = param[1];
                return add(k, v, m);
              },
              empty,
              bs
            );
          }
          function add_seq(i, m) {
            return caml_call3(
              Stdlib_Seq[5],
              function(m2, param) {
                var v = param[2], k = param[1];
                return add(k, v, m2);
              },
              m,
              i
            );
          }
          function of_seq(i) {
            return add_seq(i, empty);
          }
          function seq_of_enum(c, param) {
            if (!c)
              return 0;
            var rest = c[4], t = c[3], v = c[2], k = c[1], _m_ = cons_enum(t, rest);
            return [0, [0, k, v], function(_n_) {
              return seq_of_enum(_m_, _n_);
            }];
          }
          function to_seq(m) {
            var _k_ = cons_enum(m, 0);
            return function(_l_) {
              return seq_of_enum(_k_, _l_);
            };
          }
          function snoc_enum(s2, e) {
            var s$0 = s2, e$0 = e;
            for (; ; ) {
              if (!s$0)
                return e$0;
              var r = s$0[4], d = s$0[3], v = s$0[2], l = s$0[1], e$1 = [0, v, d, l, e$0], s$0 = r, e$0 = e$1;
            }
          }
          function rev_seq_of_enum(c, param) {
            if (!c)
              return 0;
            var rest = c[4], t = c[3], v = c[2], k = c[1], _i_ = snoc_enum(t, rest);
            return [
              0,
              [0, k, v],
              function(_j_) {
                return rev_seq_of_enum(_i_, _j_);
              }
            ];
          }
          function to_rev_seq(c) {
            var _g_ = snoc_enum(c, 0);
            return function(_h_) {
              return rev_seq_of_enum(_g_, _h_);
            };
          }
          function to_seq_from(low, m) {
            a: {
              b: {
                var m$0 = m, c = 0;
                for (; ; ) {
                  if (!m$0)
                    break;
                  var r = m$0[4], d = m$0[3], v = m$0[2], l = m$0[1], n = caml_call2(Ord[1], v, low);
                  if (0 === n)
                    break b;
                  if (0 <= n)
                    var c$0 = [0, v, d, r, c], m$0 = l, c = c$0;
                  else
                    var m$0 = r;
                }
                var _e_ = c;
                break a;
              }
              var _e_ = [0, v, d, r, c];
            }
            return function(_f_) {
              return seq_of_enum(_e_, _f_);
            };
          }
          return [
            0,
            empty,
            add,
            add_to_list,
            update,
            singleton,
            remove,
            merge,
            union,
            cardinal,
            bindings,
            min_binding,
            min_binding_opt,
            max_binding,
            max_binding_opt,
            min_binding,
            min_binding_opt,
            find,
            find_opt,
            find_first,
            find_first_opt,
            find_last,
            find_last_opt,
            iter,
            fold,
            map,
            mapi,
            filter,
            filter_map,
            partition,
            split,
            is_empty,
            mem,
            equal,
            compare,
            for_all,
            exists,
            bindings,
            of_list,
            to_seq,
            to_rev_seq,
            to_seq_from,
            add_seq,
            of_seq
          ];
        }
      ];
      runtime.caml_register_global(12, Stdlib_Map, "Stdlib__Map");
      return;
    })(globalThis);
    (function(globalThis2) {
      "use strict";
      var runtime = globalThis2.jsoo_runtime, caml_maybe_attach_backtrace2 = runtime.caml_maybe_attach_backtrace;
      function caml_call1(f, a0) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 1 ? f(a0) : runtime.caml_call_gen(f, [a0]);
      }
      function caml_call2(f, a0, a1) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 2 ? f(a0, a1) : runtime.caml_call_gen(f, [a0, a1]);
      }
      function caml_call3(f, a0, a1, a2) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 3 ? f(a0, a1, a2) : runtime.caml_call_gen(f, [a0, a1, a2]);
      }
      var global_data = runtime.caml_get_global_data(), Stdlib_Seq = global_data.Stdlib__Seq, Stdlib_List = global_data.Stdlib__List, Empty = [248, "Stdlib.Stack.Empty", runtime.caml_fresh_oo_id(0)];
      function create(param) {
        return [0, 0, 0];
      }
      function clear(s2) {
        s2[1] = 0;
        s2[2] = 0;
        return 0;
      }
      function copy(s2) {
        return [0, s2[1], s2[2]];
      }
      function push(x2, s2) {
        s2[1] = [0, x2, s2[1]];
        s2[2] = s2[2] + 1 | 0;
        return 0;
      }
      function pop(s2) {
        var match = s2[1];
        if (!match)
          throw caml_maybe_attach_backtrace2(Empty, 1);
        var tl = match[2], hd = match[1];
        s2[1] = tl;
        s2[2] = s2[2] - 1 | 0;
        return hd;
      }
      function pop_opt(s2) {
        var match = s2[1];
        if (!match)
          return 0;
        var tl = match[2], hd = match[1];
        s2[1] = tl;
        s2[2] = s2[2] - 1 | 0;
        return [0, hd];
      }
      function drop(s2) {
        var match = s2[1];
        if (!match)
          throw caml_maybe_attach_backtrace2(Empty, 1);
        var tl = match[2];
        s2[1] = tl;
        s2[2] = s2[2] - 1 | 0;
        return 0;
      }
      function top(s2) {
        var match = s2[1];
        if (!match)
          throw caml_maybe_attach_backtrace2(Empty, 1);
        var hd = match[1];
        return hd;
      }
      function top_opt(s2) {
        var match = s2[1];
        if (!match)
          return 0;
        var hd = match[1];
        return [0, hd];
      }
      function is_empty(s2) {
        return 0 === s2[1] ? 1 : 0;
      }
      function length(s2) {
        return s2[2];
      }
      function iter(f, s2) {
        return caml_call2(Stdlib_List[18], f, s2[1]);
      }
      function fold(f, acc, s2) {
        return caml_call3(Stdlib_List[26], f, acc, s2[1]);
      }
      function to_seq(s2) {
        return caml_call1(Stdlib_List[64], s2[1]);
      }
      function add_seq(q, i) {
        return caml_call2(Stdlib_Seq[4], function(x2) {
          return push(x2, q);
        }, i);
      }
      function of_seq(g) {
        var s2 = create(0);
        add_seq(s2, g);
        return s2;
      }
      var Stdlib_Stack = [
        0,
        Empty,
        create,
        push,
        pop,
        pop_opt,
        drop,
        top,
        top_opt,
        clear,
        copy,
        is_empty,
        length,
        iter,
        fold,
        to_seq,
        add_seq,
        of_seq
      ];
      runtime.caml_register_global(3, Stdlib_Stack, "Stdlib__Stack");
      return;
    })(globalThis);
    (function(globalThis2) {
      "use strict";
      var runtime = globalThis2.jsoo_runtime, caml_maybe_attach_backtrace2 = runtime.caml_maybe_attach_backtrace;
      function caml_call1(f, a0) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 1 ? f(a0) : runtime.caml_call_gen(f, [a0]);
      }
      function caml_call2(f, a0, a1) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 2 ? f(a0, a1) : runtime.caml_call_gen(f, [a0, a1]);
      }
      var global_data = runtime.caml_get_global_data(), Stdlib_Seq = global_data.Stdlib__Seq, Empty = [248, "Stdlib.Queue.Empty", runtime.caml_fresh_oo_id(0)];
      function create(param) {
        return [0, 0, 0, 0];
      }
      function clear(q) {
        q[1] = 0;
        q[2] = 0;
        q[3] = 0;
        return 0;
      }
      function add(x2, q) {
        var cell = [0, x2, 0], match = q[3];
        return match ? (q[1] = q[1] + 1 | 0, match[2] = cell, q[3] = cell, 0) : (q[1] = 1, q[2] = cell, q[3] = cell, 0);
      }
      function peek(q) {
        var match = q[2];
        if (!match)
          throw caml_maybe_attach_backtrace2(Empty, 1);
        var content = match[1];
        return content;
      }
      function peek_opt(q) {
        var match = q[2];
        if (!match)
          return 0;
        var content = match[1];
        return [0, content];
      }
      function take(q) {
        var _f_ = q[2];
        if (!_f_)
          throw caml_maybe_attach_backtrace2(Empty, 1);
        var content = _f_[1];
        if (_f_[2]) {
          var next = _f_[2];
          q[1] = q[1] - 1 | 0;
          q[2] = next;
          return content;
        }
        clear(q);
        return content;
      }
      function take_opt(q) {
        var _e_ = q[2];
        if (!_e_)
          return 0;
        var content = _e_[1];
        if (_e_[2]) {
          var next = _e_[2];
          q[1] = q[1] - 1 | 0;
          q[2] = next;
          return [0, content];
        }
        clear(q);
        return [0, content];
      }
      function copy(q) {
        var cell$0 = q[2], q_res = [0, q[1], 0, 0], prev = 0, cell = cell$0;
        for (; ; ) {
          if (!cell) {
            q_res[3] = prev;
            return q_res;
          }
          var content = cell[1], next = cell[2], prev$0 = [0, content, 0];
          if (prev)
            prev[2] = prev$0;
          else
            q_res[2] = prev$0;
          var prev = prev$0, cell = next;
        }
      }
      function is_empty(q) {
        return 0 === q[1] ? 1 : 0;
      }
      function length(q) {
        return q[1];
      }
      function iter(f, q) {
        var cell$0 = q[2], cell = cell$0;
        for (; ; ) {
          if (!cell)
            return 0;
          var content = cell[1], next = cell[2];
          caml_call1(f, content);
          var cell = next;
        }
      }
      function fold(f, accu$1, q) {
        var cell$0 = q[2], accu = accu$1, cell = cell$0;
        for (; ; ) {
          if (!cell)
            return accu;
          var content = cell[1], next = cell[2], accu$0 = caml_call2(f, accu, content), accu = accu$0, cell = next;
        }
      }
      function transfer(q1, q2) {
        var _d_ = 0 < q1[1] ? 1 : 0;
        if (!_d_)
          return _d_;
        var match = q2[3];
        return match ? (q2[1] = q2[1] + q1[1] | 0, match[2] = q1[2], q2[3] = q1[3], clear(q1)) : (q2[1] = q1[1], q2[2] = q1[2], q2[3] = q1[3], clear(q1));
      }
      function to_seq(q) {
        function aux(c, param) {
          if (!c)
            return 0;
          var x2 = c[1], next = c[2];
          return [0, x2, function(_c_) {
            return aux(next, _c_);
          }];
        }
        var _a_ = q[2];
        return function(_b_) {
          return aux(_a_, _b_);
        };
      }
      function add_seq(q, i) {
        return caml_call2(Stdlib_Seq[4], function(x2) {
          return add(x2, q);
        }, i);
      }
      function of_seq(g) {
        var q = create(0);
        add_seq(q, g);
        return q;
      }
      var Stdlib_Queue = [
        0,
        Empty,
        create,
        add,
        add,
        take,
        take_opt,
        take,
        peek,
        peek_opt,
        peek,
        clear,
        copy,
        is_empty,
        length,
        iter,
        fold,
        transfer,
        to_seq,
        add_seq,
        of_seq
      ];
      runtime.caml_register_global(2, Stdlib_Queue, "Stdlib__Queue");
      return;
    })(globalThis);
    (function(globalThis2) {
      "use strict";
      var runtime = globalThis2.jsoo_runtime, caml_blit_string2 = runtime.caml_blit_string, caml_bswap162 = runtime.caml_bswap16, caml_bytes_get2 = runtime.caml_bytes_get, caml_bytes_set2 = runtime.caml_bytes_set, caml_bytes_set162 = runtime.caml_bytes_set16, caml_bytes_set322 = runtime.caml_bytes_set32, caml_bytes_set642 = runtime.caml_bytes_set64, caml_bytes_unsafe_set2 = runtime.caml_bytes_unsafe_set, caml_create_bytes2 = runtime.caml_create_bytes, caml_int32_bswap2 = runtime.caml_int32_bswap, caml_int64_bswap2 = runtime.caml_int64_bswap, caml_maybe_attach_backtrace2 = runtime.caml_maybe_attach_backtrace, caml_ml_bytes_length2 = runtime.caml_ml_bytes_length, caml_ml_string_length2 = runtime.caml_ml_string_length, caml_string_get2 = runtime.caml_string_get;
      function caml_call1(f, a0) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 1 ? f(a0) : runtime.caml_call_gen(f, [a0]);
      }
      function caml_call2(f, a0, a1) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 2 ? f(a0, a1) : runtime.caml_call_gen(f, [a0, a1]);
      }
      function caml_call3(f, a0, a1, a2) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 3 ? f(a0, a1, a2) : runtime.caml_call_gen(f, [a0, a1, a2]);
      }
      function caml_call4(f, a0, a1, a2, a3) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 4 ? f(a0, a1, a2, a3) : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
      }
      function caml_call5(f, a0, a1, a2, a3, a4) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 5 ? f(a0, a1, a2, a3, a4) : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
      }
      var undef = void 0, global_data = runtime.caml_get_global_data(), Stdlib_Bytes = global_data.Stdlib__Bytes, Stdlib_Sys = global_data.Stdlib__Sys, Stdlib_Seq = global_data.Stdlib__Seq, Stdlib = global_data.Stdlib, Stdlib_String = global_data.Stdlib__String, Assert_failure = global_data.Assert_failure, cst_Buffer_sub = "Buffer.sub", cst_Buffer_blit = "Buffer.blit", cst_Buffer_nth = "Buffer.nth", cst_Buffer_add_cannot_grow_buf = "Buffer.add: cannot grow buffer";
      function create(n) {
        var n$0 = 1 <= n ? n : 1, n$1 = Stdlib_Sys[12] < n$0 ? Stdlib_Sys[12] : n$0, s2 = caml_create_bytes2(n$1);
        return [0, [0, s2, n$1], 0, s2];
      }
      function contents(b) {
        return caml_call3(Stdlib_Bytes[8], b[1][1], 0, b[2]);
      }
      function to_bytes(b) {
        return caml_call3(Stdlib_Bytes[7], b[1][1], 0, b[2]);
      }
      function sub(b, ofs, len) {
        if (0 <= ofs && 0 <= len && (b[2] - len | 0) >= ofs)
          return caml_call3(Stdlib_Bytes[8], b[1][1], ofs, len);
        return caml_call1(Stdlib[1], cst_Buffer_sub);
      }
      function blit(src, srcoff, dst, dstoff, len) {
        if (0 <= len && 0 <= srcoff && (src[2] - len | 0) >= srcoff && 0 <= dstoff && (caml_ml_bytes_length2(dst) - len | 0) >= dstoff)
          return caml_call5(Stdlib_Bytes[11], src[1][1], srcoff, dst, dstoff, len);
        return caml_call1(Stdlib[1], cst_Buffer_blit);
      }
      function nth(b, ofs) {
        var position = b[2], match = b[1], length2 = match[2], buffer = match[1];
        if (0 <= ofs && position > ofs && length2 >= position)
          return runtime.caml_bytes_unsafe_get(buffer, ofs);
        return caml_call1(Stdlib[1], cst_Buffer_nth);
      }
      function length(b) {
        return b[2];
      }
      function clear(b) {
        b[2] = 0;
        return 0;
      }
      function reset(b) {
        b[2] = 0;
        var inner = [0, b[3], caml_ml_bytes_length2(b[3])];
        b[1] = inner;
        return 0;
      }
      function resize(b, more) {
        var old_pos = b[2], old_len = b[1][2], new_len = [0, old_len];
        for (; ; ) {
          if (new_len[1] >= (old_pos + more | 0))
            break;
          new_len[1] = 2 * new_len[1] | 0;
        }
        if (Stdlib_Sys[12] < new_len[1])
          if ((old_pos + more | 0) <= Stdlib_Sys[12])
            new_len[1] = Stdlib_Sys[12];
          else
            caml_call1(Stdlib[2], cst_Buffer_add_cannot_grow_buf);
        var new_buffer = caml_create_bytes2(new_len[1]);
        caml_call5(Stdlib_Bytes[11], b[1][1], 0, new_buffer, 0, b[2]);
        b[1] = [0, new_buffer, new_len[1]];
        return;
      }
      function add_char(b, c) {
        var pos = b[2], match = b[1], length2 = match[2], buffer = match[1];
        if (length2 <= pos) {
          resize(b, 1);
          caml_bytes_set2(b[1][1], b[2], c);
        } else
          caml_bytes_unsafe_set2(buffer, pos, c);
        b[2] = pos + 1 | 0;
        return 0;
      }
      var uchar_utf_8_byte_length_max = 4, uchar_utf_16_byte_length_max = 4, cst_Buffer_add_substring_add_s = "Buffer.add_substring/add_subbytes", cst_Buffer_add_channel = "Buffer.add_channel", _a_ = [0, "buffer.ml", 220, 9], cst_Buffer_truncate = "Buffer.truncate";
      function add_utf_8_uchar(b, u) {
        for (; ; ) {
          var pos = b[2];
          if (b[1][2] <= pos)
            resize(b, uchar_utf_8_byte_length_max);
          var n = caml_call3(Stdlib_Bytes[51], b[1][1], pos, u);
          if (0 !== n) {
            b[2] = pos + n | 0;
            return 0;
          }
          resize(b, uchar_utf_8_byte_length_max);
        }
      }
      function add_utf_16be_uchar(b, u) {
        for (; ; ) {
          var pos = b[2];
          if (b[1][2] <= pos)
            resize(b, uchar_utf_16_byte_length_max);
          var n = caml_call3(Stdlib_Bytes[54], b[1][1], pos, u);
          if (0 !== n) {
            b[2] = pos + n | 0;
            return 0;
          }
          resize(b, uchar_utf_16_byte_length_max);
        }
      }
      function add_utf_16le_uchar(b, u) {
        for (; ; ) {
          var pos = b[2];
          if (b[1][2] <= pos)
            resize(b, uchar_utf_16_byte_length_max);
          var n = caml_call3(Stdlib_Bytes[57], b[1][1], pos, u);
          if (0 !== n) {
            b[2] = pos + n | 0;
            return 0;
          }
          resize(b, uchar_utf_16_byte_length_max);
        }
      }
      function add_substring(b, s2, offset, len) {
        var _q_ = offset < 0 ? 1 : 0;
        if (_q_)
          var _r_ = _q_;
        else
          var _s_ = len < 0 ? 1 : 0, _r_ = _s_ || ((caml_ml_string_length2(s2) - len | 0) < offset ? 1 : 0);
        if (_r_)
          caml_call1(Stdlib[1], cst_Buffer_add_substring_add_s);
        var position = b[2], match = b[1], length2 = match[2], buffer = match[1], new_position = position + len | 0;
        if (length2 < new_position) {
          resize(b, len);
          caml_call5(Stdlib_Bytes[12], s2, offset, b[1][1], b[2], len);
        } else
          caml_blit_string2(s2, offset, buffer, position, len);
        b[2] = new_position;
        return 0;
      }
      function add_subbytes(b, s2, offset, len) {
        return add_substring(b, caml_call1(Stdlib_Bytes[44], s2), offset, len);
      }
      function add_string(b, s2) {
        var len = caml_ml_string_length2(s2), position = b[2], match = b[1], length2 = match[2], buffer = match[1], new_position = position + len | 0;
        if (length2 < new_position) {
          resize(b, len);
          caml_call5(Stdlib_Bytes[12], s2, 0, b[1][1], b[2], len);
        } else
          caml_blit_string2(s2, 0, buffer, position, len);
        b[2] = new_position;
        return 0;
      }
      function add_bytes(b, s2) {
        return add_string(b, caml_call1(Stdlib_Bytes[44], s2));
      }
      function add_buffer(b, bs) {
        return add_subbytes(b, bs[1][1], 0, bs[2]);
      }
      function add_channel(b, ic, to_read$1) {
        var _o_ = to_read$1 < 0 ? 1 : 0, _p_ = _o_ || (Stdlib_Sys[12] < to_read$1 ? 1 : 0);
        if (_p_)
          caml_call1(Stdlib[1], cst_Buffer_add_channel);
        if (b[1][2] < (b[2] + to_read$1 | 0))
          resize(b, to_read$1);
        var ofs$1 = b[2], buf = b[1][1], already_read = 0, ofs = ofs$1, to_read = to_read$1;
        for (; ; ) {
          if (0 !== to_read) {
            var r = caml_call4(Stdlib[84], ic, buf, ofs, to_read);
            if (0 !== r) {
              var already_read$0 = already_read + r | 0, ofs$0 = ofs + r | 0, to_read$0 = to_read - r | 0, already_read = already_read$0, ofs = ofs$0, to_read = to_read$0;
              continue;
            }
          }
          b[2] = b[2] + already_read | 0;
          if (already_read < to_read$1)
            throw caml_maybe_attach_backtrace2(Stdlib[12], 1);
          return 0;
        }
      }
      function output_buffer(oc, b) {
        return caml_call4(Stdlib[68], oc, b[1][1], 0, b[2]);
      }
      function add_substitute(b, f, s2) {
        var lim$1 = caml_ml_string_length2(s2), previous = 32, i$4 = 0;
        for (; ; ) {
          if (i$4 >= lim$1) {
            var _n_ = 92 === previous ? 1 : 0;
            return _n_ ? add_char(b, previous) : _n_;
          }
          var previous$0 = caml_string_get2(s2, i$4);
          if (36 === previous$0)
            if (92 === previous) {
              add_char(b, previous$0);
              var i$5 = i$4 + 1 | 0, previous = 32, i$4 = i$5;
            } else {
              var start$0 = i$4 + 1 | 0;
              if (lim$1 <= start$0)
                throw caml_maybe_attach_backtrace2(Stdlib[8], 1);
              var opening = caml_string_get2(s2, start$0);
              a: {
                if (40 !== opening && 123 !== opening) {
                  var start = start$0 + 1 | 0, lim$0 = caml_ml_string_length2(s2);
                  b: {
                    c: {
                      d: {
                        var i$2 = start;
                        for (; ; ) {
                          if (lim$0 <= i$2)
                            break c;
                          var match = caml_string_get2(s2, i$2);
                          if (91 <= match) {
                            if (97 <= match) {
                              if (123 <= match)
                                break d;
                            } else if (95 !== match)
                              break d;
                          } else if (58 <= match) {
                            if (65 > match)
                              break;
                          } else if (48 > match)
                            break d;
                          var i$3 = i$2 + 1 | 0, i$2 = i$3;
                        }
                      }
                      var stop$0 = i$2;
                      break b;
                    }
                    var stop$0 = lim$0;
                  }
                  var match$0 = [
                    0,
                    caml_call3(Stdlib_String[16], s2, start$0, stop$0 - start$0 | 0),
                    stop$0
                  ];
                  break a;
                }
                var new_start = start$0 + 1 | 0, k$2 = 0;
                if (40 === opening)
                  var closing = 41;
                else {
                  if (123 !== opening)
                    throw caml_maybe_attach_backtrace2([0, Assert_failure, _a_], 1);
                  var closing = 125;
                }
                var lim = caml_ml_string_length2(s2), k = k$2, stop = new_start;
                for (; ; ) {
                  if (lim <= stop)
                    throw caml_maybe_attach_backtrace2(Stdlib[8], 1);
                  if (caml_string_get2(s2, stop) === opening)
                    var i = stop + 1 | 0, k$0 = k + 1 | 0, k = k$0, stop = i;
                  else if (caml_string_get2(s2, stop) === closing) {
                    if (0 === k)
                      break;
                    var i$0 = stop + 1 | 0, k$1 = k - 1 | 0, k = k$1, stop = i$0;
                  } else
                    var i$1 = stop + 1 | 0, stop = i$1;
                }
                var match$0 = [
                  0,
                  caml_call3(Stdlib_String[16], s2, new_start, (stop - start$0 | 0) - 1 | 0),
                  stop + 1 | 0
                ];
              }
              var next_i = match$0[2], ident = match$0[1];
              add_string(b, caml_call1(f, ident));
              var previous = 32, i$4 = next_i;
            }
          else if (92 === previous) {
            add_char(b, 92);
            add_char(b, previous$0);
            var i$6 = i$4 + 1 | 0, previous = 32, i$4 = i$6;
          } else if (92 === previous$0)
            var i$7 = i$4 + 1 | 0, previous = previous$0, i$4 = i$7;
          else {
            add_char(b, previous$0);
            var i$8 = i$4 + 1 | 0, previous = previous$0, i$4 = i$8;
          }
        }
      }
      function truncate(b, len) {
        if (0 <= len && b[2] >= len) {
          b[2] = len;
          return 0;
        }
        return caml_call1(Stdlib[1], cst_Buffer_truncate);
      }
      function to_seq(b) {
        function aux(i, param) {
          if (b[2] <= i)
            return 0;
          var x2 = caml_bytes_get2(b[1][1], i), _l_ = i + 1 | 0;
          return [0, x2, function(_m_) {
            return aux(_l_, _m_);
          }];
        }
        var _j_ = 0;
        return function(_k_) {
          return aux(_j_, _k_);
        };
      }
      function to_seqi(b) {
        function aux(i, param) {
          if (b[2] <= i)
            return 0;
          var x2 = caml_bytes_get2(b[1][1], i), _h_ = i + 1 | 0;
          return [0, [0, i, x2], function(_i_) {
            return aux(_h_, _i_);
          }];
        }
        var _f_ = 0;
        return function(_g_) {
          return aux(_f_, _g_);
        };
      }
      function add_seq(b, seq) {
        return caml_call2(Stdlib_Seq[4], function(_e_) {
          return add_char(b, _e_);
        }, seq);
      }
      function of_seq(i) {
        var b = create(32);
        add_seq(b, i);
        return b;
      }
      function add_int8(b, x2) {
        var position = b[2], match = b[1], length2 = match[2], buffer = match[1], new_position = position + 1 | 0;
        if (length2 < new_position) {
          resize(b, 1);
          caml_bytes_set2(b[1][1], b[2], x2);
        } else
          caml_bytes_unsafe_set2(buffer, position, x2);
        b[2] = new_position;
        return 0;
      }
      function add_int16_ne(b, x2) {
        var position = b[2], match = b[1], length2 = match[2], buffer = match[1], new_position = position + 2 | 0;
        if (length2 < new_position) {
          resize(b, 2);
          caml_bytes_set162(b[1][1], b[2], x2);
        } else
          caml_bytes_set162(buffer, position, x2);
        b[2] = new_position;
        return 0;
      }
      function add_int32_ne(b, x2) {
        var position = b[2], match = b[1], length2 = match[2], buffer = match[1], new_position = position + 4 | 0;
        if (length2 < new_position) {
          resize(b, 4);
          caml_bytes_set322(b[1][1], b[2], x2);
        } else
          caml_bytes_set322(buffer, position, x2);
        b[2] = new_position;
        return 0;
      }
      function add_int64_ne(b, x2) {
        var position = b[2], match = b[1], length2 = match[2], buffer = match[1], new_position = position + 8 | 0;
        if (length2 < new_position) {
          resize(b, 8);
          caml_bytes_set642(b[1][1], b[2], x2);
        } else
          caml_bytes_set642(buffer, position, x2);
        b[2] = new_position;
        return 0;
      }
      function add_int16_le(b, x2) {
        var _d_ = Stdlib_Sys[11] ? caml_bswap162(x2) : x2;
        return add_int16_ne(b, _d_);
      }
      function add_int16_be(b, x2) {
        var x$0 = Stdlib_Sys[11] ? x2 : caml_bswap162(x2);
        return add_int16_ne(b, x$0);
      }
      function add_int32_le(b, x2) {
        var _c_ = Stdlib_Sys[11] ? caml_int32_bswap2(x2) : x2;
        return add_int32_ne(b, _c_);
      }
      function add_int32_be(b, x2) {
        var x$0 = Stdlib_Sys[11] ? x2 : caml_int32_bswap2(x2);
        return add_int32_ne(b, x$0);
      }
      function add_int64_le(b, x2) {
        var _b_ = Stdlib_Sys[11] ? caml_int64_bswap2(x2) : x2;
        return add_int64_ne(b, _b_);
      }
      function add_int64_be(b, x2) {
        var x$0 = Stdlib_Sys[11] ? x2 : caml_int64_bswap2(x2);
        return add_int64_ne(b, x$0);
      }
      var Stdlib_Buffer = [
        0,
        create,
        contents,
        to_bytes,
        sub,
        blit,
        nth,
        length,
        clear,
        reset,
        output_buffer,
        truncate,
        add_char,
        add_utf_8_uchar,
        add_utf_16le_uchar,
        add_utf_16be_uchar,
        add_string,
        add_bytes,
        add_substring,
        add_subbytes,
        add_substitute,
        add_buffer,
        add_channel,
        to_seq,
        to_seqi,
        add_seq,
        of_seq,
        add_int8,
        add_int8,
        add_int16_ne,
        add_int16_be,
        add_int16_le,
        add_int16_ne,
        add_int16_be,
        add_int16_le,
        add_int32_ne,
        add_int32_be,
        add_int32_le,
        add_int64_ne,
        add_int64_be,
        add_int64_le
      ];
      runtime.caml_register_global(14, Stdlib_Buffer, "Stdlib__Buffer");
      return;
    })(globalThis);
    (function(globalThis2) {
      "use strict";
      var runtime = globalThis2.jsoo_runtime, caml_maybe_attach_backtrace2 = runtime.caml_maybe_attach_backtrace, caml_ml_mutex_lock2 = runtime.caml_ml_mutex_lock, caml_ml_mutex_unlock2 = runtime.caml_ml_mutex_unlock, caml_wrap_exception2 = runtime.caml_wrap_exception;
      function caml_call1(f, a0) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 1 ? f(a0) : runtime.caml_call_gen(f, [a0]);
      }
      function protect(m, f) {
        caml_ml_mutex_lock2(m);
        try {
          var x2 = caml_call1(f, 0);
        } catch (e$0) {
          var e = caml_wrap_exception2(e$0);
          caml_ml_mutex_unlock2(m);
          throw caml_maybe_attach_backtrace2(e, 0);
        }
        caml_ml_mutex_unlock2(m);
        return x2;
      }
      var Stdlib_Mutex = [
        0,
        runtime.caml_ml_mutex_new,
        caml_ml_mutex_lock2,
        runtime.caml_ml_mutex_try_lock,
        caml_ml_mutex_unlock2,
        protect
      ];
      runtime.caml_register_global(0, Stdlib_Mutex, "Stdlib__Mutex");
      return;
    })(globalThis);
    (function(globalThis2) {
      "use strict";
      var runtime = globalThis2.jsoo_runtime, Stdlib_Condition = [
        0,
        runtime.caml_ml_condition_new,
        runtime.caml_ml_condition_wait,
        runtime.caml_ml_condition_signal,
        runtime.caml_ml_condition_broadcast
      ];
      runtime.caml_register_global(0, Stdlib_Condition, "Stdlib__Condition");
      return;
    })(globalThis);
    (function(globalThis2) {
      "use strict";
      var runtime = globalThis2.jsoo_runtime, caml_check_bound2 = runtime.caml_check_bound, caml_domain_dls_set2 = runtime.caml_domain_dls_set, caml_make_vect2 = runtime.caml_make_vect, caml_maybe_attach_backtrace2 = runtime.caml_maybe_attach_backtrace, caml_ml_domain_id2 = runtime.caml_ml_domain_id, caml_wrap_exception2 = runtime.caml_wrap_exception;
      function caml_call1(f, a0) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 1 ? f(a0) : runtime.caml_call_gen(f, [a0]);
      }
      function caml_call2(f, a0, a1) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 2 ? f(a0, a1) : runtime.caml_call_gen(f, [a0, a1]);
      }
      function caml_call3(f, a0, a1, a2) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 3 ? f(a0, a1, a2) : runtime.caml_call_gen(f, [a0, a1, a2]);
      }
      function caml_call5(f, a0, a1, a2, a3, a4) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 5 ? f(a0, a1, a2, a3, a4) : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
      }
      var undef = void 0, global_data = runtime.caml_get_global_data(), Stdlib_Mutex = global_data.Stdlib__Mutex, Stdlib_Condition = global_data.Stdlib__Condition, Stdlib = global_data.Stdlib, Stdlib_Atomic = global_data.Stdlib__Atomic, Stdlib_List = global_data.Stdlib__List, Stdlib_Array = global_data.Stdlib__Array;
      function cpu_relax(param) {
        return runtime.caml_ml_domain_cpu_relax(0);
      }
      var unique_value = [0, 0];
      function create_dls(param) {
        var st = caml_make_vect2(8, unique_value);
        caml_domain_dls_set2(st);
        return;
      }
      create_dls(0);
      var key_counter = caml_call1(Stdlib_Atomic[1], 0), parent_keys = caml_call1(Stdlib_Atomic[1], 0);
      function new_key(split_from_parent, init_orphan) {
        var idx = caml_call2(Stdlib_Atomic[6], key_counter, 1), k = [0, idx, init_orphan];
        if (split_from_parent) {
          var split = split_from_parent[1], ki = [0, k, split];
          for (; ; ) {
            var l = caml_call1(Stdlib_Atomic[2], parent_keys);
            if (!(1 - caml_call3(Stdlib_Atomic[5], parent_keys, l, [0, ki, l])))
              break;
          }
        }
        return k;
      }
      function maybe_grow(idx) {
        var st = runtime.caml_domain_dls_get(0), sz = st.length - 1;
        if (idx < sz)
          return st;
        var new_sz = sz;
        for (; ; ) {
          if (idx < new_sz) {
            var new_st = caml_make_vect2(new_sz, unique_value);
            caml_call5(Stdlib_Array[8], st, 0, new_st, 0, sz);
            caml_domain_dls_set2(new_st);
            return new_st;
          }
          var s2 = 2 * new_sz | 0, new_sz = s2;
        }
      }
      function set(param, x2) {
        var idx = param[1], st = maybe_grow(idx);
        caml_check_bound2(st, idx)[1 + idx] = x2;
        return 0;
      }
      function get(param) {
        var init = param[2], idx = param[1], st = maybe_grow(idx), v = caml_check_bound2(st, idx)[1 + idx];
        if (v !== unique_value)
          return v;
        var v$0 = caml_call1(init, 0);
        caml_check_bound2(st, idx)[1 + idx] = v$0;
        return v$0;
      }
      function get_id(param) {
        var domain = param[1];
        return domain;
      }
      function self2(param) {
        return caml_ml_domain_id2(0);
      }
      function is_main_domain(param) {
        return 0 === caml_ml_domain_id2(0) ? 1 : 0;
      }
      var first_domain_spawned = caml_call1(Stdlib_Atomic[1], 0), first_spawn_function = [0, function(param) {
        return;
      }], cst_first_domain_already_spawn = "first domain already spawned";
      function before_first_spawn(f) {
        if (caml_call1(Stdlib_Atomic[2], first_domain_spawned))
          throw caml_maybe_attach_backtrace2([0, Stdlib[6], cst_first_domain_already_spawn], 1);
        var old_f = first_spawn_function[1];
        function new_f(param) {
          caml_call1(old_f, 0);
          return caml_call1(f, 0);
        }
        first_spawn_function[1] = new_f;
        return 0;
      }
      var at_exit_key = new_key(0, function(param, _c_) {
        return 0;
      });
      function at_exit(f) {
        var old_exit = get(at_exit_key);
        function new_exit(param) {
          caml_call1(f, 0);
          return caml_call1(old_exit, 0);
        }
        return set(at_exit_key, new_exit);
      }
      function do_at_exit(param) {
        var f = get(at_exit_key);
        return caml_call1(f, 0);
      }
      Stdlib[104][1] = do_at_exit;
      var cst_internal_error_Am_I_alread = "internal error: Am I already finished?";
      function spawn(f) {
        if (1 - caml_call1(Stdlib_Atomic[2], first_domain_spawned)) {
          caml_call2(Stdlib_Atomic[3], first_domain_spawned, 1);
          caml_call1(first_spawn_function[1], 0);
          first_spawn_function[1] = function(param) {
            return 0;
          };
        }
        var _a_ = caml_call1(Stdlib_Atomic[2], parent_keys), pk = caml_call2(
          Stdlib_List[20],
          function(param) {
            var split = param[2], k = param[1], idx = k[1];
            return [0, idx, caml_call1(split, get(k))];
          },
          _a_
        ), term_mutex = caml_call1(Stdlib_Mutex[1], 0), term_condition = caml_call1(Stdlib_Condition[1], 0), term_state = [0, 0];
        function body(param) {
          a: {
            try {
              create_dls(0);
              caml_call2(
                Stdlib_List[18],
                function(param2) {
                  var v = param2[2], idx = param2[1], st = maybe_grow(idx);
                  caml_check_bound2(st, idx)[1 + idx] = v;
                  return 0;
                },
                pk
              );
              var res = caml_call1(f, 0);
            } catch (ex$02) {
              var ex = caml_wrap_exception2(ex$02), result = [1, ex];
              break a;
            }
            var result = [0, res];
          }
          try {
            do_at_exit(0);
            var result$0 = result;
          } catch (ex2) {
            var ex$0 = caml_wrap_exception2(ex2), _b_ = 0 === result[0] ? [1, ex$0] : result, result$0 = _b_;
          }
          caml_call1(Stdlib_Mutex[2], term_mutex);
          return term_state[1] ? caml_call1(Stdlib[2], cst_internal_error_Am_I_alread) : (term_state[1] = [0, result$0], caml_call1(Stdlib_Condition[4], term_condition));
        }
        return [
          0,
          runtime.caml_domain_spawn(body, term_mutex),
          term_mutex,
          term_condition,
          term_state
        ];
      }
      function join(param) {
        var term_state = param[4], term_condition = param[3], term_mutex = param[2];
        caml_call1(Stdlib_Mutex[2], term_mutex);
        for (; ; ) {
          var match = term_state[1];
          if (match) {
            var res = match[1];
            caml_call1(Stdlib_Mutex[4], term_mutex);
            if (0 === res[0]) {
              var x2 = res[1];
              return x2;
            }
            var ex = res[1];
            throw caml_maybe_attach_backtrace2(ex, 1);
          }
          caml_call2(Stdlib_Condition[2], term_condition, term_mutex);
        }
      }
      var recommended_domain_count = runtime.caml_recommended_domain_count, Stdlib_Domain = [
        0,
        spawn,
        join,
        get_id,
        self2,
        before_first_spawn,
        at_exit,
        cpu_relax,
        is_main_domain,
        recommended_domain_count,
        [0, new_key, get, set]
      ];
      runtime.caml_register_global(8, Stdlib_Domain, "Stdlib__Domain");
      return;
    })(globalThis);
    (function(globalThis2) {
      "use strict";
      var runtime = globalThis2.jsoo_runtime, cst$43 = "", cst_and = " and ", cst_Li$3 = "%Li", cst_i$3 = "%i", cst_li$3 = "%li", cst_ni$3 = "%ni", cst_u$0 = "%u", cst$42 = "' '", cst$41 = "'#'", cst$39 = "'*'", cst$40 = "'+'", cst$44 = ", ", cst_0$3 = "0", cst_at_character_number = ": at character number ", cst$38 = "@[", cst$37 = "@{", cst_bad_input_format_type_mism = "bad input: format type mismatch between ", cst_bad_input_format_type_mism$0 = "bad input: format type mismatch between %S and %S", cst_camlinternalFormat_ml = "camlinternalFormat.ml", cst_invalid_format = "invalid format ", cst_precision$3 = "precision", caml_blit_string2 = runtime.caml_blit_string, caml_bytes_set2 = runtime.caml_bytes_set, caml_create_bytes2 = runtime.caml_create_bytes, caml_format_float2 = runtime.caml_format_float, caml_format_int2 = runtime.caml_format_int, caml_maybe_attach_backtrace2 = runtime.caml_maybe_attach_backtrace, caml_ml_string_length2 = runtime.caml_ml_string_length, caml_notequal2 = runtime.caml_notequal, caml_string_get2 = runtime.caml_string_get, caml_string_notequal2 = runtime.caml_string_notequal, caml_string_unsafe_get2 = runtime.caml_string_unsafe_get, caml_trampoline2 = runtime.caml_trampoline, caml_trampoline_return2 = runtime.caml_trampoline_return, caml_wrap_exception2 = runtime.caml_wrap_exception;
      function caml_call1(f, a0) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 1 ? f(a0) : runtime.caml_call_gen(f, [a0]);
      }
      function caml_call2(f, a0, a1) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 2 ? f(a0, a1) : runtime.caml_call_gen(f, [a0, a1]);
      }
      function caml_call3(f, a0, a1, a2) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 3 ? f(a0, a1, a2) : runtime.caml_call_gen(f, [a0, a1, a2]);
      }
      function caml_call4(f, a0, a1, a2, a3) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 4 ? f(a0, a1, a2, a3) : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
      }
      function caml_call5(f, a0, a1, a2, a3, a4) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 5 ? f(a0, a1, a2, a3, a4) : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
      }
      var undef = void 0, global_data = runtime.caml_get_global_data(), cst$9 = "%{", cst$10 = "%}", cst$11 = "%(", cst$12 = "%)", cst$13 = "%?", cst$18 = cst$37, cst$19 = cst$38, cst$20 = cst$37, cst$21 = cst$38, cst$22 = cst$37, cst$23 = cst$38, cst$26 = cst$39, cst$24 = "'-'", cst$25 = cst$39, cst$27 = cst$40, cst$28 = cst$41, cst$29 = cst$42, cst$30 = cst$40, cst$31 = "'_'", sub_format = [0, 0, cst$43], formatting_lit = [0, "@;", 1, 0], cst$35 = cst$41, cst$32 = cst$40, cst$33 = cst$40, cst$34 = cst$42, cst$36 = cst$40, cst$17 = ".", cst$14 = "%!", cst$15 = cst$37, cst$16 = cst$38, cst$8 = "%%", cst$0 = "@]", cst$1 = "@}", cst$2 = "@?", cst$3 = "@\n", cst$4 = "@.", cst$5 = "@@", cst$6 = "@%", cst$7 = "@", cst = ".*", Assert_failure = global_data.Assert_failure, CamlinternalFormatBasics = global_data.CamlinternalFormatBasics, Stdlib = global_data.Stdlib, Stdlib_Buffer = global_data.Stdlib__Buffer, Stdlib_String = global_data.Stdlib__String, Stdlib_Sys = global_data.Stdlib__Sys, Stdlib_Char = global_data.Stdlib__Char, Stdlib_Bytes = global_data.Stdlib__Bytes, Stdlib_Int = global_data.Stdlib__Int, _a_ = [0, 0, 0], cst_c = "%c", cst_s = "%s", cst_i = cst_i$3, cst_li = cst_li$3, cst_ni = cst_ni$3, cst_Li = cst_Li$3, cst_f = "%f", cst_B = "%B", cst_a = "%a", cst_t = "%t", cst_r = "%r", cst_r$0 = "%_r", cst_0c = "0c", _b_ = [0, cst_camlinternalFormat_ml, 850, 23], _c_ = [0, cst_camlinternalFormat_ml, 837, 26], _d_ = [0, cst_camlinternalFormat_ml, 847, 28], _e_ = [0, cst_camlinternalFormat_ml, 815, 21], _f_ = [0, cst_camlinternalFormat_ml, 819, 21], _g_ = [0, cst_camlinternalFormat_ml, 823, 19], _h_ = [0, cst_camlinternalFormat_ml, 827, 22], _i_ = [0, cst_camlinternalFormat_ml, 832, 30], _j_ = [0, cst_camlinternalFormat_ml, 851, 23], _k_ = [0, cst_camlinternalFormat_ml, 836, 26], _l_ = [0, cst_camlinternalFormat_ml, 846, 28], _m_ = [0, cst_camlinternalFormat_ml, 814, 21], _n_ = [0, cst_camlinternalFormat_ml, 818, 21], _o_ = [0, cst_camlinternalFormat_ml, 822, 19], _p_ = [0, cst_camlinternalFormat_ml, 826, 22], _q_ = [0, cst_camlinternalFormat_ml, 831, 30];
      function create_char_set(param) {
        return caml_call2(Stdlib_Bytes[1], 32, 0);
      }
      function add_in_char_set(char_set, c) {
        var str_ind = c >>> 3 | 0, mask = 1 << (c & 7), _dt_ = runtime.caml_bytes_get(char_set, str_ind) | mask;
        return caml_bytes_set2(char_set, str_ind, caml_call1(Stdlib[29], _dt_));
      }
      function freeze_char_set(char_set) {
        return caml_call1(Stdlib_Bytes[6], char_set);
      }
      function rev_char_set(char_set) {
        var char_set$0 = create_char_set(0), i = 0;
        for (; ; ) {
          var _dr_ = caml_string_get2(char_set, i) ^ 255;
          caml_bytes_set2(char_set$0, i, caml_call1(Stdlib[29], _dr_));
          var _ds_ = i + 1 | 0;
          if (31 === i)
            return caml_call1(Stdlib_Bytes[44], char_set$0);
          var i = _ds_;
        }
      }
      function is_in_char_set(char_set, c) {
        var str_ind = c >>> 3 | 0, mask = 1 << (c & 7);
        return 0 !== (caml_string_get2(char_set, str_ind) & mask) ? 1 : 0;
      }
      function pad_of_pad_opt(pad_opt) {
        if (!pad_opt)
          return 0;
        var width = pad_opt[1];
        return [0, 1, width];
      }
      function param_format_of_ignored_format(ign, fmt) {
        if (typeof ign === "number")
          switch (ign) {
            case 0:
              return [0, [0, fmt]];
            case 1:
              return [0, [1, fmt]];
            case 2:
              return [0, [19, fmt]];
            default:
              return [0, [22, fmt]];
          }
        switch (ign[0]) {
          case 0:
            var pad_opt = ign[1];
            return [0, [2, pad_of_pad_opt(pad_opt), fmt]];
          case 1:
            var pad_opt$0 = ign[1];
            return [0, [3, pad_of_pad_opt(pad_opt$0), fmt]];
          case 2:
            var pad_opt$1 = ign[2], iconv = ign[1];
            return [0, [4, iconv, pad_of_pad_opt(pad_opt$1), 0, fmt]];
          case 3:
            var pad_opt$2 = ign[2], iconv$0 = ign[1];
            return [0, [5, iconv$0, pad_of_pad_opt(pad_opt$2), 0, fmt]];
          case 4:
            var pad_opt$3 = ign[2], iconv$1 = ign[1];
            return [0, [6, iconv$1, pad_of_pad_opt(pad_opt$3), 0, fmt]];
          case 5:
            var pad_opt$4 = ign[2], iconv$2 = ign[1];
            return [0, [7, iconv$2, pad_of_pad_opt(pad_opt$4), 0, fmt]];
          case 6:
            var prec_opt = ign[2], pad_opt$5 = ign[1];
            if (prec_opt)
              var ndec = prec_opt[1], _dq_ = [0, ndec];
            else
              var _dq_ = 0;
            return [0, [8, _a_, pad_of_pad_opt(pad_opt$5), _dq_, fmt]];
          case 7:
            var pad_opt$6 = ign[1];
            return [0, [9, pad_of_pad_opt(pad_opt$6), fmt]];
          case 8:
            var fmtty = ign[2], pad_opt$7 = ign[1];
            return [0, [13, pad_opt$7, fmtty, fmt]];
          case 9:
            var fmtty$0 = ign[2], pad_opt$8 = ign[1];
            return [0, [14, pad_opt$8, fmtty$0, fmt]];
          case 10:
            var char_set = ign[2], width_opt = ign[1];
            return [0, [20, width_opt, char_set, fmt]];
          default:
            var counter = ign[1];
            return [0, [21, counter, fmt]];
        }
      }
      function default_float_precision(fconv) {
        return 5 === fconv[2] ? 12 : -6;
      }
      function buffer_create(init_size) {
        return [0, 0, caml_create_bytes2(init_size)];
      }
      function buffer_check_size(buf, overhead) {
        var len = runtime.caml_ml_bytes_length(buf[2]), min_len = buf[1] + overhead | 0;
        if (len < min_len) {
          var new_len = caml_call2(Stdlib_Int[11], len * 2 | 0, min_len), new_str = caml_create_bytes2(new_len);
          caml_call5(Stdlib_Bytes[11], buf[2], 0, new_str, 0, len);
          buf[2] = new_str;
        }
        return;
      }
      function buffer_add_char(buf, c) {
        buffer_check_size(buf, 1);
        caml_bytes_set2(buf[2], buf[1], c);
        buf[1] = buf[1] + 1 | 0;
        return;
      }
      function buffer_add_string(buf, s2) {
        var str_len = caml_ml_string_length2(s2);
        buffer_check_size(buf, str_len);
        caml_call5(Stdlib_String[6], s2, 0, buf[2], buf[1], str_len);
        buf[1] = buf[1] + str_len | 0;
        return;
      }
      function buffer_contents(buf) {
        return caml_call3(Stdlib_Bytes[8], buf[2], 0, buf[1]);
      }
      function char_of_iconv(iconv) {
        switch (iconv) {
          case 6:
          case 7:
            return 120;
          case 8:
          case 9:
            return 88;
          case 10:
          case 11:
            return 111;
          case 12:
          case 15:
            return 117;
          case 0:
          case 1:
          case 2:
          case 13:
            return 100;
          default:
            return 105;
        }
      }
      function char_of_fconv(opt, fconv) {
        if (opt)
          var sth = opt[1], cF = sth;
        else
          var cF = 70;
        switch (fconv[2]) {
          case 0:
            return 102;
          case 1:
            return 101;
          case 2:
            return 69;
          case 3:
            return 103;
          case 4:
            return 71;
          case 5:
            return cF;
          case 6:
            return 104;
          case 7:
            return 72;
          default:
            return 70;
        }
      }
      function bprint_padty(buf, padty) {
        switch (padty) {
          case 0:
            return buffer_add_char(buf, 45);
          case 1:
            return;
          default:
            return buffer_add_char(buf, 48);
        }
      }
      function bprint_ignored_flag(buf, ign_flag) {
        return ign_flag ? buffer_add_char(buf, 95) : ign_flag;
      }
      function bprint_pad_opt(buf, pad_opt) {
        if (!pad_opt)
          return;
        var width = pad_opt[1];
        return buffer_add_string(buf, caml_call1(Stdlib_Int[12], width));
      }
      function bprint_padding(buf, pad) {
        if (typeof pad === "number")
          return;
        if (0 === pad[0]) {
          var n = pad[2], padty = pad[1];
          bprint_padty(buf, padty);
          return buffer_add_string(buf, caml_call1(Stdlib_Int[12], n));
        }
        var padty$0 = pad[1];
        bprint_padty(buf, padty$0);
        return buffer_add_char(buf, 42);
      }
      function bprint_precision(buf, prec) {
        if (typeof prec !== "number") {
          var n = prec[1];
          buffer_add_char(buf, 46);
          return buffer_add_string(buf, caml_call1(Stdlib_Int[12], n));
        }
        if (prec)
          return buffer_add_string(buf, cst);
        return;
      }
      function bprint_iconv_flag(buf, iconv) {
        switch (iconv) {
          case 1:
          case 4:
            return buffer_add_char(buf, 43);
          case 2:
          case 5:
            return buffer_add_char(buf, 32);
          case 7:
          case 9:
          case 11:
          case 13:
          case 14:
          case 15:
            return buffer_add_char(buf, 35);
          default:
            return;
        }
      }
      function bprint_altint_fmt(buf, ign_flag, iconv, pad, prec, c) {
        buffer_add_char(buf, 37);
        bprint_ignored_flag(buf, ign_flag);
        bprint_iconv_flag(buf, iconv);
        bprint_padding(buf, pad);
        bprint_precision(buf, prec);
        buffer_add_char(buf, c);
        return buffer_add_char(buf, char_of_iconv(iconv));
      }
      function bprint_fconv_flag(buf, fconv) {
        switch (fconv[1]) {
          case 0:
            break;
          case 1:
            buffer_add_char(buf, 43);
            break;
          default:
            buffer_add_char(buf, 32);
        }
        if (8 <= fconv[2])
          return buffer_add_char(buf, 35);
        return;
      }
      function string_of_formatting_lit(formatting_lit2) {
        if (typeof formatting_lit2 === "number")
          switch (formatting_lit2) {
            case 0:
              return cst$0;
            case 1:
              return cst$1;
            case 2:
              return cst$2;
            case 3:
              return cst$3;
            case 4:
              return cst$4;
            case 5:
              return cst$5;
            default:
              return cst$6;
          }
        switch (formatting_lit2[0]) {
          case 0:
            var str = formatting_lit2[1];
            return str;
          case 1:
            var str$0 = formatting_lit2[1];
            return str$0;
          default:
            var c = formatting_lit2[1], _dp_ = caml_call2(Stdlib_String[1], 1, c);
            return caml_call2(Stdlib[28], cst$7, _dp_);
        }
      }
      function bprint_char_literal(buf, chr) {
        return 37 === chr ? buffer_add_string(buf, cst$8) : buffer_add_char(buf, chr);
      }
      function bprint_string_literal(buf, str) {
        var _dn_ = caml_ml_string_length2(str) - 1 | 0, _dm_ = 0;
        if (_dn_ >= 0) {
          var i = _dm_;
          for (; ; ) {
            bprint_char_literal(buf, caml_string_get2(str, i));
            var _do_ = i + 1 | 0;
            if (_dn_ === i)
              break;
            var i = _do_;
          }
        }
        return;
      }
      function bprint_fmtty(buf, fmtty) {
        var fmtty$0 = fmtty;
        for (; ; ) {
          if (typeof fmtty$0 === "number")
            return;
          switch (fmtty$0[0]) {
            case 0:
              var fmtty$1 = fmtty$0[1];
              buffer_add_string(buf, cst_c);
              var fmtty$0 = fmtty$1;
              break;
            case 1:
              var fmtty$2 = fmtty$0[1];
              buffer_add_string(buf, cst_s);
              var fmtty$0 = fmtty$2;
              break;
            case 2:
              var fmtty$3 = fmtty$0[1];
              buffer_add_string(buf, cst_i);
              var fmtty$0 = fmtty$3;
              break;
            case 3:
              var fmtty$4 = fmtty$0[1];
              buffer_add_string(buf, cst_li);
              var fmtty$0 = fmtty$4;
              break;
            case 4:
              var fmtty$5 = fmtty$0[1];
              buffer_add_string(buf, cst_ni);
              var fmtty$0 = fmtty$5;
              break;
            case 5:
              var fmtty$6 = fmtty$0[1];
              buffer_add_string(buf, cst_Li);
              var fmtty$0 = fmtty$6;
              break;
            case 6:
              var fmtty$7 = fmtty$0[1];
              buffer_add_string(buf, cst_f);
              var fmtty$0 = fmtty$7;
              break;
            case 7:
              var fmtty$8 = fmtty$0[1];
              buffer_add_string(buf, cst_B);
              var fmtty$0 = fmtty$8;
              break;
            case 8:
              var fmtty$9 = fmtty$0[2], sub_fmtty = fmtty$0[1];
              buffer_add_string(buf, cst$9);
              bprint_fmtty(buf, sub_fmtty);
              buffer_add_string(buf, cst$10);
              var fmtty$0 = fmtty$9;
              break;
            case 9:
              var fmtty$10 = fmtty$0[3], sub_fmtty$0 = fmtty$0[1];
              buffer_add_string(buf, cst$11);
              bprint_fmtty(buf, sub_fmtty$0);
              buffer_add_string(buf, cst$12);
              var fmtty$0 = fmtty$10;
              break;
            case 10:
              var fmtty$11 = fmtty$0[1];
              buffer_add_string(buf, cst_a);
              var fmtty$0 = fmtty$11;
              break;
            case 11:
              var fmtty$12 = fmtty$0[1];
              buffer_add_string(buf, cst_t);
              var fmtty$0 = fmtty$12;
              break;
            case 12:
              var fmtty$13 = fmtty$0[1];
              buffer_add_string(buf, cst$13);
              var fmtty$0 = fmtty$13;
              break;
            case 13:
              var fmtty$14 = fmtty$0[1];
              buffer_add_string(buf, cst_r);
              var fmtty$0 = fmtty$14;
              break;
            default:
              var fmtty$15 = fmtty$0[1];
              buffer_add_string(buf, cst_r$0);
              var fmtty$0 = fmtty$15;
          }
        }
      }
      function int_of_custom_arity(param) {
        if (!param)
          return 0;
        var x2 = param[1];
        return 1 + int_of_custom_arity(x2) | 0;
      }
      function string_of_fmt(fmt) {
        var buf = buffer_create(16);
        function fmtiter(fmt2, ign_flag) {
          var fmt$0 = fmt2, ign_flag$0 = ign_flag;
          for (; ; ) {
            if (typeof fmt$0 === "number")
              return;
            switch (fmt$0[0]) {
              case 0:
                var rest = fmt$0[1];
                buffer_add_char(buf, 37);
                bprint_ignored_flag(buf, ign_flag$0);
                buffer_add_char(buf, 99);
                var fmt$0 = rest, ign_flag$0 = 0;
                break;
              case 1:
                var rest$0 = fmt$0[1];
                buffer_add_char(buf, 37);
                bprint_ignored_flag(buf, ign_flag$0);
                buffer_add_char(buf, 67);
                var fmt$0 = rest$0, ign_flag$0 = 0;
                break;
              case 2:
                var rest$1 = fmt$0[2], pad = fmt$0[1];
                buffer_add_char(buf, 37);
                bprint_ignored_flag(buf, ign_flag$0);
                bprint_padding(buf, pad);
                buffer_add_char(buf, 115);
                var fmt$0 = rest$1, ign_flag$0 = 0;
                break;
              case 3:
                var rest$2 = fmt$0[2], pad$0 = fmt$0[1];
                buffer_add_char(buf, 37);
                bprint_ignored_flag(buf, ign_flag$0);
                bprint_padding(buf, pad$0);
                buffer_add_char(buf, 83);
                var fmt$0 = rest$2, ign_flag$0 = 0;
                break;
              case 4:
                var rest$3 = fmt$0[4], prec = fmt$0[3], pad$1 = fmt$0[2], iconv = fmt$0[1];
                buffer_add_char(buf, 37);
                bprint_ignored_flag(buf, ign_flag$0);
                bprint_iconv_flag(buf, iconv);
                bprint_padding(buf, pad$1);
                bprint_precision(buf, prec);
                buffer_add_char(buf, char_of_iconv(iconv));
                var fmt$0 = rest$3, ign_flag$0 = 0;
                break;
              case 5:
                var rest$4 = fmt$0[4], prec$0 = fmt$0[3], pad$2 = fmt$0[2], iconv$0 = fmt$0[1];
                bprint_altint_fmt(buf, ign_flag$0, iconv$0, pad$2, prec$0, 108);
                var fmt$0 = rest$4, ign_flag$0 = 0;
                break;
              case 6:
                var rest$5 = fmt$0[4], prec$1 = fmt$0[3], pad$3 = fmt$0[2], iconv$1 = fmt$0[1];
                bprint_altint_fmt(buf, ign_flag$0, iconv$1, pad$3, prec$1, 110);
                var fmt$0 = rest$5, ign_flag$0 = 0;
                break;
              case 7:
                var rest$6 = fmt$0[4], prec$2 = fmt$0[3], pad$4 = fmt$0[2], iconv$2 = fmt$0[1];
                bprint_altint_fmt(buf, ign_flag$0, iconv$2, pad$4, prec$2, 76);
                var fmt$0 = rest$6, ign_flag$0 = 0;
                break;
              case 8:
                var rest$7 = fmt$0[4], prec$3 = fmt$0[3], pad$5 = fmt$0[2], fconv = fmt$0[1];
                buffer_add_char(buf, 37);
                bprint_ignored_flag(buf, ign_flag$0);
                bprint_fconv_flag(buf, fconv);
                bprint_padding(buf, pad$5);
                bprint_precision(buf, prec$3);
                buffer_add_char(buf, char_of_fconv(0, fconv));
                var fmt$0 = rest$7, ign_flag$0 = 0;
                break;
              case 9:
                var rest$8 = fmt$0[2], pad$6 = fmt$0[1];
                buffer_add_char(buf, 37);
                bprint_ignored_flag(buf, ign_flag$0);
                bprint_padding(buf, pad$6);
                buffer_add_char(buf, 66);
                var fmt$0 = rest$8, ign_flag$0 = 0;
                break;
              case 10:
                var rest$9 = fmt$0[1];
                buffer_add_string(buf, cst$14);
                var fmt$0 = rest$9;
                break;
              case 11:
                var rest$10 = fmt$0[2], str = fmt$0[1];
                bprint_string_literal(buf, str);
                var fmt$0 = rest$10;
                break;
              case 12:
                var rest$11 = fmt$0[2], chr = fmt$0[1];
                bprint_char_literal(buf, chr);
                var fmt$0 = rest$11;
                break;
              case 13:
                var rest$12 = fmt$0[3], fmtty = fmt$0[2], pad_opt = fmt$0[1];
                buffer_add_char(buf, 37);
                bprint_ignored_flag(buf, ign_flag$0);
                bprint_pad_opt(buf, pad_opt);
                buffer_add_char(buf, 123);
                bprint_fmtty(buf, fmtty);
                buffer_add_char(buf, 37);
                buffer_add_char(buf, 125);
                var fmt$0 = rest$12, ign_flag$0 = 0;
                break;
              case 14:
                var rest$13 = fmt$0[3], fmtty$0 = fmt$0[2], pad_opt$0 = fmt$0[1];
                buffer_add_char(buf, 37);
                bprint_ignored_flag(buf, ign_flag$0);
                bprint_pad_opt(buf, pad_opt$0);
                buffer_add_char(buf, 40);
                bprint_fmtty(buf, fmtty$0);
                buffer_add_char(buf, 37);
                buffer_add_char(buf, 41);
                var fmt$0 = rest$13, ign_flag$0 = 0;
                break;
              case 15:
                var rest$14 = fmt$0[1];
                buffer_add_char(buf, 37);
                bprint_ignored_flag(buf, ign_flag$0);
                buffer_add_char(buf, 97);
                var fmt$0 = rest$14, ign_flag$0 = 0;
                break;
              case 16:
                var rest$15 = fmt$0[1];
                buffer_add_char(buf, 37);
                bprint_ignored_flag(buf, ign_flag$0);
                buffer_add_char(buf, 116);
                var fmt$0 = rest$15, ign_flag$0 = 0;
                break;
              case 17:
                var rest$16 = fmt$0[2], fmting_lit = fmt$0[1];
                bprint_string_literal(buf, string_of_formatting_lit(fmting_lit));
                var fmt$0 = rest$16;
                break;
              case 18:
                var rest$17 = fmt$0[2], fmting_gen = fmt$0[1];
                if (0 === fmting_gen[0]) {
                  var str$0 = fmting_gen[1][2];
                  buffer_add_string(buf, cst$15);
                  buffer_add_string(buf, str$0);
                } else {
                  var str$1 = fmting_gen[1][2];
                  buffer_add_string(buf, cst$16);
                  buffer_add_string(buf, str$1);
                }
                var fmt$0 = rest$17;
                break;
              case 19:
                var rest$18 = fmt$0[1];
                buffer_add_char(buf, 37);
                bprint_ignored_flag(buf, ign_flag$0);
                buffer_add_char(buf, 114);
                var fmt$0 = rest$18, ign_flag$0 = 0;
                break;
              case 20:
                var rest$19 = fmt$0[3], char_set = fmt$0[2], width_opt = fmt$0[1];
                buffer_add_char(buf, 37);
                bprint_ignored_flag(buf, ign_flag$0);
                bprint_pad_opt(buf, width_opt);
                var print_char = function(buf2, i2) {
                  var c = caml_call1(Stdlib[29], i2);
                  return 37 === c ? (buffer_add_char(buf2, 37), buffer_add_char(buf2, 37)) : 64 === c ? (buffer_add_char(buf2, 37), buffer_add_char(buf2, 64)) : buffer_add_char(buf2, c);
                };
                buffer_add_char(buf, 91);
                var set = is_in_char_set(char_set, 0) ? (buffer_add_char(buf, 94), rev_char_set(char_set)) : char_set;
                let set$0 = set;
                var is_alone = function(c) {
                  var after = caml_call1(Stdlib_Char[1], c + 1 | 0), before = caml_call1(Stdlib_Char[1], c - 1 | 0), _di_ = is_in_char_set(set$0, c);
                  if (_di_)
                    var _dj_ = is_in_char_set(set$0, before), _dk_ = _dj_ ? is_in_char_set(set$0, after) : _dj_, _dl_ = 1 - _dk_;
                  else
                    var _dl_ = _di_;
                  return _dl_;
                };
                if (is_alone(93))
                  buffer_add_char(buf, 93);
                a:
                  b: {
                    c: {
                      d: {
                        var i = 1;
                        for (; ; ) {
                          if (i >= 256)
                            break;
                          if (is_in_char_set(set, caml_call1(Stdlib[29], i))) {
                            var switcher = caml_call1(Stdlib[29], i) - 45 | 0;
                            if (48 < switcher >>> 0) {
                              if (210 <= switcher)
                                break d;
                            } else if (46 < switcher - 1 >>> 0) {
                              var i$2 = i + 1 | 0, i = i$2;
                              continue;
                            }
                            var i$1 = i + 1 | 0;
                            if (is_in_char_set(set, caml_call1(Stdlib[29], i$1))) {
                              var switcher$0 = caml_call1(Stdlib[29], i$1) - 45 | 0;
                              if (48 < switcher$0 >>> 0) {
                                if (210 <= switcher$0)
                                  break c;
                              } else if (46 < switcher$0 - 1 >>> 0 && !is_in_char_set(set, caml_call1(Stdlib[29], i$1 + 1 | 0))) {
                                print_char(buf, i$1 - 1 | 0);
                                var i$5 = i$1 + 1 | 0, i = i$5;
                                continue;
                              }
                              if (is_in_char_set(set, caml_call1(Stdlib[29], i$1 + 1 | 0))) {
                                var j = i$1 + 2 | 0, i$3 = i$1 - 1 | 0, j$0 = j;
                                for (; ; ) {
                                  if (256 === j$0)
                                    break;
                                  if (!is_in_char_set(set, caml_call1(Stdlib[29], j$0)))
                                    break;
                                  var j$1 = j$0 + 1 | 0, j$0 = j$1;
                                }
                                print_char(buf, i$3);
                                print_char(buf, 45);
                                print_char(buf, j$0 - 1 | 0);
                                if (j$0 >= 256)
                                  break b;
                                var i$7 = j$0 + 1 | 0, i = i$7;
                              } else {
                                print_char(buf, i$1 - 1 | 0);
                                print_char(buf, i$1);
                                var i$4 = i$1 + 2 | 0, i = i$4;
                              }
                            } else {
                              print_char(buf, i$1 - 1 | 0);
                              var i$6 = i$1 + 1 | 0, i = i$6;
                            }
                          } else
                            var i$0 = i + 1 | 0, i = i$0;
                        }
                        break a;
                      }
                      print_char(buf, 255);
                      break a;
                    }
                    print_char(buf, 254);
                    print_char(buf, 255);
                    break a;
                  }
                if (is_alone(45))
                  buffer_add_char(buf, 45);
                buffer_add_char(buf, 93);
                var fmt$0 = rest$19, ign_flag$0 = 0;
                break;
              case 21:
                var rest$20 = fmt$0[2], counter = fmt$0[1];
                buffer_add_char(buf, 37);
                bprint_ignored_flag(buf, ign_flag$0);
                switch (counter) {
                  case 0:
                    var _de_ = 108;
                    break;
                  case 1:
                    var _de_ = 110;
                    break;
                  default:
                    var _de_ = 78;
                }
                buffer_add_char(buf, _de_);
                var fmt$0 = rest$20, ign_flag$0 = 0;
                break;
              case 22:
                var rest$21 = fmt$0[1];
                buffer_add_char(buf, 37);
                bprint_ignored_flag(buf, ign_flag$0);
                bprint_string_literal(buf, cst_0c);
                var fmt$0 = rest$21, ign_flag$0 = 0;
                break;
              case 23:
                var rest$22 = fmt$0[2], ign = fmt$0[1], fmt$1 = param_format_of_ignored_format(ign, rest$22)[1], fmt$0 = fmt$1, ign_flag$0 = 1;
                break;
              default:
                var rest$23 = fmt$0[3], arity = fmt$0[1], _dg_ = int_of_custom_arity(arity), _df_ = 1;
                if (_dg_ >= 1) {
                  var i$8 = _df_;
                  for (; ; ) {
                    buffer_add_char(buf, 37);
                    bprint_ignored_flag(buf, ign_flag$0);
                    buffer_add_char(buf, 63);
                    var _dh_ = i$8 + 1 | 0;
                    if (_dg_ === i$8)
                      break;
                    var i$8 = _dh_;
                  }
                }
                var fmt$0 = rest$23, ign_flag$0 = 0;
            }
          }
        }
        fmtiter(fmt, 0);
        return buffer_contents(buf);
      }
      function symm(param) {
        if (typeof param === "number")
          return 0;
        switch (param[0]) {
          case 0:
            var rest = param[1];
            return [0, symm(rest)];
          case 1:
            var rest$0 = param[1];
            return [1, symm(rest$0)];
          case 2:
            var rest$1 = param[1];
            return [2, symm(rest$1)];
          case 3:
            var rest$2 = param[1];
            return [3, symm(rest$2)];
          case 4:
            var rest$3 = param[1];
            return [4, symm(rest$3)];
          case 5:
            var rest$4 = param[1];
            return [5, symm(rest$4)];
          case 6:
            var rest$5 = param[1];
            return [6, symm(rest$5)];
          case 7:
            var rest$6 = param[1];
            return [7, symm(rest$6)];
          case 8:
            var rest$7 = param[2], ty = param[1];
            return [8, ty, symm(rest$7)];
          case 9:
            var rest$8 = param[3], ty2 = param[2], ty1 = param[1];
            return [9, ty2, ty1, symm(rest$8)];
          case 10:
            var rest$9 = param[1];
            return [10, symm(rest$9)];
          case 11:
            var rest$10 = param[1];
            return [11, symm(rest$10)];
          case 12:
            var rest$11 = param[1];
            return [12, symm(rest$11)];
          case 13:
            var rest$12 = param[1];
            return [13, symm(rest$12)];
          default:
            var rest$13 = param[1];
            return [14, symm(rest$13)];
        }
      }
      function fmtty_rel_det(param) {
        if (typeof param === "number")
          return [
            0,
            function(param2) {
              return;
            },
            function(param2) {
              return;
            },
            function(param2) {
              return;
            },
            function(param2) {
              return;
            }
          ];
        switch (param[0]) {
          case 0:
            var rest = param[1], match = fmtty_rel_det(rest), de = match[4], ed = match[3], af = match[2], fa = match[1];
            return [
              0,
              function(param2) {
                fa(0);
                return;
              },
              function(param2) {
                af(0);
                return;
              },
              ed,
              de
            ];
          case 1:
            var rest$0 = param[1], match$0 = fmtty_rel_det(rest$0), de$0 = match$0[4], ed$0 = match$0[3], af$0 = match$0[2], fa$0 = match$0[1];
            return [
              0,
              function(param2) {
                fa$0(0);
                return;
              },
              function(param2) {
                af$0(0);
                return;
              },
              ed$0,
              de$0
            ];
          case 2:
            var rest$1 = param[1], match$1 = fmtty_rel_det(rest$1), de$1 = match$1[4], ed$1 = match$1[3], af$1 = match$1[2], fa$1 = match$1[1];
            return [
              0,
              function(param2) {
                fa$1(0);
                return;
              },
              function(param2) {
                af$1(0);
                return;
              },
              ed$1,
              de$1
            ];
          case 3:
            var rest$2 = param[1], match$2 = fmtty_rel_det(rest$2), de$2 = match$2[4], ed$2 = match$2[3], af$2 = match$2[2], fa$2 = match$2[1];
            return [
              0,
              function(param2) {
                fa$2(0);
                return;
              },
              function(param2) {
                af$2(0);
                return;
              },
              ed$2,
              de$2
            ];
          case 4:
            var rest$3 = param[1], match$3 = fmtty_rel_det(rest$3), de$3 = match$3[4], ed$3 = match$3[3], af$3 = match$3[2], fa$3 = match$3[1];
            return [
              0,
              function(param2) {
                fa$3(0);
                return;
              },
              function(param2) {
                af$3(0);
                return;
              },
              ed$3,
              de$3
            ];
          case 5:
            var rest$4 = param[1], match$4 = fmtty_rel_det(rest$4), de$4 = match$4[4], ed$4 = match$4[3], af$4 = match$4[2], fa$4 = match$4[1];
            return [
              0,
              function(param2) {
                fa$4(0);
                return;
              },
              function(param2) {
                af$4(0);
                return;
              },
              ed$4,
              de$4
            ];
          case 6:
            var rest$5 = param[1], match$5 = fmtty_rel_det(rest$5), de$5 = match$5[4], ed$5 = match$5[3], af$5 = match$5[2], fa$5 = match$5[1];
            return [
              0,
              function(param2) {
                fa$5(0);
                return;
              },
              function(param2) {
                af$5(0);
                return;
              },
              ed$5,
              de$5
            ];
          case 7:
            var rest$6 = param[1], match$6 = fmtty_rel_det(rest$6), de$6 = match$6[4], ed$6 = match$6[3], af$6 = match$6[2], fa$6 = match$6[1];
            return [
              0,
              function(param2) {
                fa$6(0);
                return;
              },
              function(param2) {
                af$6(0);
                return;
              },
              ed$6,
              de$6
            ];
          case 8:
            var rest$7 = param[2], match$7 = fmtty_rel_det(rest$7), de$7 = match$7[4], ed$7 = match$7[3], af$7 = match$7[2], fa$7 = match$7[1];
            return [
              0,
              function(param2) {
                fa$7(0);
                return;
              },
              function(param2) {
                af$7(0);
                return;
              },
              ed$7,
              de$7
            ];
          case 9:
            var rest$8 = param[3], ty2 = param[2], ty1 = param[1], match$8 = fmtty_rel_det(rest$8), de$8 = match$8[4], ed$8 = match$8[3], af$8 = match$8[2], fa$8 = match$8[1], ty = trans(symm(ty1), ty2), match$9 = fmtty_rel_det(ty), jd = match$9[4], dj = match$9[3], ga = match$9[2], ag = match$9[1];
            return [
              0,
              function(param2) {
                fa$8(0);
                ag(0);
                return;
              },
              function(param2) {
                ga(0);
                af$8(0);
                return;
              },
              function(param2) {
                ed$8(0);
                dj(0);
                return;
              },
              function(param2) {
                jd(0);
                de$8(0);
                return;
              }
            ];
          case 10:
            var rest$9 = param[1], match$10 = fmtty_rel_det(rest$9), de$9 = match$10[4], ed$9 = match$10[3], af$9 = match$10[2], fa$9 = match$10[1];
            return [
              0,
              function(param2) {
                fa$9(0);
                return;
              },
              function(param2) {
                af$9(0);
                return;
              },
              ed$9,
              de$9
            ];
          case 11:
            var rest$10 = param[1], match$11 = fmtty_rel_det(rest$10), de$10 = match$11[4], ed$10 = match$11[3], af$10 = match$11[2], fa$10 = match$11[1];
            return [
              0,
              function(param2) {
                fa$10(0);
                return;
              },
              function(param2) {
                af$10(0);
                return;
              },
              ed$10,
              de$10
            ];
          case 12:
            var rest$11 = param[1], match$12 = fmtty_rel_det(rest$11), de$11 = match$12[4], ed$11 = match$12[3], af$11 = match$12[2], fa$11 = match$12[1];
            return [
              0,
              function(param2) {
                fa$11(0);
                return;
              },
              function(param2) {
                af$11(0);
                return;
              },
              ed$11,
              de$11
            ];
          case 13:
            var rest$12 = param[1], match$13 = fmtty_rel_det(rest$12), de$12 = match$13[4], ed$12 = match$13[3], af$12 = match$13[2], fa$12 = match$13[1];
            return [
              0,
              function(param2) {
                fa$12(0);
                return;
              },
              function(param2) {
                af$12(0);
                return;
              },
              function(param2) {
                ed$12(0);
                return;
              },
              function(param2) {
                de$12(0);
                return;
              }
            ];
          default:
            var rest$13 = param[1], match$14 = fmtty_rel_det(rest$13), de$13 = match$14[4], ed$13 = match$14[3], af$13 = match$14[2], fa$13 = match$14[1];
            return [
              0,
              function(param2) {
                fa$13(0);
                return;
              },
              function(param2) {
                af$13(0);
                return;
              },
              function(param2) {
                ed$13(0);
                return;
              },
              function(param2) {
                de$13(0);
                return;
              }
            ];
        }
      }
      function trans(ty1, ty2) {
        a: {
          b: {
            c: {
              d: {
                e: {
                  f: {
                    g: {
                      if (typeof ty1 !== "number") {
                        switch (ty1[0]) {
                          case 0:
                            var rest1 = ty1[1];
                            if (typeof ty2 !== "number")
                              switch (ty2[0]) {
                                case 0:
                                  var rest2 = ty2[1];
                                  return [0, trans(rest1, rest2)];
                                case 8:
                                  break f;
                                case 9:
                                  break g;
                                case 10:
                                  break a;
                                case 11:
                                  break b;
                                case 12:
                                  break c;
                                case 13:
                                  break d;
                                case 14:
                                  break e;
                              }
                            break;
                          case 1:
                            var rest1$0 = ty1[1];
                            if (typeof ty2 !== "number")
                              switch (ty2[0]) {
                                case 1:
                                  var rest2$0 = ty2[1];
                                  return [1, trans(rest1$0, rest2$0)];
                                case 8:
                                  break f;
                                case 9:
                                  break g;
                                case 10:
                                  break a;
                                case 11:
                                  break b;
                                case 12:
                                  break c;
                                case 13:
                                  break d;
                                case 14:
                                  break e;
                              }
                            break;
                          case 2:
                            var rest1$1 = ty1[1];
                            if (typeof ty2 !== "number")
                              switch (ty2[0]) {
                                case 2:
                                  var rest2$1 = ty2[1];
                                  return [2, trans(rest1$1, rest2$1)];
                                case 8:
                                  break f;
                                case 9:
                                  break g;
                                case 10:
                                  break a;
                                case 11:
                                  break b;
                                case 12:
                                  break c;
                                case 13:
                                  break d;
                                case 14:
                                  break e;
                              }
                            break;
                          case 3:
                            var rest1$2 = ty1[1];
                            if (typeof ty2 !== "number")
                              switch (ty2[0]) {
                                case 3:
                                  var rest2$2 = ty2[1];
                                  return [3, trans(rest1$2, rest2$2)];
                                case 8:
                                  break f;
                                case 9:
                                  break g;
                                case 10:
                                  break a;
                                case 11:
                                  break b;
                                case 12:
                                  break c;
                                case 13:
                                  break d;
                                case 14:
                                  break e;
                              }
                            break;
                          case 4:
                            var rest1$3 = ty1[1];
                            if (typeof ty2 !== "number")
                              switch (ty2[0]) {
                                case 4:
                                  var rest2$3 = ty2[1];
                                  return [4, trans(rest1$3, rest2$3)];
                                case 8:
                                  break f;
                                case 9:
                                  break g;
                                case 10:
                                  break a;
                                case 11:
                                  break b;
                                case 12:
                                  break c;
                                case 13:
                                  break d;
                                case 14:
                                  break e;
                              }
                            break;
                          case 5:
                            var rest1$4 = ty1[1];
                            if (typeof ty2 !== "number")
                              switch (ty2[0]) {
                                case 5:
                                  var rest2$4 = ty2[1];
                                  return [5, trans(rest1$4, rest2$4)];
                                case 8:
                                  break f;
                                case 9:
                                  break g;
                                case 10:
                                  break a;
                                case 11:
                                  break b;
                                case 12:
                                  break c;
                                case 13:
                                  break d;
                                case 14:
                                  break e;
                              }
                            break;
                          case 6:
                            var rest1$5 = ty1[1];
                            if (typeof ty2 !== "number")
                              switch (ty2[0]) {
                                case 6:
                                  var rest2$5 = ty2[1];
                                  return [6, trans(rest1$5, rest2$5)];
                                case 8:
                                  break f;
                                case 9:
                                  break g;
                                case 10:
                                  break a;
                                case 11:
                                  break b;
                                case 12:
                                  break c;
                                case 13:
                                  break d;
                                case 14:
                                  break e;
                              }
                            break;
                          case 7:
                            var rest1$6 = ty1[1];
                            if (typeof ty2 !== "number")
                              switch (ty2[0]) {
                                case 7:
                                  var rest2$6 = ty2[1];
                                  return [7, trans(rest1$6, rest2$6)];
                                case 8:
                                  break f;
                                case 9:
                                  break g;
                                case 10:
                                  break a;
                                case 11:
                                  break b;
                                case 12:
                                  break c;
                                case 13:
                                  break d;
                                case 14:
                                  break e;
                              }
                            break;
                          case 8:
                            var rest1$7 = ty1[2], ty1$0 = ty1[1];
                            if (typeof ty2 !== "number")
                              switch (ty2[0]) {
                                case 8:
                                  var rest2$7 = ty2[2], ty2$0 = ty2[1], _dd_ = trans(rest1$7, rest2$7);
                                  return [8, trans(ty1$0, ty2$0), _dd_];
                                case 10:
                                  break a;
                                case 11:
                                  break b;
                                case 12:
                                  break c;
                                case 13:
                                  break d;
                                case 14:
                                  break e;
                              }
                            throw caml_maybe_attach_backtrace2([0, Assert_failure, _k_], 1);
                          case 9:
                            var rest1$8 = ty1[3], ty12 = ty1[2], ty11 = ty1[1];
                            if (typeof ty2 !== "number")
                              switch (ty2[0]) {
                                case 8:
                                  break f;
                                case 9:
                                  var rest2$8 = ty2[3], ty22 = ty2[2], ty21 = ty2[1], ty = trans(symm(ty12), ty21), match = fmtty_rel_det(ty), f4 = match[4], f2 = match[2];
                                  f2(0);
                                  f4(0);
                                  return [9, ty11, ty22, trans(rest1$8, rest2$8)];
                                case 10:
                                  break a;
                                case 11:
                                  break b;
                                case 12:
                                  break c;
                                case 13:
                                  break d;
                                case 14:
                                  break e;
                              }
                            throw caml_maybe_attach_backtrace2([0, Assert_failure, _l_], 1);
                          case 10:
                            var rest1$9 = ty1[1];
                            if (typeof ty2 !== "number" && 10 === ty2[0]) {
                              var rest2$9 = ty2[1];
                              return [10, trans(rest1$9, rest2$9)];
                            }
                            throw caml_maybe_attach_backtrace2([0, Assert_failure, _m_], 1);
                          case 11:
                            var rest1$10 = ty1[1];
                            if (typeof ty2 !== "number")
                              switch (ty2[0]) {
                                case 10:
                                  break a;
                                case 11:
                                  var rest2$10 = ty2[1];
                                  return [11, trans(rest1$10, rest2$10)];
                              }
                            throw caml_maybe_attach_backtrace2([0, Assert_failure, _n_], 1);
                          case 12:
                            var rest1$11 = ty1[1];
                            if (typeof ty2 !== "number")
                              switch (ty2[0]) {
                                case 10:
                                  break a;
                                case 11:
                                  break b;
                                case 12:
                                  var rest2$11 = ty2[1];
                                  return [12, trans(rest1$11, rest2$11)];
                              }
                            throw caml_maybe_attach_backtrace2([0, Assert_failure, _o_], 1);
                          case 13:
                            var rest1$12 = ty1[1];
                            if (typeof ty2 !== "number")
                              switch (ty2[0]) {
                                case 10:
                                  break a;
                                case 11:
                                  break b;
                                case 12:
                                  break c;
                                case 13:
                                  var rest2$12 = ty2[1];
                                  return [13, trans(rest1$12, rest2$12)];
                              }
                            throw caml_maybe_attach_backtrace2([0, Assert_failure, _p_], 1);
                          default:
                            var rest1$13 = ty1[1];
                            if (typeof ty2 !== "number")
                              switch (ty2[0]) {
                                case 10:
                                  break a;
                                case 11:
                                  break b;
                                case 12:
                                  break c;
                                case 13:
                                  break d;
                                case 14:
                                  var rest2$13 = ty2[1];
                                  return [14, trans(rest1$13, rest2$13)];
                              }
                            throw caml_maybe_attach_backtrace2([0, Assert_failure, _q_], 1);
                        }
                        throw caml_maybe_attach_backtrace2([0, Assert_failure, _j_], 1);
                      }
                      if (typeof ty2 === "number")
                        return 0;
                      switch (ty2[0]) {
                        case 10:
                          break a;
                        case 11:
                          break b;
                        case 12:
                          break c;
                        case 13:
                          break d;
                        case 14:
                          break e;
                        case 8:
                          break f;
                        case 9:
                          break;
                        default:
                          throw caml_maybe_attach_backtrace2([0, Assert_failure, _b_], 1);
                      }
                    }
                    throw caml_maybe_attach_backtrace2([0, Assert_failure, _d_], 1);
                  }
                  throw caml_maybe_attach_backtrace2([0, Assert_failure, _c_], 1);
                }
                throw caml_maybe_attach_backtrace2([0, Assert_failure, _i_], 1);
              }
              throw caml_maybe_attach_backtrace2([0, Assert_failure, _h_], 1);
            }
            throw caml_maybe_attach_backtrace2([0, Assert_failure, _g_], 1);
          }
          throw caml_maybe_attach_backtrace2([0, Assert_failure, _f_], 1);
        }
        throw caml_maybe_attach_backtrace2([0, Assert_failure, _e_], 1);
      }
      function fmtty_of_fmt(fmtty) {
        var fmtty$0 = fmtty;
        for (; ; ) {
          if (typeof fmtty$0 === "number")
            return 0;
          switch (fmtty$0[0]) {
            case 0:
              var rest = fmtty$0[1];
              return [0, fmtty_of_fmt(rest)];
            case 1:
              var rest$0 = fmtty$0[1];
              return [0, fmtty_of_fmt(rest$0)];
            case 2:
              var rest$1 = fmtty$0[2], pad = fmtty$0[1];
              return fmtty_of_padding_fmtty(pad, [1, fmtty_of_fmt(rest$1)]);
            case 3:
              var rest$2 = fmtty$0[2], pad$0 = fmtty$0[1];
              return fmtty_of_padding_fmtty(pad$0, [1, fmtty_of_fmt(rest$2)]);
            case 4:
              var rest$3 = fmtty$0[4], prec = fmtty$0[3], pad$1 = fmtty$0[2], ty_rest = fmtty_of_fmt(rest$3), prec_ty = fmtty_of_precision_fmtty(prec, [2, ty_rest]);
              return fmtty_of_padding_fmtty(pad$1, prec_ty);
            case 5:
              var rest$4 = fmtty$0[4], prec$0 = fmtty$0[3], pad$2 = fmtty$0[2], ty_rest$0 = fmtty_of_fmt(rest$4), prec_ty$0 = fmtty_of_precision_fmtty(prec$0, [3, ty_rest$0]);
              return fmtty_of_padding_fmtty(pad$2, prec_ty$0);
            case 6:
              var rest$5 = fmtty$0[4], prec$1 = fmtty$0[3], pad$3 = fmtty$0[2], ty_rest$1 = fmtty_of_fmt(rest$5), prec_ty$1 = fmtty_of_precision_fmtty(prec$1, [4, ty_rest$1]);
              return fmtty_of_padding_fmtty(pad$3, prec_ty$1);
            case 7:
              var rest$6 = fmtty$0[4], prec$2 = fmtty$0[3], pad$4 = fmtty$0[2], ty_rest$2 = fmtty_of_fmt(rest$6), prec_ty$2 = fmtty_of_precision_fmtty(prec$2, [5, ty_rest$2]);
              return fmtty_of_padding_fmtty(pad$4, prec_ty$2);
            case 8:
              var rest$7 = fmtty$0[4], prec$3 = fmtty$0[3], pad$5 = fmtty$0[2], ty_rest$3 = fmtty_of_fmt(rest$7), prec_ty$3 = fmtty_of_precision_fmtty(prec$3, [6, ty_rest$3]);
              return fmtty_of_padding_fmtty(pad$5, prec_ty$3);
            case 9:
              var rest$8 = fmtty$0[2], pad$6 = fmtty$0[1];
              return fmtty_of_padding_fmtty(pad$6, [7, fmtty_of_fmt(rest$8)]);
            case 10:
              var fmtty$1 = fmtty$0[1], fmtty$0 = fmtty$1;
              break;
            case 11:
              var fmtty$2 = fmtty$0[2], fmtty$0 = fmtty$2;
              break;
            case 12:
              var fmtty$3 = fmtty$0[2], fmtty$0 = fmtty$3;
              break;
            case 13:
              var rest$9 = fmtty$0[3], ty = fmtty$0[2];
              return [8, ty, fmtty_of_fmt(rest$9)];
            case 14:
              var rest$10 = fmtty$0[3], ty$0 = fmtty$0[2];
              return [9, ty$0, ty$0, fmtty_of_fmt(rest$10)];
            case 15:
              var rest$11 = fmtty$0[1];
              return [10, fmtty_of_fmt(rest$11)];
            case 16:
              var rest$12 = fmtty$0[1];
              return [11, fmtty_of_fmt(rest$12)];
            case 17:
              var fmtty$4 = fmtty$0[2], fmtty$0 = fmtty$4;
              break;
            case 18:
              var rest$13 = fmtty$0[2], formatting_gen = fmtty$0[1], _da_ = fmtty_of_fmt(rest$13);
              if (0 === formatting_gen[0])
                var fmt = formatting_gen[1][1], _db_ = fmtty_of_fmt(fmt);
              else
                var fmt$0 = formatting_gen[1][1], _db_ = fmtty_of_fmt(fmt$0);
              return caml_call2(CamlinternalFormatBasics[1], _db_, _da_);
            case 19:
              var rest$14 = fmtty$0[1];
              return [13, fmtty_of_fmt(rest$14)];
            case 20:
              var rest$15 = fmtty$0[3];
              return [1, fmtty_of_fmt(rest$15)];
            case 21:
              var rest$16 = fmtty$0[2];
              return [2, fmtty_of_fmt(rest$16)];
            case 22:
              var rest$17 = fmtty$0[1];
              return [0, fmtty_of_fmt(rest$17)];
            case 23:
              var fmtty$5 = fmtty$0[2], ign = fmtty$0[1];
              if (typeof ign === "number")
                switch (ign) {
                  case 0:
                    var fmtty$0 = fmtty$5;
                    break;
                  case 1:
                    var fmtty$0 = fmtty$5;
                    break;
                  case 2:
                    return [14, fmtty_of_fmt(fmtty$5)];
                  default:
                    var fmtty$0 = fmtty$5;
                }
              else
                switch (ign[0]) {
                  case 0:
                    var fmtty$0 = fmtty$5;
                    break;
                  case 1:
                    var fmtty$0 = fmtty$5;
                    break;
                  case 2:
                    var fmtty$0 = fmtty$5;
                    break;
                  case 3:
                    var fmtty$0 = fmtty$5;
                    break;
                  case 4:
                    var fmtty$0 = fmtty$5;
                    break;
                  case 5:
                    var fmtty$0 = fmtty$5;
                    break;
                  case 6:
                    var fmtty$0 = fmtty$5;
                    break;
                  case 7:
                    var fmtty$0 = fmtty$5;
                    break;
                  case 8:
                    var fmtty$0 = fmtty$5;
                    break;
                  case 9:
                    var fmtty$6 = ign[2], _dc_ = fmtty_of_fmt(fmtty$5);
                    return caml_call2(CamlinternalFormatBasics[1], fmtty$6, _dc_);
                  case 10:
                    var fmtty$0 = fmtty$5;
                    break;
                  default:
                    var fmtty$0 = fmtty$5;
                }
              break;
            default:
              var rest$18 = fmtty$0[3], arity = fmtty$0[1];
              return fmtty_of_custom(arity, fmtty_of_fmt(rest$18));
          }
        }
      }
      function fmtty_of_custom(arity, fmtty) {
        if (!arity)
          return fmtty;
        var arity$0 = arity[1];
        return [12, fmtty_of_custom(arity$0, fmtty)];
      }
      function fmtty_of_padding_fmtty(pad, fmtty) {
        return typeof pad === "number" ? fmtty : 0 === pad[0] ? fmtty : [2, fmtty];
      }
      function fmtty_of_precision_fmtty(prec, fmtty) {
        return typeof prec === "number" ? prec ? [2, fmtty] : fmtty : fmtty;
      }
      var Type_mismatch = [248, "CamlinternalFormat.Type_mismatch", runtime.caml_fresh_oo_id(0)], cst_d = "%d", cst_d$0 = "%+d", cst_d$1 = "% d", cst_i$0 = cst_i$3, cst_i$1 = "%+i", cst_i$2 = "% i", cst_x = "%x", cst_x$0 = "%#x", cst_X = "%X", cst_X$0 = "%#X", cst_o = "%o", cst_o$0 = "%#o", cst_u = cst_u$0, cst_Ld = "%Ld", cst_Ld$0 = "%+Ld", cst_Ld$1 = "% Ld", cst_Li$0 = cst_Li$3, cst_Li$1 = "%+Li", cst_Li$2 = "% Li", cst_Lx = "%Lx", cst_Lx$0 = "%#Lx", cst_LX = "%LX", cst_LX$0 = "%#LX", cst_Lo = "%Lo", cst_Lo$0 = "%#Lo", cst_Lu = "%Lu", cst_ld = "%ld", cst_ld$0 = "%+ld", cst_ld$1 = "% ld", cst_li$0 = cst_li$3, cst_li$1 = "%+li", cst_li$2 = "% li", cst_lx = "%lx", cst_lx$0 = "%#lx", cst_lX = "%lX", cst_lX$0 = "%#lX", cst_lo = "%lo", cst_lo$0 = "%#lo", cst_lu = "%lu", cst_nd = "%nd", cst_nd$0 = "%+nd", cst_nd$1 = "% nd", cst_ni$0 = cst_ni$3, cst_ni$1 = "%+ni", cst_ni$2 = "% ni", cst_nx = "%nx", cst_nx$0 = "%#nx", cst_nX = "%nX", cst_nX$0 = "%#nX", cst_no = "%no", cst_no$0 = "%#no", cst_nu = "%nu", _r_ = [0, 103], cst_neg_infinity = "neg_infinity", cst_infinity = "infinity", cst_nan = "nan", _s_ = [0, cst_camlinternalFormat_ml, 1558, 4], cst_Printf_bad_conversion = "Printf: bad conversion %[", _t_ = [0, cst_camlinternalFormat_ml, 1626, 39], _u_ = [0, cst_camlinternalFormat_ml, 1649, 31], _v_ = [0, cst_camlinternalFormat_ml, 1650, 31], cst_Printf_bad_conversion$0 = "Printf: bad conversion %_", _w_ = [0, cst_camlinternalFormat_ml, 1830, 8], _x_ = [0, 0, 4], _y_ = [
        0,
        [11, "invalid box description ", [3, 0, 0]],
        "invalid box description %S"
      ], _z_ = [
        0,
        [
          11,
          cst_invalid_format,
          [
            3,
            0,
            [11, cst_at_character_number, [4, 0, 0, 0, [11, cst$44, [2, 0, 0]]]]
          ]
        ],
        "invalid format %S: at character number %d, %s"
      ], cst_unexpected_end_of_format = "unexpected end of format", cst_non_zero_widths_are_unsupp = "non-zero widths are unsupported for %c conversions", _A_ = [
        0,
        [
          11,
          cst_invalid_format,
          [
            3,
            0,
            [
              11,
              cst_at_character_number,
              [4, 0, 0, 0, [11, ", '", [0, [11, "' without ", [2, 0, 0]]]]]
            ]
          ]
        ],
        "invalid format %S: at character number %d, '%c' without %s"
      ], _B_ = [
        0,
        [
          11,
          cst_invalid_format,
          [
            3,
            0,
            [
              11,
              cst_at_character_number,
              [4, 0, 0, 0, [11, cst$44, [2, 0, [11, " expected, read ", [1, 0]]]]]
            ]
          ]
        ],
        "invalid format %S: at character number %d, %s expected, read %C"
      ], _C_ = [
        0,
        [
          11,
          cst_invalid_format,
          [
            3,
            0,
            [
              11,
              cst_at_character_number,
              [4, 0, 0, 0, [11, ", duplicate flag ", [1, 0]]]
            ]
          ]
        ],
        "invalid format %S: at character number %d, duplicate flag %C"
      ], cst_padding = "padding", _D_ = [0, 1, 0], cst_0 = cst_0$3, _E_ = [0, 0], cst_precision = cst_precision$3, _F_ = [1, 0], _G_ = [1, 1], cst_precision$0 = cst_precision$3, _H_ = [1, 1], cst_precision$1 = cst_precision$3, cst_0$0 = cst_0$3, _I_ = [1, 1], cst_0$1 = cst_0$3, cst_0$2 = "'0'", _J_ = [
        0,
        [
          11,
          cst_invalid_format,
          [
            3,
            0,
            [
              11,
              cst_at_character_number,
              [
                4,
                0,
                0,
                0,
                [11, ', invalid conversion "', [12, 37, [0, [12, 34, 0]]]]
              ]
            ]
          ]
        ],
        'invalid format %S: at character number %d, invalid conversion "%%%c"'
      ], _K_ = [0, 0], cst_padding$0 = "`padding'", _L_ = [0, 0], cst_precision$2 = "`precision'", _M_ = [
        0,
        [
          11,
          cst_invalid_format,
          [
            3,
            0,
            [
              11,
              cst_at_character_number,
              [
                4,
                0,
                0,
                0,
                [
                  11,
                  ", flag ",
                  [
                    1,
                    [
                      11,
                      " is only allowed after the '",
                      [12, 37, [11, "', before padding and precision", 0]]
                    ]
                  ]
                ]
              ]
            ]
          ]
        ],
        "invalid format %S: at character number %d, flag %C is only allowed after the '%%', before padding and precision"
      ], _N_ = [0, [12, 64, 0]], _O_ = [0, "@ ", 1, 0], _P_ = [0, "@,", 0, 0], _Q_ = [2, 60], _R_ = [
        0,
        [
          11,
          cst_invalid_format,
          [
            3,
            0,
            [
              11,
              ": '",
              [
                12,
                37,
                [
                  11,
                  "' alone is not accepted in character sets, use ",
                  [
                    12,
                    37,
                    [
                      12,
                      37,
                      [11, " instead at position ", [4, 0, 0, 0, [12, 46, 0]]]
                    ]
                  ]
                ]
              ]
            ]
          ]
        ],
        "invalid format %S: '%%' alone is not accepted in character sets, use %%%% instead at position %d."
      ], _S_ = [
        0,
        [
          11,
          cst_invalid_format,
          [
            3,
            0,
            [
              11,
              ": integer ",
              [4, 0, 0, 0, [11, " is greater than the limit ", [4, 0, 0, 0, 0]]]
            ]
          ]
        ],
        "invalid format %S: integer %d is greater than the limit %d"
      ], _T_2 = [0, cst_camlinternalFormat_ml, 2837, 11], cst_digit = "digit", _U_ = [
        0,
        [
          11,
          cst_invalid_format,
          [
            3,
            0,
            [
              11,
              ': unclosed sub-format, expected "',
              [12, 37, [0, [11, '" at character number ', [4, 0, 0, 0, 0]]]]
            ]
          ]
        ],
        'invalid format %S: unclosed sub-format, expected "%%%c" at character number %d'
      ], cst_character = "character ')'", cst_character$0 = "character '}'", _V_ = [0, cst_camlinternalFormat_ml, 2899, 34], _W_ = [0, cst_camlinternalFormat_ml, 2935, 28], _X_ = [0, cst_camlinternalFormat_ml, 2957, 11], _Y_ = [
        0,
        [
          11,
          cst_invalid_format,
          [
            3,
            0,
            [
              11,
              cst_at_character_number,
              [
                4,
                0,
                0,
                0,
                [
                  11,
                  cst$44,
                  [
                    2,
                    0,
                    [
                      11,
                      " is incompatible with '",
                      [0, [11, "' in sub-format ", [3, 0, 0]]]
                    ]
                  ]
                ]
              ]
            ]
          ]
        ],
        "invalid format %S: at character number %d, %s is incompatible with '%c' in sub-format %S"
      ], _Z_ = [
        0,
        [11, cst_bad_input_format_type_mism, [3, 0, [11, cst_and, [3, 0, 0]]]],
        cst_bad_input_format_type_mism$0
      ], ___ = [
        0,
        [11, cst_bad_input_format_type_mism, [3, 0, [11, cst_and, [3, 0, 0]]]],
        cst_bad_input_format_type_mism$0
      ];
      function type_padding(pad, fmtty) {
        if (typeof pad === "number")
          return [0, 0, fmtty];
        if (0 === pad[0]) {
          var w = pad[2], padty = pad[1];
          return [0, [0, padty, w], fmtty];
        }
        if (typeof fmtty !== "number" && 2 === fmtty[0]) {
          var rest = fmtty[1], padty$0 = pad[1];
          return [0, [1, padty$0], rest];
        }
        throw caml_maybe_attach_backtrace2(Type_mismatch, 1);
      }
      function type_padprec(pad, prec, fmtty) {
        var match = type_padding(pad, fmtty);
        if (typeof prec !== "number") {
          var rest$1 = match[2], pad$2 = match[1], p = prec[1];
          return [0, pad$2, [0, p], rest$1];
        }
        if (!prec) {
          var rest$0 = match[2], pad$1 = match[1];
          return [0, pad$1, 0, rest$0];
        }
        var match$0 = match[2];
        if (typeof match$0 !== "number" && 2 === match$0[0]) {
          var rest = match$0[1], pad$0 = match[1];
          return [0, pad$0, 1, rest];
        }
        throw caml_maybe_attach_backtrace2(Type_mismatch, 1);
      }
      function type_format(fmt, fmtty) {
        var _c$_ = type_format_gen(fmt, fmtty);
        if (typeof _c$_[2] !== "number")
          throw caml_maybe_attach_backtrace2(Type_mismatch, 1);
        var fmt$0 = _c$_[1];
        return fmt$0;
      }
      function type_format_gen(fmt, fmtty0) {
        if (typeof fmt === "number")
          return [0, 0, fmtty0];
        switch (fmt[0]) {
          case 0:
            if (typeof fmtty0 !== "number" && 0 === fmtty0[0]) {
              var fmtty_rest = fmtty0[1], fmt_rest = fmt[1], match = type_format_gen(fmt_rest, fmtty_rest), fmtty = match[2], fmt$0 = match[1];
              return [0, [0, fmt$0], fmtty];
            }
            break;
          case 1:
            if (typeof fmtty0 !== "number" && 0 === fmtty0[0]) {
              var fmtty_rest$0 = fmtty0[1], fmt_rest$0 = fmt[1], match$0 = type_format_gen(fmt_rest$0, fmtty_rest$0), fmtty$0 = match$0[2], fmt$1 = match$0[1];
              return [0, [1, fmt$1], fmtty$0];
            }
            break;
          case 2:
            var fmt_rest$1 = fmt[2], pad = fmt[1], match$1 = type_padding(pad, fmtty0), pad$0 = match$1[1], match$2 = match$1[2];
            if (typeof match$2 !== "number" && 1 === match$2[0]) {
              var fmtty_rest$1 = match$2[1], match$3 = type_format_gen(fmt_rest$1, fmtty_rest$1), fmtty$1 = match$3[2], fmt$2 = match$3[1];
              return [0, [2, pad$0, fmt$2], fmtty$1];
            }
            throw caml_maybe_attach_backtrace2(Type_mismatch, 1);
          case 3:
            var fmt_rest$2 = fmt[2], pad$1 = fmt[1], match$4 = type_padding(pad$1, fmtty0), pad$2 = match$4[1], match$5 = match$4[2];
            if (typeof match$5 !== "number" && 1 === match$5[0]) {
              var fmtty_rest$2 = match$5[1], match$6 = type_format_gen(fmt_rest$2, fmtty_rest$2), fmtty$2 = match$6[2], fmt$3 = match$6[1];
              return [0, [3, pad$2, fmt$3], fmtty$2];
            }
            throw caml_maybe_attach_backtrace2(Type_mismatch, 1);
          case 4:
            var fmt_rest$3 = fmt[4], prec = fmt[3], pad$3 = fmt[2], iconv = fmt[1], match$7 = type_padprec(pad$3, prec, fmtty0), pad$4 = match$7[1], match$8 = match$7[3];
            if (typeof match$8 !== "number" && 2 === match$8[0]) {
              var fmtty_rest$3 = match$8[1], prec$0 = match$7[2], match$9 = type_format_gen(fmt_rest$3, fmtty_rest$3), fmtty$3 = match$9[2], fmt$4 = match$9[1];
              return [0, [4, iconv, pad$4, prec$0, fmt$4], fmtty$3];
            }
            throw caml_maybe_attach_backtrace2(Type_mismatch, 1);
          case 5:
            var fmt_rest$4 = fmt[4], prec$1 = fmt[3], pad$5 = fmt[2], iconv$0 = fmt[1], match$10 = type_padprec(pad$5, prec$1, fmtty0), pad$6 = match$10[1], match$11 = match$10[3];
            if (typeof match$11 !== "number" && 3 === match$11[0]) {
              var fmtty_rest$4 = match$11[1], prec$2 = match$10[2], match$12 = type_format_gen(fmt_rest$4, fmtty_rest$4), fmtty$4 = match$12[2], fmt$5 = match$12[1];
              return [0, [5, iconv$0, pad$6, prec$2, fmt$5], fmtty$4];
            }
            throw caml_maybe_attach_backtrace2(Type_mismatch, 1);
          case 6:
            var fmt_rest$5 = fmt[4], prec$3 = fmt[3], pad$7 = fmt[2], iconv$1 = fmt[1], match$13 = type_padprec(pad$7, prec$3, fmtty0), pad$8 = match$13[1], match$14 = match$13[3];
            if (typeof match$14 !== "number" && 4 === match$14[0]) {
              var fmtty_rest$5 = match$14[1], prec$4 = match$13[2], match$15 = type_format_gen(fmt_rest$5, fmtty_rest$5), fmtty$5 = match$15[2], fmt$6 = match$15[1];
              return [0, [6, iconv$1, pad$8, prec$4, fmt$6], fmtty$5];
            }
            throw caml_maybe_attach_backtrace2(Type_mismatch, 1);
          case 7:
            var fmt_rest$6 = fmt[4], prec$5 = fmt[3], pad$9 = fmt[2], iconv$2 = fmt[1], match$16 = type_padprec(pad$9, prec$5, fmtty0), pad$10 = match$16[1], match$17 = match$16[3];
            if (typeof match$17 !== "number" && 5 === match$17[0]) {
              var fmtty_rest$6 = match$17[1], prec$6 = match$16[2], match$18 = type_format_gen(fmt_rest$6, fmtty_rest$6), fmtty$6 = match$18[2], fmt$7 = match$18[1];
              return [0, [7, iconv$2, pad$10, prec$6, fmt$7], fmtty$6];
            }
            throw caml_maybe_attach_backtrace2(Type_mismatch, 1);
          case 8:
            var fmt_rest$7 = fmt[4], prec$7 = fmt[3], pad$11 = fmt[2], fconv = fmt[1], match$19 = type_padprec(pad$11, prec$7, fmtty0), pad$12 = match$19[1], match$20 = match$19[3];
            if (typeof match$20 !== "number" && 6 === match$20[0]) {
              var fmtty_rest$7 = match$20[1], prec$8 = match$19[2], match$21 = type_format_gen(fmt_rest$7, fmtty_rest$7), fmtty$7 = match$21[2], fmt$8 = match$21[1];
              return [0, [8, fconv, pad$12, prec$8, fmt$8], fmtty$7];
            }
            throw caml_maybe_attach_backtrace2(Type_mismatch, 1);
          case 9:
            var fmt_rest$8 = fmt[2], pad$13 = fmt[1], match$22 = type_padding(pad$13, fmtty0), pad$14 = match$22[1], match$23 = match$22[2];
            if (typeof match$23 !== "number" && 7 === match$23[0]) {
              var fmtty_rest$8 = match$23[1], match$24 = type_format_gen(fmt_rest$8, fmtty_rest$8), fmtty$8 = match$24[2], fmt$9 = match$24[1];
              return [0, [9, pad$14, fmt$9], fmtty$8];
            }
            throw caml_maybe_attach_backtrace2(Type_mismatch, 1);
          case 10:
            var fmt_rest$9 = fmt[1], match$25 = type_format_gen(fmt_rest$9, fmtty0), fmtty$9 = match$25[2], fmt$10 = match$25[1];
            return [0, [10, fmt$10], fmtty$9];
          case 11:
            var fmt_rest$10 = fmt[2], str = fmt[1], match$26 = type_format_gen(fmt_rest$10, fmtty0), fmtty$10 = match$26[2], fmt$11 = match$26[1];
            return [0, [11, str, fmt$11], fmtty$10];
          case 12:
            var fmt_rest$11 = fmt[2], chr = fmt[1], match$27 = type_format_gen(fmt_rest$11, fmtty0), fmtty$11 = match$27[2], fmt$12 = match$27[1];
            return [0, [12, chr, fmt$12], fmtty$11];
          case 13:
            if (typeof fmtty0 !== "number" && 8 === fmtty0[0]) {
              var fmtty_rest$9 = fmtty0[2], sub_fmtty = fmtty0[1], fmt_rest$12 = fmt[3], sub_fmtty$0 = fmt[2], pad_opt = fmt[1];
              if (caml_notequal2([0, sub_fmtty$0], [0, sub_fmtty]))
                throw caml_maybe_attach_backtrace2(Type_mismatch, 1);
              var match$28 = type_format_gen(fmt_rest$12, fmtty_rest$9), fmtty$12 = match$28[2], fmt$13 = match$28[1];
              return [0, [13, pad_opt, sub_fmtty, fmt$13], fmtty$12];
            }
            break;
          case 14:
            if (typeof fmtty0 !== "number" && 9 === fmtty0[0]) {
              var fmtty_rest$10 = fmtty0[3], sub_fmtty1 = fmtty0[1], fmt_rest$13 = fmt[3], sub_fmtty$1 = fmt[2], pad_opt$0 = fmt[1], _c9_ = [0, caml_call1(CamlinternalFormatBasics[2], sub_fmtty1)];
              if (caml_notequal2([0, caml_call1(CamlinternalFormatBasics[2], sub_fmtty$1)], _c9_))
                throw caml_maybe_attach_backtrace2(Type_mismatch, 1);
              var match$29 = type_format_gen(
                fmt_rest$13,
                caml_call1(CamlinternalFormatBasics[2], fmtty_rest$10)
              ), fmtty$13 = match$29[2], fmt$14 = match$29[1];
              return [0, [14, pad_opt$0, sub_fmtty1, fmt$14], fmtty$13];
            }
            break;
          case 15:
            if (typeof fmtty0 !== "number" && 10 === fmtty0[0]) {
              var fmtty_rest$11 = fmtty0[1], fmt_rest$14 = fmt[1], match$30 = type_format_gen(fmt_rest$14, fmtty_rest$11), fmtty$14 = match$30[2], fmt$15 = match$30[1];
              return [0, [15, fmt$15], fmtty$14];
            }
            break;
          case 16:
            if (typeof fmtty0 !== "number" && 11 === fmtty0[0]) {
              var fmtty_rest$12 = fmtty0[1], fmt_rest$15 = fmt[1], match$31 = type_format_gen(fmt_rest$15, fmtty_rest$12), fmtty$15 = match$31[2], fmt$16 = match$31[1];
              return [0, [16, fmt$16], fmtty$15];
            }
            break;
          case 17:
            var fmt_rest$16 = fmt[2], formatting_lit2 = fmt[1], match$32 = type_format_gen(fmt_rest$16, fmtty0), fmtty$16 = match$32[2], fmt$17 = match$32[1];
            return [0, [17, formatting_lit2, fmt$17], fmtty$16];
          case 18:
            var fmt_rest$17 = fmt[2], formatting_gen = fmt[1];
            if (0 === formatting_gen[0]) {
              var match$36 = formatting_gen[1], str$0 = match$36[2], fmt1 = match$36[1], match$37 = type_format_gen(fmt1, fmtty0), fmtty2 = match$37[2], fmt2 = match$37[1], match$38 = type_format_gen(fmt_rest$17, fmtty2), fmtty3 = match$38[2], fmt3 = match$38[1];
              return [0, [18, [0, [0, fmt2, str$0]], fmt3], fmtty3];
            }
            var match$39 = formatting_gen[1], str$1 = match$39[2], fmt1$0 = match$39[1], match$40 = type_format_gen(fmt1$0, fmtty0), fmtty2$0 = match$40[2], fmt2$0 = match$40[1], match$41 = type_format_gen(fmt_rest$17, fmtty2$0), fmtty3$0 = match$41[2], fmt3$0 = match$41[1];
            return [0, [18, [1, [0, fmt2$0, str$1]], fmt3$0], fmtty3$0];
          case 19:
            if (typeof fmtty0 !== "number" && 13 === fmtty0[0]) {
              var fmtty_rest$13 = fmtty0[1], fmt_rest$18 = fmt[1], match$33 = type_format_gen(fmt_rest$18, fmtty_rest$13), fmtty$17 = match$33[2], fmt$18 = match$33[1];
              return [0, [19, fmt$18], fmtty$17];
            }
            break;
          case 20:
            if (typeof fmtty0 !== "number" && 1 === fmtty0[0]) {
              var fmtty_rest$14 = fmtty0[1], fmt_rest$19 = fmt[3], char_set = fmt[2], width_opt = fmt[1], match$34 = type_format_gen(fmt_rest$19, fmtty_rest$14), fmtty$18 = match$34[2], fmt$19 = match$34[1];
              return [0, [20, width_opt, char_set, fmt$19], fmtty$18];
            }
            break;
          case 21:
            if (typeof fmtty0 !== "number" && 2 === fmtty0[0]) {
              var fmtty_rest$15 = fmtty0[1], fmt_rest$20 = fmt[2], counter = fmt[1], match$35 = type_format_gen(fmt_rest$20, fmtty_rest$15), fmtty$19 = match$35[2], fmt$20 = match$35[1];
              return [0, [21, counter, fmt$20], fmtty$19];
            }
            break;
          case 23:
            var rest = fmt[2], ign = fmt[1];
            if (typeof ign !== "number")
              switch (ign[0]) {
                case 0:
                  return type_ignored_param_one(ign, rest, fmtty0);
                case 1:
                  return type_ignored_param_one(ign, rest, fmtty0);
                case 2:
                  return type_ignored_param_one(ign, rest, fmtty0);
                case 3:
                  return type_ignored_param_one(ign, rest, fmtty0);
                case 4:
                  return type_ignored_param_one(ign, rest, fmtty0);
                case 5:
                  return type_ignored_param_one(ign, rest, fmtty0);
                case 6:
                  return type_ignored_param_one(ign, rest, fmtty0);
                case 7:
                  return type_ignored_param_one(ign, rest, fmtty0);
                case 8:
                  var sub_fmtty$2 = ign[2], pad_opt$1 = ign[1];
                  return type_ignored_param_one([8, pad_opt$1, sub_fmtty$2], rest, fmtty0);
                case 9:
                  var sub_fmtty$3 = ign[2], pad_opt$2 = ign[1], _c__ = type_ignored_format_substituti(sub_fmtty$3, rest, fmtty0), match$43 = _c__[2], fmtty$21 = match$43[2], fmt$22 = match$43[1], sub_fmtty$4 = _c__[1];
                  return [0, [23, [9, pad_opt$2, sub_fmtty$4], fmt$22], fmtty$21];
                case 10:
                  return type_ignored_param_one(ign, rest, fmtty0);
                default:
                  return type_ignored_param_one(ign, rest, fmtty0);
              }
            switch (ign) {
              case 0:
                return type_ignored_param_one(ign, rest, fmtty0);
              case 1:
                return type_ignored_param_one(ign, rest, fmtty0);
              case 2:
                if (typeof fmtty0 !== "number" && 14 === fmtty0[0]) {
                  var fmtty_rest$16 = fmtty0[1], match$42 = type_format_gen(rest, fmtty_rest$16), fmtty$20 = match$42[2], fmt$21 = match$42[1];
                  return [0, [23, 2, fmt$21], fmtty$20];
                }
                throw caml_maybe_attach_backtrace2(Type_mismatch, 1);
              default:
                return type_ignored_param_one(ign, rest, fmtty0);
            }
        }
        throw caml_maybe_attach_backtrace2(Type_mismatch, 1);
      }
      function type_ignored_param_one(ign, fmt, fmtty) {
        var match = type_format_gen(fmt, fmtty), fmtty$0 = match[2], fmt$0 = match[1];
        return [0, [23, ign, fmt$0], fmtty$0];
      }
      function type_ignored_format_substituti(sub_fmtty, fmt, fmtty) {
        if (typeof sub_fmtty === "number")
          return [0, 0, type_format_gen(fmt, fmtty)];
        switch (sub_fmtty[0]) {
          case 0:
            if (typeof fmtty !== "number" && 0 === fmtty[0]) {
              var fmtty_rest = fmtty[1], sub_fmtty_rest = sub_fmtty[1], match = type_ignored_format_substituti(sub_fmtty_rest, fmt, fmtty_rest), fmt$0 = match[2], sub_fmtty_rest$0 = match[1];
              return [0, [0, sub_fmtty_rest$0], fmt$0];
            }
            break;
          case 1:
            if (typeof fmtty !== "number" && 1 === fmtty[0]) {
              var fmtty_rest$0 = fmtty[1], sub_fmtty_rest$1 = sub_fmtty[1], match$0 = type_ignored_format_substituti(sub_fmtty_rest$1, fmt, fmtty_rest$0), fmt$1 = match$0[2], sub_fmtty_rest$2 = match$0[1];
              return [0, [1, sub_fmtty_rest$2], fmt$1];
            }
            break;
          case 2:
            if (typeof fmtty !== "number" && 2 === fmtty[0]) {
              var fmtty_rest$1 = fmtty[1], sub_fmtty_rest$3 = sub_fmtty[1], match$1 = type_ignored_format_substituti(sub_fmtty_rest$3, fmt, fmtty_rest$1), fmt$2 = match$1[2], sub_fmtty_rest$4 = match$1[1];
              return [0, [2, sub_fmtty_rest$4], fmt$2];
            }
            break;
          case 3:
            if (typeof fmtty !== "number" && 3 === fmtty[0]) {
              var fmtty_rest$2 = fmtty[1], sub_fmtty_rest$5 = sub_fmtty[1], match$2 = type_ignored_format_substituti(sub_fmtty_rest$5, fmt, fmtty_rest$2), fmt$3 = match$2[2], sub_fmtty_rest$6 = match$2[1];
              return [0, [3, sub_fmtty_rest$6], fmt$3];
            }
            break;
          case 4:
            if (typeof fmtty !== "number" && 4 === fmtty[0]) {
              var fmtty_rest$3 = fmtty[1], sub_fmtty_rest$7 = sub_fmtty[1], match$3 = type_ignored_format_substituti(sub_fmtty_rest$7, fmt, fmtty_rest$3), fmt$4 = match$3[2], sub_fmtty_rest$8 = match$3[1];
              return [0, [4, sub_fmtty_rest$8], fmt$4];
            }
            break;
          case 5:
            if (typeof fmtty !== "number" && 5 === fmtty[0]) {
              var fmtty_rest$4 = fmtty[1], sub_fmtty_rest$9 = sub_fmtty[1], match$4 = type_ignored_format_substituti(sub_fmtty_rest$9, fmt, fmtty_rest$4), fmt$5 = match$4[2], sub_fmtty_rest$10 = match$4[1];
              return [0, [5, sub_fmtty_rest$10], fmt$5];
            }
            break;
          case 6:
            if (typeof fmtty !== "number" && 6 === fmtty[0]) {
              var fmtty_rest$5 = fmtty[1], sub_fmtty_rest$11 = sub_fmtty[1], match$5 = type_ignored_format_substituti(sub_fmtty_rest$11, fmt, fmtty_rest$5), fmt$6 = match$5[2], sub_fmtty_rest$12 = match$5[1];
              return [0, [6, sub_fmtty_rest$12], fmt$6];
            }
            break;
          case 7:
            if (typeof fmtty !== "number" && 7 === fmtty[0]) {
              var fmtty_rest$6 = fmtty[1], sub_fmtty_rest$13 = sub_fmtty[1], match$6 = type_ignored_format_substituti(sub_fmtty_rest$13, fmt, fmtty_rest$6), fmt$7 = match$6[2], sub_fmtty_rest$14 = match$6[1];
              return [0, [7, sub_fmtty_rest$14], fmt$7];
            }
            break;
          case 8:
            if (typeof fmtty !== "number" && 8 === fmtty[0]) {
              var fmtty_rest$7 = fmtty[2], sub2_fmtty = fmtty[1], sub_fmtty_rest$15 = sub_fmtty[2], sub2_fmtty$0 = sub_fmtty[1];
              if (caml_notequal2([0, sub2_fmtty$0], [0, sub2_fmtty]))
                throw caml_maybe_attach_backtrace2(Type_mismatch, 1);
              var match$7 = type_ignored_format_substituti(sub_fmtty_rest$15, fmt, fmtty_rest$7), fmt$8 = match$7[2], sub_fmtty_rest$16 = match$7[1];
              return [0, [8, sub2_fmtty, sub_fmtty_rest$16], fmt$8];
            }
            break;
          case 9:
            if (typeof fmtty !== "number" && 9 === fmtty[0]) {
              var fmtty_rest$8 = fmtty[3], sub2_fmtty$1 = fmtty[2], sub1_fmtty = fmtty[1], sub_fmtty_rest$17 = sub_fmtty[3], sub2_fmtty$2 = sub_fmtty[2], sub1_fmtty$0 = sub_fmtty[1], _c7_ = [0, caml_call1(CamlinternalFormatBasics[2], sub1_fmtty)];
              if (caml_notequal2([0, caml_call1(CamlinternalFormatBasics[2], sub1_fmtty$0)], _c7_))
                throw caml_maybe_attach_backtrace2(Type_mismatch, 1);
              var _c8_ = [0, caml_call1(CamlinternalFormatBasics[2], sub2_fmtty$1)];
              if (caml_notequal2([0, caml_call1(CamlinternalFormatBasics[2], sub2_fmtty$2)], _c8_))
                throw caml_maybe_attach_backtrace2(Type_mismatch, 1);
              var sub_fmtty$0 = trans(symm(sub1_fmtty), sub2_fmtty$1), match$8 = fmtty_rel_det(sub_fmtty$0), f4 = match$8[4], f2 = match$8[2];
              f2(0);
              f4(0);
              var match$9 = type_ignored_format_substituti(
                caml_call1(CamlinternalFormatBasics[2], sub_fmtty_rest$17),
                fmt,
                fmtty_rest$8
              ), fmt$9 = match$9[2], sub_fmtty_rest$18 = match$9[1];
              return [
                0,
                [9, sub1_fmtty, sub2_fmtty$1, symm(sub_fmtty_rest$18)],
                fmt$9
              ];
            }
            break;
          case 10:
            if (typeof fmtty !== "number" && 10 === fmtty[0]) {
              var fmtty_rest$9 = fmtty[1], sub_fmtty_rest$19 = sub_fmtty[1], match$10 = type_ignored_format_substituti(sub_fmtty_rest$19, fmt, fmtty_rest$9), fmt$10 = match$10[2], sub_fmtty_rest$20 = match$10[1];
              return [0, [10, sub_fmtty_rest$20], fmt$10];
            }
            break;
          case 11:
            if (typeof fmtty !== "number" && 11 === fmtty[0]) {
              var fmtty_rest$10 = fmtty[1], sub_fmtty_rest$21 = sub_fmtty[1], match$11 = type_ignored_format_substituti(sub_fmtty_rest$21, fmt, fmtty_rest$10), fmt$11 = match$11[2], sub_fmtty_rest$22 = match$11[1];
              return [0, [11, sub_fmtty_rest$22], fmt$11];
            }
            break;
          case 13:
            if (typeof fmtty !== "number" && 13 === fmtty[0]) {
              var fmtty_rest$11 = fmtty[1], sub_fmtty_rest$23 = sub_fmtty[1], match$12 = type_ignored_format_substituti(sub_fmtty_rest$23, fmt, fmtty_rest$11), fmt$12 = match$12[2], sub_fmtty_rest$24 = match$12[1];
              return [0, [13, sub_fmtty_rest$24], fmt$12];
            }
            break;
          case 14:
            if (typeof fmtty !== "number" && 14 === fmtty[0]) {
              var fmtty_rest$12 = fmtty[1], sub_fmtty_rest$25 = sub_fmtty[1], match$13 = type_ignored_format_substituti(sub_fmtty_rest$25, fmt, fmtty_rest$12), fmt$13 = match$13[2], sub_fmtty_rest$26 = match$13[1];
              return [0, [14, sub_fmtty_rest$26], fmt$13];
            }
            break;
        }
        throw caml_maybe_attach_backtrace2(Type_mismatch, 1);
      }
      function recast(fmt, fmtty) {
        var _c6_ = symm(fmtty);
        return type_format(fmt, caml_call1(CamlinternalFormatBasics[2], _c6_));
      }
      function fix_padding(padty, width, str) {
        var len = caml_ml_string_length2(str), padty$0 = 0 <= width ? padty : 0, width$0 = caml_call1(Stdlib[18], width);
        if (width$0 <= len)
          return str;
        var _c5_ = 2 === padty$0 ? 48 : 32, res = caml_call2(Stdlib_Bytes[1], width$0, _c5_);
        switch (padty$0) {
          case 0:
            caml_call5(Stdlib_String[6], str, 0, res, 0, len);
            break;
          case 1:
            caml_call5(Stdlib_String[6], str, 0, res, width$0 - len | 0, len);
            break;
          default:
            a:
              if (0 < len) {
                if (43 !== caml_string_get2(str, 0) && 45 !== caml_string_get2(str, 0) && 32 !== caml_string_get2(str, 0))
                  break a;
                caml_bytes_set2(res, 0, caml_string_get2(str, 0));
                caml_call5(
                  Stdlib_String[6],
                  str,
                  1,
                  res,
                  (width$0 - len | 0) + 1 | 0,
                  len - 1 | 0
                );
                break;
              }
            a:
              if (1 < len && 48 === caml_string_get2(str, 0)) {
                if (120 !== caml_string_get2(str, 1) && 88 !== caml_string_get2(str, 1))
                  break a;
                caml_bytes_set2(res, 1, caml_string_get2(str, 1));
                caml_call5(
                  Stdlib_String[6],
                  str,
                  2,
                  res,
                  (width$0 - len | 0) + 2 | 0,
                  len - 2 | 0
                );
                break;
              }
            caml_call5(Stdlib_String[6], str, 0, res, width$0 - len | 0, len);
        }
        return caml_call1(Stdlib_Bytes[44], res);
      }
      function fix_int_precision(prec, str) {
        var prec$0 = caml_call1(Stdlib[18], prec), len = caml_ml_string_length2(str), c = caml_string_get2(str, 0);
        a: {
          b: {
            if (58 > c) {
              if (32 !== c) {
                if (43 > c)
                  break a;
                switch (c - 43 | 0) {
                  case 5:
                    c:
                      if (len < (prec$0 + 2 | 0) && 1 < len) {
                        if (120 !== caml_string_get2(str, 1) && 88 !== caml_string_get2(str, 1))
                          break c;
                        var res$1 = caml_call2(Stdlib_Bytes[1], prec$0 + 2 | 0, 48);
                        caml_bytes_set2(res$1, 1, caml_string_get2(str, 1));
                        caml_call5(
                          Stdlib_String[6],
                          str,
                          2,
                          res$1,
                          (prec$0 - len | 0) + 4 | 0,
                          len - 2 | 0
                        );
                        return caml_call1(Stdlib_Bytes[44], res$1);
                      }
                    break b;
                  case 0:
                  case 2:
                    break;
                  case 1:
                  case 3:
                  case 4:
                    break a;
                  default:
                    break b;
                }
              }
              if (len >= (prec$0 + 1 | 0))
                break a;
              var res$0 = caml_call2(Stdlib_Bytes[1], prec$0 + 1 | 0, 48);
              caml_bytes_set2(res$0, 0, c);
              caml_call5(
                Stdlib_String[6],
                str,
                1,
                res$0,
                (prec$0 - len | 0) + 2 | 0,
                len - 1 | 0
              );
              return caml_call1(Stdlib_Bytes[44], res$0);
            }
            if (71 <= c) {
              if (5 < c - 97 >>> 0)
                break a;
            } else if (65 > c)
              break a;
          }
          if (len < prec$0) {
            var res = caml_call2(Stdlib_Bytes[1], prec$0, 48);
            caml_call5(Stdlib_String[6], str, 0, res, prec$0 - len | 0, len);
            return caml_call1(Stdlib_Bytes[44], res);
          }
        }
        return str;
      }
      function string_to_caml_string(str) {
        var str$0 = caml_call1(Stdlib_String[25], str), l = caml_ml_string_length2(str$0), res = caml_call2(Stdlib_Bytes[1], l + 2 | 0, 34);
        caml_blit_string2(str$0, 0, res, 1, l);
        return caml_call1(Stdlib_Bytes[44], res);
      }
      function format_of_fconv(fconv, prec) {
        var prec$0 = caml_call1(Stdlib[18], prec), symb = char_of_fconv(_r_, fconv), buf = buffer_create(16);
        buffer_add_char(buf, 37);
        bprint_fconv_flag(buf, fconv);
        buffer_add_char(buf, 46);
        buffer_add_string(buf, caml_call1(Stdlib_Int[12], prec$0));
        buffer_add_char(buf, symb);
        return buffer_contents(buf);
      }
      function transform_int_alt(iconv, s2) {
        if (13 > iconv)
          return s2;
        var n = [0, 0], _c0_ = caml_ml_string_length2(s2) - 1 | 0, _cZ_ = 0;
        if (_c0_ >= 0) {
          var i$0 = _cZ_;
          for (; ; ) {
            if (9 >= caml_string_unsafe_get2(s2, i$0) - 48 >>> 0)
              n[1]++;
            var _c4_ = i$0 + 1 | 0;
            if (_c0_ === i$0)
              break;
            var i$0 = _c4_;
          }
        }
        var digits = n[1], buf = caml_create_bytes2(caml_ml_string_length2(s2) + ((digits - 1 | 0) / 3 | 0) | 0), pos = [0, 0];
        function put(c2) {
          caml_bytes_set2(buf, pos[1], c2);
          pos[1]++;
          return;
        }
        var left = [0, ((digits - 1 | 0) % 3 | 0) + 1 | 0], _c2_ = caml_ml_string_length2(s2) - 1 | 0, _c1_ = 0;
        if (_c2_ >= 0) {
          var i = _c1_;
          for (; ; ) {
            var c = caml_string_unsafe_get2(s2, i);
            if (9 < c - 48 >>> 0)
              put(c);
            else {
              if (0 === left[1]) {
                put(95);
                left[1] = 3;
              }
              left[1] += -1;
              put(c);
            }
            var _c3_ = i + 1 | 0;
            if (_c2_ === i)
              break;
            var i = _c3_;
          }
        }
        return caml_call1(Stdlib_Bytes[44], buf);
      }
      function convert_int(iconv, n) {
        switch (iconv) {
          case 1:
            var _cY_ = cst_d$0;
            break;
          case 2:
            var _cY_ = cst_d$1;
            break;
          case 4:
            var _cY_ = cst_i$1;
            break;
          case 5:
            var _cY_ = cst_i$2;
            break;
          case 6:
            var _cY_ = cst_x;
            break;
          case 7:
            var _cY_ = cst_x$0;
            break;
          case 8:
            var _cY_ = cst_X;
            break;
          case 9:
            var _cY_ = cst_X$0;
            break;
          case 10:
            var _cY_ = cst_o;
            break;
          case 11:
            var _cY_ = cst_o$0;
            break;
          case 0:
          case 13:
            var _cY_ = cst_d;
            break;
          case 3:
          case 14:
            var _cY_ = cst_i$0;
            break;
          default:
            var _cY_ = cst_u;
        }
        return transform_int_alt(iconv, caml_format_int2(_cY_, n));
      }
      function convert_int32(iconv, n) {
        switch (iconv) {
          case 1:
            var _cX_ = cst_ld$0;
            break;
          case 2:
            var _cX_ = cst_ld$1;
            break;
          case 4:
            var _cX_ = cst_li$1;
            break;
          case 5:
            var _cX_ = cst_li$2;
            break;
          case 6:
            var _cX_ = cst_lx;
            break;
          case 7:
            var _cX_ = cst_lx$0;
            break;
          case 8:
            var _cX_ = cst_lX;
            break;
          case 9:
            var _cX_ = cst_lX$0;
            break;
          case 10:
            var _cX_ = cst_lo;
            break;
          case 11:
            var _cX_ = cst_lo$0;
            break;
          case 0:
          case 13:
            var _cX_ = cst_ld;
            break;
          case 3:
          case 14:
            var _cX_ = cst_li$0;
            break;
          default:
            var _cX_ = cst_lu;
        }
        return transform_int_alt(iconv, caml_format_int2(_cX_, n));
      }
      function convert_nativeint(iconv, n) {
        switch (iconv) {
          case 1:
            var _cW_ = cst_nd$0;
            break;
          case 2:
            var _cW_ = cst_nd$1;
            break;
          case 4:
            var _cW_ = cst_ni$1;
            break;
          case 5:
            var _cW_ = cst_ni$2;
            break;
          case 6:
            var _cW_ = cst_nx;
            break;
          case 7:
            var _cW_ = cst_nx$0;
            break;
          case 8:
            var _cW_ = cst_nX;
            break;
          case 9:
            var _cW_ = cst_nX$0;
            break;
          case 10:
            var _cW_ = cst_no;
            break;
          case 11:
            var _cW_ = cst_no$0;
            break;
          case 0:
          case 13:
            var _cW_ = cst_nd;
            break;
          case 3:
          case 14:
            var _cW_ = cst_ni$0;
            break;
          default:
            var _cW_ = cst_nu;
        }
        return transform_int_alt(iconv, caml_format_int2(_cW_, n));
      }
      function convert_int64(iconv, n) {
        switch (iconv) {
          case 1:
            var _cV_ = cst_Ld$0;
            break;
          case 2:
            var _cV_ = cst_Ld$1;
            break;
          case 4:
            var _cV_ = cst_Li$1;
            break;
          case 5:
            var _cV_ = cst_Li$2;
            break;
          case 6:
            var _cV_ = cst_Lx;
            break;
          case 7:
            var _cV_ = cst_Lx$0;
            break;
          case 8:
            var _cV_ = cst_LX;
            break;
          case 9:
            var _cV_ = cst_LX$0;
            break;
          case 10:
            var _cV_ = cst_Lo;
            break;
          case 11:
            var _cV_ = cst_Lo$0;
            break;
          case 0:
          case 13:
            var _cV_ = cst_Ld;
            break;
          case 3:
          case 14:
            var _cV_ = cst_Li$0;
            break;
          default:
            var _cV_ = cst_Lu;
        }
        return transform_int_alt(iconv, runtime.caml_int64_format(_cV_, n));
      }
      function convert_float(fconv, prec, x2) {
        function hex(param) {
          switch (fconv[1]) {
            case 0:
              var sign = 45;
              break;
            case 1:
              var sign = 43;
              break;
            default:
              var sign = 32;
          }
          return runtime.caml_hexstring_of_float(x2, prec, sign);
        }
        function caml_special_val(str2) {
          var match = runtime.caml_classify_float(x2);
          return 3 === match ? x2 < 0 ? cst_neg_infinity : cst_infinity : 4 <= match ? cst_nan : str2;
        }
        switch (fconv[2]) {
          case 5:
            var str = caml_format_float2(format_of_fconv(fconv, prec), x2), len = caml_ml_string_length2(str), i = 0;
            for (; ; ) {
              if (i === len)
                var _cS_ = 0;
              else {
                var _cR_ = caml_string_get2(str, i) - 46 | 0;
                a: {
                  if (23 < _cR_ >>> 0) {
                    if (55 === _cR_)
                      break a;
                  } else if (21 < _cR_ - 1 >>> 0)
                    break a;
                  var i$0 = i + 1 | 0, i = i$0;
                  continue;
                }
                var _cS_ = 1;
              }
              var _cT_ = _cS_ ? str : caml_call2(Stdlib[28], str, cst$17);
              return caml_special_val(_cT_);
            }
          case 6:
            return hex(0);
          case 7:
            var _cU_ = hex(0);
            return caml_call1(Stdlib_String[26], _cU_);
          case 8:
            return caml_special_val(hex(0));
          default:
            return caml_format_float2(format_of_fconv(fconv, prec), x2);
        }
      }
      function string_of_fmtty(fmtty) {
        var buf = buffer_create(16);
        bprint_fmtty(buf, fmtty);
        return buffer_contents(buf);
      }
      function make_printf$0(counter, k, acc, fmt) {
        var k$0 = k, acc$0 = acc, fmt$0 = fmt;
        for (; ; ) {
          if (typeof fmt$0 === "number")
            return caml_call1(k$0, acc$0);
          switch (fmt$0[0]) {
            case 0:
              var rest = fmt$0[1];
              return function(c) {
                var new_acc2 = [5, acc$0, c];
                return make_printf(k$0, new_acc2, rest);
              };
            case 1:
              var rest$0 = fmt$0[1];
              return function(c) {
                var str2 = caml_call1(Stdlib_Char[2], c), l = caml_ml_string_length2(str2), res = caml_call2(Stdlib_Bytes[1], l + 2 | 0, 39);
                caml_blit_string2(str2, 0, res, 1, l);
                var new_acc2 = [4, acc$0, caml_call1(Stdlib_Bytes[44], res)];
                return make_printf(k$0, new_acc2, rest$0);
              };
            case 2:
              var rest$1 = fmt$0[2], pad = fmt$0[1];
              return make_padding(k$0, acc$0, rest$1, pad, function(str2) {
                return str2;
              });
            case 3:
              var rest$2 = fmt$0[2], pad$0 = fmt$0[1];
              return make_padding(k$0, acc$0, rest$2, pad$0, string_to_caml_string);
            case 4:
              var rest$3 = fmt$0[4], prec = fmt$0[3], pad$1 = fmt$0[2], iconv = fmt$0[1];
              return make_int_padding_precision(k$0, acc$0, rest$3, pad$1, prec, convert_int, iconv);
            case 5:
              var rest$4 = fmt$0[4], prec$0 = fmt$0[3], pad$2 = fmt$0[2], iconv$0 = fmt$0[1];
              return make_int_padding_precision(k$0, acc$0, rest$4, pad$2, prec$0, convert_int32, iconv$0);
            case 6:
              var rest$5 = fmt$0[4], prec$1 = fmt$0[3], pad$3 = fmt$0[2], iconv$1 = fmt$0[1];
              return make_int_padding_precision(
                k$0,
                acc$0,
                rest$5,
                pad$3,
                prec$1,
                convert_nativeint,
                iconv$1
              );
            case 7:
              var rest$6 = fmt$0[4], prec$2 = fmt$0[3], pad$4 = fmt$0[2], iconv$2 = fmt$0[1];
              return make_int_padding_precision(k$0, acc$0, rest$6, pad$4, prec$2, convert_int64, iconv$2);
            case 8:
              var rest$7 = fmt$0[4], prec$3 = fmt$0[3], pad$5 = fmt$0[2], fconv = fmt$0[1];
              if (typeof pad$5 === "number") {
                if (typeof prec$3 === "number")
                  return prec$3 ? function(p2, x2) {
                    var str2 = convert_float(fconv, p2, x2);
                    return make_printf(k$0, [4, acc$0, str2], rest$7);
                  } : function(x2) {
                    var str2 = convert_float(fconv, default_float_precision(fconv), x2);
                    return make_printf(k$0, [4, acc$0, str2], rest$7);
                  };
                var p = prec$3[1];
                return function(x2) {
                  var str2 = convert_float(fconv, p, x2);
                  return make_printf(k$0, [4, acc$0, str2], rest$7);
                };
              }
              if (0 === pad$5[0]) {
                var w = pad$5[2], padty = pad$5[1];
                if (typeof prec$3 === "number")
                  return prec$3 ? function(p2, x2) {
                    var str2 = fix_padding(padty, w, convert_float(fconv, p2, x2));
                    return make_printf(k$0, [4, acc$0, str2], rest$7);
                  } : function(x2) {
                    var str2 = convert_float(fconv, default_float_precision(fconv), x2), str$0 = fix_padding(padty, w, str2);
                    return make_printf(k$0, [4, acc$0, str$0], rest$7);
                  };
                var p$0 = prec$3[1];
                return function(x2) {
                  var str2 = fix_padding(padty, w, convert_float(fconv, p$0, x2));
                  return make_printf(k$0, [4, acc$0, str2], rest$7);
                };
              }
              var padty$0 = pad$5[1];
              if (typeof prec$3 === "number")
                return prec$3 ? function(w2, p2, x2) {
                  var str2 = fix_padding(padty$0, w2, convert_float(fconv, p2, x2));
                  return make_printf(k$0, [4, acc$0, str2], rest$7);
                } : function(w2, x2) {
                  var str2 = convert_float(fconv, default_float_precision(fconv), x2), str$0 = fix_padding(padty$0, w2, str2);
                  return make_printf(k$0, [4, acc$0, str$0], rest$7);
                };
              var p$1 = prec$3[1];
              return function(w2, x2) {
                var str2 = fix_padding(padty$0, w2, convert_float(fconv, p$1, x2));
                return make_printf(k$0, [4, acc$0, str2], rest$7);
              };
            case 9:
              var rest$8 = fmt$0[2], pad$6 = fmt$0[1];
              return make_padding(k$0, acc$0, rest$8, pad$6, Stdlib[30]);
            case 10:
              var rest$9 = fmt$0[1], acc$1 = [7, acc$0], acc$0 = acc$1, fmt$0 = rest$9;
              break;
            case 11:
              var rest$10 = fmt$0[2], str = fmt$0[1], acc$2 = [2, acc$0, str], acc$0 = acc$2, fmt$0 = rest$10;
              break;
            case 12:
              var rest$11 = fmt$0[2], chr = fmt$0[1], acc$3 = [3, acc$0, chr], acc$0 = acc$3, fmt$0 = rest$11;
              break;
            case 13:
              var rest$12 = fmt$0[3], sub_fmtty = fmt$0[2], ty = string_of_fmtty(sub_fmtty);
              return function(str2) {
                return make_printf(k$0, [4, acc$0, ty], rest$12);
              };
            case 14:
              var rest$13 = fmt$0[3], fmtty = fmt$0[2];
              return function(param) {
                var fmt2 = param[1], _cQ_ = recast(fmt2, fmtty);
                return make_printf(
                  k$0,
                  acc$0,
                  caml_call2(CamlinternalFormatBasics[3], _cQ_, rest$13)
                );
              };
            case 15:
              var rest$14 = fmt$0[1];
              return function(f2, x2) {
                return make_printf(
                  k$0,
                  [6, acc$0, function(o) {
                    return caml_call2(f2, o, x2);
                  }],
                  rest$14
                );
              };
            case 16:
              var rest$15 = fmt$0[1];
              return function(f2) {
                return make_printf(k$0, [6, acc$0, f2], rest$15);
              };
            case 17:
              var rest$16 = fmt$0[2], fmting_lit = fmt$0[1], acc$4 = [0, acc$0, fmting_lit], acc$0 = acc$4, fmt$0 = rest$16;
              break;
            case 18:
              var _cO_ = fmt$0[1];
              if (0 === _cO_[0]) {
                var rest$17 = fmt$0[2], fmt$1 = _cO_[1][1];
                let acc2 = acc$0, k2 = k$0, rest2 = rest$17;
                var k$1 = function(kacc) {
                  return make_printf(k2, [1, acc2, [0, kacc]], rest2);
                }, k$0 = k$1, acc$0 = 0, fmt$0 = fmt$1;
              } else {
                var rest$18 = fmt$0[2], fmt$2 = _cO_[1][1];
                let acc2 = acc$0, k2 = k$0, rest2 = rest$18;
                var k$2 = function(kacc) {
                  return make_printf(k2, [1, acc2, [1, kacc]], rest2);
                }, k$0 = k$2, acc$0 = 0, fmt$0 = fmt$2;
              }
              break;
            case 19:
              throw caml_maybe_attach_backtrace2([0, Assert_failure, _s_], 1);
            case 20:
              var rest$19 = fmt$0[3], new_acc = [8, acc$0, cst_Printf_bad_conversion];
              return function(param) {
                return make_printf(k$0, new_acc, rest$19);
              };
            case 21:
              var rest$20 = fmt$0[2];
              return function(n) {
                var new_acc2 = [4, acc$0, caml_format_int2(cst_u$0, n)];
                return make_printf(k$0, new_acc2, rest$20);
              };
            case 22:
              var rest$21 = fmt$0[1];
              return function(c) {
                var new_acc2 = [5, acc$0, c];
                return make_printf(k$0, new_acc2, rest$21);
              };
            case 23:
              var rest$22 = fmt$0[2], ign = fmt$0[1];
              if (counter >= 50)
                return caml_trampoline_return2(make_ignored_param$0, [0, k$0, acc$0, ign, rest$22]);
              var counter$1 = counter + 1 | 0;
              return make_ignored_param$0(counter$1, k$0, acc$0, ign, rest$22);
            default:
              var rest$23 = fmt$0[3], f = fmt$0[2], arity = fmt$0[1], _cP_ = caml_call1(f, 0);
              if (counter >= 50)
                return caml_trampoline_return2(make_custom$0, [0, k$0, acc$0, rest$23, arity, _cP_]);
              var counter$0 = counter + 1 | 0;
              return make_custom$0(counter$0, k$0, acc$0, rest$23, arity, _cP_);
          }
        }
      }
      function make_printf(k, acc, fmt) {
        return caml_trampoline2(make_printf$0(0, k, acc, fmt));
      }
      function make_ignored_param$0(counter, k, acc, ign, fmt) {
        if (typeof ign === "number")
          switch (ign) {
            case 0:
              if (counter >= 50)
                return caml_trampoline_return2(make_invalid_arg, [0, k, acc, fmt]);
              var counter$0 = counter + 1 | 0;
              return make_invalid_arg(counter$0, k, acc, fmt);
            case 1:
              if (counter >= 50)
                return caml_trampoline_return2(make_invalid_arg, [0, k, acc, fmt]);
              var counter$1 = counter + 1 | 0;
              return make_invalid_arg(counter$1, k, acc, fmt);
            case 2:
              throw caml_maybe_attach_backtrace2([0, Assert_failure, _t_], 1);
            default:
              if (counter >= 50)
                return caml_trampoline_return2(make_invalid_arg, [0, k, acc, fmt]);
              var counter$2 = counter + 1 | 0;
              return make_invalid_arg(counter$2, k, acc, fmt);
          }
        switch (ign[0]) {
          case 0:
            if (counter >= 50)
              return caml_trampoline_return2(make_invalid_arg, [0, k, acc, fmt]);
            var counter$3 = counter + 1 | 0;
            return make_invalid_arg(counter$3, k, acc, fmt);
          case 1:
            if (counter >= 50)
              return caml_trampoline_return2(make_invalid_arg, [0, k, acc, fmt]);
            var counter$4 = counter + 1 | 0;
            return make_invalid_arg(counter$4, k, acc, fmt);
          case 2:
            if (counter >= 50)
              return caml_trampoline_return2(make_invalid_arg, [0, k, acc, fmt]);
            var counter$5 = counter + 1 | 0;
            return make_invalid_arg(counter$5, k, acc, fmt);
          case 3:
            if (counter >= 50)
              return caml_trampoline_return2(make_invalid_arg, [0, k, acc, fmt]);
            var counter$6 = counter + 1 | 0;
            return make_invalid_arg(counter$6, k, acc, fmt);
          case 4:
            if (counter >= 50)
              return caml_trampoline_return2(make_invalid_arg, [0, k, acc, fmt]);
            var counter$7 = counter + 1 | 0;
            return make_invalid_arg(counter$7, k, acc, fmt);
          case 5:
            if (counter >= 50)
              return caml_trampoline_return2(make_invalid_arg, [0, k, acc, fmt]);
            var counter$8 = counter + 1 | 0;
            return make_invalid_arg(counter$8, k, acc, fmt);
          case 6:
            if (counter >= 50)
              return caml_trampoline_return2(make_invalid_arg, [0, k, acc, fmt]);
            var counter$9 = counter + 1 | 0;
            return make_invalid_arg(counter$9, k, acc, fmt);
          case 7:
            if (counter >= 50)
              return caml_trampoline_return2(make_invalid_arg, [0, k, acc, fmt]);
            var counter$10 = counter + 1 | 0;
            return make_invalid_arg(counter$10, k, acc, fmt);
          case 8:
            if (counter >= 50)
              return caml_trampoline_return2(make_invalid_arg, [0, k, acc, fmt]);
            var counter$11 = counter + 1 | 0;
            return make_invalid_arg(counter$11, k, acc, fmt);
          case 9:
            var fmtty = ign[2];
            if (counter >= 50)
              return caml_trampoline_return2(make_from_fmtty$0, [0, k, acc, fmtty, fmt]);
            var counter$14 = counter + 1 | 0;
            return make_from_fmtty$0(counter$14, k, acc, fmtty, fmt);
          case 10:
            if (counter >= 50)
              return caml_trampoline_return2(make_invalid_arg, [0, k, acc, fmt]);
            var counter$12 = counter + 1 | 0;
            return make_invalid_arg(counter$12, k, acc, fmt);
          default:
            if (counter >= 50)
              return caml_trampoline_return2(make_invalid_arg, [0, k, acc, fmt]);
            var counter$13 = counter + 1 | 0;
            return make_invalid_arg(counter$13, k, acc, fmt);
        }
      }
      function make_ignored_param(k, acc, ign, fmt) {
        return caml_trampoline2(make_ignored_param$0(0, k, acc, ign, fmt));
      }
      function make_from_fmtty$0(counter, k, acc, fmtty, fmt) {
        if (typeof fmtty !== "number")
          switch (fmtty[0]) {
            case 0:
              var rest = fmtty[1];
              return function(param) {
                return make_from_fmtty(k, acc, rest, fmt);
              };
            case 1:
              var rest$0 = fmtty[1];
              return function(param) {
                return make_from_fmtty(k, acc, rest$0, fmt);
              };
            case 2:
              var rest$1 = fmtty[1];
              return function(param) {
                return make_from_fmtty(k, acc, rest$1, fmt);
              };
            case 3:
              var rest$2 = fmtty[1];
              return function(param) {
                return make_from_fmtty(k, acc, rest$2, fmt);
              };
            case 4:
              var rest$3 = fmtty[1];
              return function(param) {
                return make_from_fmtty(k, acc, rest$3, fmt);
              };
            case 5:
              var rest$4 = fmtty[1];
              return function(param) {
                return make_from_fmtty(k, acc, rest$4, fmt);
              };
            case 6:
              var rest$5 = fmtty[1];
              return function(param) {
                return make_from_fmtty(k, acc, rest$5, fmt);
              };
            case 7:
              var rest$6 = fmtty[1];
              return function(param) {
                return make_from_fmtty(k, acc, rest$6, fmt);
              };
            case 8:
              var rest$7 = fmtty[2];
              return function(param) {
                return make_from_fmtty(k, acc, rest$7, fmt);
              };
            case 9:
              var rest$8 = fmtty[3], ty2 = fmtty[2], ty1 = fmtty[1], ty = trans(symm(ty1), ty2);
              return function(param) {
                return make_from_fmtty(
                  k,
                  acc,
                  caml_call2(CamlinternalFormatBasics[1], ty, rest$8),
                  fmt
                );
              };
            case 10:
              var rest$9 = fmtty[1];
              return function(param, _cN_) {
                return make_from_fmtty(k, acc, rest$9, fmt);
              };
            case 11:
              var rest$10 = fmtty[1];
              return function(param) {
                return make_from_fmtty(k, acc, rest$10, fmt);
              };
            case 12:
              var rest$11 = fmtty[1];
              return function(param) {
                return make_from_fmtty(k, acc, rest$11, fmt);
              };
            case 13:
              throw caml_maybe_attach_backtrace2([0, Assert_failure, _u_], 1);
            default:
              throw caml_maybe_attach_backtrace2([0, Assert_failure, _v_], 1);
          }
        if (counter >= 50)
          return caml_trampoline_return2(make_invalid_arg, [0, k, acc, fmt]);
        var counter$0 = counter + 1 | 0;
        return make_invalid_arg(counter$0, k, acc, fmt);
      }
      function make_from_fmtty(k, acc, fmtty, fmt) {
        return caml_trampoline2(make_from_fmtty$0(0, k, acc, fmtty, fmt));
      }
      function make_invalid_arg(counter, k, acc, fmt) {
        var _cM_ = [8, acc, cst_Printf_bad_conversion$0];
        if (counter >= 50)
          return caml_trampoline_return2(make_printf$0, [0, k, _cM_, fmt]);
        var counter$0 = counter + 1 | 0;
        return make_printf$0(counter$0, k, _cM_, fmt);
      }
      function make_padding(k, acc, fmt, pad, trans2) {
        if (typeof pad === "number")
          return function(x2) {
            var new_acc = [4, acc, caml_call1(trans2, x2)];
            return make_printf(k, new_acc, fmt);
          };
        if (0 === pad[0]) {
          var width = pad[2], padty = pad[1];
          return function(x2) {
            var new_acc = [4, acc, fix_padding(padty, width, caml_call1(trans2, x2))];
            return make_printf(k, new_acc, fmt);
          };
        }
        var padty$0 = pad[1];
        return function(w, x2) {
          var new_acc = [4, acc, fix_padding(padty$0, w, caml_call1(trans2, x2))];
          return make_printf(k, new_acc, fmt);
        };
      }
      function make_int_padding_precision(k, acc, fmt, pad, prec, trans2, iconv) {
        if (typeof pad === "number") {
          if (typeof prec === "number")
            return prec ? function(p2, x2) {
              var str = fix_int_precision(p2, caml_call2(trans2, iconv, x2));
              return make_printf(k, [4, acc, str], fmt);
            } : function(x2) {
              var str = caml_call2(trans2, iconv, x2);
              return make_printf(k, [4, acc, str], fmt);
            };
          var p = prec[1];
          return function(x2) {
            var str = fix_int_precision(p, caml_call2(trans2, iconv, x2));
            return make_printf(k, [4, acc, str], fmt);
          };
        }
        if (0 === pad[0]) {
          var w = pad[2], padty = pad[1];
          if (typeof prec === "number")
            return prec ? function(p2, x2) {
              var str = fix_padding(
                padty,
                w,
                fix_int_precision(p2, caml_call2(trans2, iconv, x2))
              );
              return make_printf(k, [4, acc, str], fmt);
            } : function(x2) {
              var str = fix_padding(padty, w, caml_call2(trans2, iconv, x2));
              return make_printf(k, [4, acc, str], fmt);
            };
          var p$0 = prec[1];
          return function(x2) {
            var str = fix_padding(padty, w, fix_int_precision(p$0, caml_call2(trans2, iconv, x2)));
            return make_printf(k, [4, acc, str], fmt);
          };
        }
        var padty$0 = pad[1];
        if (typeof prec === "number")
          return prec ? function(w2, p2, x2) {
            var str = fix_padding(
              padty$0,
              w2,
              fix_int_precision(p2, caml_call2(trans2, iconv, x2))
            );
            return make_printf(k, [4, acc, str], fmt);
          } : function(w2, x2) {
            var str = fix_padding(padty$0, w2, caml_call2(trans2, iconv, x2));
            return make_printf(k, [4, acc, str], fmt);
          };
        var p$1 = prec[1];
        return function(w2, x2) {
          var str = fix_padding(padty$0, w2, fix_int_precision(p$1, caml_call2(trans2, iconv, x2)));
          return make_printf(k, [4, acc, str], fmt);
        };
      }
      function make_custom$0(counter, k, acc, rest, arity, f) {
        if (arity) {
          var arity$0 = arity[1];
          return function(x2) {
            return make_custom(k, acc, rest, arity$0, caml_call1(f, x2));
          };
        }
        var _cL_ = [4, acc, f];
        if (counter >= 50)
          return caml_trampoline_return2(make_printf$0, [0, k, _cL_, rest]);
        var counter$0 = counter + 1 | 0;
        return make_printf$0(counter$0, k, _cL_, rest);
      }
      function make_custom(k, acc, rest, arity, f) {
        return caml_trampoline2(make_custom$0(0, k, acc, rest, arity, f));
      }
      function make_iprintf$0(counter, k, o, fmt) {
        var k$0 = k, fmt$0 = fmt;
        for (; ; ) {
          if (typeof fmt$0 === "number")
            return caml_call1(k$0, o);
          switch (fmt$0[0]) {
            case 0:
              var rest = fmt$0[1], _b2_ = make_iprintf(k$0, o, rest);
              return function(_cK_) {
                return _b2_;
              };
            case 1:
              var rest$0 = fmt$0[1], _b3_ = make_iprintf(k$0, o, rest$0);
              return function(_cJ_) {
                return _b3_;
              };
            case 2:
              var _b4_ = fmt$0[1];
              if (typeof _b4_ === "number") {
                var rest$1 = fmt$0[2], _b5_ = make_iprintf(k$0, o, rest$1);
                return function(_cI_) {
                  return _b5_;
                };
              }
              if (0 === _b4_[0]) {
                var rest$2 = fmt$0[2], _b6_ = make_iprintf(k$0, o, rest$2);
                return function(_cH_) {
                  return _b6_;
                };
              }
              var rest$3 = fmt$0[2], _b7_ = make_iprintf(k$0, o, rest$3), _b8_ = function(_cG_) {
                return _b7_;
              };
              return function(_cF_) {
                return _b8_;
              };
            case 3:
              var _b9_ = fmt$0[1];
              if (typeof _b9_ === "number") {
                var rest$4 = fmt$0[2], _b__ = make_iprintf(k$0, o, rest$4);
                return function(_cE_) {
                  return _b__;
                };
              }
              if (0 === _b9_[0]) {
                var rest$5 = fmt$0[2], _b$_ = make_iprintf(k$0, o, rest$5);
                return function(_cD_) {
                  return _b$_;
                };
              }
              var rest$6 = fmt$0[2], _ca_ = make_iprintf(k$0, o, rest$6), _cb_ = function(_cC_) {
                return _ca_;
              };
              return function(_cB_) {
                return _cb_;
              };
            case 4:
              var rest$7 = fmt$0[4], prec = fmt$0[3], pad = fmt$0[2];
              return fn_of_padding_precision(k$0, o, rest$7, pad, prec);
            case 5:
              var rest$8 = fmt$0[4], prec$0 = fmt$0[3], pad$0 = fmt$0[2];
              return fn_of_padding_precision(k$0, o, rest$8, pad$0, prec$0);
            case 6:
              var rest$9 = fmt$0[4], prec$1 = fmt$0[3], pad$1 = fmt$0[2];
              return fn_of_padding_precision(k$0, o, rest$9, pad$1, prec$1);
            case 7:
              var rest$10 = fmt$0[4], prec$2 = fmt$0[3], pad$2 = fmt$0[2];
              return fn_of_padding_precision(k$0, o, rest$10, pad$2, prec$2);
            case 8:
              var rest$11 = fmt$0[4], prec$3 = fmt$0[3], pad$3 = fmt$0[2];
              return fn_of_padding_precision(k$0, o, rest$11, pad$3, prec$3);
            case 9:
              var _cc_ = fmt$0[1];
              if (typeof _cc_ === "number") {
                var rest$12 = fmt$0[2], _cd_ = make_iprintf(k$0, o, rest$12);
                return function(_cA_) {
                  return _cd_;
                };
              }
              if (0 === _cc_[0]) {
                var rest$13 = fmt$0[2], _ce_ = make_iprintf(k$0, o, rest$13);
                return function(_cz_) {
                  return _ce_;
                };
              }
              var rest$14 = fmt$0[2], _cf_ = make_iprintf(k$0, o, rest$14), _cg_ = function(_cy_) {
                return _cf_;
              };
              return function(_cx_) {
                return _cg_;
              };
            case 10:
              var rest$15 = fmt$0[1], fmt$0 = rest$15;
              break;
            case 11:
              var rest$16 = fmt$0[2], fmt$0 = rest$16;
              break;
            case 12:
              var rest$17 = fmt$0[2], fmt$0 = rest$17;
              break;
            case 13:
              var rest$18 = fmt$0[3], _ch_ = make_iprintf(k$0, o, rest$18);
              return function(_cw_) {
                return _ch_;
              };
            case 14:
              var rest$19 = fmt$0[3], fmtty = fmt$0[2];
              return function(param) {
                var fmt2 = param[1], _cv_ = recast(fmt2, fmtty);
                return make_iprintf(
                  k$0,
                  o,
                  caml_call2(CamlinternalFormatBasics[3], _cv_, rest$19)
                );
              };
            case 15:
              var rest$20 = fmt$0[1], _ci_ = make_iprintf(k$0, o, rest$20), _cj_ = function(_cu_) {
                return _ci_;
              };
              return function(_ct_) {
                return _cj_;
              };
            case 16:
              var rest$21 = fmt$0[1], _ck_ = make_iprintf(k$0, o, rest$21);
              return function(_cs_) {
                return _ck_;
              };
            case 17:
              var rest$22 = fmt$0[2], fmt$0 = rest$22;
              break;
            case 18:
              var _cl_ = fmt$0[1];
              if (0 === _cl_[0]) {
                var rest$23 = fmt$0[2], fmt$1 = _cl_[1][1];
                let k2 = k$0, rest2 = rest$23;
                var k$1 = function(koc) {
                  return make_iprintf(k2, koc, rest2);
                }, k$0 = k$1, fmt$0 = fmt$1;
              } else {
                var rest$24 = fmt$0[2], fmt$2 = _cl_[1][1];
                let k2 = k$0, rest2 = rest$24;
                var k$2 = function(koc) {
                  return make_iprintf(k2, koc, rest2);
                }, k$0 = k$2, fmt$0 = fmt$2;
              }
              break;
            case 19:
              throw caml_maybe_attach_backtrace2([0, Assert_failure, _w_], 1);
            case 20:
              var rest$25 = fmt$0[3], _cm_ = make_iprintf(k$0, o, rest$25);
              return function(_cr_) {
                return _cm_;
              };
            case 21:
              var rest$26 = fmt$0[2], _cn_ = make_iprintf(k$0, o, rest$26);
              return function(_cq_) {
                return _cn_;
              };
            case 22:
              var rest$27 = fmt$0[1], _co_ = make_iprintf(k$0, o, rest$27);
              return function(_cp_) {
                return _co_;
              };
            case 23:
              var rest$28 = fmt$0[2], ign = fmt$0[1];
              return make_ignored_param(function(param) {
                return caml_call1(k$0, o);
              }, 0, ign, rest$28);
            default:
              var rest$29 = fmt$0[3], arity = fmt$0[1];
              if (counter >= 50)
                return caml_trampoline_return2(fn_of_custom_arity$0, [0, k$0, o, rest$29, arity]);
              var counter$0 = counter + 1 | 0;
              return fn_of_custom_arity$0(counter$0, k$0, o, rest$29, arity);
          }
        }
      }
      function make_iprintf(k, o, fmt) {
        return caml_trampoline2(make_iprintf$0(0, k, o, fmt));
      }
      function fn_of_padding_precision(k, o, fmt, pad, prec) {
        if (typeof pad === "number") {
          if (typeof prec !== "number") {
            var _bB_ = make_iprintf(k, o, fmt);
            return function(_b1_) {
              return _bB_;
            };
          }
          if (prec) {
            var _by_ = make_iprintf(k, o, fmt), _bz_ = function(_b0_) {
              return _by_;
            };
            return function(_bZ_) {
              return _bz_;
            };
          }
          var _bA_ = make_iprintf(k, o, fmt);
          return function(_bY_) {
            return _bA_;
          };
        }
        if (0 === pad[0]) {
          if (typeof prec !== "number") {
            var _bF_ = make_iprintf(k, o, fmt);
            return function(_bX_) {
              return _bF_;
            };
          }
          if (prec) {
            var _bC_ = make_iprintf(k, o, fmt), _bD_ = function(_bW_) {
              return _bC_;
            };
            return function(_bV_) {
              return _bD_;
            };
          }
          var _bE_ = make_iprintf(k, o, fmt);
          return function(_bU_) {
            return _bE_;
          };
        }
        if (typeof prec !== "number") {
          var _bL_ = make_iprintf(k, o, fmt), _bM_ = function(_bT_) {
            return _bL_;
          };
          return function(_bS_) {
            return _bM_;
          };
        }
        if (prec) {
          var _bG_ = make_iprintf(k, o, fmt), _bH_ = function(_bR_) {
            return _bG_;
          }, _bI_ = function(_bQ_) {
            return _bH_;
          };
          return function(_bP_) {
            return _bI_;
          };
        }
        var _bJ_ = make_iprintf(k, o, fmt);
        function _bK_(_bO_) {
          return _bJ_;
        }
        return function(_bN_) {
          return _bK_;
        };
      }
      function fn_of_custom_arity$0(counter, k, o, fmt, param) {
        if (param) {
          var arity = param[1], _bw_ = fn_of_custom_arity(k, o, fmt, arity);
          return function(_bx_) {
            return _bw_;
          };
        }
        if (counter >= 50)
          return caml_trampoline_return2(make_iprintf$0, [0, k, o, fmt]);
        var counter$0 = counter + 1 | 0;
        return make_iprintf$0(counter$0, k, o, fmt);
      }
      function fn_of_custom_arity(k, o, fmt, param) {
        return caml_trampoline2(fn_of_custom_arity$0(0, k, o, fmt, param));
      }
      function output_acc(o, acc) {
        var acc$0 = acc;
        for (; ; ) {
          if (typeof acc$0 === "number")
            return 0;
          switch (acc$0[0]) {
            case 0:
              var fmting_lit = acc$0[2], p = acc$0[1], s2 = string_of_formatting_lit(fmting_lit);
              output_acc(o, p);
              return caml_call2(Stdlib[66], o, s2);
            case 1:
              var match = acc$0[2], p$0 = acc$0[1];
              if (0 === match[0]) {
                var acc$1 = match[1];
                output_acc(o, p$0);
                caml_call2(Stdlib[66], o, cst$18);
                var acc$0 = acc$1;
              } else {
                var acc$2 = match[1];
                output_acc(o, p$0);
                caml_call2(Stdlib[66], o, cst$19);
                var acc$0 = acc$2;
              }
              break;
            case 6:
              var f = acc$0[2], p$3 = acc$0[1];
              output_acc(o, p$3);
              return caml_call1(f, o);
            case 7:
              var p$4 = acc$0[1];
              output_acc(o, p$4);
              return caml_call1(Stdlib[63], o);
            case 8:
              var msg = acc$0[2], p$5 = acc$0[1];
              output_acc(o, p$5);
              return caml_call1(Stdlib[1], msg);
            case 2:
            case 4:
              var s$0 = acc$0[2], p$1 = acc$0[1];
              output_acc(o, p$1);
              return caml_call2(Stdlib[66], o, s$0);
            default:
              var c = acc$0[2], p$2 = acc$0[1];
              output_acc(o, p$2);
              return caml_call2(Stdlib[65], o, c);
          }
        }
      }
      function bufput_acc(b, acc) {
        var acc$0 = acc;
        for (; ; ) {
          if (typeof acc$0 === "number")
            return 0;
          switch (acc$0[0]) {
            case 0:
              var fmting_lit = acc$0[2], p = acc$0[1], s2 = string_of_formatting_lit(fmting_lit);
              bufput_acc(b, p);
              return caml_call2(Stdlib_Buffer[16], b, s2);
            case 1:
              var match = acc$0[2], p$0 = acc$0[1];
              if (0 === match[0]) {
                var acc$1 = match[1];
                bufput_acc(b, p$0);
                caml_call2(Stdlib_Buffer[16], b, cst$20);
                var acc$0 = acc$1;
              } else {
                var acc$2 = match[1];
                bufput_acc(b, p$0);
                caml_call2(Stdlib_Buffer[16], b, cst$21);
                var acc$0 = acc$2;
              }
              break;
            case 6:
              var f = acc$0[2], p$3 = acc$0[1];
              bufput_acc(b, p$3);
              return caml_call1(f, b);
            case 7:
              var acc$3 = acc$0[1], acc$0 = acc$3;
              break;
            case 8:
              var msg = acc$0[2], p$4 = acc$0[1];
              bufput_acc(b, p$4);
              return caml_call1(Stdlib[1], msg);
            case 2:
            case 4:
              var s$0 = acc$0[2], p$1 = acc$0[1];
              bufput_acc(b, p$1);
              return caml_call2(Stdlib_Buffer[16], b, s$0);
            default:
              var c = acc$0[2], p$2 = acc$0[1];
              bufput_acc(b, p$2);
              return caml_call2(Stdlib_Buffer[12], b, c);
          }
        }
      }
      function strput_acc(b, acc) {
        var acc$0 = acc;
        for (; ; ) {
          if (typeof acc$0 === "number")
            return 0;
          switch (acc$0[0]) {
            case 0:
              var fmting_lit = acc$0[2], p = acc$0[1], s2 = string_of_formatting_lit(fmting_lit);
              strput_acc(b, p);
              return caml_call2(Stdlib_Buffer[16], b, s2);
            case 1:
              var match = acc$0[2], p$0 = acc$0[1];
              if (0 === match[0]) {
                var acc$1 = match[1];
                strput_acc(b, p$0);
                caml_call2(Stdlib_Buffer[16], b, cst$22);
                var acc$0 = acc$1;
              } else {
                var acc$2 = match[1];
                strput_acc(b, p$0);
                caml_call2(Stdlib_Buffer[16], b, cst$23);
                var acc$0 = acc$2;
              }
              break;
            case 6:
              var f = acc$0[2], p$3 = acc$0[1];
              strput_acc(b, p$3);
              var _bv_ = caml_call1(f, 0);
              return caml_call2(Stdlib_Buffer[16], b, _bv_);
            case 7:
              var acc$3 = acc$0[1], acc$0 = acc$3;
              break;
            case 8:
              var msg = acc$0[2], p$4 = acc$0[1];
              strput_acc(b, p$4);
              return caml_call1(Stdlib[1], msg);
            case 2:
            case 4:
              var s$0 = acc$0[2], p$1 = acc$0[1];
              strput_acc(b, p$1);
              return caml_call2(Stdlib_Buffer[16], b, s$0);
            default:
              var c = acc$0[2], p$2 = acc$0[1];
              strput_acc(b, p$2);
              return caml_call2(Stdlib_Buffer[12], b, c);
          }
        }
      }
      function failwith_message(param) {
        var fmt = param[1], buf = caml_call1(Stdlib_Buffer[1], 256);
        function k(acc) {
          strput_acc(buf, acc);
          var _bu_ = caml_call1(Stdlib_Buffer[2], buf);
          return caml_call1(Stdlib[2], _bu_);
        }
        return make_printf(k, 0, fmt);
      }
      function open_box_of_string(str) {
        if (runtime.caml_string_equal(str, cst$43))
          return _x_;
        var len = caml_ml_string_length2(str);
        function invalid_box(param) {
          return caml_call1(failwith_message(_y_), str);
        }
        function parse_spaces(i) {
          var i$0 = i;
          for (; ; ) {
            if (i$0 === len)
              return i$0;
            var match2 = caml_string_get2(str, i$0);
            if (9 !== match2 && 32 !== match2)
              return i$0;
            var i$1 = i$0 + 1 | 0, i$0 = i$1;
          }
        }
        var wstart = parse_spaces(0);
        a:
          b: {
            var wend = wstart;
            for (; ; ) {
              if (wend === len)
                break b;
              if (25 < caml_string_get2(str, wend) - 97 >>> 0)
                break;
              var j = wend + 1 | 0, wend = j;
            }
            break a;
          }
        var box_name = caml_call3(Stdlib_String[16], str, wstart, wend - wstart | 0), nstart = parse_spaces(wend);
        a:
          b: {
            var nend = nstart;
            for (; ; ) {
              if (nend === len)
                break b;
              var match = caml_string_get2(str, nend);
              if (48 <= match) {
                if (58 <= match)
                  break;
              } else if (45 !== match)
                break;
              var j$0 = nend + 1 | 0, nend = j$0;
            }
            break a;
          }
        if (nstart === nend)
          var indent = 0;
        else
          try {
            var _bs_ = runtime.caml_int_of_string(caml_call3(Stdlib_String[16], str, nstart, nend - nstart | 0)), indent = _bs_;
          } catch (_bt_) {
            var _br_ = caml_wrap_exception2(_bt_);
            if (_br_[1] !== Stdlib[7])
              throw caml_maybe_attach_backtrace2(_br_, 0);
            var indent = invalid_box(0);
          }
        var exp_end = parse_spaces(nend);
        if (exp_end !== len)
          invalid_box(0);
        a: {
          if (caml_string_notequal2(box_name, cst$43) && caml_string_notequal2(box_name, "b")) {
            if (!caml_string_notequal2(box_name, "h")) {
              var box_type = 0;
              break a;
            }
            if (!caml_string_notequal2(box_name, "hov")) {
              var box_type = 3;
              break a;
            }
            if (!caml_string_notequal2(box_name, "hv")) {
              var box_type = 2;
              break a;
            }
            if (caml_string_notequal2(box_name, "v")) {
              var box_type = invalid_box(0);
              break a;
            }
            var box_type = 1;
            break a;
          }
          var box_type = 4;
        }
        return [0, indent, box_type];
      }
      function make_padding_fmt_ebb(pad, fmt) {
        if (typeof pad === "number")
          return [0, 0, fmt];
        if (0 === pad[0]) {
          var w = pad[2], s2 = pad[1];
          return [0, [0, s2, w], fmt];
        }
        var s$0 = pad[1];
        return [0, [1, s$0], fmt];
      }
      function make_padprec_fmt_ebb(pad, prec, fmt) {
        if (typeof prec === "number")
          var match = prec ? [0, 1] : [0, 0];
        else
          var p = prec[1], match = [0, [0, p]];
        var prec$0 = match[1];
        if (typeof pad === "number")
          return [0, 0, prec$0, fmt];
        if (0 === pad[0]) {
          var w = pad[2], s2 = pad[1];
          return [0, [0, s2, w], prec$0, fmt];
        }
        var s$0 = pad[1];
        return [0, [1, s$0], prec$0, fmt];
      }
      function fmt_ebb_of_string(legacy_behavior, str) {
        if (legacy_behavior)
          var flag = legacy_behavior[1], legacy_behavior$0 = flag;
        else
          var legacy_behavior$0 = 1;
        function invalid_format_message(str_ind, msg) {
          return caml_call3(failwith_message(_z_), str, str_ind, msg);
        }
        function unexpected_end_of_format(end_ind) {
          return invalid_format_message(end_ind, cst_unexpected_end_of_format);
        }
        function invalid_format_without(str_ind, c, s2) {
          return caml_call4(failwith_message(_A_), str, str_ind, c, s2);
        }
        function expected_character(str_ind, expected, read) {
          return caml_call4(failwith_message(_B_), str, str_ind, expected, read);
        }
        function parse(lit_start, end_ind) {
          a: {
            var str_ind = lit_start;
            for (; ; ) {
              if (str_ind === end_ind)
                return add_literal(lit_start, str_ind, 0);
              var match = caml_string_get2(str, str_ind);
              if (37 === match)
                break;
              if (64 === match)
                break a;
              var str_ind$1 = str_ind + 1 | 0, str_ind = str_ind$1;
            }
            var str_ind$2 = str_ind + 1 | 0;
            if (str_ind$2 === end_ind)
              unexpected_end_of_format(end_ind);
            var match$1 = 95 === caml_string_get2(str, str_ind$2) ? parse_flags(str_ind, str_ind$2 + 1 | 0, end_ind, 1) : parse_flags(str_ind, str_ind$2, end_ind, 0), fmt_rest = match$1[1];
            return add_literal(lit_start, str_ind, fmt_rest);
          }
          var str_ind$0 = str_ind + 1 | 0;
          a:
            if (str_ind$0 === end_ind)
              var match$0 = _N_;
            else {
              var c = caml_string_get2(str, str_ind$0);
              if (65 <= c) {
                if (94 <= c) {
                  var switcher = c - 123 | 0;
                  if (2 >= switcher >>> 0)
                    switch (switcher) {
                      case 0:
                        var match$0 = parse_tag(1, str_ind$0 + 1 | 0, end_ind);
                        break a;
                      case 1:
                        break;
                      default:
                        var fmt_rest$2 = parse(str_ind$0 + 1 | 0, end_ind)[1], match$0 = [0, [17, 1, fmt_rest$2]];
                        break a;
                    }
                } else if (91 <= c)
                  switch (c - 91 | 0) {
                    case 0:
                      var match$0 = parse_tag(0, str_ind$0 + 1 | 0, end_ind);
                      break a;
                    case 1:
                      break;
                    default:
                      var fmt_rest$3 = parse(str_ind$0 + 1 | 0, end_ind)[1], match$0 = [0, [17, 0, fmt_rest$3]];
                      break a;
                  }
              } else {
                if (10 === c) {
                  var fmt_rest$4 = parse(str_ind$0 + 1 | 0, end_ind)[1], match$0 = [0, [17, 3, fmt_rest$4]];
                  break a;
                }
                if (32 <= c)
                  switch (c - 32 | 0) {
                    case 0:
                      var fmt_rest$5 = parse(str_ind$0 + 1 | 0, end_ind)[1], match$0 = [0, [17, _O_, fmt_rest$5]];
                      break a;
                    case 5:
                      if ((str_ind$0 + 1 | 0) < end_ind && 37 === caml_string_get2(str, str_ind$0 + 1 | 0)) {
                        var fmt_rest$6 = parse(str_ind$0 + 2 | 0, end_ind)[1], match$0 = [0, [17, 6, fmt_rest$6]];
                        break a;
                      }
                      var fmt_rest$7 = parse(str_ind$0, end_ind)[1], match$0 = [0, [12, 64, fmt_rest$7]];
                      break a;
                    case 12:
                      var fmt_rest$8 = parse(str_ind$0 + 1 | 0, end_ind)[1], match$0 = [0, [17, _P_, fmt_rest$8]];
                      break a;
                    case 14:
                      var fmt_rest$9 = parse(str_ind$0 + 1 | 0, end_ind)[1], match$0 = [0, [17, 4, fmt_rest$9]];
                      break a;
                    case 27:
                      var str_ind$3 = str_ind$0 + 1 | 0;
                      b:
                        try {
                          var _bg_ = str_ind$3 === end_ind ? 1 : 0, _bh_ = _bg_ || (60 !== caml_string_get2(str, str_ind$3) ? 1 : 0);
                          if (_bh_)
                            throw caml_maybe_attach_backtrace2(Stdlib[8], 1);
                          var str_ind_1 = parse_spaces(str_ind$3 + 1 | 0, end_ind), match$2 = caml_string_get2(str, str_ind_1);
                          c: {
                            if (48 <= match$2) {
                              if (58 > match$2)
                                break c;
                            } else if (45 === match$2)
                              break c;
                            throw caml_maybe_attach_backtrace2(Stdlib[8], 1);
                          }
                          var match$3 = parse_integer(str_ind_1, end_ind), width = match$3[2], str_ind_2 = match$3[1], str_ind_3 = parse_spaces(str_ind_2, end_ind), switcher$0 = caml_string_get2(str, str_ind_3) - 45 | 0;
                          if (12 < switcher$0 >>> 0) {
                            if (17 === switcher$0) {
                              var s2 = caml_call3(
                                Stdlib_String[16],
                                str,
                                str_ind$3 - 2 | 0,
                                (str_ind_3 - str_ind$3 | 0) + 3 | 0
                              ), _bi_ = [0, s2, width, 0], _bj_ = str_ind_3 + 1 | 0, formatting_lit$0 = _bi_, next_ind = _bj_;
                              break b;
                            }
                          } else if (1 < switcher$0 - 1 >>> 0) {
                            var match$4 = parse_integer(str_ind_3, end_ind), offset = match$4[2], str_ind_4 = match$4[1], str_ind_5 = parse_spaces(str_ind_4, end_ind);
                            if (62 !== caml_string_get2(str, str_ind_5))
                              throw caml_maybe_attach_backtrace2(Stdlib[8], 1);
                            var s$0 = caml_call3(
                              Stdlib_String[16],
                              str,
                              str_ind$3 - 2 | 0,
                              (str_ind_5 - str_ind$3 | 0) + 3 | 0
                            ), _bk_ = [0, s$0, width, offset], _bl_ = str_ind_5 + 1 | 0, formatting_lit$0 = _bk_, next_ind = _bl_;
                            break b;
                          }
                          throw caml_maybe_attach_backtrace2(Stdlib[8], 1);
                        } catch (_bq_) {
                          var _bf_ = caml_wrap_exception2(_bq_);
                          if (_bf_ !== Stdlib[8] && _bf_[1] !== Stdlib[7])
                            throw caml_maybe_attach_backtrace2(_bf_, 0);
                          var formatting_lit$0 = formatting_lit, next_ind = str_ind$3;
                        }
                      var fmt_rest$12 = parse(next_ind, end_ind)[1], match$0 = [0, [17, formatting_lit$0, fmt_rest$12]];
                      break a;
                    case 28:
                      var str_ind$4 = str_ind$0 + 1 | 0;
                      try {
                        var str_ind_1$0 = parse_spaces(str_ind$4, end_ind), match$6 = caml_string_get2(str, str_ind_1$0);
                        b: {
                          c: {
                            if (48 <= match$6) {
                              if (58 > match$6)
                                break c;
                            } else if (45 === match$6)
                              break c;
                            var _bo_ = 0;
                            break b;
                          }
                          var match$7 = parse_integer(str_ind_1$0, end_ind), size = match$7[2], str_ind_2$0 = match$7[1], str_ind_3$0 = parse_spaces(str_ind_2$0, end_ind);
                          if (62 !== caml_string_get2(str, str_ind_3$0))
                            throw caml_maybe_attach_backtrace2(Stdlib[8], 1);
                          var s$1 = caml_call3(
                            Stdlib_String[16],
                            str,
                            str_ind$4 - 2 | 0,
                            (str_ind_3$0 - str_ind$4 | 0) + 3 | 0
                          ), _bo_ = [0, [0, str_ind_3$0 + 1 | 0, [1, s$1, size]]];
                        }
                        var _bn_ = _bo_;
                      } catch (_bp_) {
                        var _bm_ = caml_wrap_exception2(_bp_);
                        if (_bm_ !== Stdlib[8] && _bm_[1] !== Stdlib[7])
                          throw caml_maybe_attach_backtrace2(_bm_, 0);
                        var _bn_ = 0;
                      }
                      if (_bn_)
                        var match$5 = _bn_[1], formatting_lit$1 = match$5[2], next_ind$0 = match$5[1], fmt_rest$13 = parse(next_ind$0, end_ind)[1], _be_ = [0, [17, formatting_lit$1, fmt_rest$13]];
                      else
                        var fmt_rest$14 = parse(str_ind$4, end_ind)[1], _be_ = [0, [17, _Q_, fmt_rest$14]];
                      var match$0 = _be_;
                      break a;
                    case 31:
                      var fmt_rest$10 = parse(str_ind$0 + 1 | 0, end_ind)[1], match$0 = [0, [17, 2, fmt_rest$10]];
                      break a;
                    case 32:
                      var fmt_rest$11 = parse(str_ind$0 + 1 | 0, end_ind)[1], match$0 = [0, [17, 5, fmt_rest$11]];
                      break a;
                  }
              }
              var fmt_rest$1 = parse(str_ind$0 + 1 | 0, end_ind)[1], match$0 = [0, [17, [2, c], fmt_rest$1]];
            }
          var fmt_rest$0 = match$0[1];
          return add_literal(lit_start, str_ind, fmt_rest$0);
        }
        function parse_flags(pct_ind, str_ind, end_ind, ign) {
          var zero = [0, 0], minus = [0, 0], plus = [0, 0], space = [0, 0], hash = [0, 0];
          function set_flag(str_ind2, flag2) {
            var _bb_ = flag2[1], _bc_ = _bb_ ? 1 - legacy_behavior$0 : _bb_;
            if (_bc_) {
              var _bd_ = caml_string_get2(str, str_ind2);
              caml_call3(failwith_message(_C_), str, str_ind2, _bd_);
            }
            flag2[1] = 1;
            return;
          }
          a:
            b: {
              var str_ind$0 = str_ind;
              c:
                for (; ; ) {
                  if (str_ind$0 === end_ind)
                    unexpected_end_of_format(end_ind);
                  var switcher = caml_string_get2(str, str_ind$0) - 32 | 0;
                  if (16 < switcher >>> 0)
                    break b;
                  switch (switcher) {
                    case 0:
                      set_flag(str_ind$0, space);
                      var str_ind$1 = str_ind$0 + 1 | 0, str_ind$0 = str_ind$1;
                      break;
                    case 3:
                      set_flag(str_ind$0, hash);
                      var str_ind$2 = str_ind$0 + 1 | 0, str_ind$0 = str_ind$2;
                      break;
                    case 11:
                      set_flag(str_ind$0, plus);
                      var str_ind$3 = str_ind$0 + 1 | 0, str_ind$0 = str_ind$3;
                      break;
                    case 13:
                      set_flag(str_ind$0, minus);
                      var str_ind$4 = str_ind$0 + 1 | 0, str_ind$0 = str_ind$4;
                      break;
                    case 16:
                      set_flag(str_ind$0, zero);
                      var str_ind$5 = str_ind$0 + 1 | 0, str_ind$0 = str_ind$5;
                      break;
                    default:
                      break c;
                  }
                }
              break a;
            }
          var space$0 = space[1], hash$0 = hash[1], plus$0 = plus[1], minus$0 = minus[1], zero$0 = zero[1];
          if (str_ind$0 === end_ind)
            unexpected_end_of_format(end_ind);
          var padty = zero$0 ? minus$0 ? legacy_behavior$0 ? 0 : incompatible_flag(pct_ind, str_ind$0, 45, cst_0) : 2 : minus$0 ? 0 : 1, match = caml_string_get2(str, str_ind$0);
          if (48 <= match) {
            if (58 > match) {
              var match$0 = parse_positive(str_ind$0, end_ind, 0), width = match$0[2], new_ind = match$0[1];
              return parse_after_padding(
                pct_ind,
                new_ind,
                end_ind,
                minus$0,
                plus$0,
                hash$0,
                space$0,
                ign,
                [0, padty, width]
              );
            }
          } else if (42 === match)
            return parse_after_padding(
              pct_ind,
              str_ind$0 + 1 | 0,
              end_ind,
              minus$0,
              plus$0,
              hash$0,
              space$0,
              ign,
              [1, padty]
            );
          switch (padty) {
            case 0:
              if (1 - legacy_behavior$0)
                invalid_format_without(str_ind$0 - 1 | 0, 45, cst_padding);
              return parse_after_padding(
                pct_ind,
                str_ind$0,
                end_ind,
                minus$0,
                plus$0,
                hash$0,
                space$0,
                ign,
                0
              );
            case 1:
              return parse_after_padding(
                pct_ind,
                str_ind$0,
                end_ind,
                minus$0,
                plus$0,
                hash$0,
                space$0,
                ign,
                0
              );
            default:
              return parse_after_padding(
                pct_ind,
                str_ind$0,
                end_ind,
                minus$0,
                plus$0,
                hash$0,
                space$0,
                ign,
                _D_
              );
          }
        }
        function parse_after_padding(pct_ind, str_ind, end_ind, minus, plus, hash, space, ign, pad) {
          if (str_ind === end_ind)
            unexpected_end_of_format(end_ind);
          var symb = caml_string_get2(str, str_ind);
          if (46 !== symb)
            return parse_conversion(
              pct_ind,
              str_ind + 1 | 0,
              end_ind,
              plus,
              hash,
              space,
              ign,
              pad,
              0,
              pad,
              symb
            );
          var str_ind$0 = str_ind + 1 | 0;
          if (str_ind$0 === end_ind)
            unexpected_end_of_format(end_ind);
          function parse_literal(minus2, str_ind2) {
            var match = parse_positive(str_ind2, end_ind, 0), prec = match[2], new_ind = match[1];
            return parse_after_precision(
              pct_ind,
              new_ind,
              end_ind,
              minus2,
              plus,
              hash,
              space,
              ign,
              pad,
              [0, prec]
            );
          }
          var symb$0 = caml_string_get2(str, str_ind$0);
          if (48 <= symb$0) {
            if (58 > symb$0)
              return parse_literal(minus, str_ind$0);
          } else if (42 <= symb$0)
            switch (symb$0 - 42 | 0) {
              case 0:
                return parse_after_precision(
                  pct_ind,
                  str_ind$0 + 1 | 0,
                  end_ind,
                  minus,
                  plus,
                  hash,
                  space,
                  ign,
                  pad,
                  1
                );
              case 1:
              case 3:
                if (legacy_behavior$0) {
                  var _ba_ = str_ind$0 + 1 | 0, minus$0 = minus || (45 === symb$0 ? 1 : 0);
                  return parse_literal(minus$0, _ba_);
                }
                break;
            }
          return legacy_behavior$0 ? parse_after_precision(
            pct_ind,
            str_ind$0,
            end_ind,
            minus,
            plus,
            hash,
            space,
            ign,
            pad,
            _E_
          ) : invalid_format_without(str_ind$0 - 1 | 0, 46, cst_precision);
        }
        function parse_after_precision(pct_ind, str_ind, end_ind, minus, plus, hash, space, ign, pad, prec) {
          if (str_ind === end_ind)
            unexpected_end_of_format(end_ind);
          function parse_conv(padprec) {
            return parse_conversion(
              pct_ind,
              str_ind + 1 | 0,
              end_ind,
              plus,
              hash,
              space,
              ign,
              pad,
              prec,
              padprec,
              caml_string_get2(str, str_ind)
            );
          }
          if (typeof pad !== "number")
            return parse_conv(pad);
          if (typeof prec === "number" && !prec)
            return parse_conv(0);
          if (minus) {
            if (typeof prec === "number")
              return parse_conv(_F_);
            var n = prec[1];
            return parse_conv([0, 0, n]);
          }
          if (typeof prec === "number")
            return parse_conv(_G_);
          var n$0 = prec[1];
          return parse_conv([0, 1, n$0]);
        }
        function parse_conversion(pct_ind, str_ind, end_ind, plus, hash, space, ign, pad, prec, padprec, symb) {
          var plus_used = [0, 0], hash_used = [0, 0], space_used = [0, 0], ign_used = [0, 0], pad_used = [0, 0], prec_used = [0, 0];
          function get_plus(param) {
            plus_used[1] = 1;
            return plus;
          }
          function get_hash(param) {
            hash_used[1] = 1;
            return hash;
          }
          function get_space(param) {
            space_used[1] = 1;
            return space;
          }
          function get_ign(param) {
            ign_used[1] = 1;
            return ign;
          }
          function get_pad(param) {
            pad_used[1] = 1;
            return pad;
          }
          function get_prec(param) {
            prec_used[1] = 1;
            return prec;
          }
          function get_padprec(param) {
            pad_used[1] = 1;
            return padprec;
          }
          function get_int_pad(param) {
            var pad2 = get_pad(0), match2 = get_prec(0);
            if (typeof match2 === "number" && !match2)
              return pad2;
            if (typeof pad2 === "number")
              return 0;
            if (0 !== pad2[0])
              return 2 <= pad2[1] ? legacy_behavior$0 ? _H_ : incompatible_flag(pct_ind, str_ind, 48, cst_precision$1) : pad2;
            if (2 > pad2[1])
              return pad2;
            var n = pad2[2];
            return legacy_behavior$0 ? [0, 1, n] : incompatible_flag(pct_ind, str_ind, 48, cst_precision$0);
          }
          function check_no_0(symb2, pad2) {
            if (typeof pad2 === "number")
              return pad2;
            if (0 !== pad2[0])
              return 2 <= pad2[1] ? legacy_behavior$0 ? _I_ : incompatible_flag(pct_ind, str_ind, symb2, cst_0$1) : pad2;
            if (2 > pad2[1])
              return pad2;
            var width = pad2[2];
            return legacy_behavior$0 ? [0, 1, width] : incompatible_flag(pct_ind, str_ind, symb2, cst_0$0);
          }
          function opt_of_pad(c2, pad2) {
            if (typeof pad2 === "number")
              return 0;
            if (0 === pad2[0])
              switch (pad2[1]) {
                case 0:
                  var width = pad2[2];
                  return legacy_behavior$0 ? [0, width] : incompatible_flag(pct_ind, str_ind, c2, cst$24);
                case 1:
                  var width$0 = pad2[2];
                  return [0, width$0];
                default:
                  var width$1 = pad2[2];
                  return legacy_behavior$0 ? [0, width$1] : incompatible_flag(pct_ind, str_ind, c2, cst_0$2);
              }
            return incompatible_flag(pct_ind, str_ind, c2, cst$25);
          }
          function get_pad_opt(c2) {
            return opt_of_pad(c2, get_pad(0));
          }
          function get_padprec_opt(c2) {
            return opt_of_pad(c2, get_padprec(0));
          }
          a: {
            if (124 > symb)
              switch (symb) {
                case 33:
                  var fmt_rest$5 = parse(str_ind, end_ind)[1], fmt_result = [0, [10, fmt_rest$5]];
                  break a;
                case 40:
                  var sub_end = search_subformat_end(str_ind, end_ind, 41), fmt_rest$7 = parse(sub_end + 2 | 0, end_ind)[1], sub_fmt = parse(str_ind, sub_end)[1], sub_fmtty = fmtty_of_fmt(sub_fmt);
                  if (get_ign(0))
                    var ignored$2 = [9, get_pad_opt(95), sub_fmtty], _aJ_ = [0, [23, ignored$2, fmt_rest$7]];
                  else
                    var _aJ_ = [0, [14, get_pad_opt(40), sub_fmtty, fmt_rest$7]];
                  var fmt_result = _aJ_;
                  break a;
                case 44:
                  var fmt_result = parse(str_ind, end_ind);
                  break a;
                case 67:
                  var fmt_rest$10 = parse(str_ind, end_ind)[1], _aL_ = get_ign(0) ? [0, [23, 1, fmt_rest$10]] : [0, [1, fmt_rest$10]], fmt_result = _aL_;
                  break a;
                case 78:
                  var fmt_rest$14 = parse(str_ind, end_ind)[1], counter$0 = 2;
                  if (get_ign(0))
                    var ignored$6 = [11, counter$0], _aR_ = [0, [23, ignored$6, fmt_rest$14]];
                  else
                    var _aR_ = [0, [21, counter$0, fmt_rest$14]];
                  var fmt_result = _aR_;
                  break a;
                case 83:
                  var pad$6 = check_no_0(symb, get_padprec(0)), fmt_rest$15 = parse(str_ind, end_ind)[1];
                  if (get_ign(0))
                    var ignored$7 = [1, get_padprec_opt(95)], _aS_ = [0, [23, ignored$7, fmt_rest$15]];
                  else
                    var match$5 = make_padding_fmt_ebb(pad$6, fmt_rest$15), fmt_rest$16 = match$5[2], pad$7 = match$5[1], _aS_ = [0, [3, pad$7, fmt_rest$16]];
                  var fmt_result = _aS_;
                  break a;
                case 91:
                  if (str_ind === end_ind)
                    unexpected_end_of_format(end_ind);
                  var char_set = create_char_set(0), add_char = function(c2) {
                    return add_in_char_set(char_set, c2);
                  }, add_range = function(c$0, c2) {
                    if (c2 >= c$0) {
                      var i = c$0;
                      for (; ; ) {
                        add_in_char_set(char_set, caml_call1(Stdlib[29], i));
                        var _a$_ = i + 1 | 0;
                        if (c2 === i)
                          break;
                        var i = _a$_;
                      }
                    }
                    return;
                  }, fail_single_percent = function(str_ind2) {
                    return caml_call2(failwith_message(_R_), str, str_ind2);
                  }, parse_char_set_content = function(counter2, str_ind2, end_ind2) {
                    var str_ind$02 = str_ind2;
                    for (; ; ) {
                      if (str_ind$02 === end_ind2)
                        unexpected_end_of_format(end_ind2);
                      var c2 = caml_string_get2(str, str_ind$02);
                      if (45 !== c2) {
                        if (93 === c2)
                          return str_ind$02 + 1 | 0;
                        var _a__ = str_ind$02 + 1 | 0;
                        if (counter2 >= 50)
                          return caml_trampoline_return2(parse_char_set_after_char$0, [0, _a__, end_ind2, c2]);
                        var counter$02 = counter2 + 1 | 0;
                        return parse_char_set_after_char$0(counter$02, _a__, end_ind2, c2);
                      }
                      add_char(45);
                      var str_ind$12 = str_ind$02 + 1 | 0, str_ind$02 = str_ind$12;
                    }
                  }, parse_char_set_after_char$0 = function(counter2, str_ind2, end_ind2, c2) {
                    var str_ind$02 = str_ind2, c$0 = c2;
                    for (; ; ) {
                      if (str_ind$02 === end_ind2)
                        unexpected_end_of_format(end_ind2);
                      var c$1 = caml_string_get2(str, str_ind$02);
                      a: {
                        if (46 <= c$1) {
                          if (64 !== c$1) {
                            if (93 !== c$1)
                              break a;
                            add_char(c$0);
                            return str_ind$02 + 1 | 0;
                          }
                        } else if (37 !== c$1) {
                          if (45 > c$1)
                            break a;
                          var str_ind$2 = str_ind$02 + 1 | 0;
                          if (str_ind$2 === end_ind2)
                            unexpected_end_of_format(end_ind2);
                          var c$2 = caml_string_get2(str, str_ind$2);
                          if (37 === c$2) {
                            if ((str_ind$2 + 1 | 0) === end_ind2)
                              unexpected_end_of_format(end_ind2);
                            var c$3 = caml_string_get2(str, str_ind$2 + 1 | 0);
                            if (37 !== c$3 && 64 !== c$3)
                              return fail_single_percent(str_ind$2);
                            add_range(c$0, c$3);
                            var _a8_ = str_ind$2 + 2 | 0;
                            if (counter2 >= 50)
                              return caml_trampoline_return2(parse_char_set_content, [0, _a8_, end_ind2]);
                            var counter$2 = counter2 + 1 | 0;
                            return parse_char_set_content(counter$2, _a8_, end_ind2);
                          }
                          if (93 === c$2) {
                            add_char(c$0);
                            add_char(45);
                            return str_ind$2 + 1 | 0;
                          }
                          add_range(c$0, c$2);
                          var _a9_ = str_ind$2 + 1 | 0;
                          if (counter2 >= 50)
                            return caml_trampoline_return2(parse_char_set_content, [0, _a9_, end_ind2]);
                          var counter$1 = counter2 + 1 | 0;
                          return parse_char_set_content(counter$1, _a9_, end_ind2);
                        }
                        if (37 === c$0) {
                          add_char(c$1);
                          var _a7_ = str_ind$02 + 1 | 0;
                          if (counter2 >= 50)
                            return caml_trampoline_return2(parse_char_set_content, [0, _a7_, end_ind2]);
                          var counter$02 = counter2 + 1 | 0;
                          return parse_char_set_content(counter$02, _a7_, end_ind2);
                        }
                      }
                      if (37 === c$0)
                        fail_single_percent(str_ind$02);
                      add_char(c$0);
                      var str_ind$12 = str_ind$02 + 1 | 0, str_ind$02 = str_ind$12, c$0 = c$1;
                    }
                  }, parse_char_set_after_char = function(str_ind2, end_ind2, c2) {
                    return caml_trampoline2(parse_char_set_after_char$0(0, str_ind2, end_ind2, c2));
                  };
                  if (str_ind === end_ind)
                    unexpected_end_of_format(end_ind);
                  if (94 === caml_string_get2(str, str_ind))
                    var str_ind$0 = str_ind + 1 | 0, reverse = 1, str_ind$1 = str_ind$0;
                  else
                    var reverse = 0, str_ind$1 = str_ind;
                  if (str_ind$1 === end_ind)
                    unexpected_end_of_format(end_ind);
                  var c = caml_string_get2(str, str_ind$1), next_ind = parse_char_set_after_char(str_ind$1 + 1 | 0, end_ind, c), char_set$0 = freeze_char_set(char_set), char_set$1 = reverse ? rev_char_set(char_set$0) : char_set$0, fmt_rest$19 = parse(next_ind, end_ind)[1];
                  if (get_ign(0))
                    var ignored$9 = [10, get_pad_opt(95), char_set$1], _aX_ = [0, [23, ignored$9, fmt_rest$19]];
                  else
                    var _aX_ = [0, [20, get_pad_opt(91), char_set$1, fmt_rest$19]];
                  var fmt_result = _aX_;
                  break a;
                case 97:
                  var fmt_rest$20 = parse(str_ind, end_ind)[1], fmt_result = [0, [15, fmt_rest$20]];
                  break a;
                case 99:
                  var char_format = function(fmt_rest2) {
                    return get_ign(0) ? [0, [23, 0, fmt_rest2]] : [0, [0, fmt_rest2]];
                  }, fmt_rest$21 = parse(str_ind, end_ind)[1], match$7 = get_pad_opt(99);
                  if (match$7) {
                    if (0 === match$7[1])
                      var _aY_ = get_ign(0) ? [0, [23, 3, fmt_rest$21]] : [0, [22, fmt_rest$21]], _aZ_ = _aY_;
                    else
                      var _aZ_ = legacy_behavior$0 ? char_format(fmt_rest$21) : invalid_format_message(str_ind, cst_non_zero_widths_are_unsupp);
                    var _a0_ = _aZ_;
                  } else
                    var _a0_ = char_format(fmt_rest$21);
                  var fmt_result = _a0_;
                  break a;
                case 114:
                  var fmt_rest$22 = parse(str_ind, end_ind)[1], _a1_ = get_ign(0) ? [0, [23, 2, fmt_rest$22]] : [0, [19, fmt_rest$22]], fmt_result = _a1_;
                  break a;
                case 115:
                  var pad$9 = check_no_0(symb, get_padprec(0)), fmt_rest$23 = parse(str_ind, end_ind)[1];
                  if (get_ign(0))
                    var ignored$10 = [0, get_padprec_opt(95)], _a2_ = [0, [23, ignored$10, fmt_rest$23]];
                  else
                    var match$8 = make_padding_fmt_ebb(pad$9, fmt_rest$23), fmt_rest$24 = match$8[2], pad$10 = match$8[1], _a2_ = [0, [2, pad$10, fmt_rest$24]];
                  var fmt_result = _a2_;
                  break a;
                case 116:
                  var fmt_rest$25 = parse(str_ind, end_ind)[1], fmt_result = [0, [16, fmt_rest$25]];
                  break a;
                case 123:
                  var sub_end$0 = search_subformat_end(str_ind, end_ind, 125), sub_fmt$0 = parse(str_ind, sub_end$0)[1], fmt_rest$26 = parse(sub_end$0 + 2 | 0, end_ind)[1], sub_fmtty$0 = fmtty_of_fmt(sub_fmt$0);
                  if (get_ign(0))
                    var ignored$11 = [8, get_pad_opt(95), sub_fmtty$0], _a3_ = [0, [23, ignored$11, fmt_rest$26]];
                  else
                    var _a3_ = [0, [13, get_pad_opt(123), sub_fmtty$0, fmt_rest$26]];
                  var fmt_result = _a3_;
                  break a;
                case 66:
                case 98:
                  var pad$3 = check_no_0(symb, get_padprec(0)), fmt_rest$8 = parse(str_ind, end_ind)[1];
                  if (get_ign(0))
                    var ignored$3 = [7, get_padprec_opt(95)], _aK_ = [0, [23, ignored$3, fmt_rest$8]];
                  else
                    var match$3 = make_padding_fmt_ebb(pad$3, fmt_rest$8), fmt_rest$9 = match$3[2], pad$4 = match$3[1], _aK_ = [0, [9, pad$4, fmt_rest$9]];
                  var fmt_result = _aK_;
                  break a;
                case 37:
                case 64:
                  var fmt_rest$6 = parse(str_ind, end_ind)[1], fmt_result = [0, [12, symb, fmt_rest$6]];
                  break a;
                case 76:
                case 108:
                case 110:
                  if (str_ind !== end_ind) {
                    var symb$0 = caml_string_get2(str, str_ind), _a4_ = symb$0 - 88 | 0;
                    b: {
                      if (32 >= _a4_ >>> 0)
                        switch (_a4_) {
                          case 0:
                          case 12:
                          case 17:
                          case 23:
                          case 29:
                          case 32:
                            var _aQ_ = 1;
                            break b;
                        }
                      var _aQ_ = 0;
                    }
                    if (_aQ_)
                      break;
                  }
                  var fmt_rest$13 = parse(str_ind, end_ind)[1];
                  b: {
                    if (108 <= symb) {
                      if (111 > symb)
                        switch (symb - 108 | 0) {
                          case 0:
                            var counter = 0;
                            break b;
                          case 1:
                            break;
                          default:
                            var counter = 1;
                            break b;
                        }
                    } else if (76 === symb) {
                      var counter = 2;
                      break b;
                    }
                    throw caml_maybe_attach_backtrace2([0, Assert_failure, _V_], 1);
                  }
                  if (get_ign(0))
                    var ignored$5 = [11, counter], _aP_ = [0, [23, ignored$5, fmt_rest$13]];
                  else
                    var _aP_ = [0, [21, counter, fmt_rest$13]];
                  var fmt_result = _aP_;
                  break a;
                case 32:
                case 35:
                case 43:
                case 45:
                case 95:
                  var fmt_result = caml_call3(failwith_message(_M_), str, pct_ind, symb);
                  break a;
                case 88:
                case 100:
                case 105:
                case 111:
                case 117:
                case 120:
                  var _aT_ = get_space(0), _aU_ = get_hash(0), iconv$2 = compute_int_conv(pct_ind, str_ind, get_plus(0), _aU_, _aT_, symb), fmt_rest$17 = parse(str_ind, end_ind)[1];
                  if (get_ign(0))
                    var ignored$8 = [2, iconv$2, get_pad_opt(95)], _aV_ = [0, [23, ignored$8, fmt_rest$17]];
                  else
                    var _aW_ = get_prec(0), match$6 = make_padprec_fmt_ebb(get_int_pad(0), _aW_, fmt_rest$17), fmt_rest$18 = match$6[3], prec$4 = match$6[2], pad$8 = match$6[1], _aV_ = [0, [4, iconv$2, pad$8, prec$4, fmt_rest$18]];
                  var fmt_result = _aV_;
                  break a;
                case 69:
                case 70:
                case 71:
                case 72:
                case 101:
                case 102:
                case 103:
                case 104:
                  var space$1 = get_space(0), hash$1 = get_hash(0), plus$2 = get_plus(0), flag2 = plus$2 ? space$1 ? legacy_behavior$0 ? 1 : incompatible_flag(pct_ind, str_ind, 32, cst$36) : 1 : space$1 ? 2 : 0;
                  b: {
                    c:
                      if (73 <= symb) {
                        var switcher = symb - 101 | 0;
                        if (3 >= switcher >>> 0) {
                          switch (switcher) {
                            case 0:
                              var _a5_ = 1;
                              break;
                            case 1:
                              var _a5_ = 0;
                              break;
                            case 2:
                              var _a5_ = 3;
                              break;
                            default:
                              var _a5_ = 6;
                          }
                          var kind = _a5_;
                          break b;
                        }
                      } else if (69 <= symb) {
                        switch (symb - 69 | 0) {
                          case 0:
                            var _a6_ = 2;
                            break;
                          case 1:
                            break c;
                          case 2:
                            var _a6_ = 4;
                            break;
                          default:
                            var _a6_ = 7;
                        }
                        var kind = _a6_;
                        break b;
                      }
                    if (hash$1) {
                      if (70 === symb) {
                        var kind = 8;
                        break b;
                      }
                    } else if (70 === symb) {
                      var kind = 5;
                      break b;
                    }
                    throw caml_maybe_attach_backtrace2([0, Assert_failure, _X_], 1);
                  }
                  var fconv = [0, flag2, kind], fmt_rest$11 = parse(str_ind, end_ind)[1];
                  if (get_ign(0)) {
                    var match = get_prec(0);
                    if (typeof match === "number")
                      var _aM_ = match ? incompatible_flag(pct_ind, str_ind, 95, cst$26) : 0;
                    else
                      var ndec = match[1], _aM_ = [0, ndec];
                    var ignored$4 = [6, get_pad_opt(95), _aM_], _aN_ = [0, [23, ignored$4, fmt_rest$11]];
                  } else
                    var _aO_ = get_prec(0), match$4 = make_padprec_fmt_ebb(get_pad(0), _aO_, fmt_rest$11), fmt_rest$12 = match$4[3], prec$3 = match$4[2], pad$5 = match$4[1], _aN_ = [0, [8, fconv, pad$5, prec$3, fmt_rest$12]];
                  var fmt_result = _aN_;
                  break a;
              }
            b:
              if (108 <= symb) {
                if (111 > symb) {
                  switch (symb - 108 | 0) {
                    case 0:
                      var _at_ = caml_string_get2(str, str_ind), _au_ = get_space(0), _av_ = get_hash(0), iconv = compute_int_conv(pct_ind, str_ind + 1 | 0, get_plus(0), _av_, _au_, _at_), fmt_rest = parse(str_ind + 1 | 0, end_ind)[1];
                      if (get_ign(0))
                        var ignored = [3, iconv, get_pad_opt(95)], _aw_ = [0, [23, ignored, fmt_rest]];
                      else
                        var _ay_ = get_prec(0), match$0 = make_padprec_fmt_ebb(get_int_pad(0), _ay_, fmt_rest), fmt_rest$0 = match$0[3], prec$0 = match$0[2], pad$0 = match$0[1], _aw_ = [0, [5, iconv, pad$0, prec$0, fmt_rest$0]];
                      var _ax_ = _aw_;
                      break;
                    case 1:
                      break b;
                    default:
                      var _az_ = caml_string_get2(str, str_ind), _aA_ = get_space(0), _aB_ = get_hash(0), iconv$0 = compute_int_conv(pct_ind, str_ind + 1 | 0, get_plus(0), _aB_, _aA_, _az_), fmt_rest$1 = parse(str_ind + 1 | 0, end_ind)[1];
                      if (get_ign(0))
                        var ignored$0 = [4, iconv$0, get_pad_opt(95)], _aC_ = [0, [23, ignored$0, fmt_rest$1]];
                      else
                        var _aD_ = get_prec(0), match$1 = make_padprec_fmt_ebb(get_int_pad(0), _aD_, fmt_rest$1), fmt_rest$2 = match$1[3], prec$1 = match$1[2], pad$1 = match$1[1], _aC_ = [0, [6, iconv$0, pad$1, prec$1, fmt_rest$2]];
                      var _ax_ = _aC_;
                  }
                  var fmt_result = _ax_;
                  break a;
                }
              } else if (76 === symb) {
                var _aE_ = caml_string_get2(str, str_ind), _aF_ = get_space(0), _aG_ = get_hash(0), iconv$1 = compute_int_conv(pct_ind, str_ind + 1 | 0, get_plus(0), _aG_, _aF_, _aE_), fmt_rest$3 = parse(str_ind + 1 | 0, end_ind)[1];
                if (get_ign(0))
                  var ignored$1 = [5, iconv$1, get_pad_opt(95)], _aH_ = [0, [23, ignored$1, fmt_rest$3]];
                else
                  var _aI_ = get_prec(0), match$2 = make_padprec_fmt_ebb(get_int_pad(0), _aI_, fmt_rest$3), fmt_rest$4 = match$2[3], prec$2 = match$2[2], pad$2 = match$2[1], _aH_ = [0, [7, iconv$1, pad$2, prec$2, fmt_rest$4]];
                var fmt_result = _aH_;
                break a;
              }
            var fmt_result = caml_call3(failwith_message(_J_), str, str_ind - 1 | 0, symb);
          }
          if (1 - legacy_behavior$0) {
            var _ak_ = 1 - plus_used[1], plus$0 = _ak_ ? plus : _ak_;
            if (plus$0)
              incompatible_flag(pct_ind, str_ind, symb, cst$27);
            var _al_ = 1 - hash_used[1], hash$0 = _al_ ? hash : _al_;
            if (hash$0)
              incompatible_flag(pct_ind, str_ind, symb, cst$28);
            var _am_ = 1 - space_used[1], space$0 = _am_ ? space : _am_;
            if (space$0)
              incompatible_flag(pct_ind, str_ind, symb, cst$29);
            var _an_ = 1 - pad_used[1], _ao_ = _an_ ? caml_notequal2([0, pad], _K_) : _an_;
            if (_ao_)
              incompatible_flag(pct_ind, str_ind, symb, cst_padding$0);
            var _ap_ = 1 - prec_used[1], _aq_ = _ap_ ? caml_notequal2([0, prec], _L_) : _ap_;
            if (_aq_) {
              var _ar_ = ign ? 95 : symb;
              incompatible_flag(pct_ind, str_ind, _ar_, cst_precision$2);
            }
            var plus$1 = ign ? plus : ign;
            if (plus$1)
              incompatible_flag(pct_ind, str_ind, 95, cst$30);
          }
          var _as_ = 1 - ign_used[1], ign$0 = _as_ ? ign : _as_;
          a:
            if (ign$0) {
              b: {
                if (38 <= symb) {
                  if (44 !== symb && 64 !== symb)
                    break b;
                } else if (33 !== symb && 37 > symb)
                  break b;
                if (legacy_behavior$0)
                  break a;
              }
              incompatible_flag(pct_ind, str_ind, symb, cst$31);
            }
          return fmt_result;
        }
        function parse_tag(is_open_tag, str_ind, end_ind) {
          try {
            if (str_ind === end_ind)
              throw caml_maybe_attach_backtrace2(Stdlib[8], 1);
            if (60 !== caml_string_get2(str, str_ind))
              throw caml_maybe_attach_backtrace2(Stdlib[8], 1);
            var ind = caml_call3(Stdlib_String[32], str, str_ind + 1 | 0, 62);
            if (end_ind <= ind)
              throw caml_maybe_attach_backtrace2(Stdlib[8], 1);
            var sub_str = caml_call3(Stdlib_String[16], str, str_ind, (ind - str_ind | 0) + 1 | 0), fmt_rest$0 = parse(ind + 1 | 0, end_ind)[1], sub_fmt = parse(str_ind, ind + 1 | 0)[1], sub_format$0 = [0, sub_fmt, sub_str], formatting$0 = is_open_tag ? [0, sub_format$0] : [1, sub_format$0], _ai_ = [0, [18, formatting$0, fmt_rest$0]];
            return _ai_;
          } catch (_aj_) {
            var _ah_ = caml_wrap_exception2(_aj_);
            if (_ah_ !== Stdlib[8])
              throw caml_maybe_attach_backtrace2(_ah_, 0);
            var fmt_rest = parse(str_ind, end_ind)[1], formatting = is_open_tag ? [0, sub_format] : [1, sub_format];
            return [0, [18, formatting, fmt_rest]];
          }
        }
        function parse_spaces(str_ind, end_ind) {
          var str_ind$0 = str_ind;
          for (; ; ) {
            if (str_ind$0 === end_ind)
              unexpected_end_of_format(end_ind);
            if (32 !== caml_string_get2(str, str_ind$0))
              return str_ind$0;
            var str_ind$1 = str_ind$0 + 1 | 0, str_ind$0 = str_ind$1;
          }
        }
        function parse_positive(str_ind, end_ind, acc) {
          var str_ind$0 = str_ind, acc$0 = acc;
          for (; ; ) {
            if (str_ind$0 === end_ind)
              unexpected_end_of_format(end_ind);
            var c = caml_string_get2(str, str_ind$0);
            if (9 < c - 48 >>> 0)
              return [0, str_ind$0, acc$0];
            var new_acc = (acc$0 * 10 | 0) + (c - 48 | 0) | 0;
            if (Stdlib_Sys[12] < new_acc) {
              var _ag_ = Stdlib_Sys[12];
              return caml_call3(failwith_message(_S_), str, new_acc, _ag_);
            }
            var str_ind$1 = str_ind$0 + 1 | 0, str_ind$0 = str_ind$1, acc$0 = new_acc;
          }
        }
        function parse_integer(str_ind, end_ind) {
          if (str_ind === end_ind)
            unexpected_end_of_format(end_ind);
          var match = caml_string_get2(str, str_ind);
          if (48 <= match) {
            if (58 > match)
              return parse_positive(str_ind, end_ind, 0);
          } else if (45 === match) {
            if ((str_ind + 1 | 0) === end_ind)
              unexpected_end_of_format(end_ind);
            var c = caml_string_get2(str, str_ind + 1 | 0);
            if (9 < c - 48 >>> 0)
              return expected_character(str_ind + 1 | 0, cst_digit, c);
            var match$0 = parse_positive(str_ind + 1 | 0, end_ind, 0), n = match$0[2], next_ind = match$0[1];
            return [0, next_ind, -n | 0];
          }
          throw caml_maybe_attach_backtrace2([0, Assert_failure, _T_2], 1);
        }
        function add_literal(lit_start, str_ind, fmt) {
          var size = str_ind - lit_start | 0;
          return 0 === size ? [0, fmt] : 1 === size ? [0, [12, caml_string_get2(str, lit_start), fmt]] : [
            0,
            [
              11,
              caml_call3(Stdlib_String[16], str, lit_start, size),
              fmt
            ]
          ];
        }
        function search_subformat_end(str_ind, end_ind, c) {
          var str_ind$0 = str_ind;
          for (; ; ) {
            if (str_ind$0 === end_ind)
              caml_call3(failwith_message(_U_), str, c, end_ind);
            if (37 === caml_string_get2(str, str_ind$0)) {
              if ((str_ind$0 + 1 | 0) === end_ind)
                unexpected_end_of_format(end_ind);
              if (caml_string_get2(str, str_ind$0 + 1 | 0) === c)
                return str_ind$0;
              var match = caml_string_get2(str, str_ind$0 + 1 | 0);
              if (95 <= match) {
                if (123 <= match) {
                  if (126 > match)
                    switch (match - 123 | 0) {
                      case 0:
                        var sub_end = search_subformat_end(str_ind$0 + 2 | 0, end_ind, 125), str_ind$2 = sub_end + 2 | 0, str_ind$0 = str_ind$2;
                        continue;
                      case 1:
                        break;
                      default:
                        return expected_character(str_ind$0 + 1 | 0, cst_character, 125);
                    }
                } else if (96 > match) {
                  if ((str_ind$0 + 2 | 0) === end_ind)
                    unexpected_end_of_format(end_ind);
                  var match$0 = caml_string_get2(str, str_ind$0 + 2 | 0);
                  if (40 === match$0) {
                    var sub_end$0 = search_subformat_end(str_ind$0 + 3 | 0, end_ind, 41), str_ind$3 = sub_end$0 + 2 | 0, str_ind$0 = str_ind$3;
                    continue;
                  }
                  if (123 === match$0) {
                    var sub_end$1 = search_subformat_end(str_ind$0 + 3 | 0, end_ind, 125), str_ind$4 = sub_end$1 + 2 | 0, str_ind$0 = str_ind$4;
                    continue;
                  }
                  var str_ind$5 = str_ind$0 + 3 | 0, str_ind$0 = str_ind$5;
                  continue;
                }
              } else {
                if (40 === match) {
                  var sub_end$2 = search_subformat_end(str_ind$0 + 2 | 0, end_ind, 41), str_ind$6 = sub_end$2 + 2 | 0, str_ind$0 = str_ind$6;
                  continue;
                }
                if (41 === match)
                  return expected_character(str_ind$0 + 1 | 0, cst_character$0, 41);
              }
              var str_ind$1 = str_ind$0 + 2 | 0, str_ind$0 = str_ind$1;
            } else
              var str_ind$7 = str_ind$0 + 1 | 0, str_ind$0 = str_ind$7;
          }
        }
        function compute_int_conv(pct_ind, str_ind, plus, hash, space, symb) {
          var plus$0 = plus, hash$0 = hash, space$0 = space;
          for (; ; ) {
            a: {
              if (plus$0) {
                if (!hash$0) {
                  if (space$0)
                    break a;
                  if (100 === symb)
                    return 1;
                  if (105 === symb)
                    return 4;
                  break a;
                }
              } else {
                if (!hash$0) {
                  if (space$0) {
                    if (100 === symb)
                      return 2;
                    if (105 === symb)
                      return 5;
                    break a;
                  }
                  var switcher$1 = symb - 88 | 0;
                  if (32 < switcher$1 >>> 0)
                    break a;
                  switch (switcher$1) {
                    case 0:
                      return 8;
                    case 12:
                      return 0;
                    case 17:
                      return 3;
                    case 23:
                      return 10;
                    case 29:
                      return 12;
                    case 32:
                      return 6;
                    default:
                      break a;
                  }
                }
                if (!space$0) {
                  var switcher$0 = symb - 88 | 0;
                  if (32 >= switcher$0 >>> 0)
                    switch (switcher$0) {
                      case 0:
                        return 9;
                      case 12:
                        return 13;
                      case 17:
                        return 14;
                      case 23:
                        return 11;
                      case 29:
                        return 15;
                      case 32:
                        return 7;
                    }
                }
              }
              var switcher = symb - 88 | 0;
              if (32 >= switcher >>> 0)
                switch (switcher) {
                  case 0:
                    if (legacy_behavior$0)
                      return 9;
                    break;
                  case 23:
                    if (legacy_behavior$0)
                      return 11;
                    break;
                  case 32:
                    if (legacy_behavior$0)
                      return 7;
                    break;
                  case 12:
                  case 17:
                  case 29:
                    if (!legacy_behavior$0)
                      return incompatible_flag(pct_ind, str_ind, symb, cst$35);
                    var hash$0 = 0;
                    continue;
                }
            }
            if (plus$0)
              if (space$0) {
                if (!legacy_behavior$0)
                  return incompatible_flag(pct_ind, str_ind, 32, cst$32);
                var space$0 = 0;
              } else {
                if (!legacy_behavior$0)
                  return incompatible_flag(pct_ind, str_ind, symb, cst$33);
                var plus$0 = 0;
              }
            else {
              if (!space$0)
                throw caml_maybe_attach_backtrace2([0, Assert_failure, _W_], 1);
              if (!legacy_behavior$0)
                return incompatible_flag(pct_ind, str_ind, symb, cst$34);
              var space$0 = 0;
            }
          }
        }
        function incompatible_flag(pct_ind, str_ind, symb, option) {
          var subfmt = caml_call3(Stdlib_String[16], str, pct_ind, str_ind - pct_ind | 0);
          return caml_call5(failwith_message(_Y_), str, pct_ind, option, symb, subfmt);
        }
        return parse(0, caml_ml_string_length2(str));
      }
      function format_of_string_fmtty(str, fmtty) {
        var fmt = fmt_ebb_of_string(0, str)[1];
        try {
          var _ae_ = [0, type_format(fmt, fmtty), str];
          return _ae_;
        } catch (_af_) {
          var _ac_ = caml_wrap_exception2(_af_);
          if (_ac_ !== Type_mismatch)
            throw caml_maybe_attach_backtrace2(_ac_, 0);
          var _ad_ = string_of_fmtty(fmtty);
          return caml_call2(failwith_message(_Z_), str, _ad_);
        }
      }
      function format_of_string_format(str, param) {
        var str$0 = param[2], fmt = param[1], fmt$0 = fmt_ebb_of_string(0, str)[1];
        try {
          var _aa_ = [0, type_format(fmt$0, fmtty_of_fmt(fmt)), str];
          return _aa_;
        } catch (_ab_) {
          var _$_ = caml_wrap_exception2(_ab_);
          if (_$_ === Type_mismatch)
            return caml_call2(failwith_message(___), str, str$0);
          throw caml_maybe_attach_backtrace2(_$_, 0);
        }
      }
      var CamlinternalFormat = [
        0,
        is_in_char_set,
        rev_char_set,
        create_char_set,
        add_in_char_set,
        freeze_char_set,
        param_format_of_ignored_format,
        make_printf,
        make_iprintf,
        output_acc,
        bufput_acc,
        strput_acc,
        type_format,
        fmt_ebb_of_string,
        format_of_string_fmtty,
        format_of_string_format,
        char_of_iconv,
        string_of_formatting_lit,
        string_of_fmtty,
        string_of_fmt,
        open_box_of_string,
        symm,
        trans,
        recast
      ];
      runtime.caml_register_global(197, CamlinternalFormat, "CamlinternalFormat");
      return;
    })(globalThis);
    (function(globalThis2) {
      "use strict";
      var runtime = globalThis2.jsoo_runtime;
      function caml_call1(f, a0) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 1 ? f(a0) : runtime.caml_call_gen(f, [a0]);
      }
      function caml_call2(f, a0, a1) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 2 ? f(a0, a1) : runtime.caml_call_gen(f, [a0, a1]);
      }
      function caml_call3(f, a0, a1, a2) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 3 ? f(a0, a1, a2) : runtime.caml_call_gen(f, [a0, a1, a2]);
      }
      var global_data = runtime.caml_get_global_data(), Stdlib_Buffer = global_data.Stdlib__Buffer, CamlinternalFormat = global_data.CamlinternalFormat, Stdlib = global_data.Stdlib;
      function kfprintf(k, o, param) {
        var fmt = param[1];
        return caml_call3(
          CamlinternalFormat[7],
          function(acc) {
            caml_call2(CamlinternalFormat[9], o, acc);
            return caml_call1(k, o);
          },
          0,
          fmt
        );
      }
      function kbprintf(k, b, param) {
        var fmt = param[1];
        return caml_call3(
          CamlinternalFormat[7],
          function(acc) {
            caml_call2(CamlinternalFormat[10], b, acc);
            return caml_call1(k, b);
          },
          0,
          fmt
        );
      }
      function ikfprintf(k, oc, param) {
        var fmt = param[1];
        return caml_call3(CamlinternalFormat[8], k, oc, fmt);
      }
      function fprintf(oc, fmt) {
        return kfprintf(function(_d_) {
          return 0;
        }, oc, fmt);
      }
      function bprintf(b, fmt) {
        return kbprintf(function(_c_) {
          return 0;
        }, b, fmt);
      }
      function ifprintf(oc, fmt) {
        return ikfprintf(function(_b_) {
          return 0;
        }, oc, fmt);
      }
      function ibprintf(b, fmt) {
        return ikfprintf(function(_a_) {
          return 0;
        }, b, fmt);
      }
      function printf(fmt) {
        return fprintf(Stdlib[39], fmt);
      }
      function eprintf(fmt) {
        return fprintf(Stdlib[40], fmt);
      }
      function ksprintf(k, param) {
        var fmt = param[1];
        function k$0(acc) {
          var buf = caml_call1(Stdlib_Buffer[1], 64);
          caml_call2(CamlinternalFormat[11], buf, acc);
          return caml_call1(k, caml_call1(Stdlib_Buffer[2], buf));
        }
        return caml_call3(CamlinternalFormat[7], k$0, 0, fmt);
      }
      function sprintf(fmt) {
        return ksprintf(function(s2) {
          return s2;
        }, fmt);
      }
      var Stdlib_Printf = [
        0,
        fprintf,
        printf,
        eprintf,
        sprintf,
        bprintf,
        ifprintf,
        ibprintf,
        kfprintf,
        ikfprintf,
        ksprintf,
        kbprintf,
        ikfprintf,
        ksprintf
      ];
      runtime.caml_register_global(3, Stdlib_Printf, "Stdlib__Printf");
      return;
    })(globalThis);
    (function(globalThis2) {
      "use strict";
      var runtime = globalThis2.jsoo_runtime, cst$4 = "", cst_s = "%s\n", cst_Program_not_linked_with_g_$0 = "(Program not linked with -g, cannot print stack backtrace)\n", cst_characters = ", characters ", cst_Fatal_error_exception = "Fatal error: exception ", cst_Fatal_error_exception_s = "Fatal error: exception %s\n", cst_Uncaught_exception = "Uncaught exception: ", cst_Uncaught_exception_s = "Uncaught exception: %s\n", caml_check_bound2 = runtime.caml_check_bound, caml_get_exception_raw_backtra = runtime.caml_get_exception_raw_backtrace, caml_maybe_attach_backtrace2 = runtime.caml_maybe_attach_backtrace, caml_obj_tag2 = runtime.caml_obj_tag, caml_wrap_exception2 = runtime.caml_wrap_exception;
      function caml_call1(f, a0) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 1 ? f(a0) : runtime.caml_call_gen(f, [a0]);
      }
      function caml_call2(f, a0, a1) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 2 ? f(a0, a1) : runtime.caml_call_gen(f, [a0, a1]);
      }
      function caml_call3(f, a0, a1, a2) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 3 ? f(a0, a1, a2) : runtime.caml_call_gen(f, [a0, a1, a2]);
      }
      function caml_call6(f, a0, a1, a2, a3, a4, a5) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 6 ? f(a0, a1, a2, a3, a4, a5) : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
      }
      function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 8 ? f(a0, a1, a2, a3, a4, a5, a6, a7) : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
      }
      var global_data = runtime.caml_get_global_data(), cst$0 = cst$4, cst$3 = cst$4, partial = [4, 0, 0, 0, [12, 45, [4, 0, 0, 0, 0]]], cst$1 = cst$4, cst$2 = cst$4, cst = "_", locfmt = [
        0,
        [
          11,
          'File "',
          [
            2,
            0,
            [
              11,
              '", line ',
              [
                4,
                0,
                0,
                0,
                [
                  11,
                  cst_characters,
                  [4, 0, 0, 0, [12, 45, [4, 0, 0, 0, [11, ": ", [2, 0, 0]]]]]
                ]
              ]
            ]
          ]
        ],
        'File "%s", line %d, characters %d-%d: %s'
      ], Stdlib_Printf = global_data.Stdlib__Printf, Stdlib_Atomic = global_data.Stdlib__Atomic, Stdlib = global_data.Stdlib, Stdlib_Buffer = global_data.Stdlib__Buffer, Stdlib_Obj = global_data.Stdlib__Obj, printers = caml_call1(Stdlib_Atomic[1], 0), _a_ = [0, [3, 0, 0], "%S"], _b_ = [0, [4, 0, 0, 0, 0], "%d"], _c_ = [0, [11, ", ", [2, 0, [2, 0, 0]]], ", %s%s"], _d_ = [0, [12, 40, [2, 0, [2, 0, [12, 41, 0]]]], "(%s%s)"], _e_ = [0, [12, 40, [2, 0, [12, 41, 0]]], "(%s)"], cst_Out_of_memory2 = "Out of memory", cst_Stack_overflow2 = "Stack overflow", cst_Pattern_matching_failed = "Pattern matching failed", cst_Assertion_failed = "Assertion failed", cst_Undefined_recursive_module2 = "Undefined recursive module", _f_ = [
        0,
        [11, cst_Uncaught_exception, [2, 0, [12, 10, 0]]],
        cst_Uncaught_exception_s
      ], _g_ = [
        0,
        [11, cst_Uncaught_exception, [2, 0, [12, 10, 0]]],
        cst_Uncaught_exception_s
      ], cst_Raised_at = "Raised at", cst_Re_raised_at = "Re-raised at", cst_Raised_by_primitive_operat = "Raised by primitive operation at", cst_Called_from = "Called from", cst_inlined = " (inlined)", _h_ = [
        0,
        [
          2,
          0,
          [
            12,
            32,
            [
              2,
              0,
              [
                11,
                ' in file "',
                [
                  2,
                  0,
                  [
                    12,
                    34,
                    [
                      2,
                      0,
                      [11, ", line ", [4, 0, 0, 0, [11, cst_characters, partial]]]
                    ]
                  ]
                ]
              ]
            ]
          ]
        ],
        '%s %s in file "%s"%s, line %d, characters %d-%d'
      ], _i_ = [0, [2, 0, [11, " unknown location", 0]], "%s unknown location"], _j_ = [0, [2, 0, [12, 10, 0]], cst_s], _k_ = [
        0,
        [11, cst_Program_not_linked_with_g_$0, 0],
        cst_Program_not_linked_with_g_$0
      ], _l_ = [0, [2, 0, [12, 10, 0]], cst_s], cst_Program_not_linked_with_g_ = cst_Program_not_linked_with_g_$0;
      function field(x2, i) {
        var f = x2[1 + i];
        if (!caml_call1(Stdlib_Obj[1], f))
          return caml_call2(Stdlib_Printf[4], _b_, f);
        var _ag_ = Stdlib_Obj[15];
        if (caml_obj_tag2(f) === _ag_)
          return caml_call2(Stdlib_Printf[4], _a_, f);
        var _ah_ = Stdlib_Obj[16];
        return caml_obj_tag2(f) === _ah_ ? caml_call1(Stdlib[35], f) : cst;
      }
      function other_fields(x2, i) {
        if (x2.length - 1 <= i)
          return cst$0;
        var _ae_ = other_fields(x2, i + 1 | 0), _af_ = field(x2, i);
        return caml_call3(Stdlib_Printf[4], _c_, _af_, _ae_);
      }
      function use_printers(x2) {
        var param = caml_call1(Stdlib_Atomic[2], printers);
        for (; ; ) {
          if (!param)
            return 0;
          var tl = param[2], hd = param[1];
          a: {
            try {
              var val = caml_call1(hd, x2);
            } catch (_ad_) {
              break a;
            }
            if (val) {
              var s2 = val[1];
              return [0, s2];
            }
          }
          var param = tl;
        }
      }
      function string_of_extension_constructo(t) {
        if (0 === caml_obj_tag2(t)) {
          var constructor = t[1][1], match = t.length - 1;
          if (2 < match >>> 0)
            var _$_ = other_fields(t, 2), _aa_ = field(t, 1), _ac_ = caml_call3(Stdlib_Printf[4], _d_, _aa_, _$_);
          else
            switch (match) {
              case 0:
                var _ac_ = cst$1;
                break;
              case 1:
                var _ac_ = cst$2;
                break;
              default:
                var _ab_ = field(t, 1), _ac_ = caml_call2(Stdlib_Printf[4], _e_, _ab_);
            }
          var match$0 = [0, constructor, [0, _ac_]];
        } else
          var match$0 = [0, t[1], 0];
        var fields_opt = match$0[2], constructor$0 = match$0[1];
        if (!fields_opt)
          return constructor$0;
        var f = fields_opt[1];
        return caml_call2(Stdlib[28], constructor$0, f);
      }
      function to_string_default(x2) {
        if (x2 === Stdlib[9])
          return cst_Out_of_memory2;
        if (x2 === Stdlib[10])
          return cst_Stack_overflow2;
        if (x2[1] === Stdlib[4]) {
          var match = x2[2], char$0 = match[3], line = match[2], file = match[1];
          return caml_call6(
            Stdlib_Printf[4],
            locfmt,
            file,
            line,
            char$0,
            char$0 + 5 | 0,
            cst_Pattern_matching_failed
          );
        }
        if (x2[1] === Stdlib[5]) {
          var match$0 = x2[2], char$1 = match$0[3], line$0 = match$0[2], file$0 = match$0[1];
          return caml_call6(
            Stdlib_Printf[4],
            locfmt,
            file$0,
            line$0,
            char$1,
            char$1 + 6 | 0,
            cst_Assertion_failed
          );
        }
        if (x2[1] !== Stdlib[15])
          return string_of_extension_constructo(x2);
        var match$1 = x2[2], char$2 = match$1[3], line$1 = match$1[2], file$1 = match$1[1];
        return caml_call6(
          Stdlib_Printf[4],
          locfmt,
          file$1,
          line$1,
          char$2,
          char$2 + 6 | 0,
          cst_Undefined_recursive_module2
        );
      }
      function to_string(e) {
        var match = use_printers(e);
        if (!match)
          return to_string_default(e);
        var s2 = match[1];
        return s2;
      }
      function print(fct, arg) {
        try {
          var ___ = caml_call1(fct, arg);
          return ___;
        } catch (x$0) {
          var x2 = caml_wrap_exception2(x$0), _Z_ = to_string(x2);
          caml_call2(Stdlib_Printf[3], _f_, _Z_);
          caml_call1(Stdlib[63], Stdlib[40]);
          throw caml_maybe_attach_backtrace2(x2, 0);
        }
      }
      function catch$0(fct, arg) {
        try {
          var _Y_ = caml_call1(fct, arg);
          return _Y_;
        } catch (x$0) {
          var x2 = caml_wrap_exception2(x$0);
          caml_call1(Stdlib[63], Stdlib[39]);
          var _X_ = to_string(x2);
          caml_call2(Stdlib_Printf[3], _g_, _X_);
          return caml_call1(Stdlib[99], 2);
        }
      }
      function raw_backtrace_entries(bt) {
        return bt;
      }
      function convert_raw_backtrace(bt) {
        return [0, runtime.caml_convert_raw_backtrace(bt)];
      }
      function format_backtrace_slot(pos, slot) {
        function info(is_raise) {
          return is_raise ? 0 === pos ? cst_Raised_at : cst_Re_raised_at : 0 === pos ? cst_Raised_by_primitive_operat : cst_Called_from;
        }
        if (0 === slot[0]) {
          var _P_ = slot[5], _Q_ = slot[4], _R_ = slot[3], _S_ = slot[6] ? cst_inlined : cst$3, _T_2 = slot[2], _U_ = slot[7], _V_ = info(slot[1]);
          return [
            0,
            caml_call8(Stdlib_Printf[4], _h_, _V_, _U_, _T_2, _S_, _R_, _Q_, _P_)
          ];
        }
        if (slot[1])
          return 0;
        var _W_ = info(0);
        return [0, caml_call2(Stdlib_Printf[4], _i_, _W_)];
      }
      function print_raw_backtrace(outchan, raw_backtrace) {
        var backtrace = convert_raw_backtrace(raw_backtrace);
        if (!backtrace)
          return caml_call2(Stdlib_Printf[1], outchan, _k_);
        var a = backtrace[1], _N_ = a.length - 1 - 1 | 0, _M_ = 0;
        if (_N_ >= 0) {
          var i = _M_;
          for (; ; ) {
            var match = format_backtrace_slot(i, caml_check_bound2(a, i)[1 + i]);
            if (match) {
              var str = match[1];
              caml_call3(Stdlib_Printf[1], outchan, _j_, str);
            }
            var _O_ = i + 1 | 0;
            if (_N_ === i)
              break;
            var i = _O_;
          }
        }
        return 0;
      }
      function print_backtrace(outchan) {
        return print_raw_backtrace(outchan, caml_get_exception_raw_backtra(0));
      }
      function raw_backtrace_to_string(raw_backtrace) {
        var backtrace = convert_raw_backtrace(raw_backtrace);
        if (!backtrace)
          return cst_Program_not_linked_with_g_;
        var a = backtrace[1], b = caml_call1(Stdlib_Buffer[1], 1024), _K_ = a.length - 1 - 1 | 0, _J_ = 0;
        if (_K_ >= 0) {
          var i = _J_;
          for (; ; ) {
            var match = format_backtrace_slot(i, caml_check_bound2(a, i)[1 + i]);
            if (match) {
              var str = match[1];
              caml_call3(Stdlib_Printf[5], b, _l_, str);
            }
            var _L_ = i + 1 | 0;
            if (_K_ === i)
              break;
            var i = _L_;
          }
        }
        return caml_call1(Stdlib_Buffer[2], b);
      }
      function backtrace_slot_is_raise(param) {
        return 0 === param[0] ? param[1] : param[1];
      }
      function backtrace_slot_is_inline(param) {
        return 0 === param[0] ? param[6] : 0;
      }
      function backtrace_slot_location(param) {
        return 0 === param[0] ? [0, [0, param[2], param[3], param[4], param[5]]] : 0;
      }
      function backtrace_slot_defname(param) {
        if (0 === param[0] && runtime.caml_string_notequal(param[7], cst$4))
          return [0, param[7]];
        return 0;
      }
      function backtrace_slots(raw_backtrace) {
        var match = convert_raw_backtrace(raw_backtrace);
        if (!match)
          return 0;
        var backtrace = match[1], i$1 = backtrace.length - 1 - 1 | 0, i = i$1;
        for (; ; ) {
          if (-1 === i)
            var _I_ = 0;
          else {
            var _H_ = 0 === caml_check_bound2(backtrace, i)[1 + i][0] ? 1 : 0;
            if (!_H_) {
              var i$0 = i - 1 | 0, i = i$0;
              continue;
            }
            var _I_ = _H_;
          }
          return _I_ ? [0, backtrace] : 0;
        }
      }
      function backtrace_slots_of_raw_entry(entry) {
        return backtrace_slots([0, entry]);
      }
      function raw_backtrace_length(bt) {
        return bt.length - 1;
      }
      function get_backtrace(param) {
        return raw_backtrace_to_string(caml_get_exception_raw_backtra(0));
      }
      function register_printer(fn) {
        for (; ; ) {
          var old_printers = caml_call1(Stdlib_Atomic[2], printers), new_printers = [0, fn, old_printers], success = caml_call3(Stdlib_Atomic[5], printers, old_printers, new_printers), _G_ = 1 - success;
          if (!_G_)
            return _G_;
        }
      }
      function exn_slot(x2) {
        return 0 === caml_obj_tag2(x2) ? x2[1] : x2;
      }
      function exn_slot_id(x2) {
        var slot = exn_slot(x2);
        return slot[2];
      }
      function exn_slot_name(x2) {
        var slot = exn_slot(x2);
        return slot[1];
      }
      var errors = [
        0,
        cst$4,
        "(Cannot print locations:\n bytecode executable program file not found)",
        "(Cannot print locations:\n bytecode executable program file appears to be corrupt)",
        "(Cannot print locations:\n bytecode executable program file has wrong magic number)",
        "(Cannot print locations:\n bytecode executable program file cannot be opened;\n -- too many open files. Try running with OCAMLRUNPARAM=b=2)"
      ].slice(), _m_ = [
        0,
        [11, cst_Fatal_error_exception, [2, 0, [12, 10, 0]]],
        cst_Fatal_error_exception_s
      ];
      function default_uncaught_exception_han(exn, raw_backtrace) {
        var _D_ = to_string(exn);
        caml_call2(Stdlib_Printf[3], _m_, _D_);
        print_raw_backtrace(Stdlib[40], raw_backtrace);
        var status = runtime.caml_ml_debug_info_status(0);
        if (status < 0) {
          var _E_ = caml_call1(Stdlib[18], status), _F_ = caml_check_bound2(errors, _E_)[1 + _E_];
          caml_call1(Stdlib[53], _F_);
        }
        return caml_call1(Stdlib[63], Stdlib[40]);
      }
      var uncaught_exception_handler = [0, default_uncaught_exception_han];
      function set_uncaught_exception_handler(fn) {
        uncaught_exception_handler[1] = fn;
        return 0;
      }
      var empty_backtrace = [0], cst_Fatal_error_out_of_memory_ = "Fatal error: out of memory in uncaught exception handler", _n_ = [
        0,
        [11, cst_Fatal_error_exception, [2, 0, [12, 10, 0]]],
        cst_Fatal_error_exception_s
      ], _o_ = [
        0,
        [
          11,
          "Fatal error in uncaught exception handler: exception ",
          [2, 0, [12, 10, 0]]
        ],
        "Fatal error in uncaught exception handler: exception %s\n"
      ];
      function handle_uncaught_exception(exn$0, debugger_in_use) {
        try {
          try {
            var raw_backtrace = debugger_in_use ? empty_backtrace : caml_get_exception_raw_backtra(0);
            try {
              caml_call1(Stdlib[103], 0);
            } catch (_C_) {
            }
            try {
              var _y_ = caml_call2(uncaught_exception_handler[1], exn$0, raw_backtrace), _x_ = _y_;
            } catch (exn$1) {
              var exn = caml_wrap_exception2(exn$1), raw_backtrace$0 = caml_get_exception_raw_backtra(0), _v_ = to_string(exn$0);
              caml_call2(Stdlib_Printf[3], _n_, _v_);
              print_raw_backtrace(Stdlib[40], raw_backtrace);
              var _w_ = to_string(exn);
              caml_call2(Stdlib_Printf[3], _o_, _w_);
              print_raw_backtrace(Stdlib[40], raw_backtrace$0);
              var _x_ = caml_call1(Stdlib[63], Stdlib[40]);
            }
            var _z_ = _x_;
          } catch (_B_) {
            var _u_ = caml_wrap_exception2(_B_);
            if (_u_ !== Stdlib[9])
              throw caml_maybe_attach_backtrace2(_u_, 0);
            var _z_ = caml_call1(Stdlib[53], cst_Fatal_error_out_of_memory_);
          }
          return _z_;
        } catch (_A_) {
          return 0;
        }
      }
      runtime.caml_register_named_value("Printexc.handle_uncaught_exception", handle_uncaught_exception);
      var Stdlib_Printexc = [
        0,
        to_string,
        to_string_default,
        print,
        catch$0,
        print_backtrace,
        get_backtrace,
        runtime.caml_record_backtrace,
        runtime.caml_backtrace_status,
        register_printer,
        use_printers,
        raw_backtrace_entries,
        function(_t_) {
          return caml_get_exception_raw_backtra(_t_);
        },
        print_raw_backtrace,
        raw_backtrace_to_string,
        default_uncaught_exception_han,
        set_uncaught_exception_handler,
        backtrace_slots,
        backtrace_slots_of_raw_entry,
        [
          0,
          backtrace_slot_is_raise,
          backtrace_slot_is_inline,
          backtrace_slot_location,
          backtrace_slot_defname,
          format_backtrace_slot
        ],
        raw_backtrace_length,
        function(_s_, _r_) {
          return runtime.caml_raw_backtrace_slot(_s_, _r_);
        },
        function(_q_) {
          return runtime.caml_convert_raw_backtrace_slot(_q_);
        },
        function(_p_) {
          return runtime.caml_raw_backtrace_next_slot(_p_);
        },
        exn_slot_id,
        exn_slot_name,
        string_of_extension_constructo
      ];
      runtime.caml_register_global(42, Stdlib_Printexc, "Stdlib__Printexc");
      return;
    })(globalThis);
    (function(globalThis2) {
      "use strict";
      var runtime = globalThis2.jsoo_runtime, cst$16 = "", cst$15 = ">", caml_maybe_attach_backtrace2 = runtime.caml_maybe_attach_backtrace, caml_ml_string_length2 = runtime.caml_ml_string_length;
      function caml_call1(f, a0) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 1 ? f(a0) : runtime.caml_call_gen(f, [a0]);
      }
      function caml_call2(f, a0, a1) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 2 ? f(a0, a1) : runtime.caml_call_gen(f, [a0, a1]);
      }
      function caml_call3(f, a0, a1, a2) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 3 ? f(a0, a1, a2) : runtime.caml_call_gen(f, [a0, a1, a2]);
      }
      function caml_call4(f, a0, a1, a2, a3) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 4 ? f(a0, a1, a2, a3) : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
      }
      var undef = void 0, global_data = runtime.caml_get_global_data(), cst$14 = ".", cst$11 = cst$15, cst$12 = "</", cst$13 = cst$16, cst$8 = cst$15, cst$9 = "<", cst$10 = cst$16, cst$7 = "\n", cst$3 = cst$16, cst$4 = cst$16, cst$5 = cst$16, cst$6 = cst$16, cst = cst$16, cst$0 = cst$16, cst$1 = cst$16, cst$2 = cst$16, Stdlib_Queue = global_data.Stdlib__Queue, CamlinternalFormat = global_data.CamlinternalFormat, Stdlib = global_data.Stdlib, Stdlib_String = global_data.Stdlib__String, Stdlib_Domain = global_data.Stdlib__Domain, Stdlib_Buffer = global_data.Stdlib__Buffer, Stdlib_Seq = global_data.Stdlib__Seq, Stdlib_Array = global_data.Stdlib__Array, Stdlib_List = global_data.Stdlib__List, Stdlib_Stack = global_data.Stdlib__Stack, Stdlib_Int = global_data.Stdlib__Int, Stdlib_Bytes = global_data.Stdlib__Bytes;
      function id(x2) {
        return x2;
      }
      var zero = 0, unknown = -1, String_tag = [248, "Stdlib.Format.String_tag", runtime.caml_fresh_oo_id(0)];
      function pp_enqueue(state, token) {
        state[13] = state[13] + token[3] | 0;
        return caml_call2(Stdlib_Queue[3], token, state[28]);
      }
      var pp_infinity = 1000000010, _a_ = [0, cst$16, 0, cst$16], _b_ = [0, cst$16], _c_ = [1, "margin <= max_indent"], _d_ = [0, 0], _e_ = [1, "max_indent < 2"], cst_Format_pp_set_geometry = "Format.pp_set_geometry: ";
      function pp_output_string(state, s2) {
        return caml_call3(state[17], s2, 0, caml_ml_string_length2(s2));
      }
      function pp_output_newline(state) {
        return caml_call1(state[19], 0);
      }
      function format_pp_text(state, size, text) {
        state[9] = state[9] - size | 0;
        pp_output_string(state, text);
        state[11] = 0;
        return;
      }
      function format_string(state, s2) {
        var _a9_ = runtime.caml_string_notequal(s2, cst$16);
        return _a9_ ? format_pp_text(state, caml_ml_string_length2(s2), s2) : _a9_;
      }
      function break_new_line(state, param, width) {
        var after = param[3], offset = param[2], before = param[1];
        format_string(state, before);
        pp_output_newline(state);
        state[11] = 1;
        var indent = (state[6] - width | 0) + offset | 0, real_indent = caml_call2(Stdlib_Int[10], state[8], indent);
        state[10] = real_indent;
        state[9] = state[6] - state[10] | 0;
        var n = state[10];
        caml_call1(state[21], n);
        return format_string(state, after);
      }
      function break_line(state, width) {
        return break_new_line(state, _a_, width);
      }
      function break_same_line(state, param) {
        var after = param[3], width = param[2], before = param[1];
        format_string(state, before);
        state[9] = state[9] - width | 0;
        caml_call1(state[20], width);
        return format_string(state, after);
      }
      function format_pp_token(state, size$0, param) {
        if (typeof param === "number")
          switch (param) {
            case 0:
              var match$3 = caml_call1(Stdlib_Stack[8], state[3]);
              if (!match$3)
                return;
              var tabs = match$3[1][1], add_tab = function(n2, ls) {
                if (!ls)
                  return [0, n2, 0];
                var l = ls[2], x2 = ls[1];
                return runtime.caml_lessthan(n2, x2) ? [0, n2, ls] : [0, x2, add_tab(n2, l)];
              };
              tabs[1] = add_tab(state[6] - state[9] | 0, tabs[1]);
              return;
            case 1:
              caml_call1(Stdlib_Stack[5], state[2]);
              return;
            case 2:
              caml_call1(Stdlib_Stack[5], state[3]);
              return;
            case 3:
              var match$4 = caml_call1(Stdlib_Stack[8], state[2]);
              if (!match$4)
                return pp_output_newline(state);
              var width$0 = match$4[1][2];
              return break_line(state, width$0);
            case 4:
              var _a7_ = state[10] !== (state[6] - state[9] | 0) ? 1 : 0;
              if (!_a7_)
                return _a7_;
              var match$1 = caml_call1(Stdlib_Queue[6], state[28]);
              if (!match$1)
                return;
              var match$2 = match$1[1], size = match$2[1], length = match$2[3];
              state[12] = state[12] - length | 0;
              state[9] = state[9] + size | 0;
              return;
            default:
              var match$5 = caml_call1(Stdlib_Stack[5], state[5]);
              if (!match$5)
                return;
              var tag_name = match$5[1], marker = caml_call1(state[25], tag_name);
              return pp_output_string(state, marker);
          }
        switch (param[0]) {
          case 0:
            var s2 = param[1];
            return format_pp_text(state, size$0, s2);
          case 1:
            var breaks = param[2], fits = param[1], off = breaks[2], before = breaks[1], match$6 = caml_call1(Stdlib_Stack[8], state[2]);
            if (!match$6)
              return;
            var match$7 = match$6[1], width$1 = match$7[2], box_type$0 = match$7[1];
            switch (box_type$0) {
              case 0:
                return break_same_line(state, fits);
              case 1:
                return break_new_line(state, breaks, width$1);
              case 2:
                return break_new_line(state, breaks, width$1);
              case 3:
                return state[9] < (size$0 + caml_ml_string_length2(before) | 0) ? break_new_line(state, breaks, width$1) : break_same_line(state, fits);
              case 4:
                return state[11] ? break_same_line(state, fits) : state[9] < (size$0 + caml_ml_string_length2(before) | 0) ? break_new_line(state, breaks, width$1) : ((state[6] - width$1 | 0) + off | 0) < state[10] ? break_new_line(state, breaks, width$1) : break_same_line(state, fits);
              default:
                return break_same_line(state, fits);
            }
          case 2:
            var off$0 = param[2], n = param[1], insertion_point = state[6] - state[9] | 0, match$8 = caml_call1(Stdlib_Stack[8], state[3]);
            if (!match$8)
              return;
            var tabs$0 = match$8[1][1], match$9 = tabs$0[1];
            if (match$9) {
              var first = match$9[1], param$0 = tabs$0[1];
              for (; ; ) {
                if (param$0) {
                  var tail = param$0[2], head = param$0[1];
                  if (insertion_point > head) {
                    var param$0 = tail;
                    continue;
                  }
                  var _a8_ = head;
                } else
                  var _a8_ = first;
                var tab = _a8_;
                break;
              }
            } else
              var tab = insertion_point;
            var offset = tab - insertion_point | 0;
            return 0 <= offset ? break_same_line(state, [0, cst$0, offset + n | 0, cst]) : break_new_line(state, [0, cst$2, tab + off$0 | 0, cst$1], state[6]);
          case 3:
            var ty = param[2], off$1 = param[1], insertion_point$0 = state[6] - state[9] | 0;
            if (state[8] < insertion_point$0) {
              var match = caml_call1(Stdlib_Stack[8], state[2]);
              if (match) {
                var match$0 = match[1], width = match$0[2], box_type = match$0[1];
                if (state[9] < width && 3 >= box_type - 1 >>> 0)
                  break_line(state, width);
              } else
                pp_output_newline(state);
            }
            var width$2 = state[9] - off$1 | 0, box_type$1 = 1 === ty ? 1 : state[9] < size$0 ? ty : 5;
            return caml_call2(Stdlib_Stack[3], [0, box_type$1, width$2], state[2]);
          case 4:
            var tbox = param[1];
            return caml_call2(Stdlib_Stack[3], tbox, state[3]);
          default:
            var tag_name$0 = param[1], marker$0 = caml_call1(state[24], tag_name$0);
            pp_output_string(state, marker$0);
            return caml_call2(Stdlib_Stack[3], tag_name$0, state[5]);
        }
      }
      function advance_left(state) {
        for (; ; ) {
          var match = caml_call1(Stdlib_Queue[9], state[28]);
          if (!match)
            return 0;
          var match$0 = match[1], size = match$0[1], length = match$0[3], token = match$0[2], pending_count = state[13] - state[12] | 0, _a5_ = 0 <= size ? 1 : 0, _a6_ = _a5_ || (state[9] <= pending_count ? 1 : 0);
          if (!_a6_)
            return _a6_;
          caml_call1(Stdlib_Queue[5], state[28]);
          var size$0 = 0 <= size ? size : pp_infinity;
          format_pp_token(state, size$0, token);
          state[12] = length + state[12] | 0;
        }
      }
      function enqueue_advance(state, tok) {
        pp_enqueue(state, tok);
        return advance_left(state);
      }
      function enqueue_string_as(state, size, s2) {
        return enqueue_advance(state, [0, size, [0, s2], size]);
      }
      function initialize_scan_stack(stack) {
        caml_call1(Stdlib_Stack[9], stack);
        var queue_elem = [0, unknown, _b_, 0];
        return caml_call2(Stdlib_Stack[3], [0, -1, queue_elem], stack);
      }
      function set_size(state, ty) {
        var match = caml_call1(Stdlib_Stack[8], state[1]);
        if (!match)
          return;
        var match$0 = match[1], queue_elem = match$0[2], left_total = match$0[1], size = queue_elem[1];
        if (left_total < state[12])
          return initialize_scan_stack(state[1]);
        var _a4_ = queue_elem[2];
        if (typeof _a4_ !== "number")
          switch (_a4_[0]) {
            case 3:
              if (1 - ty) {
                queue_elem[1] = state[13] + size | 0;
                caml_call1(Stdlib_Stack[5], state[1]);
              }
              return;
            case 1:
            case 2:
              if (ty) {
                queue_elem[1] = state[13] + size | 0;
                caml_call1(Stdlib_Stack[5], state[1]);
              }
              return;
          }
        return;
      }
      function scan_push(state, b, token) {
        pp_enqueue(state, token);
        if (b)
          set_size(state, 1);
        var elem = [0, state[13], token];
        return caml_call2(Stdlib_Stack[3], elem, state[1]);
      }
      function pp_open_box_gen(state, indent, br_ty) {
        state[14] = state[14] + 1 | 0;
        if (state[14] < state[15]) {
          var size = -state[13] | 0, elem = [0, size, [3, indent, br_ty], 0];
          return scan_push(state, 0, elem);
        }
        var _a3_ = state[14] === state[15] ? 1 : 0;
        if (!_a3_)
          return _a3_;
        var s2 = state[16];
        return enqueue_string_as(state, caml_ml_string_length2(s2), s2);
      }
      function pp_close_box(state, param) {
        var _a1_ = 1 < state[14] ? 1 : 0;
        if (_a1_) {
          if (state[14] < state[15]) {
            pp_enqueue(state, [0, zero, 1, 0]);
            set_size(state, 1);
            set_size(state, 0);
          }
          state[14] = state[14] - 1 | 0;
          var _a2_ = 0;
        } else
          var _a2_ = _a1_;
        return _a2_;
      }
      function pp_open_stag(state, tag_name) {
        if (state[22]) {
          caml_call2(Stdlib_Stack[3], tag_name, state[4]);
          caml_call1(state[26], tag_name);
        }
        var _a0_ = state[23];
        if (!_a0_)
          return _a0_;
        var token = [5, tag_name];
        return pp_enqueue(state, [0, zero, token, 0]);
      }
      function pp_close_stag(state, param) {
        if (state[23])
          pp_enqueue(state, [0, zero, 5, 0]);
        var _aY_ = state[22];
        if (_aY_) {
          var match = caml_call1(Stdlib_Stack[5], state[4]);
          if (match) {
            var tag_name = match[1];
            return caml_call1(state[27], tag_name);
          }
          var _aZ_ = 0;
        } else
          var _aZ_ = _aY_;
        return _aZ_;
      }
      function pp_set_print_tags(state, b) {
        state[22] = b;
        return 0;
      }
      function pp_set_mark_tags(state, b) {
        state[23] = b;
        return 0;
      }
      function pp_get_print_tags(state, param) {
        return state[22];
      }
      function pp_get_mark_tags(state, param) {
        return state[23];
      }
      function pp_set_tags(state, b) {
        pp_set_print_tags(state, b);
        return pp_set_mark_tags(state, b);
      }
      function pp_get_formatter_stag_function(state, param) {
        return [0, state[24], state[25], state[26], state[27]];
      }
      function pp_set_formatter_stag_function(state, param) {
        var pct = param[4], pot = param[3], mct = param[2], mot = param[1];
        state[24] = mot;
        state[25] = mct;
        state[26] = pot;
        state[27] = pct;
        return 0;
      }
      function pp_rinit(state) {
        state[12] = 1;
        state[13] = 1;
        caml_call1(Stdlib_Queue[11], state[28]);
        initialize_scan_stack(state[1]);
        caml_call1(Stdlib_Stack[9], state[2]);
        caml_call1(Stdlib_Stack[9], state[3]);
        caml_call1(Stdlib_Stack[9], state[4]);
        caml_call1(Stdlib_Stack[9], state[5]);
        state[10] = 0;
        state[14] = 0;
        state[9] = state[6];
        return pp_open_box_gen(state, 0, 3);
      }
      function pp_flush_queue(state, end_with_newline) {
        caml_call2(
          Stdlib_Stack[13],
          function(param) {
            return pp_close_stag(state, 0);
          },
          state[4]
        );
        for (; ; ) {
          if (1 >= state[14]) {
            state[13] = pp_infinity;
            advance_left(state);
            if (end_with_newline)
              pp_output_newline(state);
            return pp_rinit(state);
          }
          pp_close_box(state, 0);
        }
      }
      function pp_print_as_size(state, size, s2) {
        var _aX_ = state[14] < state[15] ? 1 : 0;
        return _aX_ ? enqueue_string_as(state, size, s2) : _aX_;
      }
      function pp_print_as(state, isize, s2) {
        return pp_print_as_size(state, isize, s2);
      }
      function pp_print_string(state, s2) {
        return pp_print_as(state, caml_ml_string_length2(s2), s2);
      }
      function pp_print_bytes(state, s2) {
        return pp_print_as(
          state,
          runtime.caml_ml_bytes_length(s2),
          caml_call1(Stdlib_Bytes[6], s2)
        );
      }
      function pp_print_int(state, i) {
        return pp_print_string(state, caml_call1(Stdlib_Int[12], i));
      }
      function pp_print_float(state, f) {
        return pp_print_string(state, caml_call1(Stdlib[35], f));
      }
      function pp_print_bool(state, b) {
        return pp_print_string(state, caml_call1(Stdlib[30], b));
      }
      function pp_print_char(state, c) {
        return pp_print_as(state, 1, caml_call2(Stdlib_String[1], 1, c));
      }
      function pp_open_hbox(state, param) {
        return pp_open_box_gen(state, 0, 0);
      }
      function pp_open_vbox(state, indent) {
        return pp_open_box_gen(state, indent, 1);
      }
      function pp_open_hvbox(state, indent) {
        return pp_open_box_gen(state, indent, 2);
      }
      function pp_open_hovbox(state, indent) {
        return pp_open_box_gen(state, indent, 3);
      }
      function pp_open_box(state, indent) {
        return pp_open_box_gen(state, indent, 4);
      }
      function pp_print_newline(state, param) {
        pp_flush_queue(state, 1);
        return caml_call1(state[18], 0);
      }
      function pp_print_flush(state, param) {
        pp_flush_queue(state, 0);
        return caml_call1(state[18], 0);
      }
      function pp_force_newline(state, param) {
        var _aW_ = state[14] < state[15] ? 1 : 0;
        return _aW_ ? enqueue_advance(state, [0, zero, 3, 0]) : _aW_;
      }
      function pp_print_if_newline(state, param) {
        var _aV_ = state[14] < state[15] ? 1 : 0;
        return _aV_ ? enqueue_advance(state, [0, zero, 4, 0]) : _aV_;
      }
      function pp_print_custom_break(state, fits, breaks) {
        var after = fits[3], width = fits[2], before = fits[1], _aU_ = state[14] < state[15] ? 1 : 0;
        if (!_aU_)
          return _aU_;
        var size = -state[13] | 0, token = [1, fits, breaks], length = (caml_ml_string_length2(before) + width | 0) + caml_ml_string_length2(after) | 0, elem = [0, size, token, length];
        return scan_push(state, 1, elem);
      }
      function pp_print_break(state, width, offset) {
        return pp_print_custom_break(state, [0, cst$6, width, cst$5], [0, cst$4, offset, cst$3]);
      }
      function pp_print_space(state, param) {
        return pp_print_break(state, 1, 0);
      }
      function pp_print_cut(state, param) {
        return pp_print_break(state, 0, 0);
      }
      function pp_open_tbox(state, param) {
        state[14] = state[14] + 1 | 0;
        var _aT_ = state[14] < state[15] ? 1 : 0;
        if (!_aT_)
          return _aT_;
        var elem = [0, zero, [4, [0, [0, 0]]], 0];
        return enqueue_advance(state, elem);
      }
      function pp_close_tbox(state, param) {
        var _aQ_ = 1 < state[14] ? 1 : 0;
        if (_aQ_) {
          var _aR_ = state[14] < state[15] ? 1 : 0;
          if (_aR_) {
            var elem = [0, zero, 2, 0];
            enqueue_advance(state, elem);
            state[14] = state[14] - 1 | 0;
            var _aS_ = 0;
          } else
            var _aS_ = _aR_;
        } else
          var _aS_ = _aQ_;
        return _aS_;
      }
      function pp_print_tbreak(state, width, offset) {
        var _aP_ = state[14] < state[15] ? 1 : 0;
        if (!_aP_)
          return _aP_;
        var size = -state[13] | 0, elem = [0, size, [2, width, offset], width];
        return scan_push(state, 1, elem);
      }
      function pp_print_tab(state, param) {
        return pp_print_tbreak(state, 0, 0);
      }
      function pp_set_tab(state, param) {
        var _aO_ = state[14] < state[15] ? 1 : 0;
        if (!_aO_)
          return _aO_;
        var elem = [0, zero, 0, 0];
        return enqueue_advance(state, elem);
      }
      function pp_set_max_boxes(state, n) {
        var _aM_ = 1 < n ? 1 : 0, _aN_ = _aM_ ? (state[15] = n, 0) : _aM_;
        return _aN_;
      }
      function pp_get_max_boxes(state, param) {
        return state[15];
      }
      function pp_over_max_boxes(state, param) {
        return state[14] === state[15] ? 1 : 0;
      }
      function pp_set_ellipsis_text(state, s2) {
        state[16] = s2;
        return 0;
      }
      function pp_get_ellipsis_text(state, param) {
        return state[16];
      }
      function pp_limit(n) {
        return n < 1000000010 ? n : 1000000009;
      }
      function pp_set_max_indent(state, n$0) {
        var _aL_ = 1 < n$0 ? 1 : 0;
        if (!_aL_)
          return _aL_;
        var n$1 = state[6] - n$0 | 0, _aK_ = 1 <= n$1 ? 1 : 0;
        if (!_aK_)
          return _aK_;
        var n = pp_limit(n$1);
        state[7] = n;
        state[8] = state[6] - state[7] | 0;
        return pp_rinit(state);
      }
      function pp_get_max_indent(state, param) {
        return state[8];
      }
      function pp_set_margin(state, n) {
        var _aI_ = 1 <= n ? 1 : 0;
        if (!_aI_)
          return _aI_;
        var n$0 = pp_limit(n);
        state[6] = n$0;
        if (state[8] <= state[6])
          var new_max_indent = state[8];
        else
          var _aJ_ = caml_call2(Stdlib_Int[11], state[6] - state[7] | 0, state[6] / 2 | 0), new_max_indent = caml_call2(Stdlib_Int[11], _aJ_, 1);
        return pp_set_max_indent(state, new_max_indent);
      }
      function validate_geometry(param) {
        var margin = param[2], max_indent = param[1];
        return 2 <= max_indent ? margin <= max_indent ? _c_ : _d_ : _e_;
      }
      function check_geometry(geometry) {
        return 0 === validate_geometry(geometry)[0] ? 1 : 0;
      }
      function pp_get_margin(state, param) {
        return state[6];
      }
      function pp_set_full_geometry(state, param) {
        var margin = param[2], max_indent = param[1];
        pp_set_margin(state, margin);
        pp_set_max_indent(state, max_indent);
        return 0;
      }
      function pp_set_geometry(state, max_indent, margin) {
        var geometry = [0, max_indent, margin], match = validate_geometry(geometry);
        if (0 === match[0])
          return pp_set_full_geometry(state, geometry);
        var msg = match[1], _aH_ = caml_call2(Stdlib[28], cst_Format_pp_set_geometry, msg);
        throw caml_maybe_attach_backtrace2([0, Stdlib[6], _aH_], 1);
      }
      function pp_safe_set_geometry(state, max_indent, margin) {
        var geometry = [0, max_indent, margin];
        return 0 === validate_geometry(geometry)[0] ? pp_set_full_geometry(state, geometry) : 0;
      }
      function pp_get_geometry(state, param) {
        return [0, state[8], state[6]];
      }
      function pp_update_geometry(state, update) {
        var geometry = pp_get_geometry(state, 0);
        return pp_set_full_geometry(state, caml_call1(update, geometry));
      }
      function pp_set_formatter_out_functions(state, param) {
        var j = param[5], i = param[4], h = param[3], g = param[2], f = param[1];
        state[17] = f;
        state[18] = g;
        state[19] = h;
        state[20] = i;
        state[21] = j;
        return 0;
      }
      function pp_get_formatter_out_functions(state, param) {
        return [0, state[17], state[18], state[19], state[20], state[21]];
      }
      function pp_set_formatter_output_functi(state, f, g) {
        state[17] = f;
        state[18] = g;
        return 0;
      }
      function pp_get_formatter_output_functi(state, param) {
        return [0, state[17], state[18]];
      }
      function display_newline(state, param) {
        return caml_call3(state[17], cst$7, 0, 1);
      }
      var blank_line = caml_call2(Stdlib_String[1], 80, 32), _f_ = [3, 0, 3];
      function display_blanks(state, n) {
        var n$0 = n;
        for (; ; ) {
          var _aG_ = 0 < n$0 ? 1 : 0;
          if (!_aG_)
            return _aG_;
          if (80 >= n$0)
            return caml_call3(state[17], blank_line, 0, n$0);
          caml_call3(state[17], blank_line, 0, 80);
          var n$1 = n$0 - 80 | 0, n$0 = n$1;
        }
      }
      function pp_set_formatter_out_channel(state, oc) {
        state[17] = caml_call1(Stdlib[69], oc);
        state[18] = function(param) {
          return caml_call1(Stdlib[63], oc);
        };
        state[19] = function(_aF_) {
          return display_newline(state, _aF_);
        };
        state[20] = function(_aE_) {
          return display_blanks(state, _aE_);
        };
        state[21] = function(_aD_) {
          return display_blanks(state, _aD_);
        };
        return 0;
      }
      function default_pp_mark_open_tag(param) {
        if (param[1] !== String_tag)
          return cst$10;
        var s2 = param[2], _aC_ = caml_call2(Stdlib[28], s2, cst$8);
        return caml_call2(Stdlib[28], cst$9, _aC_);
      }
      function default_pp_mark_close_tag(param) {
        if (param[1] !== String_tag)
          return cst$13;
        var s2 = param[2], _aB_ = caml_call2(Stdlib[28], s2, cst$11);
        return caml_call2(Stdlib[28], cst$12, _aB_);
      }
      function default_pp_print_open_tag(_aA_) {
        return 0;
      }
      function default_pp_print_close_tag(_az_) {
        return 0;
      }
      function pp_make_formatter(f, g, h, i, j) {
        var pp_queue = caml_call1(Stdlib_Queue[2], 0), sys_tok = [0, unknown, _f_, 0];
        caml_call2(Stdlib_Queue[3], sys_tok, pp_queue);
        var scan_stack = caml_call1(Stdlib_Stack[2], 0);
        initialize_scan_stack(scan_stack);
        caml_call2(Stdlib_Stack[3], [0, 1, sys_tok], scan_stack);
        var pp_margin = 78, _av_ = Stdlib[19], _aw_ = caml_call1(Stdlib_Stack[2], 0), _ax_ = caml_call1(Stdlib_Stack[2], 0), _ay_ = caml_call1(Stdlib_Stack[2], 0);
        return [
          0,
          scan_stack,
          caml_call1(Stdlib_Stack[2], 0),
          _ay_,
          _ax_,
          _aw_,
          pp_margin,
          10,
          68,
          pp_margin,
          0,
          1,
          1,
          1,
          1,
          _av_,
          cst$14,
          f,
          g,
          h,
          i,
          j,
          0,
          0,
          default_pp_mark_open_tag,
          default_pp_mark_close_tag,
          default_pp_print_open_tag,
          default_pp_print_close_tag,
          pp_queue
        ];
      }
      function formatter_of_out_functions(out_funs) {
        return pp_make_formatter(out_funs[1], out_funs[2], out_funs[3], out_funs[4], out_funs[5]);
      }
      function make_formatter(output, flush) {
        var ppf = pp_make_formatter(
          output,
          flush,
          function(_au_) {
            return 0;
          },
          function(_at_) {
            return 0;
          },
          function(_as_) {
            return 0;
          }
        );
        ppf[19] = function(_ar_) {
          return display_newline(ppf, _ar_);
        };
        ppf[20] = function(_aq_) {
          return display_blanks(ppf, _aq_);
        };
        ppf[21] = function(_ap_) {
          return display_blanks(ppf, _ap_);
        };
        return ppf;
      }
      function formatter_of_out_channel(oc) {
        return make_formatter(
          caml_call1(Stdlib[69], oc),
          function(param) {
            return caml_call1(Stdlib[63], oc);
          }
        );
      }
      function formatter_of_buffer(b) {
        return make_formatter(caml_call1(Stdlib_Buffer[18], b), function(_ao_) {
          return 0;
        });
      }
      var pp_buffer_size = 512;
      function pp_make_buffer(param) {
        return caml_call1(Stdlib_Buffer[1], pp_buffer_size);
      }
      var stdbuf = pp_make_buffer(0), std_formatter = formatter_of_out_channel(Stdlib[39]), err_formatter = formatter_of_out_channel(Stdlib[40]), str_formatter = formatter_of_buffer(stdbuf), stdbuf_key = caml_call2(Stdlib_Domain[10][1], 0, pp_make_buffer);
      caml_call2(Stdlib_Domain[10][3], stdbuf_key, stdbuf);
      var str_formatter_key = caml_call2(
        Stdlib_Domain[10][1],
        0,
        function(param) {
          return formatter_of_buffer(caml_call1(Stdlib_Domain[10][2], stdbuf_key));
        }
      );
      caml_call2(Stdlib_Domain[10][3], str_formatter_key, str_formatter);
      function buffered_out_string(key, str, ofs, len) {
        var _an_ = caml_call1(Stdlib_Domain[10][2], key);
        return caml_call4(Stdlib_Buffer[18], _an_, str, ofs, len);
      }
      function buffered_out_flush(oc, key, param) {
        var buf = caml_call1(Stdlib_Domain[10][2], key), len = caml_call1(Stdlib_Buffer[7], buf), str = caml_call1(Stdlib_Buffer[2], buf);
        caml_call4(Stdlib[69], oc, str, 0, len);
        caml_call1(Stdlib[63], oc);
        return caml_call1(Stdlib_Buffer[8], buf);
      }
      var std_buf_key = caml_call2(
        Stdlib_Domain[10][1],
        0,
        function(param) {
          return caml_call1(Stdlib_Buffer[1], pp_buffer_size);
        }
      ), err_buf_key = caml_call2(
        Stdlib_Domain[10][1],
        0,
        function(param) {
          return caml_call1(Stdlib_Buffer[1], pp_buffer_size);
        }
      ), std_formatter_key = caml_call2(
        Stdlib_Domain[10][1],
        0,
        function(param) {
          var _ab_ = Stdlib[39], ppf = pp_make_formatter(
            function(_ak_, _al_, _am_) {
              return buffered_out_string(std_buf_key, _ak_, _al_, _am_);
            },
            function(_aj_) {
              return buffered_out_flush(_ab_, std_buf_key, _aj_);
            },
            function(_ai_) {
              return 0;
            },
            function(_ah_) {
              return 0;
            },
            function(_ag_) {
              return 0;
            }
          );
          ppf[19] = function(_af_) {
            return display_newline(ppf, _af_);
          };
          ppf[20] = function(_ae_) {
            return display_blanks(ppf, _ae_);
          };
          ppf[21] = function(_ad_) {
            return display_blanks(ppf, _ad_);
          };
          caml_call1(
            Stdlib_Domain[6],
            function(_ac_) {
              return pp_print_flush(ppf, _ac_);
            }
          );
          return ppf;
        }
      );
      caml_call2(Stdlib_Domain[10][3], std_formatter_key, std_formatter);
      var err_formatter_key = caml_call2(
        Stdlib_Domain[10][1],
        0,
        function(param) {
          var _R_ = Stdlib[40], ppf = pp_make_formatter(
            function(___, _$_, _aa_) {
              return buffered_out_string(err_buf_key, ___, _$_, _aa_);
            },
            function(_Z_) {
              return buffered_out_flush(_R_, err_buf_key, _Z_);
            },
            function(_Y_) {
              return 0;
            },
            function(_X_) {
              return 0;
            },
            function(_W_) {
              return 0;
            }
          );
          ppf[19] = function(_V_) {
            return display_newline(ppf, _V_);
          };
          ppf[20] = function(_U_) {
            return display_blanks(ppf, _U_);
          };
          ppf[21] = function(_T_2) {
            return display_blanks(ppf, _T_2);
          };
          caml_call1(Stdlib_Domain[6], function(_S_) {
            return pp_print_flush(ppf, _S_);
          });
          return ppf;
        }
      );
      caml_call2(Stdlib_Domain[10][3], err_formatter_key, err_formatter);
      function get_std_formatter(param) {
        return caml_call1(Stdlib_Domain[10][2], std_formatter_key);
      }
      function get_err_formatter(param) {
        return caml_call1(Stdlib_Domain[10][2], err_formatter_key);
      }
      function get_str_formatter(param) {
        return caml_call1(Stdlib_Domain[10][2], str_formatter_key);
      }
      function get_stdbuf(param) {
        return caml_call1(Stdlib_Domain[10][2], stdbuf_key);
      }
      function flush_buffer_formatter(buf, ppf) {
        pp_flush_queue(ppf, 0);
        var s2 = caml_call1(Stdlib_Buffer[2], buf);
        caml_call1(Stdlib_Buffer[9], buf);
        return s2;
      }
      function flush_str_formatter(param) {
        var stdbuf2 = caml_call1(Stdlib_Domain[10][2], stdbuf_key), str_formatter2 = caml_call1(Stdlib_Domain[10][2], str_formatter_key);
        return flush_buffer_formatter(stdbuf2, str_formatter2);
      }
      function make_synchronized_formatter(output, flush) {
        return caml_call2(
          Stdlib_Domain[10][1],
          0,
          function(param) {
            var buf = caml_call1(Stdlib_Buffer[1], pp_buffer_size), output$0 = caml_call1(Stdlib_Buffer[18], buf);
            function flush$0(param2) {
              var _Q_ = caml_call1(Stdlib_Buffer[7], buf);
              caml_call3(output, caml_call1(Stdlib_Buffer[2], buf), 0, _Q_);
              caml_call1(Stdlib_Buffer[8], buf);
              return caml_call1(flush, 0);
            }
            return make_formatter(output$0, flush$0);
          }
        );
      }
      function synchronized_formatter_of_out_(oc) {
        return make_synchronized_formatter(
          caml_call1(Stdlib[69], oc),
          function(param) {
            return caml_call1(Stdlib[63], oc);
          }
        );
      }
      function make_symbolic_output_buffer(param) {
        return [0, 0];
      }
      function clear_symbolic_output_buffer(sob) {
        sob[1] = 0;
        return 0;
      }
      function get_symbolic_output_buffer(sob) {
        return caml_call1(Stdlib_List[10], sob[1]);
      }
      function flush_symbolic_output_buffer(sob) {
        var items = get_symbolic_output_buffer(sob);
        clear_symbolic_output_buffer(sob);
        return items;
      }
      function add_symbolic_output_item(sob, item) {
        sob[1] = [0, item, sob[1]];
        return 0;
      }
      function formatter_of_symbolic_output_b(sob) {
        function f(s2, i2, n) {
          return add_symbolic_output_item(sob, [0, caml_call3(Stdlib_String[16], s2, i2, n)]);
        }
        function g(_P_) {
          return add_symbolic_output_item(sob, 0);
        }
        function h(_O_) {
          return add_symbolic_output_item(sob, 1);
        }
        function i(n) {
          return add_symbolic_output_item(sob, [1, n]);
        }
        function j(n) {
          return add_symbolic_output_item(sob, [2, n]);
        }
        return pp_make_formatter(f, g, h, i, j);
      }
      function open_hbox(v) {
        return pp_open_hbox(caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
      }
      function open_vbox(v) {
        return pp_open_vbox(caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
      }
      function open_hvbox(v) {
        return pp_open_hvbox(caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
      }
      function open_hovbox(v) {
        return pp_open_hovbox(caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
      }
      function open_box(v) {
        return pp_open_box(caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
      }
      function close_box(v) {
        return pp_close_box(caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
      }
      function open_stag(v) {
        return pp_open_stag(caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
      }
      function close_stag(v) {
        return pp_close_stag(caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
      }
      function print_as(v, w) {
        return pp_print_as(caml_call1(Stdlib_Domain[10][2], std_formatter_key), v, w);
      }
      function print_string(v) {
        return pp_print_string(caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
      }
      function print_bytes(v) {
        return pp_print_bytes(caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
      }
      function print_int(v) {
        return pp_print_int(caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
      }
      function print_float(v) {
        return pp_print_float(caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
      }
      function print_char(v) {
        return pp_print_char(caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
      }
      function print_bool(v) {
        return pp_print_bool(caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
      }
      function print_break(v, w) {
        return pp_print_break(caml_call1(Stdlib_Domain[10][2], std_formatter_key), v, w);
      }
      function print_cut(v) {
        return pp_print_cut(caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
      }
      function print_space(v) {
        return pp_print_space(caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
      }
      function force_newline(v) {
        return pp_force_newline(caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
      }
      function print_flush(v) {
        return pp_print_flush(caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
      }
      function print_newline(v) {
        return pp_print_newline(caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
      }
      function print_if_newline(v) {
        return pp_print_if_newline(caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
      }
      function open_tbox(v) {
        return pp_open_tbox(caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
      }
      function close_tbox(v) {
        return pp_close_tbox(caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
      }
      function print_tbreak(v, w) {
        return pp_print_tbreak(caml_call1(Stdlib_Domain[10][2], std_formatter_key), v, w);
      }
      function set_tab(v) {
        return pp_set_tab(caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
      }
      function print_tab(v) {
        return pp_print_tab(caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
      }
      function set_margin(v) {
        return pp_set_margin(caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
      }
      function get_margin(v) {
        return caml_call1(Stdlib_Domain[10][2], std_formatter_key)[6];
      }
      function set_max_indent(v) {
        return pp_set_max_indent(caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
      }
      function get_max_indent(v) {
        return caml_call1(Stdlib_Domain[10][2], std_formatter_key)[8];
      }
      function set_geometry(max_indent, margin) {
        return pp_set_geometry(
          caml_call1(Stdlib_Domain[10][2], std_formatter_key),
          max_indent,
          margin
        );
      }
      function safe_set_geometry(max_indent, margin) {
        return pp_safe_set_geometry(
          caml_call1(Stdlib_Domain[10][2], std_formatter_key),
          max_indent,
          margin
        );
      }
      function get_geometry(v) {
        return pp_get_geometry(caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
      }
      function update_geometry(v) {
        return pp_update_geometry(caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
      }
      function set_max_boxes(v) {
        return pp_set_max_boxes(caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
      }
      function get_max_boxes(v) {
        return caml_call1(Stdlib_Domain[10][2], std_formatter_key)[15];
      }
      function over_max_boxes(v) {
        return pp_over_max_boxes(caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
      }
      function set_ellipsis_text(v) {
        return pp_set_ellipsis_text(caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
      }
      function get_ellipsis_text(v) {
        return caml_call1(Stdlib_Domain[10][2], std_formatter_key)[16];
      }
      function set_formatter_out_channel(v) {
        return pp_set_formatter_out_channel(caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
      }
      function set_formatter_out_functions(v) {
        return pp_set_formatter_out_functions(caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
      }
      function get_formatter_out_functions(v) {
        return pp_get_formatter_out_functions(caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
      }
      function set_formatter_output_functions(v, w) {
        return pp_set_formatter_output_functi(caml_call1(Stdlib_Domain[10][2], std_formatter_key), v, w);
      }
      function get_formatter_output_functions(v) {
        return pp_get_formatter_output_functi(caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
      }
      function set_formatter_stag_functions(v) {
        return pp_set_formatter_stag_function(caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
      }
      function get_formatter_stag_functions(v) {
        return pp_get_formatter_stag_function(caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
      }
      function set_print_tags(v) {
        return pp_set_print_tags(caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
      }
      function get_print_tags(v) {
        return caml_call1(Stdlib_Domain[10][2], std_formatter_key)[22];
      }
      function set_mark_tags(v) {
        return pp_set_mark_tags(caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
      }
      function get_mark_tags(v) {
        return caml_call1(Stdlib_Domain[10][2], std_formatter_key)[23];
      }
      function set_tags(v) {
        return pp_set_tags(caml_call1(Stdlib_Domain[10][2], std_formatter_key), v);
      }
      function pp_print_iter(opt, iter, pp_v, ppf, v) {
        if (opt)
          var sth = opt[1], pp_sep = sth;
        else
          var pp_sep = pp_print_cut;
        var is_first = [0, 1];
        function pp_v$0(v2) {
          if (is_first[1])
            is_first[1] = 0;
          else
            caml_call2(pp_sep, ppf, 0);
          return caml_call2(pp_v, ppf, v2);
        }
        return caml_call2(iter, pp_v$0, v);
      }
      function pp_print_list(opt, pp_v, ppf, v) {
        if (opt)
          var sth = opt[1], pp_sep = sth;
        else
          var pp_sep = pp_print_cut;
        return pp_print_iter([0, pp_sep], Stdlib_List[18], pp_v, ppf, v);
      }
      function pp_print_array(opt, pp_v, ppf, v) {
        if (opt)
          var sth = opt[1], pp_sep = sth;
        else
          var pp_sep = pp_print_cut;
        return pp_print_iter([0, pp_sep], Stdlib_Array[11], pp_v, ppf, v);
      }
      function pp_print_seq(opt, pp_v, ppf, seq) {
        if (opt)
          var sth = opt[1], pp_sep = sth;
        else
          var pp_sep = pp_print_cut;
        return pp_print_iter([0, pp_sep], Stdlib_Seq[4], pp_v, ppf, seq);
      }
      function pp_print_text(ppf, s2) {
        var len = caml_ml_string_length2(s2), left = [0, 0], right = [0, 0];
        function flush(param) {
          pp_print_string(ppf, caml_call3(Stdlib_String[16], s2, left[1], right[1] - left[1] | 0));
          right[1]++;
          left[1] = right[1];
          return 0;
        }
        for (; ; ) {
          if (right[1] === len) {
            var _N_ = left[1] !== len ? 1 : 0;
            return _N_ ? flush(0) : _N_;
          }
          var match = runtime.caml_string_get(s2, right[1]);
          if (10 === match) {
            flush(0);
            pp_force_newline(ppf, 0);
          } else if (32 === match) {
            flush(0);
            pp_print_space(ppf, 0);
          } else
            right[1]++;
        }
      }
      function pp_print_option(opt, pp_v, ppf, param) {
        if (opt)
          var sth = opt[1], none = sth;
        else
          var none = function(param2, _M_) {
            return 0;
          };
        if (!param)
          return caml_call2(none, ppf, 0);
        var v = param[1];
        return caml_call2(pp_v, ppf, v);
      }
      function pp_print_result(ok, error, ppf, param) {
        if (0 === param[0]) {
          var v = param[1];
          return caml_call2(ok, ppf, v);
        }
        var e = param[1];
        return caml_call2(error, ppf, e);
      }
      function pp_print_either(left, right, ppf, param) {
        if (0 === param[0]) {
          var l = param[1];
          return caml_call2(left, ppf, l);
        }
        var r = param[1];
        return caml_call2(right, ppf, r);
      }
      function compute_tag(output, tag_acc) {
        var buf = caml_call1(Stdlib_Buffer[1], 16), ppf = formatter_of_buffer(buf);
        caml_call2(output, ppf, tag_acc);
        pp_print_flush(ppf, 0);
        var len = caml_call1(Stdlib_Buffer[7], buf);
        return 2 <= len ? caml_call3(Stdlib_Buffer[4], buf, 1, len - 2 | 0) : caml_call1(Stdlib_Buffer[2], buf);
      }
      function output_formatting_lit(ppf, fmting_lit) {
        if (typeof fmting_lit === "number")
          switch (fmting_lit) {
            case 0:
              return pp_close_box(ppf, 0);
            case 1:
              return pp_close_stag(ppf, 0);
            case 2:
              return pp_print_flush(ppf, 0);
            case 3:
              return pp_force_newline(ppf, 0);
            case 4:
              return pp_print_newline(ppf, 0);
            case 5:
              return pp_print_char(ppf, 64);
            default:
              return pp_print_char(ppf, 37);
          }
        switch (fmting_lit[0]) {
          case 0:
            var offset = fmting_lit[3], width = fmting_lit[2];
            return pp_print_break(ppf, width, offset);
          case 1:
            return 0;
          default:
            var c = fmting_lit[1];
            pp_print_char(ppf, 64);
            return pp_print_char(ppf, c);
        }
      }
      function output_acc(ppf, acc) {
        if (typeof acc === "number")
          return 0;
        a: {
          b: {
            c: {
              switch (acc[0]) {
                case 0:
                  var f = acc[2], p = acc[1];
                  output_acc(ppf, p);
                  return output_formatting_lit(ppf, f);
                case 1:
                  var match = acc[2], p$0 = acc[1];
                  if (0 === match[0]) {
                    var acc$0 = match[1];
                    output_acc(ppf, p$0);
                    return pp_open_stag(ppf, [0, String_tag, compute_tag(output_acc, acc$0)]);
                  }
                  var acc$1 = match[1];
                  output_acc(ppf, p$0);
                  var _D_ = compute_tag(output_acc, acc$1), match$0 = caml_call1(CamlinternalFormat[20], _D_), bty = match$0[2], indent = match$0[1];
                  return pp_open_box_gen(ppf, indent, bty);
                case 2:
                  var _E_ = acc[1];
                  if (typeof _E_ !== "number" && 0 === _E_[0]) {
                    var _F_ = _E_[2];
                    if (typeof _F_ !== "number" && 1 === _F_[0]) {
                      var s$0 = acc[2], size = _F_[2], p$2 = _E_[1];
                      break b;
                    }
                  }
                  var s2 = acc[2], p$1 = _E_;
                  break a;
                case 3:
                  var _G_ = acc[1];
                  if (typeof _G_ !== "number" && 0 === _G_[0]) {
                    var _H_ = _G_[2];
                    if (typeof _H_ !== "number" && 1 === _H_[0]) {
                      var c$0 = acc[2], size$0 = _H_[2], p$4 = _G_[1];
                      break;
                    }
                  }
                  var c = acc[2], p$3 = _G_;
                  break c;
                case 4:
                  var _I_ = acc[1];
                  if (typeof _I_ !== "number" && 0 === _I_[0]) {
                    var _J_ = _I_[2];
                    if (typeof _J_ !== "number" && 1 === _J_[0]) {
                      var s$0 = acc[2], size = _J_[2], p$2 = _I_[1];
                      break b;
                    }
                  }
                  var s2 = acc[2], p$1 = _I_;
                  break a;
                case 5:
                  var _K_ = acc[1];
                  if (typeof _K_ !== "number" && 0 === _K_[0]) {
                    var _L_ = _K_[2];
                    if (typeof _L_ !== "number" && 1 === _L_[0]) {
                      var c$0 = acc[2], size$0 = _L_[2], p$4 = _K_[1];
                      break;
                    }
                  }
                  var c = acc[2], p$3 = _K_;
                  break c;
                case 6:
                  var f$0 = acc[2], p$5 = acc[1];
                  output_acc(ppf, p$5);
                  return caml_call1(f$0, ppf);
                case 7:
                  var p$6 = acc[1];
                  output_acc(ppf, p$6);
                  return pp_print_flush(ppf, 0);
                default:
                  var msg = acc[2], p$7 = acc[1];
                  output_acc(ppf, p$7);
                  return caml_call1(Stdlib[1], msg);
              }
              output_acc(ppf, p$4);
              return pp_print_as_size(ppf, size$0, caml_call2(Stdlib_String[1], 1, c$0));
            }
            output_acc(ppf, p$3);
            return pp_print_char(ppf, c);
          }
          output_acc(ppf, p$2);
          return pp_print_as_size(ppf, size, s$0);
        }
        output_acc(ppf, p$1);
        return pp_print_string(ppf, s2);
      }
      function strput_acc(ppf, acc) {
        if (typeof acc === "number")
          return 0;
        a: {
          b: {
            c: {
              switch (acc[0]) {
                case 0:
                  var f = acc[2], p = acc[1];
                  strput_acc(ppf, p);
                  return output_formatting_lit(ppf, f);
                case 1:
                  var match = acc[2], p$0 = acc[1];
                  if (0 === match[0]) {
                    var acc$0 = match[1];
                    strput_acc(ppf, p$0);
                    return pp_open_stag(ppf, [0, String_tag, compute_tag(strput_acc, acc$0)]);
                  }
                  var acc$1 = match[1];
                  strput_acc(ppf, p$0);
                  var _u_ = compute_tag(strput_acc, acc$1), match$0 = caml_call1(CamlinternalFormat[20], _u_), bty = match$0[2], indent = match$0[1];
                  return pp_open_box_gen(ppf, indent, bty);
                case 2:
                  var _v_ = acc[1];
                  if (typeof _v_ !== "number" && 0 === _v_[0]) {
                    var _w_ = _v_[2];
                    if (typeof _w_ !== "number" && 1 === _w_[0]) {
                      var s$0 = acc[2], size = _w_[2], p$2 = _v_[1];
                      break b;
                    }
                  }
                  var s2 = acc[2], p$1 = _v_;
                  break a;
                case 3:
                  var _x_ = acc[1];
                  if (typeof _x_ !== "number" && 0 === _x_[0]) {
                    var _y_ = _x_[2];
                    if (typeof _y_ !== "number" && 1 === _y_[0]) {
                      var c$0 = acc[2], size$0 = _y_[2], p$4 = _x_[1];
                      break;
                    }
                  }
                  var c = acc[2], p$3 = _x_;
                  break c;
                case 4:
                  var _z_ = acc[1];
                  if (typeof _z_ !== "number" && 0 === _z_[0]) {
                    var _A_ = _z_[2];
                    if (typeof _A_ !== "number" && 1 === _A_[0]) {
                      var s$0 = acc[2], size = _A_[2], p$2 = _z_[1];
                      break b;
                    }
                  }
                  var s2 = acc[2], p$1 = _z_;
                  break a;
                case 5:
                  var _B_ = acc[1];
                  if (typeof _B_ !== "number" && 0 === _B_[0]) {
                    var _C_ = _B_[2];
                    if (typeof _C_ !== "number" && 1 === _C_[0]) {
                      var c$0 = acc[2], size$0 = _C_[2], p$4 = _B_[1];
                      break;
                    }
                  }
                  var c = acc[2], p$3 = _B_;
                  break c;
                case 6:
                  var p$5 = acc[1];
                  if (typeof p$5 !== "number" && 0 === p$5[0]) {
                    var match$1 = p$5[2];
                    if (typeof match$1 !== "number" && 1 === match$1[0]) {
                      var f$1 = acc[2], size$1 = match$1[2], p$6 = p$5[1];
                      strput_acc(ppf, p$6);
                      return pp_print_as_size(ppf, size$1, caml_call1(f$1, 0));
                    }
                  }
                  var f$0 = acc[2];
                  strput_acc(ppf, p$5);
                  return pp_print_string(ppf, caml_call1(f$0, 0));
                case 7:
                  var p$7 = acc[1];
                  strput_acc(ppf, p$7);
                  return pp_print_flush(ppf, 0);
                default:
                  var msg = acc[2], p$8 = acc[1];
                  strput_acc(ppf, p$8);
                  return caml_call1(Stdlib[1], msg);
              }
              strput_acc(ppf, p$4);
              return pp_print_as_size(ppf, size$0, caml_call2(Stdlib_String[1], 1, c$0));
            }
            strput_acc(ppf, p$3);
            return pp_print_char(ppf, c);
          }
          strput_acc(ppf, p$2);
          return pp_print_as_size(ppf, size, s$0);
        }
        strput_acc(ppf, p$1);
        return pp_print_string(ppf, s2);
      }
      function kfprintf(k, ppf, param) {
        var fmt = param[1];
        return caml_call3(
          CamlinternalFormat[7],
          function(acc) {
            output_acc(ppf, acc);
            return caml_call1(k, ppf);
          },
          0,
          fmt
        );
      }
      function ikfprintf(k, ppf, param) {
        var fmt = param[1];
        return caml_call3(CamlinternalFormat[8], k, ppf, fmt);
      }
      function ifprintf(ppf, param) {
        var fmt = param[1];
        return caml_call3(CamlinternalFormat[8], function(_t_) {
          return 0;
        }, 0, fmt);
      }
      function fprintf(ppf) {
        function _q_(_s_) {
          return 0;
        }
        return function(_r_) {
          return kfprintf(_q_, ppf, _r_);
        };
      }
      function printf(param) {
        var fmt = param[1];
        return caml_call3(
          CamlinternalFormat[7],
          function(acc) {
            return output_acc(caml_call1(Stdlib_Domain[10][2], std_formatter_key), acc);
          },
          0,
          fmt
        );
      }
      function eprintf(param) {
        var fmt = param[1];
        return caml_call3(
          CamlinternalFormat[7],
          function(acc) {
            return output_acc(caml_call1(Stdlib_Domain[10][2], err_formatter_key), acc);
          },
          0,
          fmt
        );
      }
      function kdprintf(k, param) {
        var fmt = param[1];
        return caml_call3(
          CamlinternalFormat[7],
          function(acc) {
            return caml_call1(k, function(ppf) {
              return output_acc(ppf, acc);
            });
          },
          0,
          fmt
        );
      }
      function dprintf(fmt) {
        return kdprintf(function(i) {
          return i;
        }, fmt);
      }
      function ksprintf(k, param) {
        var fmt = param[1], b = pp_make_buffer(0), ppf = formatter_of_buffer(b);
        function k$0(acc) {
          strput_acc(ppf, acc);
          return caml_call1(k, flush_buffer_formatter(b, ppf));
        }
        return caml_call3(CamlinternalFormat[7], k$0, 0, fmt);
      }
      function sprintf(fmt) {
        return ksprintf(id, fmt);
      }
      function kasprintf(k, param) {
        var fmt = param[1], b = pp_make_buffer(0), ppf = formatter_of_buffer(b);
        function k$0(acc) {
          output_acc(ppf, acc);
          return caml_call1(k, flush_buffer_formatter(b, ppf));
        }
        return caml_call3(CamlinternalFormat[7], k$0, 0, fmt);
      }
      function asprintf(fmt) {
        return kasprintf(id, fmt);
      }
      function flush_standard_formatters(param) {
        pp_print_flush(caml_call1(Stdlib_Domain[10][2], std_formatter_key), 0);
        return pp_print_flush(caml_call1(Stdlib_Domain[10][2], err_formatter_key), 0);
      }
      caml_call1(Stdlib[100], flush_standard_formatters);
      caml_call1(
        Stdlib_Domain[5],
        function(param) {
          flush_standard_formatters(0);
          var fs = pp_get_formatter_out_functions(std_formatter, 0), _g_ = Stdlib[39];
          pp_set_formatter_out_functions(
            std_formatter,
            [
              0,
              function(_n_, _o_, _p_) {
                return buffered_out_string(std_buf_key, _n_, _o_, _p_);
              },
              function(_m_) {
                return buffered_out_flush(_g_, std_buf_key, _m_);
              },
              fs[3],
              fs[4],
              fs[5]
            ]
          );
          var fs$0 = pp_get_formatter_out_functions(err_formatter, 0), _h_ = Stdlib[40];
          return pp_set_formatter_out_functions(
            err_formatter,
            [
              0,
              function(_j_, _k_, _l_) {
                return buffered_out_string(err_buf_key, _j_, _k_, _l_);
              },
              function(_i_) {
                return buffered_out_flush(_h_, err_buf_key, _i_);
              },
              fs$0[3],
              fs$0[4],
              fs$0[5]
            ]
          );
        }
      );
      var Stdlib_Format = [
        0,
        pp_open_box,
        open_box,
        pp_close_box,
        close_box,
        pp_open_hbox,
        open_hbox,
        pp_open_vbox,
        open_vbox,
        pp_open_hvbox,
        open_hvbox,
        pp_open_hovbox,
        open_hovbox,
        pp_print_string,
        print_string,
        pp_print_bytes,
        print_bytes,
        pp_print_as,
        print_as,
        pp_print_int,
        print_int,
        pp_print_float,
        print_float,
        pp_print_char,
        print_char,
        pp_print_bool,
        print_bool,
        pp_print_space,
        print_space,
        pp_print_cut,
        print_cut,
        pp_print_break,
        print_break,
        pp_print_custom_break,
        pp_force_newline,
        force_newline,
        pp_print_if_newline,
        print_if_newline,
        pp_print_flush,
        print_flush,
        pp_print_newline,
        print_newline,
        pp_set_margin,
        set_margin,
        pp_get_margin,
        get_margin,
        pp_set_max_indent,
        set_max_indent,
        pp_get_max_indent,
        get_max_indent,
        check_geometry,
        pp_set_geometry,
        set_geometry,
        pp_safe_set_geometry,
        safe_set_geometry,
        pp_update_geometry,
        update_geometry,
        pp_get_geometry,
        get_geometry,
        pp_set_max_boxes,
        set_max_boxes,
        pp_get_max_boxes,
        get_max_boxes,
        pp_over_max_boxes,
        over_max_boxes,
        pp_open_tbox,
        open_tbox,
        pp_close_tbox,
        close_tbox,
        pp_set_tab,
        set_tab,
        pp_print_tab,
        print_tab,
        pp_print_tbreak,
        print_tbreak,
        pp_set_ellipsis_text,
        set_ellipsis_text,
        pp_get_ellipsis_text,
        get_ellipsis_text,
        String_tag,
        pp_open_stag,
        open_stag,
        pp_close_stag,
        close_stag,
        pp_set_tags,
        set_tags,
        pp_set_print_tags,
        set_print_tags,
        pp_set_mark_tags,
        set_mark_tags,
        pp_get_print_tags,
        get_print_tags,
        pp_get_mark_tags,
        get_mark_tags,
        pp_set_formatter_out_channel,
        set_formatter_out_channel,
        pp_set_formatter_output_functi,
        set_formatter_output_functions,
        pp_get_formatter_output_functi,
        get_formatter_output_functions,
        pp_set_formatter_out_functions,
        set_formatter_out_functions,
        pp_get_formatter_out_functions,
        get_formatter_out_functions,
        pp_set_formatter_stag_function,
        set_formatter_stag_functions,
        pp_get_formatter_stag_function,
        get_formatter_stag_functions,
        formatter_of_out_channel,
        synchronized_formatter_of_out_,
        std_formatter,
        get_std_formatter,
        err_formatter,
        get_err_formatter,
        formatter_of_buffer,
        stdbuf,
        get_stdbuf,
        str_formatter,
        get_str_formatter,
        flush_str_formatter,
        make_formatter,
        make_synchronized_formatter,
        formatter_of_out_functions,
        make_symbolic_output_buffer,
        clear_symbolic_output_buffer,
        get_symbolic_output_buffer,
        flush_symbolic_output_buffer,
        add_symbolic_output_item,
        formatter_of_symbolic_output_b,
        pp_print_iter,
        pp_print_list,
        pp_print_array,
        pp_print_seq,
        pp_print_text,
        pp_print_option,
        pp_print_result,
        pp_print_either,
        fprintf,
        printf,
        eprintf,
        sprintf,
        asprintf,
        dprintf,
        ifprintf,
        kfprintf,
        kdprintf,
        ikfprintf,
        ksprintf,
        kasprintf
      ];
      runtime.caml_register_global(37, Stdlib_Format, "Stdlib__Format");
      return;
    })(globalThis);
    (function(globalThis2) {
      "use strict";
      var runtime = globalThis2.jsoo_runtime, caml_register_named_value2 = runtime.caml_register_named_value, global_data = runtime.caml_get_global_data(), Stdlib_Obj = global_data.Stdlib__Obj, register = caml_register_named_value2;
      function register_exception(name, exn) {
        var _a_ = Stdlib_Obj[10], slot = runtime.caml_obj_tag(exn) === _a_ ? exn : exn[1];
        return caml_register_named_value2(name, slot);
      }
      var Stdlib_Callback = [0, register, register_exception];
      runtime.caml_register_global(1, Stdlib_Callback, "Stdlib__Callback");
      return;
    })(globalThis);
    (function(globalThis2) {
      "use strict";
      var runtime = globalThis2.jsoo_runtime, cst_camlinternalOO_ml = "camlinternalOO.ml", caml_check_bound2 = runtime.caml_check_bound, caml_div2 = runtime.caml_div, caml_get_public_method2 = runtime.caml_get_public_method, caml_make_vect2 = runtime.caml_make_vect, caml_maybe_attach_backtrace2 = runtime.caml_maybe_attach_backtrace, caml_obj_block2 = runtime.caml_obj_block, caml_set_oo_id2 = runtime.caml_set_oo_id, caml_string_compare2 = runtime.caml_string_compare, caml_wrap_exception2 = runtime.caml_wrap_exception;
      function caml_call1(f, a0) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 1 ? f(a0) : runtime.caml_call_gen(f, [a0]);
      }
      function caml_call2(f, a0, a1) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 2 ? f(a0, a1) : runtime.caml_call_gen(f, [a0, a1]);
      }
      function caml_call3(f, a0, a1, a2) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 3 ? f(a0, a1, a2) : runtime.caml_call_gen(f, [a0, a1, a2]);
      }
      function caml_call5(f, a0, a1, a2, a3, a4) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 5 ? f(a0, a1, a2, a3, a4) : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
      }
      var global_data = runtime.caml_get_global_data(), Assert_failure = global_data.Assert_failure, Stdlib_Sys = global_data.Stdlib__Sys, Stdlib_Obj = global_data.Stdlib__Obj, Stdlib = global_data.Stdlib, Stdlib_Array = global_data.Stdlib__Array, Stdlib_List = global_data.Stdlib__List, Stdlib_Map = global_data.Stdlib__Map;
      function copy(o) {
        var o$0 = o.slice();
        return caml_set_oo_id2(o$0);
      }
      var params = [0, 1, 1, 1, 3, 16];
      function public_method_label(s2) {
        var accu = [0, 0], _al_ = runtime.caml_ml_string_length(s2) - 1 | 0, _ak_ = 0;
        if (_al_ >= 0) {
          var i = _ak_;
          for (; ; ) {
            var _am_ = runtime.caml_string_get(s2, i);
            accu[1] = (223 * accu[1] | 0) + _am_ | 0;
            var _an_ = i + 1 | 0;
            if (_al_ === i)
              break;
            var i = _an_;
          }
        }
        accu[1] = accu[1] & 2147483647;
        var tag = 1073741823 < accu[1] ? accu[1] + 2147483648 | 0 : accu[1];
        return tag;
      }
      var compare = caml_string_compare2, Vars = caml_call1(Stdlib_Map[1], [0, compare]), compare$0 = caml_string_compare2, Meths = caml_call1(Stdlib_Map[1], [0, compare$0]), compare$1 = runtime.caml_int_compare, Labs = caml_call1(Stdlib_Map[1], [0, compare$1]), dummy_table = [0, 0, [0, 0], Meths[1], Labs[1], 0, 0, Vars[1], 0], table_count = [0, 0], dummy_met = caml_obj_block2(0, 0), initial_object_size = 2;
      function fit_size(n) {
        return 2 < n ? fit_size((n + 1 | 0) / 2 | 0) * 2 | 0 : n;
      }
      function new_table(pub_labels) {
        table_count[1]++;
        var len = pub_labels.length - 1, methods = caml_make_vect2((len * 2 | 0) + 2 | 0, dummy_met);
        caml_check_bound2(methods, 0)[1] = len;
        var _ad_ = Stdlib_Sys[9], _ae_ = (runtime.caml_mul(fit_size(len), _ad_) / 8 | 0) - 1 | 0;
        caml_check_bound2(methods, 1)[2] = _ae_;
        var _ag_ = len - 1 | 0, _af_ = 0;
        if (_ag_ >= 0) {
          var i = _af_;
          for (; ; ) {
            var _ai_ = (i * 2 | 0) + 3 | 0, _ah_ = caml_check_bound2(pub_labels, i)[1 + i];
            caml_check_bound2(methods, _ai_)[1 + _ai_] = _ah_;
            var _aj_ = i + 1 | 0;
            if (_ag_ === i)
              break;
            var i = _aj_;
          }
        }
        return [
          0,
          initial_object_size,
          methods,
          Meths[1],
          Labs[1],
          0,
          0,
          Vars[1],
          0
        ];
      }
      function resize(array, new_size) {
        var old_size = array[2].length - 1, _ab_ = old_size < new_size ? 1 : 0;
        if (_ab_) {
          var new_buck = caml_make_vect2(new_size, dummy_met);
          caml_call5(Stdlib_Array[8], array[2], 0, new_buck, 0, old_size);
          array[2] = new_buck;
          var _ac_ = 0;
        } else
          var _ac_ = _ab_;
        return _ac_;
      }
      var method_count = [0, 0], inst_var_count = [0, 0], _a_ = [0, cst_camlinternalOO_ml, 279, 50], _b_ = [0, cst_camlinternalOO_ml, 407, 13], _c_ = [0, cst_camlinternalOO_ml, 410, 13], _d_ = [0, cst_camlinternalOO_ml, 413, 13], _e_ = [0, cst_camlinternalOO_ml, 416, 13], _f_ = [0, cst_camlinternalOO_ml, 419, 13], _g_ = [0, cst_camlinternalOO_ml, 437, 17];
      function new_method(table) {
        var index = table[2].length - 1;
        resize(table, index + 1 | 0);
        return index;
      }
      function get_method_label(table, name) {
        try {
          var _$_ = caml_call2(Meths[17], name, table[3]);
          return _$_;
        } catch (_aa_) {
          var ___ = caml_wrap_exception2(_aa_);
          if (___ !== Stdlib[8])
            throw caml_maybe_attach_backtrace2(___, 0);
          var label = new_method(table);
          table[3] = caml_call3(Meths[2], name, label, table[3]);
          table[4] = caml_call3(Labs[2], label, 1, table[4]);
          return label;
        }
      }
      function get_method_labels(table, names) {
        return caml_call2(
          Stdlib_Array[13],
          function(_Z_) {
            return get_method_label(table, _Z_);
          },
          names
        );
      }
      function set_method(table, label, element) {
        method_count[1]++;
        return caml_call2(Labs[17], label, table[4]) ? (resize(table, label + 1 | 0), caml_check_bound2(table[2], label)[1 + label] = element, 0) : (table[6] = [0, [0, label, element], table[6]], 0);
      }
      function get_method(table, label) {
        try {
          var _X_ = caml_call2(Stdlib_List[49], label, table[6]);
          return _X_;
        } catch (_Y_) {
          var _W_ = caml_wrap_exception2(_Y_);
          if (_W_ === Stdlib[8])
            return caml_check_bound2(table[2], label)[1 + label];
          throw caml_maybe_attach_backtrace2(_W_, 0);
        }
      }
      function to_list(arr) {
        return 0 === arr ? 0 : caml_call1(Stdlib_Array[9], arr);
      }
      function narrow(table, vars, virt_meths, concr_meths) {
        var vars$0 = to_list(vars), virt_meths$0 = to_list(virt_meths), concr_meths$0 = to_list(concr_meths), virt_meth_labs = caml_call2(
          Stdlib_List[20],
          function(_V_) {
            return get_method_label(table, _V_);
          },
          virt_meths$0
        ), concr_meth_labs = caml_call2(
          Stdlib_List[20],
          function(_U_) {
            return get_method_label(table, _U_);
          },
          concr_meths$0
        );
        table[5] = [
          0,
          [0, table[3], table[4], table[6], table[7], virt_meth_labs, vars$0],
          table[5]
        ];
        table[7] = caml_call3(
          Vars[24],
          function(lab, info, tvars) {
            return caml_call2(Stdlib_List[37], lab, vars$0) ? caml_call3(Vars[2], lab, info, tvars) : tvars;
          },
          table[7],
          Vars[1]
        );
        var by_name = [0, Meths[1]], by_label = [0, Labs[1]];
        caml_call3(
          Stdlib_List[28],
          function(met, label) {
            by_name[1] = caml_call3(Meths[2], met, label, by_name[1]);
            var _P_ = by_label[1];
            try {
              var _S_ = caml_call2(Labs[17], label, table[4]), _R_ = _S_;
            } catch (_T_2) {
              var _Q_ = caml_wrap_exception2(_T_2);
              if (_Q_ !== Stdlib[8])
                throw caml_maybe_attach_backtrace2(_Q_, 0);
              var _R_ = 1;
            }
            by_label[1] = caml_call3(Labs[2], label, _R_, _P_);
            return 0;
          },
          concr_meths$0,
          concr_meth_labs
        );
        caml_call3(
          Stdlib_List[28],
          function(met, label) {
            by_name[1] = caml_call3(Meths[2], met, label, by_name[1]);
            by_label[1] = caml_call3(Labs[2], label, 0, by_label[1]);
            return 0;
          },
          virt_meths$0,
          virt_meth_labs
        );
        table[3] = by_name[1];
        table[4] = by_label[1];
        table[6] = caml_call3(
          Stdlib_List[27],
          function(met, hm) {
            var lab = met[1];
            return caml_call2(Stdlib_List[37], lab, virt_meth_labs) ? hm : [0, met, hm];
          },
          table[6],
          0
        );
        return 0;
      }
      function widen(table) {
        var match = caml_call1(Stdlib_List[6], table[5]), vars = match[6], virt_meths = match[5], saved_vars = match[4], saved_hidden_meths = match[3], by_label = match[2], by_name = match[1];
        table[5] = caml_call1(Stdlib_List[7], table[5]);
        table[7] = caml_call3(
          Stdlib_List[26],
          function(s2, v) {
            var _O_ = caml_call2(Vars[17], v, table[7]);
            return caml_call3(Vars[2], v, _O_, s2);
          },
          saved_vars,
          vars
        );
        table[3] = by_name;
        table[4] = by_label;
        table[6] = caml_call3(
          Stdlib_List[27],
          function(met, hm) {
            var lab = met[1];
            return caml_call2(Stdlib_List[37], lab, virt_meths) ? hm : [0, met, hm];
          },
          table[6],
          saved_hidden_meths
        );
        return 0;
      }
      function new_variable(table, name) {
        try {
          var _M_ = caml_call2(Vars[17], name, table[7]);
          return _M_;
        } catch (_N_) {
          var _L_ = caml_wrap_exception2(_N_);
          if (_L_ !== Stdlib[8])
            throw caml_maybe_attach_backtrace2(_L_, 0);
          var index = table[1];
          table[1] = index + 1 | 0;
          if (runtime.caml_string_notequal(name, ""))
            table[7] = caml_call3(Vars[2], name, index, table[7]);
          return index;
        }
      }
      function to_array(arr) {
        return runtime.caml_equal(arr, 0) ? [0] : arr;
      }
      function new_methods_variables(table, meths, vals) {
        var meths$0 = to_array(meths), nmeths = meths$0.length - 1, nvals = vals.length - 1, res = caml_make_vect2(nmeths + nvals | 0, 0), _D_ = nmeths - 1 | 0, _C_ = 0;
        if (_D_ >= 0) {
          var i$0 = _C_;
          for (; ; ) {
            var _J_ = get_method_label(table, caml_check_bound2(meths$0, i$0)[1 + i$0]);
            caml_check_bound2(res, i$0)[1 + i$0] = _J_;
            var _K_ = i$0 + 1 | 0;
            if (_D_ === i$0)
              break;
            var i$0 = _K_;
          }
        }
        var _F_ = nvals - 1 | 0, _E_ = 0;
        if (_F_ >= 0) {
          var i = _E_;
          for (; ; ) {
            var _H_ = i + nmeths | 0, _G_ = new_variable(table, caml_check_bound2(vals, i)[1 + i]);
            caml_check_bound2(res, _H_)[1 + _H_] = _G_;
            var _I_ = i + 1 | 0;
            if (_F_ === i)
              break;
            var i = _I_;
          }
        }
        return res;
      }
      function get_variable(table, name) {
        try {
          var _A_ = caml_call2(Vars[17], name, table[7]);
          return _A_;
        } catch (_B_) {
          var _z_ = caml_wrap_exception2(_B_);
          if (_z_ === Stdlib[8])
            throw caml_maybe_attach_backtrace2([0, Assert_failure, _a_], 1);
          throw caml_maybe_attach_backtrace2(_z_, 0);
        }
      }
      function get_variables(table, names) {
        return caml_call2(
          Stdlib_Array[13],
          function(_y_) {
            return get_variable(table, _y_);
          },
          names
        );
      }
      function add_initializer(table, f) {
        table[8] = [0, f, table[8]];
        return 0;
      }
      function create_table(public_methods) {
        if (0 === public_methods)
          return new_table([0]);
        var tags = caml_call2(Stdlib_Array[13], public_method_label, public_methods), table = new_table(tags);
        caml_call2(
          Stdlib_Array[12],
          function(i, met) {
            var lab = (i * 2 | 0) + 2 | 0;
            table[3] = caml_call3(Meths[2], met, lab, table[3]);
            table[4] = caml_call3(Labs[2], lab, 1, table[4]);
            return 0;
          },
          public_methods
        );
        return table;
      }
      function init_class(table) {
        inst_var_count[1] = (inst_var_count[1] + table[1] | 0) - 1 | 0;
        table[8] = caml_call1(Stdlib_List[10], table[8]);
        var _x_ = Stdlib_Sys[9];
        return resize(
          table,
          3 + caml_div2(caml_check_bound2(table[2], 1)[2] * 16 | 0, _x_) | 0
        );
      }
      function inherits(cla, vals, virt_meths, concr_meths, param, top) {
        var env = param[4], super$0 = param[2];
        narrow(cla, vals, virt_meths, concr_meths);
        var init = top ? caml_call2(super$0, cla, env) : caml_call1(super$0, cla);
        widen(cla);
        var _s_ = to_array(concr_meths), _t_ = [
          0,
          caml_call2(
            Stdlib_Array[13],
            function(nm) {
              return get_method(cla, get_method_label(cla, nm));
            },
            _s_
          ),
          0
        ], _u_ = to_array(vals), _v_ = [
          0,
          [0, init],
          [
            0,
            caml_call2(
              Stdlib_Array[13],
              function(_w_) {
                return get_variable(cla, _w_);
              },
              _u_
            ),
            _t_
          ]
        ];
        return caml_call1(Stdlib_Array[4], _v_);
      }
      function make_class(pub_meths, class_init) {
        var table = create_table(pub_meths), env_init = caml_call1(class_init, table);
        init_class(table);
        return [0, caml_call1(env_init, 0), class_init, env_init, 0];
      }
      function make_class_store(pub_meths, class_init, init_table) {
        var table = create_table(pub_meths), env_init = caml_call1(class_init, table);
        init_class(table);
        init_table[2] = class_init;
        init_table[1] = env_init;
        return 0;
      }
      function dummy_class(loc) {
        function undef(param) {
          throw caml_maybe_attach_backtrace2([0, Stdlib[15], loc], 1);
        }
        return [0, undef, undef, undef, 0];
      }
      function create_object(table) {
        var obj = caml_obj_block2(Stdlib_Obj[10], table[1]);
        obj[1] = table[2];
        return caml_set_oo_id2(obj);
      }
      function create_object_opt(obj_0, table) {
        if (obj_0)
          return obj_0;
        var obj = caml_obj_block2(Stdlib_Obj[10], table[1]);
        obj[1] = table[2];
        return caml_set_oo_id2(obj);
      }
      function iter_f(obj, param) {
        var param$0 = param;
        for (; ; ) {
          if (!param$0)
            return 0;
          var l = param$0[2], f = param$0[1];
          caml_call1(f, obj);
          var param$0 = l;
        }
      }
      function run_initializers(obj, table) {
        var inits = table[8], _r_ = 0 !== inits ? 1 : 0;
        return _r_ ? iter_f(obj, inits) : _r_;
      }
      function run_initializers_opt(obj_0, obj, table) {
        if (obj_0)
          return obj;
        var inits = table[8];
        if (0 !== inits)
          iter_f(obj, inits);
        return obj;
      }
      function create_object_and_run_initiali(obj_0, table) {
        if (obj_0)
          return obj_0;
        var obj = create_object(table);
        run_initializers(obj, table);
        return obj;
      }
      function get_data(param) {
        if (param)
          return param[2];
        throw caml_maybe_attach_backtrace2([0, Assert_failure, _e_], 1);
      }
      function build_path(n, keys, tables) {
        var res = [0, 0, 0, 0], r = [0, res], _o_ = 0;
        if (n >= 0) {
          var i = _o_;
          for (; ; ) {
            var _p_ = r[1];
            r[1] = [0, caml_check_bound2(keys, i)[1 + i], _p_, 0];
            var _q_ = i + 1 | 0;
            if (n === i)
              break;
            var i = _q_;
          }
        }
        var v = r[1];
        if (!tables)
          throw caml_maybe_attach_backtrace2([0, Assert_failure, _b_], 1);
        tables[2] = v;
        return res;
      }
      function lookup_tables(root, keys) {
        var root_data = get_data(root);
        if (!root_data)
          return build_path(keys.length - 1 - 1 | 0, keys, root);
        var i$1 = keys.length - 1 - 1 | 0, i = i$1, tables$0 = root_data;
        for (; ; ) {
          if (0 > i)
            return tables$0;
          var key = caml_check_bound2(keys, i)[1 + i], tables$1 = tables$0;
          for (; ; ) {
            if (!tables$1)
              throw caml_maybe_attach_backtrace2([0, Assert_failure, _d_], 1);
            if (tables$1[1] === key)
              break;
            if (!tables$1)
              throw caml_maybe_attach_backtrace2([0, Assert_failure, _f_], 1);
            var tables = tables$1[3];
            if (!tables) {
              var next = [0, key, 0, 0];
              if (!tables$1)
                throw caml_maybe_attach_backtrace2([0, Assert_failure, _c_], 1);
              tables$1[3] = next;
              return build_path(i - 1 | 0, keys, next);
            }
            var tables$1 = tables;
          }
          var tables_data = get_data(tables$1);
          if (!tables_data)
            throw caml_maybe_attach_backtrace2([0, Assert_failure, _g_], 1);
          var i$0 = i - 1 | 0, i = i$0, tables$0 = tables_data;
        }
      }
      function new_cache(table) {
        var n = new_method(table);
        a: {
          if (0 !== (n % 2 | 0)) {
            var _n_ = Stdlib_Sys[9];
            if ((2 + caml_div2(caml_check_bound2(table[2], 1)[2] * 16 | 0, _n_) | 0) >= n) {
              var n$0 = new_method(table);
              break a;
            }
          }
          var n$0 = n;
        }
        caml_check_bound2(table[2], n$0)[1 + n$0] = 0;
        return n$0;
      }
      function set_methods(table, methods) {
        var len = methods.length - 1, i = [0, 0];
        for (; ; ) {
          if (i[1] >= len)
            return 0;
          var _h_ = i[1], label = caml_check_bound2(methods, _h_)[1 + _h_], next = function(param) {
            i[1]++;
            var _m_ = i[1];
            return caml_check_bound2(methods, _m_)[1 + _m_];
          }, clo = next(0);
          if (typeof clo === "number")
            switch (clo) {
              case 0:
                var x2 = next(0);
                let x$20 = x2;
                var clo$0 = function(obj) {
                  return x$20;
                };
                break;
              case 1:
                var n = next(0);
                let n$38 = n;
                var clo$0 = function(obj) {
                  return obj[1 + n$38];
                };
                break;
              case 2:
                var e = next(0), n$0 = next(0);
                let e$10 = e, n$37 = n$0;
                var clo$0 = function(obj) {
                  return obj[1 + e$10][1 + n$37];
                };
                break;
              case 3:
                var n$1 = next(0);
                let n$36 = n$1;
                var clo$0 = function(obj) {
                  return caml_call1(obj[1][1 + n$36], obj);
                };
                break;
              case 4:
                var n$2 = next(0);
                let n$35 = n$2;
                var clo$0 = function(obj, x3) {
                  obj[1 + n$35] = x3;
                  return 0;
                };
                break;
              case 5:
                var f = next(0), x$0 = next(0);
                let f$20 = f, x$19 = x$0;
                var clo$0 = function(obj) {
                  return caml_call1(f$20, x$19);
                };
                break;
              case 6:
                var f$0 = next(0), n$3 = next(0);
                let f$19 = f$0, n$34 = n$3;
                var clo$0 = function(obj) {
                  return caml_call1(f$19, obj[1 + n$34]);
                };
                break;
              case 7:
                var f$1 = next(0), e$0 = next(0), n$4 = next(0);
                let f$18 = f$1, e$9 = e$0, n$33 = n$4;
                var clo$0 = function(obj) {
                  return caml_call1(f$18, obj[1 + e$9][1 + n$33]);
                };
                break;
              case 8:
                var f$2 = next(0), n$5 = next(0);
                let f$17 = f$2, n$32 = n$5;
                var clo$0 = function(obj) {
                  return caml_call1(f$17, caml_call1(obj[1][1 + n$32], obj));
                };
                break;
              case 9:
                var f$3 = next(0), x$1 = next(0), y = next(0);
                let f$16 = f$3, x$18 = x$1, y$0 = y;
                var clo$0 = function(obj) {
                  return caml_call2(f$16, x$18, y$0);
                };
                break;
              case 10:
                var f$4 = next(0), x$2 = next(0), n$6 = next(0);
                let f$15 = f$4, x$17 = x$2, n$31 = n$6;
                var clo$0 = function(obj) {
                  return caml_call2(f$15, x$17, obj[1 + n$31]);
                };
                break;
              case 11:
                var f$5 = next(0), x$3 = next(0), e$1 = next(0), n$7 = next(0);
                let f$14 = f$5, x$16 = x$3, e$8 = e$1, n$30 = n$7;
                var clo$0 = function(obj) {
                  return caml_call2(f$14, x$16, obj[1 + e$8][1 + n$30]);
                };
                break;
              case 12:
                var f$6 = next(0), x$4 = next(0), n$8 = next(0);
                let f$13 = f$6, x$15 = x$4, n$29 = n$8;
                var clo$0 = function(obj) {
                  return caml_call2(f$13, x$15, caml_call1(obj[1][1 + n$29], obj));
                };
                break;
              case 13:
                var f$7 = next(0), n$9 = next(0), x$5 = next(0);
                let f$12 = f$7, n$28 = n$9, x$14 = x$5;
                var clo$0 = function(obj) {
                  return caml_call2(f$12, obj[1 + n$28], x$14);
                };
                break;
              case 14:
                var f$8 = next(0), e$2 = next(0), n$10 = next(0), x$6 = next(0);
                let f$11 = f$8, e$7 = e$2, n$27 = n$10, x$13 = x$6;
                var clo$0 = function(obj) {
                  return caml_call2(f$11, obj[1 + e$7][1 + n$27], x$13);
                };
                break;
              case 15:
                var f$9 = next(0), n$11 = next(0), x$7 = next(0);
                let f$10 = f$9, n$26 = n$11, x$12 = x$7;
                var clo$0 = function(obj) {
                  return caml_call2(f$10, caml_call1(obj[1][1 + n$26], obj), x$12);
                };
                break;
              case 16:
                var n$12 = next(0), x$8 = next(0);
                let n$25 = n$12, x$11 = x$8;
                var clo$0 = function(obj) {
                  return caml_call2(obj[1][1 + n$25], obj, x$11);
                };
                break;
              case 17:
                var n$13 = next(0), m = next(0);
                let n$24 = n$13, m$12 = m;
                var clo$0 = function(obj) {
                  return caml_call2(obj[1][1 + n$24], obj, obj[1 + m$12]);
                };
                break;
              case 18:
                var n$14 = next(0), e$3 = next(0), m$0 = next(0);
                let n$23 = n$14, e$6 = e$3, m$11 = m$0;
                var clo$0 = function(obj) {
                  return caml_call2(obj[1][1 + n$23], obj, obj[1 + e$6][1 + m$11]);
                };
                break;
              case 19:
                var n$15 = next(0), m$1 = next(0);
                let n$22 = n$15, m$10 = m$1;
                var clo$0 = function(obj) {
                  var _l_ = caml_call1(obj[1][1 + m$10], obj);
                  return caml_call2(obj[1][1 + n$22], obj, _l_);
                };
                break;
              case 20:
                var m$2 = next(0), x$9 = next(0);
                new_cache(table);
                let m$9 = m$2, x$10 = x$9;
                var clo$0 = function(obj) {
                  return caml_call1(caml_get_public_method2(x$10, m$9, 0), x$10);
                };
                break;
              case 21:
                var m$3 = next(0), n$16 = next(0);
                new_cache(table);
                let m$8 = m$3, n$21 = n$16;
                var clo$0 = function(obj) {
                  var _k_ = obj[1 + n$21];
                  return caml_call1(caml_get_public_method2(_k_, m$8, 0), _k_);
                };
                break;
              case 22:
                var m$4 = next(0), e$4 = next(0), n$17 = next(0);
                new_cache(table);
                let m$7 = m$4, e$5 = e$4, n$20 = n$17;
                var clo$0 = function(obj) {
                  var _j_ = obj[1 + e$5][1 + n$20];
                  return caml_call1(caml_get_public_method2(_j_, m$7, 0), _j_);
                };
                break;
              default:
                var m$5 = next(0), n$18 = next(0);
                new_cache(table);
                let m$6 = m$5, n$19 = n$18;
                var clo$0 = function(obj) {
                  var _i_ = caml_call1(obj[1][1 + n$19], obj);
                  return caml_call1(caml_get_public_method2(_i_, m$6, 0), _i_);
                };
            }
          else
            var clo$0 = clo;
          set_method(table, label, clo$0);
          i[1]++;
        }
      }
      function stats(param) {
        return [0, table_count[1], method_count[1], inst_var_count[1]];
      }
      var CamlinternalOO = [
        0,
        public_method_label,
        new_method,
        new_variable,
        new_methods_variables,
        get_variable,
        get_variables,
        get_method_label,
        get_method_labels,
        get_method,
        set_method,
        set_methods,
        narrow,
        widen,
        add_initializer,
        dummy_table,
        create_table,
        init_class,
        inherits,
        make_class,
        make_class_store,
        dummy_class,
        copy,
        create_object,
        create_object_opt,
        run_initializers,
        run_initializers_opt,
        create_object_and_run_initiali,
        lookup_tables,
        params,
        stats
      ];
      runtime.caml_register_global(17, CamlinternalOO, "CamlinternalOO");
      return;
    })(globalThis);
    (function(globalThis2) {
      "use strict";
      var runtime = globalThis2.jsoo_runtime, global_data = runtime.caml_get_global_data(), Stdlib_Result = global_data.Stdlib__Result, ok = Stdlib_Result[1], error = Stdlib_Result[2], value = Stdlib_Result[3], get_ok = Stdlib_Result[4], get_error = Stdlib_Result[5], bind = Stdlib_Result[6], join = Stdlib_Result[7], map = Stdlib_Result[8], map_error = Stdlib_Result[9], fold = Stdlib_Result[10], iter = Stdlib_Result[11], iter_error = Stdlib_Result[12], is_ok = Stdlib_Result[13], is_error = Stdlib_Result[14], equal = Stdlib_Result[15], compare = Stdlib_Result[16], to_option = Stdlib_Result[17], to_list = Stdlib_Result[18], to_seq = Stdlib_Result[19], Result = [
        0,
        ok,
        error,
        value,
        get_ok,
        get_error,
        bind,
        join,
        map,
        map_error,
        fold,
        iter,
        iter_error,
        is_ok,
        is_error,
        equal,
        compare,
        to_option,
        to_list,
        to_seq
      ];
      runtime.caml_register_global(1, Result, "Result");
      return;
    })(globalThis);
    (function(globalThis2) {
      "use strict";
      var runtime = globalThis2.jsoo_runtime, global_data = runtime.caml_get_global_data(), Stdlib = global_data.Stdlib, invalid_arg = Stdlib[1], failwith = Stdlib[2], Exit = Stdlib[3], Match_failure = Stdlib[4], Assert_failure = Stdlib[5], Invalid_argument = Stdlib[6], Failure = Stdlib[7], Not_found = Stdlib[8], Out_of_memory = Stdlib[9], Stack_overflow = Stdlib[10], Sys_error = Stdlib[11], End_of_file = Stdlib[12], Division_by_zero = Stdlib[13], Sys_blocked_io = Stdlib[14], Undefined_recursive_module = Stdlib[15], min = Stdlib[16], max = Stdlib[17], abs = Stdlib[18], max_int = Stdlib[19], min_int = Stdlib[20], lnot = Stdlib[21], infinity = Stdlib[22], neg_infinity = Stdlib[23], nan = Stdlib[24], max_float = Stdlib[25], min_float = Stdlib[26], epsilon_float = Stdlib[27], symbol = Stdlib[28], char_of_int = Stdlib[29], string_of_bool = Stdlib[30], bool_of_string_opt = Stdlib[31], bool_of_string = Stdlib[32], string_of_int = Stdlib[33], int_of_string_opt = Stdlib[34], string_of_float = Stdlib[35], float_of_string_opt = Stdlib[36], symbol$0 = Stdlib[37], stdin = Stdlib[38], stdout = Stdlib[39], stderr = Stdlib[40], print_char = Stdlib[41], print_string = Stdlib[42], print_bytes = Stdlib[43], print_int = Stdlib[44], print_float = Stdlib[45], print_endline = Stdlib[46], print_newline = Stdlib[47], prerr_char = Stdlib[48], prerr_string = Stdlib[49], prerr_bytes = Stdlib[50], prerr_int = Stdlib[51], prerr_float = Stdlib[52], prerr_endline = Stdlib[53], prerr_newline = Stdlib[54], read_line = Stdlib[55], read_int_opt = Stdlib[56], read_int = Stdlib[57], read_float_opt = Stdlib[58], read_float = Stdlib[59], open_out = Stdlib[60], open_out_bin = Stdlib[61], open_out_gen = Stdlib[62], flush = Stdlib[63], flush_all = Stdlib[64], output_char = Stdlib[65], output_string = Stdlib[66], output_bytes = Stdlib[67], output = Stdlib[68], output_substring = Stdlib[69], output_byte = Stdlib[70], output_binary_int = Stdlib[71], output_value = Stdlib[72], seek_out = Stdlib[73], pos_out = Stdlib[74], out_channel_length = Stdlib[75], close_out = Stdlib[76], close_out_noerr = Stdlib[77], set_binary_mode_out = Stdlib[78], open_in = Stdlib[79], open_in_bin = Stdlib[80], open_in_gen = Stdlib[81], input_char = Stdlib[82], input_line = Stdlib[83], input = Stdlib[84], really_input = Stdlib[85], really_input_string = Stdlib[86], input_byte = Stdlib[87], input_binary_int = Stdlib[88], input_value = Stdlib[89], seek_in = Stdlib[90], pos_in = Stdlib[91], in_channel_length = Stdlib[92], close_in = Stdlib[93], close_in_noerr = Stdlib[94], set_binary_mode_in = Stdlib[95], string_of_format = Stdlib[97], symbol$1 = Stdlib[98], exit = Stdlib[99], at_exit = Stdlib[100], valid_float_lexem = Stdlib[101], unsafe_really_input = Stdlib[102], do_at_exit = Stdlib[103], do_domain_local_at_exit = Stdlib[104], Result = [0], Ppx_deriving_runtime = [
        0,
        invalid_arg,
        failwith,
        Exit,
        Match_failure,
        Assert_failure,
        Invalid_argument,
        Failure,
        Not_found,
        Out_of_memory,
        Stack_overflow,
        Sys_error,
        End_of_file,
        Division_by_zero,
        Sys_blocked_io,
        Undefined_recursive_module,
        min,
        max,
        abs,
        max_int,
        min_int,
        lnot,
        infinity,
        neg_infinity,
        nan,
        max_float,
        min_float,
        epsilon_float,
        symbol,
        char_of_int,
        string_of_bool,
        bool_of_string_opt,
        bool_of_string,
        string_of_int,
        int_of_string_opt,
        string_of_float,
        float_of_string_opt,
        symbol$0,
        stdin,
        stdout,
        stderr,
        print_char,
        print_string,
        print_bytes,
        print_int,
        print_float,
        print_endline,
        print_newline,
        prerr_char,
        prerr_string,
        prerr_bytes,
        prerr_int,
        prerr_float,
        prerr_endline,
        prerr_newline,
        read_line,
        read_int_opt,
        read_int,
        read_float_opt,
        read_float,
        open_out,
        open_out_bin,
        open_out_gen,
        flush,
        flush_all,
        output_char,
        output_string,
        output_bytes,
        output,
        output_substring,
        output_byte,
        output_binary_int,
        output_value,
        seek_out,
        pos_out,
        out_channel_length,
        close_out,
        close_out_noerr,
        set_binary_mode_out,
        open_in,
        open_in_bin,
        open_in_gen,
        input_char,
        input_line,
        input,
        really_input,
        really_input_string,
        input_byte,
        input_binary_int,
        input_value,
        seek_in,
        pos_in,
        in_channel_length,
        close_in,
        close_in_noerr,
        set_binary_mode_in,
        string_of_format,
        symbol$1,
        exit,
        at_exit,
        valid_float_lexem,
        unsafe_really_input,
        do_at_exit,
        do_domain_local_at_exit,
        Result
      ];
      runtime.caml_register_global(1, Ppx_deriving_runtime, "Ppx_deriving_runtime");
      return;
    })(globalThis);
    (function(globalThis2) {
      "use strict";
      var runtime = globalThis2.jsoo_runtime;
      function caml_call1(f, a0) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 1 ? f(a0) : runtime.caml_call_gen(f, [a0]);
      }
      function caml_call2(f, a0, a1) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 2 ? f(a0, a1) : runtime.caml_call_gen(f, [a0, a1]);
      }
      var global_data = runtime.caml_get_global_data(), Stdlib_List = global_data.Stdlib__List, Ppx_deriving_runtime = global_data.Ppx_deriving_runtime, Stdlib_Array = global_data.Stdlib__Array, Stdlib_Nativeint = global_data.Stdlib__Nativeint, Stdlib_Int64 = global_data.Stdlib__Int64, Stdlib_Int32 = global_data.Stdlib__Int32, Stdlib_Bytes = global_data.Stdlib__Bytes, Stdlib_String = global_data.Stdlib__String, Result = Ppx_deriving_runtime[104];
      function symbol_bind(x2, f) {
        if (0 !== x2[0])
          return x2;
        var x$0 = x2[1];
        return caml_call1(f, x$0);
      }
      function symbol(x2, f) {
        return symbol_bind(x2, function(x3) {
          return [0, caml_call1(f, x3)];
        });
      }
      function map_bind(f, acc, xs) {
        var acc$0 = acc, xs$0 = xs;
        for (; ; ) {
          if (!xs$0)
            return [0, caml_call1(Stdlib_List[10], acc$0)];
          var xs$1 = xs$0[2], x2 = xs$0[1], err = caml_call1(f, x2);
          if (0 !== err[0])
            return err;
          var x$0 = err[1], acc$1 = [0, x$0, acc$0], acc$0 = acc$1, xs$0 = xs$1;
        }
      }
      function safe_map(f, l) {
        var _a_ = caml_call2(Stdlib_List[22], f, l);
        return caml_call1(Stdlib_List[10], _a_);
      }
      var Ppx_deriving_yojson_runtime = [
        0,
        symbol_bind,
        symbol,
        map_bind,
        safe_map,
        runtime.caml_equal,
        Stdlib_List,
        Stdlib_String,
        Stdlib_Bytes,
        Stdlib_Int32,
        Stdlib_Int64,
        Stdlib_Nativeint,
        Stdlib_Array,
        Result
      ];
      runtime.caml_register_global(8, Ppx_deriving_yojson_runtime, "Ppx_deriving_yojson_runtime");
      return;
    })(globalThis);
    (function(globalThis2) {
      "use strict";
      var runtime = globalThis2.jsoo_runtime, caml_maybe_attach_backtrace2 = runtime.caml_maybe_attach_backtrace;
      function caml_call1(f, a0) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 1 ? f(a0) : runtime.caml_call_gen(f, [a0]);
      }
      function caml_call2(f, a0, a1) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 2 ? f(a0, a1) : runtime.caml_call_gen(f, [a0, a1]);
      }
      var global_data = runtime.caml_get_global_data(), Stdlib_Buffer = global_data.Stdlib__Buffer, Stdlib_Char = global_data.Stdlib__Char, Assert_failure = global_data.Assert_failure, _a_ = [0, "lib/codec.ml", 32, 4];
      function utf8_of_code(buf, x2) {
        var add = Stdlib_Buffer[12];
        function maxbits(n, x3) {
          return 0 === (x3 >>> n | 0) ? 1 : 0;
        }
        if (maxbits(7, x2))
          return caml_call2(add, buf, caml_call1(Stdlib_Char[1], x2));
        if (maxbits(11, x2)) {
          caml_call2(add, buf, caml_call1(Stdlib_Char[1], 192 | (x2 >>> 6 | 0) & 31));
          return caml_call2(add, buf, caml_call1(Stdlib_Char[1], 128 | x2 & 63));
        }
        if (maxbits(16, x2)) {
          caml_call2(add, buf, caml_call1(Stdlib_Char[1], 224 | (x2 >>> 12 | 0) & 15));
          caml_call2(add, buf, caml_call1(Stdlib_Char[1], 128 | (x2 >>> 6 | 0) & 63));
          return caml_call2(add, buf, caml_call1(Stdlib_Char[1], 128 | x2 & 63));
        }
        if (maxbits(21, x2)) {
          caml_call2(add, buf, caml_call1(Stdlib_Char[1], 240 | (x2 >>> 18 | 0) & 7));
          caml_call2(add, buf, caml_call1(Stdlib_Char[1], 128 | (x2 >>> 12 | 0) & 63));
          caml_call2(add, buf, caml_call1(Stdlib_Char[1], 128 | (x2 >>> 6 | 0) & 63));
          return caml_call2(add, buf, caml_call1(Stdlib_Char[1], 128 | x2 & 63));
        }
        if (maxbits(26, x2)) {
          caml_call2(add, buf, caml_call1(Stdlib_Char[1], 248 | (x2 >>> 24 | 0) & 3));
          caml_call2(add, buf, caml_call1(Stdlib_Char[1], 128 | (x2 >>> 18 | 0) & 63));
          caml_call2(add, buf, caml_call1(Stdlib_Char[1], 128 | (x2 >>> 12 | 0) & 63));
          caml_call2(add, buf, caml_call1(Stdlib_Char[1], 128 | (x2 >>> 6 | 0) & 63));
          return caml_call2(add, buf, caml_call1(Stdlib_Char[1], 128 | x2 & 63));
        }
        if (!maxbits(31, x2))
          throw caml_maybe_attach_backtrace2([0, Assert_failure, _a_], 1);
        caml_call2(add, buf, caml_call1(Stdlib_Char[1], 252 | (x2 >>> 30 | 0) & 1));
        caml_call2(add, buf, caml_call1(Stdlib_Char[1], 128 | (x2 >>> 24 | 0) & 63));
        caml_call2(add, buf, caml_call1(Stdlib_Char[1], 128 | (x2 >>> 18 | 0) & 63));
        caml_call2(add, buf, caml_call1(Stdlib_Char[1], 128 | (x2 >>> 12 | 0) & 63));
        caml_call2(add, buf, caml_call1(Stdlib_Char[1], 128 | (x2 >>> 6 | 0) & 63));
        return caml_call2(add, buf, caml_call1(Stdlib_Char[1], 128 | x2 & 63));
      }
      function utf8_of_surrogate_pair(buf, i, j) {
        var high10 = i - 55296 | 0, low10 = j - 56320 | 0;
        return utf8_of_code(buf, 65536 + (high10 << 10 | low10) | 0);
      }
      var Yojson_Codec = [0, utf8_of_code, utf8_of_surrogate_pair];
      runtime.caml_register_global(4, Yojson_Codec, "Yojson__Codec");
      return;
    })(globalThis);
    (function(globalThis2) {
      "use strict";
      var runtime = globalThis2.jsoo_runtime, caml_fresh_oo_id2 = runtime.caml_fresh_oo_id, caml_maybe_attach_backtrace2 = runtime.caml_maybe_attach_backtrace;
      function caml_call1(f, a0) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 1 ? f(a0) : runtime.caml_call_gen(f, [a0]);
      }
      var global_data = runtime.caml_get_global_data(), version = "2.1.2", Stdlib_Buffer = global_data.Stdlib__Buffer, Json_error = [248, "Yojson__Common.Json_error", caml_fresh_oo_id2(0)];
      function json_error(s2) {
        throw caml_maybe_attach_backtrace2([0, Json_error, s2], 1);
      }
      var End_of_array = [248, "Yojson__Common.End_of_array", caml_fresh_oo_id2(0)], End_of_object = [248, "Yojson__Common.End_of_object", caml_fresh_oo_id2(0)], End_of_tuple = [248, "Yojson__Common.End_of_tuple", caml_fresh_oo_id2(0)], End_of_input = [248, "Yojson__Common.End_of_input", caml_fresh_oo_id2(0)], Lexer_state = [0];
      function init_lexer(buf, fname, opt, param) {
        if (opt)
          var sth = opt[1], lnum = sth;
        else
          var lnum = 1;
        if (buf)
          var buf$0 = buf[1], buf$1 = buf$0;
        else
          var buf$1 = caml_call1(Stdlib_Buffer[1], 256);
        return [0, buf$1, lnum, 0, fname];
      }
      var Yojson_Common = [
        0,
        version,
        Json_error,
        json_error,
        Lexer_state,
        init_lexer,
        End_of_array,
        End_of_object,
        End_of_tuple,
        End_of_input
      ];
      runtime.caml_register_global(7, Yojson_Common, "Yojson__Common");
      return;
    })(globalThis);
    (function(globalThis2) {
      "use strict";
      var runtime = globalThis2.jsoo_runtime, cst = "", caml_trampoline2 = runtime.caml_trampoline, caml_trampoline_return2 = runtime.caml_trampoline_return;
      function caml_call1(f, a0) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 1 ? f(a0) : runtime.caml_call_gen(f, [a0]);
      }
      function caml_call2(f, a0, a1) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 2 ? f(a0, a1) : runtime.caml_call_gen(f, [a0, a1]);
      }
      function caml_call3(f, a0, a1, a2) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 3 ? f(a0, a1, a2) : runtime.caml_call_gen(f, [a0, a1, a2]);
      }
      var global_data = runtime.caml_get_global_data(), ocaml_lex_tables = [
        0,
        "\0\0\xFE\xFF\xFF\xFF",
        "\xFF\xFF\xFF\xFF\xFF\xFF",
        "\0\0\0\0\0",
        "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0",
        cst,
        cst,
        cst,
        cst,
        cst,
        cst
      ], Stdlib_Lexing = global_data.Stdlib__Lexing, Stdlib_Buffer = global_data.Stdlib__Buffer;
      function read_junk$0(counter, buf, n, lexbuf) {
        var _c_ = 0;
        if (counter >= 50)
          return caml_trampoline_return2(ocaml_lex_read_junk_rec$0, [0, buf, n, lexbuf, _c_]);
        var counter$0 = counter + 1 | 0;
        return ocaml_lex_read_junk_rec$0(counter$0, buf, n, lexbuf, _c_);
      }
      function read_junk(buf, n, lexbuf) {
        return caml_trampoline2(read_junk$0(0, buf, n, lexbuf));
      }
      function ocaml_lex_read_junk_rec$0(counter, buf, n, lexbuf, ocaml_lex_state) {
        var ocaml_lex_state$0 = ocaml_lex_state;
        for (; ; ) {
          var ocaml_lex_state$1 = caml_call3(Stdlib_Lexing[20], ocaml_lex_tables, ocaml_lex_state$0, lexbuf);
          if (0 === ocaml_lex_state$1)
            return 0;
          if (1 === ocaml_lex_state$1) {
            if (0 >= n)
              return 0;
            var _a_ = caml_call2(Stdlib_Lexing[9], lexbuf, 0);
            caml_call2(Stdlib_Buffer[12], buf, _a_);
            var _b_ = n - 1 | 0;
            if (counter >= 50)
              return caml_trampoline_return2(read_junk$0, [0, buf, _b_, lexbuf]);
            var counter$0 = counter + 1 | 0;
            return read_junk$0(counter$0, buf, _b_, lexbuf);
          }
          caml_call1(lexbuf[1], lexbuf);
          var ocaml_lex_state$0 = ocaml_lex_state$1;
        }
      }
      function ocaml_lex_read_junk_rec(buf, n, lexbuf, ocaml_lex_state) {
        return caml_trampoline2(ocaml_lex_read_junk_rec$0(0, buf, n, lexbuf, ocaml_lex_state));
      }
      function read_junk_without_positions(buf, n, lexbuf) {
        var junk_start_pos = lexbuf[5];
        read_junk(buf, n, lexbuf);
        lexbuf[5] = junk_start_pos + 1 | 0;
        return 0;
      }
      var Yojson_Lexer_utils = [
        0,
        ocaml_lex_tables,
        read_junk,
        ocaml_lex_read_junk_rec,
        read_junk_without_positions
      ];
      runtime.caml_register_global(3, Yojson_Lexer_utils, "Yojson__Lexer_utils");
      return;
    })(globalThis);
    (function(globalThis2) {
      "use strict";
      var runtime = globalThis2.jsoo_runtime, cst$23 = "", cst$34 = "\n", cst$30 = " '", cst_16g = "%.16g", cst_17g = "%.17g", cst_S = "%S", cst_a = "%a", cst$24 = "(@[", cst$31 = ",", cst$25 = ",@ ", cst_Infinity$4 = "-Infinity", cst_Infinity_value_not_allowed$4 = "-Infinity value not allowed in standard JSON", cst_0$2 = ".0", cst$29 = "/*", cst$33 = ": ", cst$22 = ";@ ", cst_2 = "<2>", cst_hov2 = "<hov2>", cst_hov = "<hov>", cst_hv2 = "<hv2>", cst_hv = "<hv>", cst$21 = "@ ", cst$27 = "@,", cst$28 = "@,]@]", cst_1_2 = "@;<1 -2>", cst_1_0 = "@;<1 0>", cst_2$0 = "@[<2>[", cst_hv2$0 = "@[<hv2>", cst$32 = "@]", cst$26 = "@])", cst_Blank_input_data$1 = "Blank input data", cst_Expected_but_found$17 = "Expected ')' but found", cst_Expected_or_but_found$17 = "Expected ',' or ')' but found", cst_Expected_or_but_found$16 = "Expected ',' or ']' but found", cst_Expected_or_but_found$18 = "Expected ',' or '}' but found", cst_Expected_but_found$19 = "Expected ':' but found", cst_Expected_or_but_found$15 = "Expected ':' or '>' but found", cst_Expected_but_found$15 = "Expected '>' but found", cst_Expected_but_found$16 = "Expected '[' but found", cst_Expected_but_found$18 = "Expected '{' but found", cst_Expected_string_or_identif$3 = "Expected string or identifier but found", cst_Infinity$3 = "Infinity", cst_Infinity_value_not_allowed$3 = "Infinity value not allowed in standard JSON", cst_Int_overflow$1 = "Int overflow", cst_Int32_overflow$1 = "Int32 overflow", cst_Invalid_string_literal$2 = "Invalid string literal", cst_Invalid_token$2 = "Invalid token", cst_NaN$1 = "NaN", cst_NaN_value_not_allowed_in_s$1 = "NaN value not allowed in standard JSON", cst_Unexpected_end_of_input$47 = "Unexpected end of input", cst_Unterminated_comment$1 = "Unterminated comment", cst_null$2 = "null", caml_bytes_get2 = runtime.caml_bytes_get, caml_classify_float2 = runtime.caml_classify_float, caml_equal2 = runtime.caml_equal, caml_float_of_string2 = runtime.caml_float_of_string, caml_fresh_oo_id2 = runtime.caml_fresh_oo_id, caml_int64_of_string2 = runtime.caml_int64_of_string, caml_int_of_string2 = runtime.caml_int_of_string, caml_lex_engine2 = runtime.caml_lex_engine, caml_maybe_attach_backtrace2 = runtime.caml_maybe_attach_backtrace, caml_ml_string_length2 = runtime.caml_ml_string_length, caml_string_get2 = runtime.caml_string_get, caml_string_notequal2 = runtime.caml_string_notequal, caml_wrap_exception2 = runtime.caml_wrap_exception;
      function caml_call1(f, a0) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 1 ? f(a0) : runtime.caml_call_gen(f, [a0]);
      }
      function caml_call2(f, a0, a1) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 2 ? f(a0, a1) : runtime.caml_call_gen(f, [a0, a1]);
      }
      function caml_call3(f, a0, a1, a2) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 3 ? f(a0, a1, a2) : runtime.caml_call_gen(f, [a0, a1, a2]);
      }
      function caml_call4(f, a0, a1, a2, a3) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 4 ? f(a0, a1, a2, a3) : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
      }
      function caml_call5(f, a0, a1, a2, a3, a4) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 5 ? f(a0, a1, a2, a3, a4) : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
      }
      var undef = void 0, global_data = runtime.caml_get_global_data(), cst$17 = ")", cst$18 = cst$29, cst$19 = cst$29, cst$20 = "*/", stream = [0, 1], cst$12 = cst$31, cst$13 = "{}", cst$14 = cst$31, cst$15 = cst$31, cst$16 = "[]", cst$10 = "()", cst$11 = cst$31, cst$9 = cst$34, cst$8 = cst$34, cst$7 = cst$34, cst$6 = cst$34, cst$5 = cst$34, cst$4 = cst$23, cst$3 = cst$23, cst$2 = cst$23, cst$1 = cst$23, cst$0 = '\\"', cst = "\\\\", ocaml_lex_tables = [
        0,
        `\0\0\xEC\xFF\xED\xFF\0\xEF\xFF\0\xF2\xFF\xF3\xFF\xF4\xFF\xF5\xFF\0\0\0\xF9\xFFU\0\0\0\0\0\0\0\0\0\0\0\xFF\xFF\0\0\0\0\0\xFE\xFF\0\0\xFD\xFF\v\0\xFC\xFF\0\0\0\0\0\0\0\xFB\xFF\0a\0
\0\0\0\0\0\f\0\b\0\xFA\xFFw\0\x81\0\x8B\0\xA1\0\xAB\0\xB5\0\xC1\0\xD1\0\xF0\xFF\v\0&\0\xFC\xFFA\0\xFE\xFF\xFF\xFFn\0\xFC\xFF\xA3\0\xFE\xFF\xFF\xFF\xEA\0\xF7\xFF\xF8\xFF0\xFA\xFF\xFB\xFF\xFC\xFF\xFD\xFF\xFE\xFF\xFF\xFFG~\x95\xF9\xFF'\0\xFD\xFF\xFE\xFF&\0\xBB\xD2\xF8\xFF\xFF\xDC\0\xFD\xFF\xFF\xFF\xF5\0'mX\xA4\xBB\xE1\r\0\xFC\xFF\xFD\xFF\xFE\xFF\xFF\xFF\0\xFD\xFF\xFE\xFF\xFF\xFF\0\xFD\xFF\xFE\xFF\xFF\xFF\0\xFD\xFF\xFE\xFF\xFF\xFF\xFB\xFF\xFC\xFF\xFD\xFF\xFE\xFF\xFF\xFF\0\xFC\xFF\xFD\xFF\xFE\xFF\0\xFF\xFF\0\xFF\xFF\b\0\xFD\xFF\0\xFE\xFF\0\xFF\xFF.\0\xFD\xFF\xFE\xFF*\x004\x005\0\xFF\xFF5\x000\0[\0\\\0\xFF\xFF\x1B\xFA\xFF\xFB\xFF\x89\0h\0Y\0X\0j\0\xFF\xFF\x8F\0\x89\0\xB1\0\xFE\xFF\xB7\0\xA8\0\xA6\0\xB7\0\0\xFD\xFF\xB1\0\xAC\0\xBB\0\0\xFC\xFF5\xFB\xFF\xFC\xFF\xFD\xFFg\xFF\xFF\xF8\xFE\xFF\xFC\xFF\xFD\xFF\xFE\xFF\xFF\xFF(2J\xFC\xFF\xFD\xFF\xFE\xFF\xFF\xFF=Tl\xF9\xFF\xFA\xFF\xFB\xFF\xF4\0x\x8E\xB3\0\xC2\0\0\xFF\xFF\xBE\0\xBC\0\xBB\0\xC1\0\xB7\0\xB3\0\xFE\xFF\xBF\0\xC9\0\xC8\0\xC4\0\xCB\0\xC1\0\xBD\0\xFD\xFF\x9D_\xAE\xC4\xCE\xD8\xE4\xEF<\0\xFD\xFF\xFE\xFF\xFF\xFF\f\xFC\xFF\xFD\xFFW\xFF\xFF\x91\xFC\xFF\xFD\xFF\xDD\xFF\xFF\xE5\0\xFD\xFF\xFE\xFF\xFF\xFF\xE7\0\xFD\xFF\xFE\xFF\xFF\xFF\0\xFF\xFF\xFC\xFF\xFD\xFF\xFE\xFF\xFF\xFF"\xFD\xFF\xFE\xFF\xFF\xFF\0\0\xFF\xFF\0\xFE\xFF\xFF\xFF&\xFC\xFF\xFD\xFF\xFE\xFF\xFF\xFFx\xFB\xFF\xFC\xFF\xFD\xFF\xFE\xFF\xFF\xFF\xD0\0\xFD\xFF\xFE\xFF\xFF\xFF\xD3\0\xFD\xFF\xFE\xFF\xFF\xFF\xBD\0\xFF\xFF\x8F\xFC\xFF\xFD\xFF\xFE\xFF\xFF\xFF\r\xFD\xFF\xFE\xFF\xFF\xFF_\xFC\xFF\xFD\xFF\xFE\xFF\xFF\xFF2\xFD\xFF\xFE\xFF\xFF\xFF\xFD\xFF\xFE\xFF\xFF\xFF\xE9\0\xFD\xFF\xFE\xFF\xFF\xFF\xDE\0\xFD\xFF\xFE\xFF\xFF\xFFO\xED\xFF\xEE\xFF
\0\xF0\xFF,\xF3\xFF\xF4\xFF\xF5\xFF\xF6\xFF=\xF9\xFF-\xD1\0\xE4\0\xD3\0\xE8\0\xE1\0\xDF\0\xF0\0\xFF\xFF\xEB\0\xEA\0\b\xFE\xFF\xFD\xFF6\xFC\xFF '1-\xFB\xFF9RPNTJV\xFA\xFFn\f{\x9B\xA5\xB1\xBB\xC5\xF1\xFF\xC7M\xFD\xFF\xFF\xFF\x9A\xDE\xD1\x9B\xEF5Lr\xFC\xFF\xFD\xFF\xFE\xFF\xFF\xFF\x98\xFC\xFF\xFD\xFF\xE3\xFF\xFFU\x07\xF4\xFF\xF5\xFF\v\0\xF7\xFFL\xFA\xFF\xFB\xFF\xFC\xFF\xFD\xFF\xFE\xFF\xF33\x07dsh\x85v\x9A\xAB\xFF\xFF\xAD\xB0\xBF\xB9\xBB\xFD\xE6\xE6\xEA\xF7\xED\xEA	\v\x07\x8E\x98t\x07\xAA\x07\xB4\x07\xBE\x07\xC8\x07\xD2\x07\xF8\xFFx\xA7\xFD\xFF\xFF\xFF\xD8R\x07\xDC\x07\xEC\xF4\x07:\bQ\bw\bL\xFC\xFF\xFD\xFF\xFE\xFF\xFF\xFF\x9D\b\xFC\xFF\xFD\xFF\xE8\b\xFF\xFF\x87x\xFD\xFFd\xFE\xFF\xB6\xFF\xFF\v\xFF\xFF\xCC\xFC\xFF\xFD\xFF\xFE\xFF\xFF\xFF.\xFF\xFF\xB2\xFC\xFF\xFD\xFF\xFE\xFF\xFF\xFF\0\xFF\xFF\xB7\xFC\xFF\xFD\xFF\xFE\xFF\xFF\xFF\xBB\xFD\xFF\xFE\xFF\xFF\xFFy\xFD\xFF\xFE\xFF\xFF\xFF\xB8\xFC\xFF\xFD\xFF\xFE\xFF\0\xFF\xFF`,
        "\xFF\xFF\xFF\xFF\xFF\xFF\0\xFF\xFF\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x07\0\x07\0\xFF\xFF\0\0\0\0\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\b\0\b\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF	\0\xFF\xFF	\0\xFF\xFF	\0\xFF\xFF\xFF\xFF\0\xFF\xFF\xFF\xFF\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x07\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\xFF\xFF\0\xFF\xFF\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\xFF\xFF\xFF\xFF\xFF\xFF\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\xFF\xFF\0\0\xFF\xFF\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\xFF\xFF\0\xFF\xFF\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\xFF\xFF\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\xFF\xFF\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x07\0\x07\0\xFF\xFF\0\0\0\0\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\b\0\xFF\xFF\b\0\xFF\xFF\b\0\xFF\xFF\xFF\xFF\r\0\xFF\xFF\xFF\xFF\xFF\xFF\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF	\0\xFF\xFF\v\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\v\0\v\0\v\0\v\0\v\0\v\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\xFF\xFF\0\0\xFF\xFF\0\0\xFF\xFF\xFF\xFF\0\xFF\xFF\xFF\xFF\xFF\xFF\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\xFF\xFF\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\xFF\xFF",
        "\0\0\0\0\0\xFF\xFF\0\0\xFF\xFF\0\0\0\0\0\0\0\0\xFF\xFF\xFF\xFF\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\xFF\xFF\xFF\xFF\xFF\xFF\0\0\xFF\xFF\xFF\xFF\0\0\xFF\xFF\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\x009\0<\0\0\0<\0\0\0\0\0A\0\0\0A\0\0\0\0\0F\0\0\0\0\0\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\xFF\xFF\xFF\xFF\xFF\xFF\0\0T\0\0\0\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0^\0\0\0\0\0a\0\xFF\xFF\xFF\xFFa\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFh\0\0\0\0\0\0\0\0\0m\0\0\0\0\0\0\0q\0\0\0\0\0\0\0u\0\0\0\0\0\0\0y\0\0\0\0\0\0\0\0\0\0\0~\0\0\0\0\0\0\0\xFF\xFF\0\0\xFF\xFF\0\0\xFF\xFF\xFF\xFF\0\0\xFF\xFF\0\0\x8A\0\0\0\x8E\0\0\0\0\0\xFF\xFF\xFF\xFF\xFF\xFF\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\x9A\0\0\0\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\xFF\xFF\xFF\xFF\xFF\xFF\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\xB2\0\0\0\0\0\0\0\xFF\xFF\0\0\xFF\xFF\0\0\xFF\xFF\xBB\0\0\0\0\0\0\0\0\0\xFF\xFF\xFF\xFF\xC2\0\0\0\0\0\0\0\0\0\xFF\xFF\xFF\xFF\xC9\0\0\0\0\0\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xEB\0\0\0\0\0\0\0\xEF\0\0\0\0\0\xFF\xFF\0\0\xF4\0\0\0\0\0\xFF\xFF\0\0\xF9\0\0\0\0\0\0\0\xFD\0\0\0\0\0\0\0\xFF\xFF\0\0\0\0\0\0\0\0\0\0\b\0\0\0\0\0\0\xFF\xFF\0\0\xFF\xFF\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0 \0\0\0\0\0\0\xFF\xFF\0\0&\0\0\0\0\0\0\0\0+\0\0\0\0\0\0/\0\0\0\0\0\0\0\x004\0\0\0\0\0\x008\0\0\0\0\0\0<\0\0\0\0\0\0@\0\0\0\0\0\0C\0\0\0\0\xFF\xFF\0\0\xFF\xFF\0\0\0\0\0\0\0\0\xFF\xFF\xFF\xFF\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\xFF\xFF\xFF\xFF\xFF\xFF\0\0\xFF\xFF\xFF\xFF\0\0\xFF\xFF\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0y}\0\0\0\0\x80\xFF\xFF\xFF\xFF\x80\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x87\0\0\0\0\0\0\0\0\x8C\0\0\0\0\xFF\xFF\0\0\x90\0\0\0\0\xFF\xFF\0\0\xFF\xFF\0\0\0\0\0\0\0\0\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\xC1\xC5\0\0\0\0\xC8\xFF\xFF\xFF\xFF\xC8\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xCF\0\0\0\0\0\0\0\0\xD4\0\0\0\0\xFF\xFF\0\0\xFF\xFF\xFF\xFF\0\0\xFF\xFF\0\0\xDC\0\0\xFF\xFF\0\0\xE2\0\0\0\0\0\0\0\0\xFF\xFF\0\0\xE9\0\0\0\0\0\0\0\0\xFF\xFF\0\0\xF0\0\0\0\0\0\0\0\0\xF5\0\0\0\0\0\0\xF9\0\0\0\0\0\0\xFC\0\0\0\0\0\0\xFF\xFF\0\0",
        "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x86\0\0\0\0\0\0\x86\0E\x92\xFF\xFF\0\0E\x92\0\0\0\0\0\0\0\0\x7F\0\x8B\0\0\0\0\0\0\f\0\0\xAA\0\x86\0\xAF\0\0\0\x07\0\vE\x92\r\x001\0\0\n\0\v\0\v\0\v\0\v\0\v\0\v\0\v\0\v\0\v\x008\0v\0\0\x81\0\x82\x009\0\xED\x89\0\01\0\0\x000\0\x8A\0j\0>\0\0n\0i\0\0\x001\0\0\v\0\v\0\v\0\v\0\v\0\v\0\v\0\v\0\v\0\v\0\x000\0\b\0r\0\xD1\0\xEC\0\0\r\0\0\xFF\xFF0\x000\0\0\0\0 \0!\0#\0\0\x1B\0\0\0\0\"\0\0\0\0\0\0$\0)\0%\x000\0	\0*\0+\0,\0-\0.\0/\0=\0U\x000\0&\0'\0'\0'\0'\0'\0'\0'\0'\0'\x001\0C\0'\0'\0'\0'\0'\0'\0'\0'\0'\0'\0V\0\x8F\0\xFF\xFF(\0\x90\0\x91\0\x92\x007\0\x94\x007\0\x95\x000\x006\x006\x006\x006\x006\x006\x006\x006\x006\x006\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\0\xFF\xFF0\0\x96\0\x97\0\xA1\0B\0\x9E\x005\0\x9F\x005\0\xA0\x003\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\0\xA5\x003\x006\x006\x006\x006\x006\x006\x006\x006\x006\x006\0\xA2\0\xA3\0\xA6\0]\0\xFF\xFF\x006\x006\x006\x006\x006\x006\x006\x006\x006\x006\0\xFF\xFFM\0g\0l\0t\0\x84\0\x86\0\x87\0\x80\0\x8B\0\x86\0\xA4\0]\0\xAB\0M\0\xA7\0\xA8\0\xA9\0\xAC\0p\0\xAD\0\xAE\0\xD2\0\xE2\0\xD0\0\xD3\0\xD4\0;\0S\0\x86\0\xD5\0\xD6\0\xD7\0\xD8\0\xDA\0\x8D\0\xDB\0]\0\xDC\0\xDD\0{\0\xDE\0\xDF\0\xE0\0\x88\0_\0\xE1\0#A\xEA\0\x9B\0a\xFA\0\xFF\xFF\xFE\x009=_M\0,\\X	L\0|\0!K\0b\0UVWxYJ\0\xE1\x005yI\0ZH\0G\0N\0N\0N\0N\0N\0N\0N\0N\0N\0N\0b\0qz\0[@\0]N\0N\0N\0N\0N\0N\0O\0O\0O\0O\0O\0O\0O\0O\0O\0O\0\x9C\0p^`bc1O\0O\0O\0O\0O\0O\0d\x9D\0eN\0N\0N\0N\0N\0N\0\xB7\0\xB8\0\xB8\0\xB8\0\xB8\0\xB8\0\xB8\0\xB8\0\xB8\0\xB8\0p\xFF\xFFfgiO\0O\0O\0O\0O\0O\0P\0P\0P\0P\0P\0P\0P\0P\0P\0P\0jk0(lmnP\0P\0P\0P\0P\0P\0Q\0Q\0Q\0Q\0Q\0Q\0Q\0Q\0Q\0Q\0o\x1B\xFF\xFF\xAB\xAAQ\0Q\0Q\0Q\0Q\0Q\0\\\0\xA8?P\0P\0P\0P\0P\0P\0\xF8\0\xA5\xFC\0\xA2;E\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0\xFF\xFFQ\0Q\0Q\0Q\0Q\0Q\0W\0W\0W\0W\0W\0W\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0'*\xFF\xFF\xA3\xA4x\0X\0X\0X\0X\0X\0X\0\xA67\x99\0W\0W\0W\0W\0W\0W\0\x07\xA7\xA4\xA9\xA4Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\x003X\0X\0X\0X\0X\0X\0Y\0Y\0Y\0Y\0Y\0Y\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0a\0\x89\xA4\xAC\xB9\x88\xADZ\0Z\0Z\0Z\0Z\0Z\0a\0\xB3\0\xAEY\0Y\0Y\0Y\0Y\0Y\0.\xAF\xB0\xB4\0\xA4\xB8\xB5\0\xB6\0\xB6\0\xB6\0\xB6\0\xB6\0\xB6\0\xB6\0\xB6\0\xB6\0|Z\0Z\0Z\0Z\0Z\0Z\0\xC0\xB2\xB3a\0\xC1\xB4\xB5\xB6\xB7\xA4\xD8\xFF\xFFa\0\xB8\xD8\xD1a\0\xDFa\0\xD0\xE6\0\0a\0\xDB%\xD8\xD9\0\0\xDC\xD8a\0\0\0\0\0\xD8a\0\0\0a\0`\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0\xD8\0\0~\0\0\0\0\0\0\0\0c\0c\0c\0c\0c\0c\0a\0\0\0\xDA\xFA\0\0\0\0a\0\0\0||a\0\0\0\xDD\0\0\xFD\0\0\0\0\0\0a\0\xFF\xFF\0\0\xC4a\0\0\0a\0`\0c\0c\0c\0c\0c\0c\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0\xEB\0\0\xF1\0\0\xFF\xF2\0\0d\0d\0d\0d\0d\0d\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0\xF6\x81\x81\xE4\0\0\xC4\0\0e\0e\0e\0e\0e\0e\0\0\0\xC6\0\0d\0d\0d\0d\0d\0d\0\0\0\0\0\0\0\xC4\xEA\x86a\0a\0a\0a\0a\0a\0a\0a\0a\0a\0\0\0e\0e\0e\0e\0e\0e\0a\0a\0a\0a\0a\0a\0\xB6\0\xB6\0\xB6\0\xB6\0\xB6\0\xB6\0\xB6\0\xB6\0\xB6\0\xB6\0\0\0\0\0\xC9\xB1\0\xB8\0\xB8\0\xB8\0\xB8\0\xB8\0\xB8\0\xB8\0\xB8\0\xB8\0\xB8\0\xBC\0\0\0a\0a\0a\0a\0a\0a\0\xC9\xE3\0\0\xBF\0\xCE{\xBD\0\xBE\0\xBE\0\xBE\0\xBE\0\xBE\0\xBE\0\xBE\0\xBE\0\xBE\0\xBE\0\xBE\0\xBE\0\xBE\0\xBE\0\xBE\0\xBE\0\xBE\0\xBE\0\xBE\0\xBD\0\xBE\0\xBE\0\xBE\0\xBE\0\xBE\0\xBE\0\xBE\0\xBE\0\xBE\0\xC3\0\xC5\0\xC5\0\xC5\0\xC5\0\xC5\0\xC5\0\xC5\0\xC5\0\xC5\0\xC5\0\xC6\0\xFF\xFF\xF8\xC4\0\xC5\0\xC5\0\xC5\0\xC5\0\xC5\0\xC5\0\xC5\0\xC5\0\xC5\0\xC4\0\xC5\0\xC5\0\xC5\0\xC5\0\xC5\0\xC5\0\xC5\0\xC5\0\xC5\0\xCA\0\xE3\0\xE3\0\xE3\0\xE3\0\xE3\0\xE3\0\xE3\0\xE3\0\xE3\0\xE3\0\xCD\0\xFF\xFF\xFF\xFF\xCB\0\xCC\0\xCC\0\xCC\0\xCC\0\xCC\0\xCC\0\xCC\0\xCC\0\xCC\0\xE2\0\xC3\xCC\0\xCC\0\xCC\0\xCC\0\xCC\0\xCC\0\xCC\0\xCC\0\xCC\0\xCC\0\xE8\0\0\0\0\xCE\0\xDD\xEF\xFE\0\0\xCF\0\xF4\0\0\xE1\0\xCB\0\xCC\0\xCC\0\xCC\0\xCC\0\xCC\0\xCC\0\xCC\0\xCC\0\xCC\0\xE8\0\0\0\xE8\0\0\0\xE1\xE7\0\xE7\0\xE7\0\xE7\0\xE7\0\xE7\0\xE7\0\xE7\0\xE7\0\xE7\0\xD9\0\xFF\xFF\0\0\0\0\0\0\0\0\xE1\0\xE3\0\xE3\0\xE3\0\xE3\0\xE3\0\xE3\0\xE3\0\xE3\0\xE3\0\xE3\0\0\0\0\0\0\0\0\0\xFF\xFF\0\0\0\0\xE6\0\0\0\xE6\0\0\0\xE4\0\xE5\0\xE5\0\xE5\0\xE5\0\xE5\0\xE5\0\xE5\0\xE5\0\xE5\0\xE5\0\xE5\0\xE5\0\xE5\0\xE5\0\xE5\0\xE5\0\xE5\0\xE5\0\xE5\0\xE5\0\xE5\0\xE5\0\xE5\0\xE5\0\xE5\0\xE5\0\xE5\0\xE5\0\xE5\0\xE5\0\0\0\xE4\0\xE7\0\xE7\0\xE7\0\xE7\0\xE7\0\xE7\0\xE7\0\xE7\0\xE7\0\xE7\0\xBA\0\xE7\0\xE7\0\xE7\0\xE7\0\xE7\0\xE7\0\xE7\0\xE7\0\xE7\0\xE7\0\0\0\0\0\0\0\0\0\0\0\xF1\0\0\0q\0\0MMMMMMMMMMrrrrrrrrrr\0\0p\0\0\0\0\xC1\0\0\0\0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0p\0\0\0\0\0\0\xF0\0\xC8\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\0\0\xF6\0\0\0\0\0\xF0\0\0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\0\0\0\0\0\0\0\0\xF5\0\0\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xEE\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\0\0\0\0\0\0\0\0\xF5\0\0\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0EF\0\0\0\0ELMMMMMMMMM\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0E\0\0N\0\0\0\0\0\0\0\0hI\0\0\0\0\0\0\0\0O\0\0GLMMMMMMMMM\0\0\0\0H\0\0\0\0\0\0\0\0\0\0\xF3\0\0\0\0\0\0\0\0\0\0\0\0\0Pw\0\0w\0\0Qvvvvvvvvvv\0\0\0\0JrrrrrrrrrrS\0\0\0\0\0\0\0\0\0\0\0\0\0\0R\0\0\0\0s\0\0\0\0T\0\0\0\0u\0\0u\0\0Ktttttttttttttttttttt\0\0sttttttttttvvvvvvvvvvvvvvvvvvvv\0\0\x80\x82\x82\x82\x82\x82\x82\x82\x82\x82\x82\0\0\0\0\x80\0\0\0\0\0\0\x80\x82\x82\x82\x82\x82\x82\0\0\0\0\0\0\0\0\0\0\0\0\x80\0\0\0\0\xB9\0\0\x9B\x9B\x9B\x9B\x9B\x9B\x9B\x9B\x9B\x9B\0\0\0\0\0\0\0\0\0\0\x82\x82\x82\x82\x82\x82\xB8\0\0\x80\0\0\0\0\0\0\0\0\0\0\x80\0\0\0\0\0\0\x80\0\0\0\0\0\0\0\0\0\0\0\0\x80\x80\0\0\0\0D\x80\x80\x80\x7F\0\0\x80\0\0\0\0\xB8\0\0\0\0\0\0\0\0\x80\0\0\0\0\0\0\x80\0\0\x80\x7F\x83\x83\x83\x83\x83\x83\x83\x83\x83\x83\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x83\x83\x83\x83\x83\x83\x84\x84\x84\x84\x84\x84\x84\x84\x84\x84\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x84\x84\x84\x84\x84\x84\0\0\0\0\0\0\x83\x83\x83\x83\x83\x83\0\0\0\0\0\0\0\0\0\0\0\0\x80\x80\x80\x80\x80\x80\x80\x80\x80\x80\0\0\x84\x84\x84\x84\x84\x84\x80\x80\x80\x80\x80\x80\xBF\x8E\xBF\0\0\0\0\xBE\xBE\xBE\xBE\xBE\xBE\xBE\xBE\xBE\xBE\xBA\xBA\xBA\xBA\xBA\xBA\xBA\xBA\xBA\xBA\0\0\x80\x80\x80\x80\x80\x80\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\0\0\0\0\0\0\0\0\x8D\0\0\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\0\0\0\0\0\0\0\0\x8D\0\0\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x92\x93\0\0\0\0\x92\x9A\x9B\x9B\x9B\x9B\x9B\x9B\x9B\x9B\x9B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xC8\x92\0\0\x99\0\0\0\0\0\0\0\0\xB1\x96\0\0\0\0\0\0\xC8\x9C\0\0\x94\x9A\x9B\x9B\x9B\x9B\x9B\x9B\x9B\x9B\x9B\0\0\0\0\x95\0\0\0\0\0\0\0\0\0\0\0\0\x8B\0\0\0\0\0\0\0\0\0\0\x9D\0\0\0\0\0\0\0\0\x9E\xBA\xBA\xBA\xBA\xBA\xBA\xBA\xBA\xBA\xBA\xC8\0\0\x97\0\0\0\0\0\0\xC8\0\0\0\0\0\0\xC8\xBB\0\0\xA0\0\0\0\0\0\0\0\0\xC8\0\0\0\0\x9F\xC8\0\0\xC8\xC7\0\0\xA1\0\0\0\0\0\0\0\0\0\0\0\0\x98\0\0\0\0\0\0\0\0\xBD\0\0\xBD\0\0\xBB\xBC\xBC\xBC\xBC\xBC\xBC\xBC\xBC\xBC\xBC\xBC\xBC\xBC\xBC\xBC\xBC\xBC\xBC\xBC\xBC\xBC\xBC\xBC\xBC\xBC\xBC\xBC\xBC\xBC\xBC\xBE\xBE\xBE\xBE\xBE\xBE\xBE\xBE\xBE\xBE\xBE\xBE\xBE\xBE\xBE\xBE\xBE\xBE\xBE\xBE\xCA\xCA\xCA\xCA\xCA\xCA\xCA\xCA\xCA\xCA\xC8\0\0\0\0\0\0\0\0\0\0\0\0\xCA\xCA\xCA\xCA\xCA\xCA\xC8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xCA\xCA\xCA\xCA\xCA\xCA\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xC8\0\0\0\0\0\0\0\0\x91\xC8\0\0\0\0\0\0\xC8\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xC8\0\0\0\0\0\0\xC8\0\0\xC8\xC7\xCB\xCB\xCB\xCB\xCB\xCB\xCB\xCB\xCB\xCB\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xCB\xCB\xCB\xCB\xCB\xCB\xCC\xCC\xCC\xCC\xCC\xCC\xCC\xCC\xCC\xCC\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xCC\xCC\xCC\xCC\xCC\xCC\0\0\0\0\0\0\xCB\xCB\xCB\xCB\xCB\xCB\0\0\0\0\0\0\0\0\0\0\0\0\xC8\xC8\xC8\xC8\xC8\xC8\xC8\xC8\xC8\xC8\0\0\xCC\xCC\xCC\xCC\xCC\xCC\xC8\xC8\xC8\xC8\xC8\xC8\0\0\xD6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xC8\xC8\xC8\xC8\xC8\xC8\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\0\0\0\0\0\0\0\0\xD5\0\0\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\0\0\0\0\0\0\0\0\xD5\0\0\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xD3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
        "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\0\0\xFF\xFF\0\0\0\x86\0\xFF\xFF\0\xFF\xFF\x86\0E\x929\0\xFF\xFFE\x92\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF}\0\x8A\0\xFF\xFF\0\0\xFF\xFF\0\0\0\xA9\0\x86\0\xAE\0\xFF\xFF\0\0\nE\x92\f\0\0\n\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0s\0\0\0}\0\x81\0\0\xEC\x88\0\xFF&\0\xFF\xFF\n\0\x88\0f\0:\0\0\0k\0f\0\xFF\xFF\v\0\0\0\v\0\v\0\v\0\v\0\v\0\v\0\v\0\v\0\v\0\v\0\0&\0\0\0o\0\xD0\0\xE9\0\xFF\0\f\0\0<\0\v\0\n\0\0\0\0\0\0 \0\"\0\0\0\0\0\0\x1B\0!\0\0\0\0\0\0\0#\0(\0$\0&\0\0\0)\0*\0+\0,\0-\0.\0:\0R\0\v\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0\r\0'\0?\0'\0'\0'\0'\0'\0'\0'\0'\0'\0'\0U\0\x8C\0<\0\r\0\x8F\0\x90\0\x91\x000\0\x93\x000\0\x94\0'\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\0A\0'\0\x95\0\x96\0\x9C\0?\0\x9D\x003\0\x9E\x003\0\x9F\x002\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\x004\x004\x004\x004\x004\x004\x004\x004\x004\x004\x005\x005\x005\x005\x005\x005\x005\x005\x005\x005\0\x9B\x002\x006\x006\x006\x006\x006\x006\x006\x006\x006\x006\0\xA1\0\xA2\0\x9B\0[\0A\0\0\x007\x007\x007\x007\x007\x007\x007\x007\x007\x007\x009\0D\0f\0k\0s\0\x83\0\x85\0\x85\0}\0\x8A\0\x85\0\xA3\0^\0\xA5\0D\0\xA6\0\xA7\0\xA8\0\xAB\0o\0\xAC\0\xAD\0\xCE\0\xCB\0\xCF\0\xD2\0\xD3\0:\0R\0\x85\0\xD4\0\xD5\0\xD6\0\xD7\0\xD9\0\x8C\0\xDA\0a\0\xDB\0\xDC\0w\0\xDD\0\xDE\0\xDF\0\x85\0[\0\xCB\0\">\xE9\0\x98\0P\xF7\0<\0\xFB\x006:QD\0)RSD\0w\0D\0^\0TUVGXD\0\xCB\x002GD\0YD\0D\0G\0G\0G\0G\0G\0G\0G\0G\0G\0G\0a\0Lw\0Z?\0\\G\0G\0G\0G\0G\0G\0N\0N\0N\0N\0N\0N\0N\0N\0N\0N\0\x98\0L]_ab-N\0N\0N\0N\0N\0N\0c\x98\0dG\0G\0G\0G\0G\0G\0\xB4\0\xB4\0\xB4\0\xB4\0\xB4\0\xB4\0\xB4\0\xB4\0\xB4\0\xB4\0LA\0efhN\0N\0N\0N\0N\0N\0O\0O\0O\0O\0O\0O\0O\0O\0O\0O\0ij-$klmO\0O\0O\0O\0O\0O\0P\0P\0P\0P\0P\0P\0P\0P\0P\0P\0ny\x9D\x9EP\0P\0P\0P\0P\0P\0[\0\x9F>O\0O\0O\0O\0O\0O\0\xF7\0\xA0\xFB\0\xA1:D\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0^\0P\0P\0P\0P\0P\0P\0V\0V\0V\0V\0V\0V\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0$)a\0\xA2\xA3w\0W\0W\0W\0W\0W\0W\0\xA56\x98\0V\0V\0V\0V\0V\0V\0\xA6\xA7\xA8\xA9X\0X\0X\0X\0X\0X\0X\0X\0X\0X\x002W\0W\0W\0W\0W\0W\0X\0X\0X\0X\0X\0X\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0_\0\x85\xAA\xAB\x9A\x85\xACY\0Y\0Y\0Y\0Y\0Y\0_\0\xB0\0\xADX\0X\0X\0X\0X\0X\0-\xAE\xAF\xB0\0\xB0\x9A\xB0\0\xB0\0\xB0\0\xB0\0\xB0\0\xB0\0\xB0\0\xB0\0\xB0\0\xB0\0zY\0Y\0Y\0Y\0Y\0Y\0\x94\xB1\xB2b\0\x94\xB3\xB4\xB5\xB6\xB7\xD8\xC1_\0\x9A\xD8\xCDb\0\xDE_\0\xCD\xE5\xFF\xFF_\0\xDA$\xD7\xD7\xFF\xFF\xDA\xD7_\0\xFF\xFF\xFF\xFF\xD8_\0\xFF\xFF_\0_\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0\xD7\xFF\xFFz\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\0`\0`\0`\0`\0`\0b\0\xFF\xFF\xD7\xF7\xFF\xFF\xFF\xFFb\0\xFF\xFF}\x80b\0\xFF\xFF\xDC\xFF\xFF\xFB\xFF\xFF\xFF\xFF\xFF\xFFb\0y\xFF\xFF\xC2b\0\xFF\xFFb\0b\0`\0`\0`\0`\0`\0`\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0\xE7\xFF\xFF\xEE\xFF\xFF\xFB\xEE\xFF\xFFc\0c\0c\0c\0c\0c\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0\xF3}\x80\xE0\xFF\xFF\xC5\xFF\xFFd\0d\0d\0d\0d\0d\0\xFF\xFF\xC2\xFF\xFFc\0c\0c\0c\0c\0c\0\xFF\xFF\xFF\xFF\xFF\xFF\xC8\xE7\x85e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0\xFF\xFFd\0d\0d\0d\0d\0d\0e\0e\0e\0e\0e\0e\0\xB6\0\xB6\0\xB6\0\xB6\0\xB6\0\xB6\0\xB6\0\xB6\0\xB6\0\xB6\0\xFF\xFF\xFF\xFF\xC5\xB0\0\xB8\0\xB8\0\xB8\0\xB8\0\xB8\0\xB8\0\xB8\0\xB8\0\xB8\0\xB8\0\xB9\0\xFF\xFFe\0e\0e\0e\0e\0e\0\xC8\xE0\xFF\xFF\xB9\0\xCDz\xB9\0\xB9\0\xB9\0\xB9\0\xB9\0\xB9\0\xB9\0\xB9\0\xB9\0\xB9\0\xBE\0\xBE\0\xBE\0\xBE\0\xBE\0\xBE\0\xBE\0\xBE\0\xBE\0\xBE\0\xBF\0\xBF\0\xBF\0\xBF\0\xBF\0\xBF\0\xBF\0\xBF\0\xBF\0\xBF\0\xC0\0\xC5\0\xC5\0\xC5\0\xC5\0\xC5\0\xC5\0\xC5\0\xC5\0\xC5\0\xC5\0\xC0\0\xC1\xF7\xC0\0\xC0\0\xC0\0\xC0\0\xC0\0\xC0\0\xC0\0\xC0\0\xC0\0\xC0\0\xC6\0\xC6\0\xC6\0\xC6\0\xC6\0\xC6\0\xC6\0\xC6\0\xC6\0\xC6\0\xC7\0\xE2\0\xE2\0\xE2\0\xE2\0\xE2\0\xE2\0\xE2\0\xE2\0\xE2\0\xE2\0\xC7\0}\x80\xC7\0\xC7\0\xC7\0\xC7\0\xC7\0\xC7\0\xC7\0\xC7\0\xC7\0\xC7\0\xCC\0\xC2\xCC\0\xCC\0\xCC\0\xCC\0\xCC\0\xCC\0\xCC\0\xCC\0\xCC\0\xCC\0\xE7\xFF\xFF\xFF\xFF\xC7\0\xDC\xEE\xFB\xFF\xFF\xC7\0\xF3\xFF\xFF\xCC\0\xCD\0\xCD\0\xCD\0\xCD\0\xCD\0\xCD\0\xCD\0\xCD\0\xCD\0\xCD\0\xE1\0\xFF\xFF\xE1\0\xFF\xFF\xE0\xE1\0\xE1\0\xE1\0\xE1\0\xE1\0\xE1\0\xE1\0\xE1\0\xE1\0\xE1\0\xCD\0\xC5\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xCC\0\xE3\0\xE3\0\xE3\0\xE3\0\xE3\0\xE3\0\xE3\0\xE3\0\xE3\0\xE3\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xC8\xFF\xFF\xFF\xFF\xE4\0\xFF\xFF\xE4\0\xFF\xFF\xE3\0\xE4\0\xE4\0\xE4\0\xE4\0\xE4\0\xE4\0\xE4\0\xE4\0\xE4\0\xE4\0\xE5\0\xE5\0\xE5\0\xE5\0\xE5\0\xE5\0\xE5\0\xE5\0\xE5\0\xE5\0\xE6\0\xE6\0\xE6\0\xE6\0\xE6\0\xE6\0\xE6\0\xE6\0\xE6\0\xE6\0\xFF\xFF\xE3\0\xE7\0\xE7\0\xE7\0\xE7\0\xE7\0\xE7\0\xE7\0\xE7\0\xE7\0\xE7\0\xB9\0\xE8\0\xE8\0\xE8\0\xE8\0\xE8\0\xE8\0\xE8\0\xE8\0\xE8\0\xE8\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xED\0\xFF\xFFM\xFF\xFFMMMMMMMMMMqqqqqqqqqq\xFF\xFFM\xFF\xFF\xFF\xFF\xC0\0\xFF\xFF\xFF\xFF\xED\0\xED\0\xED\0\xED\0\xED\0\xED\0\xED\0\xED\0\xED\0\xED\0\xED\0\xED\0\xED\0\xED\0\xED\0\xED\0\xED\0\xED\0\xED\0\xED\0\xED\0\xED\0\xED\0\xED\0\xED\0\xED\0M\xFF\xFF\xFF\xFF\xFF\xFF\xED\0\xC7\0\xED\0\xED\0\xED\0\xED\0\xED\0\xED\0\xED\0\xED\0\xED\0\xED\0\xED\0\xED\0\xED\0\xED\0\xED\0\xED\0\xED\0\xED\0\xED\0\xED\0\xED\0\xED\0\xED\0\xED\0\xED\0\xED\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xFF\xFF\xF2\0\xFF\xFF\xFF\xFF\xF0\0\xFF\xFF\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF0\0\xF2\0\xF2\0\xF2\0\xF2\0\xF2\0\xF2\0\xF2\0\xF2\0\xF2\0\xF2\0\xF2\0\xF2\0\xF2\0\xF2\0\xF2\0\xF2\0\xF2\0\xF2\0\xF2\0\xF2\0\xF2\0\xF2\0\xF2\0\xF2\0\xF2\0\xF2\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xF2\0\xFF\xFF\xF2\0\xF2\0\xF2\0\xF2\0\xF2\0\xF2\0\xF2\0\xF2\0\xF2\0\xF2\0\xF2\0\xF2\0\xF2\0\xF2\0\xF2\0\xF2\0\xF2\0\xF2\0\xF2\0\xF2\0\xF2\0\xF2\0\xF2\0\xF2\0\xF2\0\xF2\0\xED\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xF5\0\xFF\xFF\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0\xF5\0BB\xFF\xFF\xFF\xFFBOOOOOOOOOO\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFB\xFF\xFFB\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFOB\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFB\xFF\xFFBBBBBBBBBBB\xFF\xFF\xFF\xFFB\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xF2\0\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFBp\xFF\xFFp\xFF\xFFBpppppppppp\xFF\xFF\xFF\xFFBrrrrrrrrrrB\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFFB\xFF\xFF\xFF\xFFr\xFF\xFF\xFF\xFFB\xFF\xFF\xFF\xFFs\xFF\xFFs\xFF\xFFBsssssssssstttttttttt\xFF\xFFruuuuuuuuuuvvvvvvvvvvwwwwwwwwww\xFF\xFF~\x7F\x7F\x7F\x7F\x7F\x7F\x7F\x7F\x7F\x7F\xFF\xFF\xFF\xFF~\xFF\xFF\xFF\xFF\xFF\xFF\x81\x7F\x7F\x7F\x7F\x7F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\xFF\xFF\xFF\xFF\x9B\xFF\xFF\x9B\x9B\x9B\x9B\x9B\x9B\x9B\x9B\x9B\x9B\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x7F\x7F\x7F\x7F\x7F\x7F\x9B\xFF\xFF~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF~\xFF\xFF\xFF\xFF\xFF\xFF~\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81~\xFF\xFF\xFF\xFFB~\x81~~\xFF\xFF\x81\xFF\xFF\xFF\xFF\x9B\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\xFF\xFF\xFF\xFF\xFF\xFF\x81\xFF\xFF\x81\x81\x82\x82\x82\x82\x82\x82\x82\x82\x82\x82\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x82\x82\x82\x82\x82\x83\x83\x83\x83\x83\x83\x83\x83\x83\x83\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x83\x83\x83\x83\x83\xFF\xFF\xFF\xFF\xFF\xFF\x82\x82\x82\x82\x82\x82\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x84\x84\x84\x84\x84\x84\x84\x84\x84\x84\xFF\xFF\x83\x83\x83\x83\x83\x83\x84\x84\x84\x84\x84\x84\xB8\x8A\xB8\xFF\xFF\xFF\xFF\xB8\xB8\xB8\xB8\xB8\xB8\xB8\xB8\xB8\xB8\xB9\xB9\xB9\xB9\xB9\xB9\xB9\xB9\xB9\xB9\xFF\xFF\x84\x84\x84\x84\x84\x84\x8A\x8A\x8A\x8A\x8A\x8A\x8A\x8A\x8A\x8A\x8A\x8A\x8A\x8A\x8A\x8A\x8A\x8A\x8A\x8A\x8A\x8A\x8A\x8A\x8A\x8A\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x8A\xFF\xFF\x8A\x8A\x8A\x8A\x8A\x8A\x8A\x8A\x8A\x8A\x8A\x8A\x8A\x8A\x8A\x8A\x8A\x8A\x8A\x8A\x8A\x8A\x8A\x8A\x8A\x8A\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x8D\xFF\xFF\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8D\x8F\x8F\xFF\xFF\xFF\xFF\x8F\x9C\x9C\x9C\x9C\x9C\x9C\x9C\x9C\x9C\x9C\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xC6\x8F\xFF\xFF\x8F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x9C\x8F\xFF\xFF\xFF\xFF\xFF\xFF\xC6\x8F\xFF\xFF\x8F\x8F\x8F\x8F\x8F\x8F\x8F\x8F\x8F\x8F\x8F\xFF\xFF\xFF\xFF\x8F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x8A\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x8F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x8F\xBA\xBA\xBA\xBA\xBA\xBA\xBA\xBA\xBA\xBA\xC6\xFF\xFF\x8F\xFF\xFF\xFF\xFF\xFF\xFF\xC6\xFF\xFF\xFF\xFF\xFF\xFF\xC6\xBA\xFF\xFF\x8F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xC6\xFF\xFF\xFF\xFF\x8F\xC6\xFF\xFF\xC6\xC6\xFF\xFF\x8F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x8F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xBB\xFF\xFF\xBB\xFF\xFF\xBA\xBB\xBB\xBB\xBB\xBB\xBB\xBB\xBB\xBB\xBB\xBC\xBC\xBC\xBC\xBC\xBC\xBC\xBC\xBC\xBC\xBD\xBD\xBD\xBD\xBD\xBD\xBD\xBD\xBD\xBD\xBE\xBE\xBE\xBE\xBE\xBE\xBE\xBE\xBE\xBE\xBF\xBF\xBF\xBF\xBF\xBF\xBF\xBF\xBF\xBF\xC7\xC7\xC7\xC7\xC7\xC7\xC7\xC7\xC7\xC7\xC9\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xC7\xC7\xC7\xC7\xC7\xC7\xC9\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xC7\xC7\xC7\xC7\xC7\xC7\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xC9\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x8F\xC9\xFF\xFF\xFF\xFF\xFF\xFF\xC9\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xC9\xFF\xFF\xFF\xFF\xFF\xFF\xC9\xFF\xFF\xC9\xC9\xCA\xCA\xCA\xCA\xCA\xCA\xCA\xCA\xCA\xCA\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xCA\xCA\xCA\xCA\xCA\xCA\xCB\xCB\xCB\xCB\xCB\xCB\xCB\xCB\xCB\xCB\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xCB\xCB\xCB\xCB\xCB\xCB\xFF\xFF\xFF\xFF\xFF\xFF\xCA\xCA\xCA\xCA\xCA\xCA\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xCC\xCC\xCC\xCC\xCC\xCC\xCC\xCC\xCC\xCC\xFF\xFF\xCB\xCB\xCB\xCB\xCB\xCB\xCC\xCC\xCC\xCC\xCC\xCC\xFF\xFF\xD2\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xCC\xCC\xCC\xCC\xCC\xCC\xD2\xD2\xD2\xD2\xD2\xD2\xD2\xD2\xD2\xD2\xD2\xD2\xD2\xD2\xD2\xD2\xD2\xD2\xD2\xD2\xD2\xD2\xD2\xD2\xD2\xD2\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xD2\xFF\xFF\xD2\xD2\xD2\xD2\xD2\xD2\xD2\xD2\xD2\xD2\xD2\xD2\xD2\xD2\xD2\xD2\xD2\xD2\xD2\xD2\xD2\xD2\xD2\xD2\xD2\xD2\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xD5\xFF\xFF\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xD5\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xD2\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF",
        cst$23,
        cst$23,
        cst$23,
        cst$23,
        cst$23,
        cst$23
      ], Stdlib_List = global_data.Stdlib__List, Stdlib = global_data.Stdlib, Stdlib_Buffer = global_data.Stdlib__Buffer, Stdlib_String = global_data.Stdlib__String, Stdlib_Format = global_data.Stdlib__Format, Assert_failure = global_data.Assert_failure, Yojson_Common = global_data.Yojson__Common, Yojson_Codec = global_data.Yojson__Codec, Stdlib_Bytes = global_data.Stdlib__Bytes, Yojson_Lexer_utils = global_data.Yojson__Lexer_utils, Stdlib_Printf = global_data.Stdlib__Printf, Stdlib_Seq = global_data.Stdlib__Seq, Stdlib_Char = global_data.Stdlib__Char, Stdlib_Lexing = global_data.Stdlib__Lexing, cst_u00 = "\\u00", _a_ = [
        0,
        [
          11,
          "src=",
          [
            3,
            0,
            [
              11,
              " start=",
              [4, 3, 0, 0, [11, " len=", [4, 3, 0, 0, [12, 10, [10, 0]]]]]
            ]
          ]
        ],
        "src=%S start=%i len=%i\n%!"
      ], cst_b = "\\b", cst_t = "\\t", cst_n = "\\n", cst_f = "\\f", cst_r = "\\r", cst_null = cst_null$2, cst_true = "true", cst_false = "false", cst_Infinity = cst_Infinity$3, cst_Infinity$0 = cst_Infinity$4, cst_NaN = cst_NaN$1, _b_ = [0, [8, [0, 0, 3], 0, [0, 16], 0], cst_16g], cst_0 = cst_0$2, _c_ = [0, [8, [0, 0, 3], 0, [0, 17], 0], cst_17g], _d_ = [0, [8, [0, 0, 3], 0, [0, 17], 0], cst_17g], cst_0$0 = cst_0$2, _e_ = [0, [8, [0, 0, 3], 0, [0, 1], 0], "%.1g"], _f_ = [0, [8, [0, 0, 3], 0, [0, 2], 0], "%.2g"], _g_ = [0, [8, [0, 0, 3], 0, [0, 3], 0], "%.3g"], _h_ = [0, [8, [0, 0, 3], 0, [0, 4], 0], "%.4g"], _i_ = [0, [8, [0, 0, 3], 0, [0, 5], 0], "%.5g"], _j_ = [0, [8, [0, 0, 3], 0, [0, 6], 0], "%.6g"], _k_ = [0, [8, [0, 0, 3], 0, [0, 7], 0], "%.7g"], _l_ = [0, [8, [0, 0, 3], 0, [0, 8], 0], "%.8g"], _m_ = [0, [8, [0, 0, 3], 0, [0, 9], 0], "%.9g"], _n_ = [0, [8, [0, 0, 3], 0, [0, 10], 0], "%.10g"], _o_ = [0, [8, [0, 0, 3], 0, [0, 11], 0], "%.11g"], _p_ = [0, [8, [0, 0, 3], 0, [0, 12], 0], "%.12g"], _q_ = [0, [8, [0, 0, 3], 0, [0, 13], 0], "%.13g"], _r_ = [0, [8, [0, 0, 3], 0, [0, 14], 0], "%.14g"], _s_ = [0, [8, [0, 0, 3], 0, [0, 15], 0], "%.15g"], _t_ = [0, [8, [0, 0, 3], 0, [0, 16], 0], cst_16g], cst_Infinity$1 = cst_Infinity$3, cst_Infinity$2 = cst_Infinity$4, cst_NaN$0 = cst_NaN$1, cst_Infinity_value_not_allowed = cst_Infinity_value_not_allowed$3, cst_Infinity_value_not_allowed$0 = cst_Infinity_value_not_allowed$4, cst_NaN_value_not_allowed_in_s = cst_NaN_value_not_allowed_in_s$1, _u_ = [0, [8, [0, 0, 3], 0, [0, 16], 0], cst_16g], cst_0$1 = cst_0$2, _v_ = [0, [8, [0, 0, 3], 0, [0, 17], 0], cst_17g], cst_Infinity_value_not_allowed$1 = cst_Infinity_value_not_allowed$3, cst_Infinity_value_not_allowed$2 = cst_Infinity_value_not_allowed$4, cst_NaN_value_not_allowed_in_s$0 = cst_NaN_value_not_allowed_in_s$1;
      function to_basic(x2) {
        if (typeof x2 !== "number") {
          var _dY_ = x2[1];
          if (726928360 <= _dY_) {
            if (737456202 !== _dY_) {
              if (963043957 <= _dY_) {
                var l = x2[2], _dZ_ = caml_call2(
                  Stdlib_List[22],
                  function(param) {
                    var v2 = param[2], k2 = param[1];
                    return [0, k2, to_basic(v2)];
                  },
                  l
                );
                return [0, 963043957, caml_call1(Stdlib_List[10], _dZ_)];
              }
              var l$0 = x2[2], _d0_ = caml_call2(Stdlib_List[22], to_basic, l$0);
              return [0, 848054398, caml_call1(Stdlib_List[10], _d0_)];
            }
          } else {
            if (-752863768 === _dY_) {
              var s2 = x2[2];
              return [0, -976970511, s2];
            }
            if (708012133 <= _dY_) {
              var _d1_ = x2[2], match = _d1_[2], k = _d1_[1];
              if (!match)
                return [0, -976970511, k];
              var v = match[1];
              return [0, 848054398, [0, [0, -976970511, k], [0, to_basic(v), 0]]];
            }
          }
        }
        return x2;
      }
      function hex(n) {
        var _dX_ = 10 <= n ? n + 87 | 0 : n + 48 | 0;
        return caml_call1(Stdlib_Char[1], _dX_);
      }
      function write_special(src, start, stop, ob, str) {
        caml_call4(Stdlib_Buffer[18], ob, src, start[1], stop - start[1] | 0);
        caml_call2(Stdlib_Buffer[16], ob, str);
        start[1] = stop + 1 | 0;
        return;
      }
      function write_string(ob, src) {
        caml_call2(Stdlib_Buffer[12], ob, 34);
        var start = [0, 0], _dV_ = caml_ml_string_length2(src) - 1 | 0, _dU_ = 0;
        if (_dV_ >= 0) {
          var stop = _dU_;
          for (; ; ) {
            var c = caml_string_get2(src, stop);
            a:
              if (92 === c)
                write_special(src, start, stop, ob, cst);
              else {
                b: {
                  c: {
                    if (35 > c) {
                      if (8 > c)
                        break b;
                      switch (c - 8 | 0) {
                        case 0:
                          write_special(src, start, stop, ob, cst_b);
                          break;
                        case 1:
                          write_special(src, start, stop, ob, cst_t);
                          break;
                        case 2:
                          write_special(src, start, stop, ob, cst_n);
                          break;
                        case 4:
                          write_special(src, start, stop, ob, cst_f);
                          break;
                        case 5:
                          write_special(src, start, stop, ob, cst_r);
                          break;
                        case 26:
                          write_special(src, start, stop, ob, cst$0);
                          break;
                        case 24:
                        case 25:
                          break c;
                        default:
                          break b;
                      }
                      break a;
                    }
                    if (127 === c)
                      break b;
                  }
                  break a;
                }
                caml_call4(Stdlib_Buffer[18], ob, src, start[1], stop - start[1] | 0);
                caml_call2(Stdlib_Buffer[16], ob, cst_u00);
                var _dS_ = hex(c >>> 4 | 0);
                caml_call2(Stdlib_Buffer[12], ob, _dS_);
                var _dT_ = hex(c & 15);
                caml_call2(Stdlib_Buffer[12], ob, _dT_);
                start[1] = stop + 1 | 0;
              }
            var _dW_ = stop + 1 | 0;
            if (_dV_ === stop)
              break;
            var stop = _dW_;
          }
        }
        try {
          caml_call4(
            Stdlib_Buffer[18],
            ob,
            src,
            start[1],
            caml_ml_string_length2(src) - start[1] | 0
          );
        } catch (exc$0) {
          var exc = caml_wrap_exception2(exc$0);
          caml_call4(
            Stdlib_Printf[3],
            _a_,
            src,
            start[1],
            caml_ml_string_length2(src) - start[1] | 0
          );
          throw caml_maybe_attach_backtrace2(exc, 0);
        }
        return caml_call2(Stdlib_Buffer[12], ob, 34);
      }
      function json_string_of_string(s2) {
        var ob = caml_call1(Stdlib_Buffer[1], 10);
        write_string(ob, s2);
        return caml_call1(Stdlib_Buffer[2], ob);
      }
      function write_null(ob, param) {
        return caml_call2(Stdlib_Buffer[16], ob, cst_null);
      }
      function write_bool(ob, x2) {
        var _dR_ = x2 ? cst_true : cst_false;
        return caml_call2(Stdlib_Buffer[16], ob, _dR_);
      }
      function write_digits(s2, x2) {
        if (0 === x2)
          return 0;
        var d = x2 % 10 | 0;
        write_digits(s2, x2 / 10 | 0);
        var n = caml_call1(Stdlib[18], d), _dQ_ = caml_call1(Stdlib_Char[1], n + 48 | 0);
        return caml_call2(Stdlib_Buffer[12], s2, _dQ_);
      }
      function write_int(ob, x2) {
        return 0 < x2 ? write_digits(ob, x2) : 0 <= x2 ? caml_call2(Stdlib_Buffer[12], ob, 48) : (caml_call2(Stdlib_Buffer[12], ob, 45), write_digits(ob, x2));
      }
      function float_needs_period(s2) {
        try {
          var _dM_ = caml_ml_string_length2(s2) - 1 | 0, _dL_ = 0;
          if (_dM_ >= 0) {
            var i = _dL_;
            for (; ; ) {
              var match = caml_string_get2(s2, i);
              a: {
                if (48 <= match) {
                  if (58 > match)
                    break a;
                } else if (45 === match)
                  break a;
                throw caml_maybe_attach_backtrace2(Stdlib[3], 1);
              }
              var _dO_ = i + 1 | 0;
              if (_dM_ === i)
                break;
              var i = _dO_;
            }
          }
          var _dN_ = 1;
          return _dN_;
        } catch (_dP_) {
          var _dK_ = caml_wrap_exception2(_dP_);
          if (_dK_ === Stdlib[3])
            return 0;
          throw caml_maybe_attach_backtrace2(_dK_, 0);
        }
      }
      function write_float(ob, x2) {
        var match = caml_classify_float2(x2);
        if (3 === match) {
          var _dI_ = 0 < x2 ? cst_Infinity : cst_Infinity$0;
          return caml_call2(Stdlib_Buffer[16], ob, _dI_);
        }
        if (4 <= match)
          return caml_call2(Stdlib_Buffer[16], ob, cst_NaN);
        var s1 = caml_call2(Stdlib_Printf[4], _b_, x2), s2 = caml_float_of_string2(s1) == x2 ? s1 : caml_call2(Stdlib_Printf[4], _c_, x2);
        caml_call2(Stdlib_Buffer[16], ob, s2);
        var _dJ_ = float_needs_period(s2);
        return _dJ_ ? caml_call2(Stdlib_Buffer[16], ob, cst_0) : _dJ_;
      }
      function write_normal_float_prec(significant_figures, ob, x2) {
        var switcher = significant_figures - 1 | 0;
        if (15 < switcher >>> 0)
          var s2 = caml_call2(Stdlib_Printf[4], _d_, x2);
        else
          switch (switcher) {
            case 0:
              var s2 = caml_call2(Stdlib_Printf[4], _e_, x2);
              break;
            case 1:
              var s2 = caml_call2(Stdlib_Printf[4], _f_, x2);
              break;
            case 2:
              var s2 = caml_call2(Stdlib_Printf[4], _g_, x2);
              break;
            case 3:
              var s2 = caml_call2(Stdlib_Printf[4], _h_, x2);
              break;
            case 4:
              var s2 = caml_call2(Stdlib_Printf[4], _i_, x2);
              break;
            case 5:
              var s2 = caml_call2(Stdlib_Printf[4], _j_, x2);
              break;
            case 6:
              var s2 = caml_call2(Stdlib_Printf[4], _k_, x2);
              break;
            case 7:
              var s2 = caml_call2(Stdlib_Printf[4], _l_, x2);
              break;
            case 8:
              var s2 = caml_call2(Stdlib_Printf[4], _m_, x2);
              break;
            case 9:
              var s2 = caml_call2(Stdlib_Printf[4], _n_, x2);
              break;
            case 10:
              var s2 = caml_call2(Stdlib_Printf[4], _o_, x2);
              break;
            case 11:
              var s2 = caml_call2(Stdlib_Printf[4], _p_, x2);
              break;
            case 12:
              var s2 = caml_call2(Stdlib_Printf[4], _q_, x2);
              break;
            case 13:
              var s2 = caml_call2(Stdlib_Printf[4], _r_, x2);
              break;
            case 14:
              var s2 = caml_call2(Stdlib_Printf[4], _s_, x2);
              break;
            default:
              var s2 = caml_call2(Stdlib_Printf[4], _t_, x2);
          }
        caml_call2(Stdlib_Buffer[16], ob, s2);
        var _dH_ = float_needs_period(s2);
        return _dH_ ? caml_call2(Stdlib_Buffer[16], ob, cst_0$0) : _dH_;
      }
      function write_float_prec(significant_figures, ob, x2) {
        var match = caml_classify_float2(x2);
        if (3 !== match)
          return 4 <= match ? caml_call2(Stdlib_Buffer[16], ob, cst_NaN$0) : write_normal_float_prec(significant_figures, ob, x2);
        var _dG_ = 0 < x2 ? cst_Infinity$1 : cst_Infinity$2;
        return caml_call2(Stdlib_Buffer[16], ob, _dG_);
      }
      function write_std_float(ob, x2) {
        var match = caml_classify_float2(x2);
        if (3 === match) {
          var _dE_ = 0 < x2 ? cst_Infinity_value_not_allowed : cst_Infinity_value_not_allowed$0;
          return caml_call1(Yojson_Common[3], _dE_);
        }
        if (4 <= match)
          return caml_call1(Yojson_Common[3], cst_NaN_value_not_allowed_in_s);
        var s1 = caml_call2(Stdlib_Printf[4], _u_, x2), s2 = caml_float_of_string2(s1) == x2 ? s1 : caml_call2(Stdlib_Printf[4], _v_, x2);
        caml_call2(Stdlib_Buffer[16], ob, s2);
        var _dF_ = float_needs_period(s2);
        return _dF_ ? caml_call2(Stdlib_Buffer[16], ob, cst_0$1) : _dF_;
      }
      function write_std_float_prec(significant_figures, ob, x2) {
        var match = caml_classify_float2(x2);
        if (3 !== match)
          return 4 <= match ? caml_call1(Yojson_Common[3], cst_NaN_value_not_allowed_in_s$0) : write_normal_float_prec(significant_figures, ob, x2);
        var _dD_ = 0 < x2 ? cst_Infinity_value_not_allowed$1 : cst_Infinity_value_not_allowed$2;
        return caml_call1(Yojson_Common[3], _dD_);
      }
      var write_intlit = Stdlib_Buffer[16], _w_ = [0, [2, 0, [17, [0, cst$21, 1, 0], 0]], "%s@ "], cst_null$0 = cst_null$2, _x_ = [0, [18, [1, [0, [11, cst_hov2, 0], cst_hov2]], 0], "@[<hov2>"], _y_ = [
        0,
        [
          12,
          40,
          [
            17,
            [0, cst$27, 0, 0],
            [15, [17, [0, "@;<0 -2>", 0, -2], [12, 41, 0]]]
          ]
        ],
        "(@,%a@;<0 -2>)"
      ], _z_ = [0, [17, 0, 0], cst$32], _A_ = [0, [18, [1, [0, [11, cst_hv2, 0], cst_hv2]], 0], cst_hv2$0], _B_ = [
        0,
        [
          12,
          123,
          [
            17,
            [0, cst_1_0, 1, 0],
            [15, [17, [0, cst_1_2, 1, -2], [12, 125, 0]]]
          ]
        ],
        "{@;<1 0>%a@;<1 -2>}"
      ], _C_ = [0, [17, 0, 0], cst$32], _D_ = [0, [18, [1, [0, [11, cst_hv2, 0], cst_hv2]], 0], cst_hv2$0], _E_ = [
        0,
        [
          12,
          91,
          [
            17,
            [0, cst_1_0, 1, 0],
            [
              18,
              [1, [0, [11, cst_hov, 0], cst_hov]],
              [15, [17, 0, [17, [0, cst_1_2, 1, -2], [12, 93, 0]]]]
            ]
          ]
        ],
        "[@;<1 0>@[<hov>%a@]@;<1 -2>]"
      ], _F_ = [0, [17, 0, 0], cst$32], _G_ = [
        0,
        [
          12,
          91,
          [
            17,
            [0, cst_1_0, 1, 0],
            [
              18,
              [1, [0, [11, cst_hv, 0], cst_hv]],
              [15, [17, 0, [17, [0, cst_1_2, 1, -2], [12, 93, 0]]]]
            ]
          ]
        ],
        "[@;<1 0>@[<hv>%a@]@;<1 -2>]"
      ], _H_ = [
        0,
        [
          12,
          60,
          [
            18,
            [1, [0, [11, cst_hv2, 0], cst_hv2]],
            [2, 0, [11, cst$33, [15, [17, 0, [12, 62, 0]]]]]
          ]
        ],
        "<@[<hv2>%s: %a@]>"
      ], _I_ = [0, [12, 60, [2, 0, [12, 62, 0]]], "<%s>"], _J_ = [
        0,
        [
          18,
          [1, [0, [11, cst_hv2, 0], cst_hv2]],
          [2, 0, [11, cst$33, [15, [17, 0, 0]]]]
        ],
        "@[<hv2>%s: %a@]"
      ], _K_ = [
        0,
        [18, [1, [0, [11, cst_hv2, 0], cst_hv2]], [15, [17, 0, 0]]],
        "@[<hv2>%a@]"
      ], _L_ = [0, [15, 0], cst_a], _M_ = [0, [15, [17, 2, 0]], "%a@?"], cst_Null = "`Null", _N_ = [
        0,
        [11, "`Tuple (", [18, [1, [0, [11, cst_hov, 0], cst_hov]], 0]],
        "`Tuple (@[<hov>"
      ], _O_ = [0, [18, [1, [0, [11, cst_2, 0], cst_2]], [12, 91, 0]], cst_2$0], _P_ = [0, [12, 59, [17, [0, cst$21, 1, 0], 0]], cst$22], _Q_ = [0, [17, [0, cst$27, 0, 0], [12, 93, [17, 0, 0]]], cst$28], _R_ = [0, [17, 0, [12, 41, 0]], cst$26], _S_ = [
        0,
        [11, "`Assoc (", [18, [1, [0, [11, cst_hov, 0], cst_hov]], 0]],
        "`Assoc (@[<hov>"
      ], _T_2 = [0, [18, [1, [0, [11, cst_2, 0], cst_2]], [12, 91, 0]], cst_2$0], _U_ = [0, [12, 59, [17, [0, cst$21, 1, 0], 0]], cst$22], _V_ = [0, [12, 40, [18, [1, [0, 0, cst$23]], 0]], cst$24], _W_ = [0, [3, 0, 0], cst_S], _X_ = [0, [12, 44, [17, [0, cst$21, 1, 0], 0]], cst$25], _Y_ = [0, [17, 0, [12, 41, 0]], cst$26], _Z_ = [0, [17, [0, cst$27, 0, 0], [12, 93, [17, 0, 0]]], cst$28], ___ = [0, [17, 0, [12, 41, 0]], cst$26], _$_ = [
        0,
        [11, "`List (", [18, [1, [0, [11, cst_hov, 0], cst_hov]], 0]],
        "`List (@[<hov>"
      ], _aa_ = [0, [18, [1, [0, [11, cst_2, 0], cst_2]], [12, 91, 0]], cst_2$0], _ab_ = [0, [12, 59, [17, [0, cst$21, 1, 0], 0]], cst$22], _ac_ = [0, [17, [0, cst$27, 0, 0], [12, 93, [17, 0, 0]]], cst$28], _ad_ = [0, [17, 0, [12, 41, 0]], cst$26], _ae_ = [
        0,
        [11, "`Bool (", [18, [1, [0, [11, cst_hov, 0], cst_hov]], 0]],
        "`Bool (@[<hov>"
      ], _af_ = [0, [9, 0, 0], "%B"], _ag_ = [0, [17, 0, [12, 41, 0]], cst$26], _ah_ = [
        0,
        [11, "`Variant (", [18, [1, [0, [11, cst_hov, 0], cst_hov]], 0]],
        "`Variant (@[<hov>"
      ], _ai_ = [0, [12, 40, [18, [1, [0, 0, cst$23]], 0]], cst$24], _aj_ = [0, [3, 0, 0], cst_S], _ak_ = [0, [12, 44, [17, [0, cst$21, 1, 0], 0]], cst$25], cst_Some = "(Some ", _al_ = [0, [17, 0, [12, 41, 0]], cst$26], _am_ = [0, [17, 0, [12, 41, 0]], cst$26], cst_None = "None", _an_ = [
        0,
        [11, "`Float (", [18, [1, [0, [11, cst_hov, 0], cst_hov]], 0]],
        "`Float (@[<hov>"
      ], _ao_ = [0, [8, [0, 0, 5], 0, 0, 0], "%F"], _ap_ = [0, [17, 0, [12, 41, 0]], cst$26], _aq_ = [
        0,
        [11, "`Int (", [18, [1, [0, [11, cst_hov, 0], cst_hov]], 0]],
        "`Int (@[<hov>"
      ], _ar_ = [0, [4, 0, 0, 0, 0], "%d"], _as_ = [0, [17, 0, [12, 41, 0]], cst$26], _at_ = [
        0,
        [11, "`Intlit (", [18, [1, [0, [11, cst_hov, 0], cst_hov]], 0]],
        "`Intlit (@[<hov>"
      ], _au_ = [0, [3, 0, 0], cst_S], _av_ = [0, [17, 0, [12, 41, 0]], cst$26], _aw_ = [
        0,
        [11, "`String (", [18, [1, [0, [11, cst_hov, 0], cst_hov]], 0]],
        "`String (@[<hov>"
      ], _ax_ = [0, [3, 0, 0], cst_S], _ay_ = [0, [17, 0, [12, 41, 0]], cst$26], _az_ = [0, [15, 0], cst_a];
      function iter2(f_elt, f_sep2, x2, param$0) {
        if (!param$0)
          return;
        var l$0 = param$0[2], y$0 = param$0[1];
        caml_call2(f_elt, x2, y$0);
        var param = l$0;
        for (; ; ) {
          if (!param)
            return;
          var l = param[2], y = param[1];
          caml_call1(f_sep2, x2);
          caml_call2(f_elt, x2, y);
          var param = l;
        }
      }
      function f_sep(ob) {
        return caml_call2(Stdlib_Buffer[12], ob, 44);
      }
      function write_json(ob, x2) {
        if (typeof x2 === "number")
          return write_null(ob, 0);
        var _dC_ = x2[1];
        if (708012133 <= _dC_) {
          if (726928360 === _dC_) {
            var l = x2[2];
            return write_tuple(ob, l);
          }
          if (848054398 <= _dC_) {
            if (963043957 <= _dC_) {
              var l$0 = x2[2];
              return write_assoc(ob, l$0);
            }
            var l$1 = x2[2];
            return write_list(ob, l$1);
          }
          if (737456202 <= _dC_) {
            var b = x2[2];
            return write_bool(ob, b);
          }
          var match = x2[2], o = match[2], s2 = match[1];
          return write_variant(ob, s2, o);
        }
        if (3654863 <= _dC_) {
          if (365180284 <= _dC_) {
            var f = x2[2];
            return write_float(ob, f);
          }
          var i = x2[2];
          return write_int(ob, i);
        }
        if (-752863768 <= _dC_) {
          var s$0 = x2[2];
          return caml_call2(Stdlib_Buffer[16], ob, s$0);
        }
        var s$1 = x2[2];
        return write_string(ob, s$1);
      }
      function write_assoc(ob, l) {
        function f_elt(ob2, param) {
          var x2 = param[2], s2 = param[1];
          write_string(ob2, s2);
          caml_call2(Stdlib_Buffer[12], ob2, 58);
          return write_json(ob2, x2);
        }
        caml_call2(Stdlib_Buffer[12], ob, 123);
        iter2(f_elt, f_sep, ob, l);
        return caml_call2(Stdlib_Buffer[12], ob, 125);
      }
      function write_list(ob, l) {
        caml_call2(Stdlib_Buffer[12], ob, 91);
        iter2(write_json, f_sep, ob, l);
        return caml_call2(Stdlib_Buffer[12], ob, 93);
      }
      function write_tuple(ob, l) {
        caml_call2(Stdlib_Buffer[12], ob, 40);
        iter2(write_json, f_sep, ob, l);
        return caml_call2(Stdlib_Buffer[12], ob, 41);
      }
      function write_variant(ob, s2, o) {
        caml_call2(Stdlib_Buffer[12], ob, 60);
        write_string(ob, s2);
        if (o) {
          var x2 = o[1];
          caml_call2(Stdlib_Buffer[12], ob, 58);
          write_json(ob, x2);
        }
        return caml_call2(Stdlib_Buffer[12], ob, 62);
      }
      function write_std_json(ob, x2) {
        if (typeof x2 === "number")
          return write_null(ob, 0);
        var _dB_ = x2[1];
        if (708012133 <= _dB_) {
          if (726928360 === _dB_) {
            var l = x2[2];
            return write_std_tuple(ob, l);
          }
          if (848054398 <= _dB_) {
            if (963043957 <= _dB_) {
              var l$0 = x2[2], f_elt = function(ob2, param) {
                var x3 = param[2], s3 = param[1];
                write_string(ob2, s3);
                caml_call2(Stdlib_Buffer[12], ob2, 58);
                return write_std_json(ob2, x3);
              };
              caml_call2(Stdlib_Buffer[12], ob, 123);
              iter2(f_elt, f_sep, ob, l$0);
              return caml_call2(Stdlib_Buffer[12], ob, 125);
            }
            var l$1 = x2[2];
            caml_call2(Stdlib_Buffer[12], ob, 91);
            iter2(write_std_json, f_sep, ob, l$1);
            return caml_call2(Stdlib_Buffer[12], ob, 93);
          }
          if (737456202 <= _dB_) {
            var b = x2[2];
            return write_bool(ob, b);
          }
          var match = x2[2], o = match[2], s2 = match[1];
          return write_std_variant(ob, s2, o);
        }
        if (3654863 <= _dB_) {
          if (365180284 <= _dB_) {
            var f = x2[2];
            return write_std_float(ob, f);
          }
          var i = x2[2];
          return write_int(ob, i);
        }
        if (-752863768 <= _dB_) {
          var s$0 = x2[2];
          return caml_call2(Stdlib_Buffer[16], ob, s$0);
        }
        var s$1 = x2[2];
        return write_string(ob, s$1);
      }
      function write_std_tuple(ob, l) {
        caml_call2(Stdlib_Buffer[12], ob, 91);
        iter2(write_std_json, f_sep, ob, l);
        return caml_call2(Stdlib_Buffer[12], ob, 93);
      }
      function write_std_variant(ob, s2, o) {
        if (!o)
          return write_string(ob, s2);
        var x2 = o[1];
        caml_call2(Stdlib_Buffer[12], ob, 91);
        write_string(ob, s2);
        caml_call2(Stdlib_Buffer[12], ob, 44);
        write_std_json(ob, x2);
        return caml_call2(Stdlib_Buffer[12], ob, 93);
      }
      function to_buffer(opt, _dA_, ob, x2) {
        if (opt)
          var sth = opt[1], suf = sth;
        else
          var suf = cst$1;
        if (_dA_)
          var sth$0 = _dA_[1], std = sth$0;
        else
          var std = 0;
        if (std)
          write_std_json(ob, x2);
        else
          write_json(ob, x2);
        return caml_call2(Stdlib_Buffer[16], ob, suf);
      }
      function to_string(buf, opt, _dz_, std, x2) {
        if (opt)
          var sth = opt[1], len = sth;
        else
          var len = 256;
        if (_dz_)
          var sth$0 = _dz_[1], suf = sth$0;
        else
          var suf = cst$2;
        if (buf) {
          var ob = buf[1];
          caml_call1(Stdlib_Buffer[8], ob);
          var ob$0 = ob;
        } else
          var ob$0 = caml_call1(Stdlib_Buffer[1], len);
        to_buffer([0, suf], std, ob$0, x2);
        var s2 = caml_call1(Stdlib_Buffer[2], ob$0);
        caml_call1(Stdlib_Buffer[8], ob$0);
        return s2;
      }
      function to_channel(buf, opt, _dy_, std, oc, x2) {
        if (opt)
          var sth = opt[1], len = sth;
        else
          var len = 4096;
        if (_dy_)
          var sth$0 = _dy_[1], suf = sth$0;
        else
          var suf = cst$3;
        if (buf) {
          var ob = buf[1];
          caml_call1(Stdlib_Buffer[8], ob);
          var ob$0 = ob;
        } else
          var ob$0 = caml_call1(Stdlib_Buffer[1], len);
        to_buffer([0, suf], std, ob$0, x2);
        caml_call2(Stdlib_Buffer[10], oc, ob$0);
        return caml_call1(Stdlib_Buffer[8], ob$0);
      }
      function to_output(buf, opt, _dw_, std, out, x2) {
        if (opt)
          var sth = opt[1], len = sth;
        else
          var len = 4096;
        if (_dw_)
          var sth$0 = _dw_[1], suf = sth$0;
        else
          var suf = cst$4;
        if (buf) {
          var ob = buf[1];
          caml_call1(Stdlib_Buffer[8], ob);
          var ob$0 = ob;
        } else
          var ob$0 = caml_call1(Stdlib_Buffer[1], len);
        to_buffer([0, suf], std, ob$0, x2);
        var _dx_ = caml_call1(Stdlib_Buffer[7], ob$0);
        caml_call4(
          runtime.caml_get_public_method(out, 209784577, 3),
          out,
          caml_call1(Stdlib_Buffer[2], ob$0),
          0,
          _dx_
        );
        return caml_call1(Stdlib_Buffer[8], ob$0);
      }
      function to_file(len, std, opt, file, x2) {
        if (opt)
          var sth = opt[1], suf = sth;
        else
          var suf = cst$5;
        var oc = caml_call1(Stdlib[60], file);
        try {
          to_channel(0, len, [0, suf], std, oc, x2);
          var _dv_ = caml_call1(Stdlib[76], oc);
          return _dv_;
        } catch (e$0) {
          var e = caml_wrap_exception2(e$0);
          caml_call1(Stdlib[77], oc);
          throw caml_maybe_attach_backtrace2(e, 0);
        }
      }
      function seq_to_buffer(opt, std, ob, st) {
        if (opt)
          var sth = opt[1], suf = sth;
        else
          var suf = cst$6;
        var _dt_ = [0, suf];
        return caml_call2(
          Stdlib_Seq[4],
          function(_du_) {
            return to_buffer(_dt_, std, ob, _du_);
          },
          st
        );
      }
      function seq_to_string(buf, opt, _ds_, std, st) {
        if (opt)
          var sth = opt[1], len = sth;
        else
          var len = 256;
        if (_ds_)
          var sth$0 = _ds_[1], suf = sth$0;
        else
          var suf = cst$7;
        if (buf) {
          var ob = buf[1];
          caml_call1(Stdlib_Buffer[8], ob);
          var ob$0 = ob;
        } else
          var ob$0 = caml_call1(Stdlib_Buffer[1], len);
        seq_to_buffer([0, suf], std, ob$0, st);
        var s2 = caml_call1(Stdlib_Buffer[2], ob$0);
        caml_call1(Stdlib_Buffer[8], ob$0);
        return s2;
      }
      function seq_to_channel(buf, opt, _dr_, std, oc, seq) {
        if (opt)
          var sth = opt[1], len = sth;
        else
          var len = 2096;
        if (_dr_)
          var sth$0 = _dr_[1], suf = sth$0;
        else
          var suf = cst$8;
        if (buf) {
          var ob = buf[1];
          caml_call1(Stdlib_Buffer[8], ob);
          var ob$0 = ob;
        } else
          var ob$0 = caml_call1(Stdlib_Buffer[1], len);
        return caml_call2(
          Stdlib_Seq[4],
          function(json) {
            to_buffer([0, suf], std, ob$0, json);
            caml_call2(Stdlib_Buffer[10], oc, ob$0);
            return caml_call1(Stdlib_Buffer[8], ob$0);
          },
          seq
        );
      }
      function seq_to_file(len, opt, std, file, st) {
        if (opt)
          var sth = opt[1], suf = sth;
        else
          var suf = cst$9;
        var oc = caml_call1(Stdlib[60], file);
        try {
          seq_to_channel(0, len, [0, suf], std, oc, st);
          var _dq_ = caml_call1(Stdlib[76], oc);
          return _dq_;
        } catch (e$0) {
          var e = caml_wrap_exception2(e$0);
          caml_call1(Stdlib[77], oc);
          throw caml_maybe_attach_backtrace2(e, 0);
        }
      }
      function sort(x2) {
        if (typeof x2 !== "number") {
          var _dk_ = x2[1];
          if (726928361 <= _dk_) {
            if (848054398 === _dk_) {
              var l = x2[2], _dl_ = caml_call2(Stdlib_List[22], sort, l);
              return [0, 848054398, caml_call1(Stdlib_List[10], _dl_)];
            }
            if (963043957 === _dk_) {
              var l$0 = x2[2], _dm_ = caml_call2(
                Stdlib_List[22],
                function(param) {
                  var v2 = param[2], k2 = param[1];
                  return [0, k2, sort(v2)];
                },
                l$0
              ), l$1 = caml_call1(Stdlib_List[10], _dm_);
              return [
                0,
                963043957,
                caml_call2(
                  Stdlib_List[60],
                  function(param, _dp_) {
                    var b = _dp_[1], a = param[1];
                    return caml_call2(Stdlib_String[10], a, b);
                  },
                  l$1
                )
              ];
            }
          } else if (708012133 === _dk_) {
            var _dn_ = x2[2], match = _dn_[2];
            if (match) {
              var v = match[1], k = _dn_[1], v$0 = sort(v);
              return v === v$0 ? x2 : [0, 708012133, [0, k, [0, v$0]]];
            }
          } else if (726928360 <= _dk_) {
            var l$2 = x2[2], _do_ = caml_call2(Stdlib_List[22], sort, l$2);
            return [0, 726928360, caml_call1(Stdlib_List[10], _do_)];
          }
        }
        return x2;
      }
      function pp_list(sep, ppx, out, l) {
        function pp_sep(out2, param) {
          return caml_call3(Stdlib_Format[137], out2, _w_, sep);
        }
        return caml_call4(Stdlib_Format[130], [0, pp_sep], ppx, out, l);
      }
      function is_atom(x2) {
        a:
          if (typeof x2 !== "number") {
            var _dj_ = x2[1];
            if (737456202 <= _dj_) {
              if (848054398 === _dj_) {
                if (!x2[2])
                  break a;
              } else if (963043957 > _dj_ || !x2[2])
                break a;
            } else if (708012133 === _dj_) {
              if (!x2[2][2])
                break a;
            } else if (726928360 > _dj_ || !x2[2])
              break a;
            return 0;
          }
        return 1;
      }
      function format(inside_box, std, out, x2) {
        var x$0 = x2;
        for (; ; ) {
          if (typeof x$0 === "number")
            return caml_call2(Stdlib_Format[13], out, cst_null$0);
          var _cM_ = x$0[1];
          if (708012133 > _cM_) {
            if (3654863 <= _cM_) {
              if (365180284 > _cM_) {
                var x$6 = x$0[2], _cL_ = caml_call1(Stdlib[33], x$6);
                return caml_call2(Stdlib_Format[13], out, _cL_);
              }
              var x$5 = x$0[2];
              if (std) {
                var ob$0 = caml_call1(Stdlib_Buffer[1], 20);
                write_std_float(ob$0, x$5);
                var s$0 = caml_call1(Stdlib_Buffer[2], ob$0);
              } else {
                var ob = caml_call1(Stdlib_Buffer[1], 20);
                write_float(ob, x$5);
                var s$0 = caml_call1(Stdlib_Buffer[2], ob);
              }
              return caml_call2(Stdlib_Format[13], out, s$0);
            }
            if (-752863768 <= _cM_) {
              var s$1 = x$0[2];
              return caml_call2(Stdlib_Format[13], out, s$1);
            }
            var s$2 = x$0[2], _c0_ = json_string_of_string(s$2);
            return caml_call2(Stdlib_Format[13], out, _c0_);
          }
          if (726928360 === _cM_) {
            var l = x$0[2];
            if (!std) {
              if (0 === l)
                return caml_call2(Stdlib_Format[13], out, cst$10);
              if (1 - inside_box)
                caml_call2(Stdlib_Format[137], out, _x_);
              var _cN_ = 0, _cO_ = function(_c3_, _c4_) {
                return format(_cN_, std, _c3_, _c4_);
              };
              caml_call4(
                Stdlib_Format[137],
                out,
                _y_,
                function(_c1_, _c2_) {
                  return pp_list(cst$11, _cO_, _c1_, _c2_);
                },
                l
              );
              var _cP_ = 1 - inside_box;
              return _cP_ ? caml_call2(Stdlib_Format[137], out, _z_) : _cP_;
            }
            var x$1 = [0, 848054398, l], x$0 = x$1;
          } else {
            if (848054398 <= _cM_) {
              if (963043957 <= _cM_) {
                var l$0 = x$0[2];
                if (!l$0)
                  return caml_call2(Stdlib_Format[13], out, cst$13);
                if (1 - inside_box)
                  caml_call2(Stdlib_Format[137], out, _A_);
                var _cQ_ = function(out2, param) {
                  var x3 = param[2], name = param[1], _df_ = 1, _dg_ = json_string_of_string(name);
                  return caml_call5(
                    Stdlib_Format[137],
                    out2,
                    _J_,
                    _dg_,
                    function(_dh_, _di_) {
                      return format(_df_, std, _dh_, _di_);
                    },
                    x3
                  );
                };
                caml_call4(
                  Stdlib_Format[137],
                  out,
                  _B_,
                  function(_dd_, _de_) {
                    return pp_list(cst$12, _cQ_, _dd_, _de_);
                  },
                  l$0
                );
                var _cR_ = 1 - inside_box;
                return _cR_ ? caml_call2(Stdlib_Format[137], out, _C_) : _cR_;
              }
              var l$1 = x$0[2];
              if (!l$1)
                return caml_call2(Stdlib_Format[13], out, cst$16);
              if (1 - inside_box)
                caml_call2(Stdlib_Format[137], out, _D_);
              if (caml_call2(Stdlib_List[33], is_atom, l$1)) {
                var _cS_ = 0, _cT_ = function(_c9_, _c__) {
                  return format(_cS_, std, _c9_, _c__);
                };
                caml_call4(
                  Stdlib_Format[137],
                  out,
                  _E_,
                  function(_c7_, _c8_) {
                    return pp_list(cst$14, _cT_, _c7_, _c8_);
                  },
                  l$1
                );
              } else {
                var _cV_ = 0, _cW_ = function(_db_, _dc_) {
                  return format(_cV_, std, _db_, _dc_);
                };
                caml_call4(
                  Stdlib_Format[137],
                  out,
                  _G_,
                  function(_c$_, _da_) {
                    return pp_list(cst$15, _cW_, _c$_, _da_);
                  },
                  l$1
                );
              }
              var _cU_ = 1 - inside_box;
              return _cU_ ? caml_call2(Stdlib_Format[137], out, _F_) : _cU_;
            }
            if (737456202 <= _cM_) {
              var x$2 = x$0[2];
              return caml_call2(Stdlib_Format[25], out, x$2);
            }
            var _cX_ = x$0[2], match = _cX_[2], s2 = _cX_[1];
            if (match) {
              var x$3 = match[1];
              if (!std) {
                var op = json_string_of_string(s2), _cY_ = 1;
                return caml_call5(
                  Stdlib_Format[137],
                  out,
                  _H_,
                  op,
                  function(_c5_, _c6_) {
                    return format(_cY_, std, _c5_, _c6_);
                  },
                  x$3
                );
              }
              var representation = [0, -976970511, s2], x$4 = [0, 848054398, [0, representation, [0, x$3, 0]]], x$0 = x$4;
            } else {
              if (!std) {
                var _cZ_ = json_string_of_string(s2);
                return caml_call3(Stdlib_Format[137], out, _I_, _cZ_);
              }
              var representation$0 = [0, -976970511, s2], x$0 = representation$0;
            }
          }
        }
      }
      function pp(opt, out, x2) {
        if (opt)
          var sth = opt[1], std = sth;
        else
          var std = 0;
        var _cI_ = 1;
        return caml_call4(
          Stdlib_Format[137],
          out,
          _K_,
          function(_cJ_, _cK_) {
            return format(_cI_, std, _cJ_, _cK_);
          },
          x2
        );
      }
      function pp$0(fmt, param) {
        if (typeof param === "number")
          return caml_call2(Stdlib_Format[13], fmt, cst_Null);
        var _cH_ = param[1];
        if (708012133 <= _cH_) {
          if (726928360 === _cH_) {
            var tup = param[2];
            caml_call2(Stdlib_Format[137], fmt, _N_);
            caml_call2(Stdlib_Format[137], fmt, _O_);
            caml_call3(
              Stdlib_List[26],
              function(sep, e) {
                if (sep)
                  caml_call2(Stdlib_Format[137], fmt, _P_);
                pp$0(fmt, e);
                return 1;
              },
              0,
              tup
            );
            caml_call2(Stdlib_Format[137], fmt, _Q_);
            return caml_call2(Stdlib_Format[137], fmt, _R_);
          }
          if (848054398 <= _cH_) {
            if (963043957 <= _cH_) {
              var xs = param[2];
              caml_call2(Stdlib_Format[137], fmt, _S_);
              caml_call2(Stdlib_Format[137], fmt, _T_2);
              caml_call3(
                Stdlib_List[26],
                function(sep, param2) {
                  var value2 = param2[2], key = param2[1];
                  if (sep)
                    caml_call2(Stdlib_Format[137], fmt, _U_);
                  caml_call2(Stdlib_Format[137], fmt, _V_);
                  caml_call3(Stdlib_Format[137], fmt, _W_, key);
                  caml_call2(Stdlib_Format[137], fmt, _X_);
                  pp$0(fmt, value2);
                  caml_call2(Stdlib_Format[137], fmt, _Y_);
                  return 1;
                },
                0,
                xs
              );
              caml_call2(Stdlib_Format[137], fmt, _Z_);
              return caml_call2(Stdlib_Format[137], fmt, ___);
            }
            var xs$0 = param[2];
            caml_call2(Stdlib_Format[137], fmt, _$_);
            caml_call2(Stdlib_Format[137], fmt, _aa_);
            caml_call3(
              Stdlib_List[26],
              function(sep, x3) {
                if (sep)
                  caml_call2(Stdlib_Format[137], fmt, _ab_);
                pp$0(fmt, x3);
                return 1;
              },
              0,
              xs$0
            );
            caml_call2(Stdlib_Format[137], fmt, _ac_);
            return caml_call2(Stdlib_Format[137], fmt, _ad_);
          }
          if (737456202 <= _cH_) {
            var x2 = param[2];
            caml_call2(Stdlib_Format[137], fmt, _ae_);
            caml_call3(Stdlib_Format[137], fmt, _af_, x2);
            return caml_call2(Stdlib_Format[137], fmt, _ag_);
          }
          var match = param[2], value = match[2], name = match[1];
          caml_call2(Stdlib_Format[137], fmt, _ah_);
          caml_call2(Stdlib_Format[137], fmt, _ai_);
          caml_call3(Stdlib_Format[137], fmt, _aj_, name);
          caml_call2(Stdlib_Format[137], fmt, _ak_);
          if (value) {
            var x$0 = value[1];
            caml_call2(Stdlib_Format[13], fmt, cst_Some);
            pp$0(fmt, x$0);
            caml_call2(Stdlib_Format[13], fmt, cst$17);
          } else
            caml_call2(Stdlib_Format[13], fmt, cst_None);
          caml_call2(Stdlib_Format[137], fmt, _al_);
          return caml_call2(Stdlib_Format[137], fmt, _am_);
        }
        if (3654863 <= _cH_) {
          if (365180284 <= _cH_) {
            var x$1 = param[2];
            caml_call2(Stdlib_Format[137], fmt, _an_);
            caml_call3(Stdlib_Format[137], fmt, _ao_, x$1);
            return caml_call2(Stdlib_Format[137], fmt, _ap_);
          }
          var x$2 = param[2];
          caml_call2(Stdlib_Format[137], fmt, _aq_);
          caml_call3(Stdlib_Format[137], fmt, _ar_, x$2);
          return caml_call2(Stdlib_Format[137], fmt, _as_);
        }
        if (-752863768 <= _cH_) {
          var x$3 = param[2];
          caml_call2(Stdlib_Format[137], fmt, _at_);
          caml_call3(Stdlib_Format[137], fmt, _au_, x$3);
          return caml_call2(Stdlib_Format[137], fmt, _av_);
        }
        var x$4 = param[2];
        caml_call2(Stdlib_Format[137], fmt, _aw_);
        caml_call3(Stdlib_Format[137], fmt, _ax_, x$4);
        return caml_call2(Stdlib_Format[137], fmt, _ay_);
      }
      function show(x2) {
        return caml_call3(Stdlib_Format[141], _az_, pp$0, x2);
      }
      function equal(a, b) {
        var a$0 = a, b$0 = b;
        for (; ; ) {
          a:
            if (typeof a$0 === "number") {
              if (870828711 === a$0 && typeof b$0 === "number" && 870828711 === b$0)
                return 1;
            } else {
              var _cz_ = a$0[1];
              if (708012133 <= _cz_) {
                if (737456203 <= _cz_) {
                  if (848054398 !== _cz_) {
                    if (963043957 !== _cz_)
                      break a;
                    if (typeof b$0 === "number")
                      break a;
                    if (963043957 !== b$0[1])
                      break a;
                    var ys$0 = b$0[2], xs$0 = a$0[2], compare_keys = function(param, _cG_) {
                      var key = _cG_[1], key$0 = param[1];
                      return caml_call2(Stdlib_String[10], key$0, key);
                    }, xs$1 = caml_call2(Stdlib_List[60], compare_keys, xs$0), ys$1 = caml_call2(Stdlib_List[60], compare_keys, ys$0);
                    try {
                      var result$0 = caml_call3(
                        Stdlib_List[35],
                        function(param, _cF_) {
                          var value2 = _cF_[2], key = _cF_[1], value$02 = param[2], key$0 = param[1];
                          return runtime.caml_string_equal(key$0, key) ? equal(value$02, value2) : 0;
                        },
                        xs$1,
                        ys$1
                      );
                      return result$0;
                    } catch (_cE_) {
                      var _cB_ = caml_wrap_exception2(_cE_);
                      if (_cB_[1] === Stdlib[6])
                        return 0;
                      throw caml_maybe_attach_backtrace2(_cB_, 0);
                    }
                  }
                  if (typeof b$0 === "number")
                    break a;
                  if (848054398 !== b$0[1])
                    break a;
                  var ys = b$0[2], xs = a$0[2];
                } else {
                  if (726928360 !== _cz_) {
                    if (708012134 <= _cz_) {
                      if (737456202 > _cz_)
                        break a;
                      if (typeof b$0 === "number")
                        break a;
                      if (737456202 !== b$0[1])
                        break a;
                      var b$1 = b$0[2], a$1 = a$0[2];
                      return caml_equal2(a$1, b$1);
                    }
                    if (typeof b$0 === "number")
                      break a;
                    if (708012133 !== b$0[1])
                      break a;
                    var _cC_ = b$0[2], value = _cC_[2], name = _cC_[1], match = a$0[2], value$0 = match[2], name$0 = match[1];
                    if (!caml_equal2(name$0, name))
                      return 0;
                    if (value$0) {
                      if (value) {
                        var y = value[1], x2 = value$0[1], a$0 = x2, b$0 = y;
                        continue;
                      }
                    } else if (!value)
                      return 1;
                    return 0;
                  }
                  if (typeof b$0 === "number")
                    break a;
                  if (726928360 !== b$0[1])
                    break a;
                  var ys = b$0[2], xs = a$0[2];
                }
                try {
                  var result = caml_call3(Stdlib_List[35], equal, xs, ys);
                  return result;
                } catch (_cD_) {
                  var _cA_ = caml_wrap_exception2(_cD_);
                  if (_cA_[1] === Stdlib[6])
                    return 0;
                  throw caml_maybe_attach_backtrace2(_cA_, 0);
                }
              }
              if (-752863767 <= _cz_) {
                if (3654863 === _cz_) {
                  if (typeof b$0 !== "number" && 3654863 === b$0[1]) {
                    var b$2 = b$0[2], a$2 = a$0[2];
                    return caml_equal2(a$2, b$2);
                  }
                } else if (365180284 === _cz_ && typeof b$0 !== "number" && 365180284 === b$0[1]) {
                  var b$3 = b$0[2], a$3 = a$0[2];
                  return caml_equal2(a$3, b$3);
                }
              } else if (-976970511 === _cz_) {
                if (typeof b$0 !== "number" && -976970511 === b$0[1]) {
                  var b$4 = b$0[2], a$4 = a$0[2];
                  return caml_equal2(a$4, b$4);
                }
              } else if (-752863768 <= _cz_ && typeof b$0 !== "number" && -752863768 === b$0[1]) {
                var b$5 = b$0[2], a$5 = a$0[2];
                return caml_equal2(a$5, b$5);
              }
            }
          return 0;
        }
      }
      function pretty_print(std, out, x2) {
        return pp(std, out, x2);
      }
      function pretty_to_string(std, x2) {
        return caml_call3(
          Stdlib_Format[141],
          _L_,
          function(_cx_, _cy_) {
            return pp(std, _cx_, _cy_);
          },
          x2
        );
      }
      function pretty_to_channel(std, oc, x2) {
        var fmt = caml_call1(Stdlib_Format[108], oc);
        return caml_call4(
          Stdlib_Format[137],
          fmt,
          _M_,
          function(_cv_, _cw_) {
            return pp(std, _cv_, _cw_);
          },
          x2
        );
      }
      var from_channel = Stdlib_Lexing[2], from_string = Stdlib_Lexing[3], lexeme = Stdlib_Lexing[8], sub_lexeme = Stdlib_Lexing[16], sub_lexeme_char = Stdlib_Lexing[18], _aA_ = [0, "lib/read.mll", 44, 13], _aB_ = [0, [11, "File ", [2, 0, [11, ", line", 0]]], "File %s, line"], _aC_ = [0, [11, "byte ", [4, 3, 0, 0, 0]], "byte %i"], _aD_ = [
        0,
        [
          2,
          0,
          [12, 32, [4, 3, 0, 0, [11, ", ", [2, 0, [11, ":\n", [2, 0, 0]]]]]]
        ],
        "%s %i, %s:\n%s"
      ], _aE_ = [
        0,
        [11, "bytes ", [4, 3, 0, 0, [12, 45, [4, 3, 0, 0, 0]]]],
        "bytes %i-%i"
      ], cst_Line = "Line", _aF_ = [0, [2, 0, [11, cst$30, [2, 0, [12, 39, 0]]]], "%s '%s'"], _aG_ = [0, [2, 0, [11, cst$30, [2, 0, [2, 0, [12, 39, 0]]]]], "%s '%s%s'"];
      function hex$0(c) {
        if (65 <= c) {
          if (97 <= c) {
            if (103 > c)
              return (c - 97 | 0) + 10 | 0;
          } else if (71 > c)
            return (c - 65 | 0) + 10 | 0;
        } else if (9 >= c - 48 >>> 0)
          return c - 48 | 0;
        throw caml_maybe_attach_backtrace2([0, Assert_failure, _aA_], 1);
      }
      function custom_error(descr, v, lexbuf) {
        var offs = lexbuf[4] - 1 | 0, bol = v[3], pos1 = ((offs + lexbuf[5] | 0) - bol | 0) - 1 | 0, pos2 = caml_call2(Stdlib[17], pos1, (offs + lexbuf[6] | 0) - bol | 0), match = v[4];
        if (match)
          var s2 = match[1], file_line = caml_call2(Stdlib_Printf[4], _aB_, s2);
        else
          var file_line = cst_Line;
        var bytes = pos1 === pos2 ? caml_call2(Stdlib_Printf[4], _aC_, pos1 + 1 | 0) : caml_call3(Stdlib_Printf[4], _aE_, pos1 + 1 | 0, pos2 + 1 | 0), msg = caml_call5(Stdlib_Printf[4], _aD_, file_line, v[2], bytes, descr);
        return caml_call1(Yojson_Common[3], msg);
      }
      function lexer_error(descr, v, lexbuf) {
        var _cu_ = caml_call1(lexeme, lexbuf);
        return custom_error(caml_call3(Stdlib_Printf[4], _aF_, descr, _cu_), v, lexbuf);
      }
      function long_error(descr, v, lexbuf) {
        var junk = caml_call1(lexeme, lexbuf), buf_size = 32, buf = caml_call1(Stdlib_Buffer[1], buf_size);
        caml_call3(Yojson_Lexer_utils[4], buf, buf_size, lexbuf);
        var extra_junk = caml_call1(Stdlib_Buffer[2], buf);
        return custom_error(
          caml_call4(Stdlib_Printf[4], _aG_, descr, junk, extra_junk),
          v,
          lexbuf
        );
      }
      var _aJ_ = [0, 737456202, 1], _aK_ = [0, 737456202, 0], cst_Unexpected_end_of_input = cst_Unexpected_end_of_input$47, cst_Invalid_token = cst_Invalid_token$2, cst_Unexpected_end_of_input$0 = cst_Unexpected_end_of_input$47, cst_Unexpected_end_of_input$1 = cst_Unexpected_end_of_input$47, cst_Invalid_escape_sequence = "Invalid escape sequence", cst_Unexpected_end_of_input$2 = cst_Unexpected_end_of_input$47, cst_Invalid_low_surrogate_for_ = "Invalid low surrogate for code point beyond U+FFFF", cst_Missing_escape_sequence_re = "Missing escape sequence representing low surrogate for code point beyond U+FFFF", cst_Unexpected_end_of_input$3 = cst_Unexpected_end_of_input$47, cst_Invalid_string_literal = cst_Invalid_string_literal$2, cst_Unexpected_end_of_input$4 = cst_Unexpected_end_of_input$47, cst_Expected_or_but_found = cst_Expected_or_but_found$15, cst_Unexpected_end_of_input$5 = cst_Unexpected_end_of_input$47, cst_Expected_but_found = "Expected '<' but found", cst_Unexpected_end_of_input$6 = cst_Unexpected_end_of_input$47, cst_Expected_but_found$0 = cst_Expected_but_found$15, cst_Unexpected_end_of_input$7 = cst_Unexpected_end_of_input$47, cst_Expected_but_found$1 = "Expected ',' but found", cst_Unexpected_end_of_input$8 = cst_Unexpected_end_of_input$47, cst_Expected_or_but_found$0 = `Expected '<', '"' or '[' but found`, cst_Unexpected_end_of_input$9 = cst_Unexpected_end_of_input$47, cst_Unterminated_comment = cst_Unterminated_comment$1, cst_Expected_null_but_found = "Expected 'null' but found", cst_Unexpected_end_of_input$10 = cst_Unexpected_end_of_input$47, cst_Expected_true_or_false_but = "Expected 'true' or 'false' but found", cst_Unexpected_end_of_input$11 = cst_Unexpected_end_of_input$47, cst_Int_overflow = cst_Int_overflow$1, cst_Int_overflow$0 = cst_Int_overflow$1, cst_Expected_an_integer_but_fo = "Expected an integer but found a string that doesn't even represent an integer", cst_Expected_integer_but_found = "Expected integer but found", cst_Unexpected_end_of_input$12 = cst_Unexpected_end_of_input$47, cst_Int32_overflow = cst_Int32_overflow$1, cst_Expected_an_int32_but_foun = "Expected an int32 but found a string that doesn't even represent an integer", cst_Expected_int32_but_found = "Expected int32 but found", cst_Unexpected_end_of_input$13 = cst_Unexpected_end_of_input$47, cst_Int32_overflow$0 = cst_Int32_overflow$1, cst_Expected_an_int64_but_foun = "Expected an int64 but found a string that doesn't even represent an integer", cst_Expected_int64_but_found = "Expected int64 but found", cst_Unexpected_end_of_input$14 = cst_Unexpected_end_of_input$47, cst_Expected_a_number_but_foun = "Expected a number but found a string that doesn't even represent a number", cst_Expected_number_but_found = "Expected number but found", cst_Unexpected_end_of_input$15 = cst_Unexpected_end_of_input$47, cst_Expected_but_found$2 = `Expected '"' but found`, cst_Unexpected_end_of_input$16 = cst_Unexpected_end_of_input$47, cst_Expected_string_or_identif = cst_Expected_string_or_identif$3, cst_Unexpected_end_of_input$17 = cst_Unexpected_end_of_input$47, cst_Expected_string_or_identif$0 = cst_Expected_string_or_identif$3, cst_Unexpected_end_of_input$18 = cst_Unexpected_end_of_input$47, cst_Expected_but_found$3 = cst_Expected_but_found$16, cst_Unexpected_end_of_input$19 = cst_Unexpected_end_of_input$47, cst_Expected_but_found$4 = cst_Expected_but_found$16, cst_Unexpected_end_of_input$20 = cst_Unexpected_end_of_input$47, cst_Expected_or_but_found$1 = cst_Expected_or_but_found$16, cst_Unexpected_end_of_input$21 = cst_Unexpected_end_of_input$47, cst_Expected_but_found$5 = cst_Expected_but_found$17, cst_Unexpected_end_of_input$22 = cst_Unexpected_end_of_input$47, cst_Expected_or_but_found$2 = "Expected ')' or '' but found", cst_Expected_or_but_found$3 = "Expected ']' or '' but found", cst_Expected_or_but_found$4 = cst_Expected_or_but_found$17, cst_Unexpected_end_of_input$23 = cst_Unexpected_end_of_input$47, cst_Expected_or_but_found$5 = cst_Expected_or_but_found$16, cst_Expected_or_but_found$6 = cst_Expected_or_but_found$17, cst_Expected_or_but_found$7 = cst_Expected_or_but_found$17, cst_Unexpected_end_of_input$24 = cst_Unexpected_end_of_input$47, cst_Expected_but_found$6 = cst_Expected_but_found$18, cst_Unexpected_end_of_input$25 = cst_Unexpected_end_of_input$47, cst_Expected_but_found$7 = cst_Expected_but_found$18, cst_Unexpected_end_of_input$26 = cst_Unexpected_end_of_input$47, cst_Expected_or_but_found$8 = cst_Expected_or_but_found$18, cst_Unexpected_end_of_input$27 = cst_Unexpected_end_of_input$47, cst_Expected_but_found$8 = cst_Expected_but_found$19, cst_Unexpected_end_of_input$28 = cst_Unexpected_end_of_input$47, cst_Expected_or_but_found$9 = "Expected '(' or '[' but found", cst_Unexpected_end_of_input$29 = cst_Unexpected_end_of_input$47, cst_Expected_but_found$9 = "Expected '(' but found", cst_Unexpected_end_of_input$30 = cst_Unexpected_end_of_input$47, cst_Expected_but_found$10 = cst_Expected_but_found$17, cst_Unexpected_end_of_input$31 = cst_Unexpected_end_of_input$47, cst_Expected_but_found$11 = cst_Expected_but_found$16, cst_Unexpected_end_of_input$32 = cst_Unexpected_end_of_input$47, cst_Expected_but_found$12 = "Expected ']' but found", cst_Unexpected_end_of_input$33 = cst_Unexpected_end_of_input$47, cst_Unexpected_end_of_input$34 = cst_Unexpected_end_of_input$47, cst_Invalid_token$0 = cst_Invalid_token$2, cst_Invalid_string_literal$0 = cst_Invalid_string_literal$2, cst_Unexpected_end_of_input$35 = cst_Unexpected_end_of_input$47, cst_Expected_or_but_found$10 = cst_Expected_or_but_found$15, cst_Unexpected_end_of_input$36 = cst_Unexpected_end_of_input$47, cst_Expected_string_or_identif$1 = cst_Expected_string_or_identif$3, cst_Unexpected_end_of_input$37 = cst_Unexpected_end_of_input$47, cst_Unexpected_end_of_input$38 = cst_Unexpected_end_of_input$47, cst_Invalid_token$1 = cst_Invalid_token$2, cst_Invalid_string_literal$1 = cst_Invalid_string_literal$2, cst_Unexpected_end_of_input$39 = cst_Unexpected_end_of_input$47, cst_Expected_or_but_found$11 = cst_Expected_or_but_found$15, cst_Unexpected_end_of_input$40 = cst_Unexpected_end_of_input$47, cst_Expected_string_or_identif$2 = cst_Expected_string_or_identif$3, cst_Unexpected_end_of_input$41 = cst_Unexpected_end_of_input$47, cst_Expected_or_but_found$12 = cst_Expected_or_but_found$18, cst_Unexpected_end_of_input$42 = cst_Unexpected_end_of_input$47, cst_Expected_or_but_found$13 = cst_Expected_or_but_found$16, cst_Unexpected_end_of_input$43 = cst_Unexpected_end_of_input$47, cst_Expected_or_but_found$14 = cst_Expected_or_but_found$17, cst_Unexpected_end_of_input$44 = cst_Unexpected_end_of_input$47, cst_Expected_but_found$13 = cst_Expected_but_found$19, cst_Unexpected_end_of_input$45 = cst_Unexpected_end_of_input$47, cst_Expected_but_found$14 = cst_Expected_but_found$15, cst_Unexpected_end_of_input$46 = cst_Unexpected_end_of_input$47, cst_Unterminated_comment$0 = cst_Unterminated_comment$1, cst_Expected_two_objects_check = "Expected two objects, check inputs", cst_Can_t_convert_each_element = "Can't convert each element of non-array type ", cst_Expected_string_or_null_go = "Expected string or null, got ", cst_Expected_string_got = "Expected string, got ", cst_Expected_array_got = "Expected array, got ", cst_Expected_int_or_null_got = "Expected int or null, got ", cst_Expected_int_got = "Expected int, got ", cst_Expected_float_or_null_got = "Expected float or null, got ", cst_Expected_float_got = "Expected float, got ", cst_Expected_number_or_null_go = "Expected number or null, got ", cst_Expected_number_got = "Expected number, got ", cst_Expected_bool_or_null_got = "Expected bool or null, got ", cst_Expected_bool_got = "Expected bool, got ", cst_Expected_object_got = "Expected object, got ", cst_Can_t_map_function_over_no = "Can't map function over non-array type ", cst_out_of_bounds = " out of bounds", cst_Index = "Index ", cst_of_non_array_type = " of non-array type ", cst_Can_t_get_index = "Can't get index ", cst_of_non_object_type = "' of non-object type ", cst_Can_t_get_member = "Can't get member '", cst_null$1 = cst_null$2, cst_object = "object", cst_floatlit = "floatlit", cst_array = "array", cst_tuple = "tuple", cst_bool = "bool", cst_variant = "variant", cst_float = "float", cst_int = "int", cst_string = "string", cst_intlit = "intlit", cst_Blank_input_data$0 = cst_Blank_input_data$1, cst_Blank_input_data = cst_Blank_input_data$1, cst_Junk_after_end_of_JSON_val = "Junk after end of JSON value:", cst_Int8_overflow = "Int8 overflow", cst_Yojson_Safe_Int_overflow = "Yojson__Safe.Int_overflow", cst_Yojson_Safe_Finally = "Yojson__Safe.Finally", cst_Yojson_Safe_Util_Type_erro = "Yojson__Safe.Util.Type_error", cst_Yojson_Safe_Util_Undefined = "Yojson__Safe.Util.Undefined", _aH_ = 0 === (Stdlib[20] % 10 | 0) ? 0 : 1, min10 = (Stdlib[20] / 10 | 0) - _aH_ | 0, _aI_ = 0 === (Stdlib[19] % 10 | 0) ? 0 : 1, max10 = (Stdlib[19] / 10 | 0) + _aI_ | 0, Int_overflow = [248, cst_Yojson_Safe_Int_overflow, caml_fresh_oo_id2(0)];
      function extract_positive_int(lexbuf) {
        var start = lexbuf[5], stop = lexbuf[6], s2 = lexbuf[2], n = [0, 0], _cr_ = stop - 1 | 0;
        if (_cr_ >= start) {
          var i = start;
          for (; ; ) {
            if (max10 <= n[1])
              throw caml_maybe_attach_backtrace2(Int_overflow, 1);
            var _cs_ = caml_bytes_get2(s2, i) - 48 | 0;
            n[1] = (10 * n[1] | 0) + _cs_ | 0;
            var _ct_ = i + 1 | 0;
            if (_cr_ === i)
              break;
            var i = _ct_;
          }
        }
        if (0 <= n[1])
          return n[1];
        throw caml_maybe_attach_backtrace2(Int_overflow, 1);
      }
      function extract_negative_int(lexbuf) {
        var start = lexbuf[5] + 1 | 0, stop = lexbuf[6], s2 = lexbuf[2], n = [0, 0], _co_ = stop - 1 | 0;
        if (_co_ >= start) {
          var i = start;
          for (; ; ) {
            if (n[1] <= min10)
              throw caml_maybe_attach_backtrace2(Int_overflow, 1);
            var _cp_ = caml_bytes_get2(s2, i) - 48 | 0;
            n[1] = (10 * n[1] | 0) - _cp_ | 0;
            var _cq_ = i + 1 | 0;
            if (_co_ === i)
              break;
            var i = _cq_;
          }
        }
        if (0 < n[1])
          throw caml_maybe_attach_backtrace2(Int_overflow, 1);
        return n[1];
      }
      function newline(v, lexbuf) {
        v[2] = v[2] + 1 | 0;
        v[3] = lexbuf[4] + lexbuf[6] | 0;
        return;
      }
      function add_lexeme(buf, lexbuf) {
        var len = lexbuf[6] - lexbuf[5] | 0;
        return caml_call4(Stdlib_Buffer[19], buf, lexbuf[2], lexbuf[5], len);
      }
      function read_json(v, lexbuf) {
        for (; ; ) {
          var ocaml_lex_state = 0;
          for (; ; ) {
            var ocaml_lex_state$0 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state, lexbuf);
            if (19 >= ocaml_lex_state$0 >>> 0)
              break;
            caml_call1(lexbuf[1], lexbuf);
            var ocaml_lex_state = ocaml_lex_state$0;
          }
          switch (ocaml_lex_state$0) {
            case 0:
              return _aJ_;
            case 1:
              return _aK_;
            case 2:
              return 870828711;
            case 3:
              return [0, 365180284, Stdlib[24]];
            case 4:
              return [0, 365180284, Stdlib[22]];
            case 5:
              return [0, 365180284, Stdlib[23]];
            case 6:
              caml_call1(Stdlib_Buffer[8], v[1]);
              return [0, -976970511, finish_string(v, lexbuf)];
            case 7:
              try {
                var _b9_ = [0, 3654863, extract_positive_int(lexbuf)];
                return _b9_;
              } catch (_cn_) {
                var _b8_ = caml_wrap_exception2(_cn_);
                if (_b8_ === Int_overflow)
                  return [0, -752863768, caml_call1(lexeme, lexbuf)];
                throw caml_maybe_attach_backtrace2(_b8_, 0);
              }
            case 8:
              try {
                var _b$_ = [0, 3654863, extract_negative_int(lexbuf)];
                return _b$_;
              } catch (_cm_) {
                var _b__ = caml_wrap_exception2(_cm_);
                if (_b__ === Int_overflow)
                  return [0, -752863768, caml_call1(lexeme, lexbuf)];
                throw caml_maybe_attach_backtrace2(_b__, 0);
              }
            case 9:
              return [
                0,
                365180284,
                caml_float_of_string2(caml_call1(lexeme, lexbuf))
              ];
            case 10:
              var acc = [0, 0];
              try {
                read_space(v, lexbuf);
                read_object_end(lexbuf);
                var field_name = read_ident(v, lexbuf);
                read_space(v, lexbuf);
                read_colon(v, lexbuf);
                read_space(v, lexbuf);
                var _cb_ = acc[1];
                acc[1] = [0, [0, field_name, read_json(v, lexbuf)], _cb_];
                for (; ; ) {
                  read_space(v, lexbuf);
                  read_object_sep(v, lexbuf);
                  read_space(v, lexbuf);
                  var field_name$0 = read_ident(v, lexbuf);
                  read_space(v, lexbuf);
                  read_colon(v, lexbuf);
                  read_space(v, lexbuf);
                  var _cc_ = acc[1];
                  acc[1] = [0, [0, field_name$0, read_json(v, lexbuf)], _cc_];
                }
              } catch (_cl_) {
                var _ca_ = caml_wrap_exception2(_cl_);
                if (_ca_ === Yojson_Common[7])
                  return [0, 963043957, caml_call1(Stdlib_List[10], acc[1])];
                throw caml_maybe_attach_backtrace2(_ca_, 0);
              }
              break;
            case 11:
              var acc$0 = [0, 0];
              try {
                read_space(v, lexbuf);
                read_array_end(lexbuf);
                var _ce_ = acc$0[1];
                acc$0[1] = [0, read_json(v, lexbuf), _ce_];
                for (; ; ) {
                  read_space(v, lexbuf);
                  read_array_sep(v, lexbuf);
                  read_space(v, lexbuf);
                  var _cf_ = acc$0[1];
                  acc$0[1] = [0, read_json(v, lexbuf), _cf_];
                }
              } catch (_ck_) {
                var _cd_ = caml_wrap_exception2(_ck_);
                if (_cd_ === Yojson_Common[6])
                  return [0, 848054398, caml_call1(Stdlib_List[10], acc$0[1])];
                throw caml_maybe_attach_backtrace2(_cd_, 0);
              }
              break;
            case 12:
              var acc$1 = [0, 0];
              try {
                read_space(v, lexbuf);
                read_tuple_end(lexbuf);
                var _ch_ = acc$1[1];
                acc$1[1] = [0, read_json(v, lexbuf), _ch_];
                for (; ; ) {
                  read_space(v, lexbuf);
                  read_tuple_sep(v, lexbuf);
                  read_space(v, lexbuf);
                  var _ci_ = acc$1[1];
                  acc$1[1] = [0, read_json(v, lexbuf), _ci_];
                }
              } catch (_cj_) {
                var _cg_ = caml_wrap_exception2(_cj_);
                if (_cg_ === Yojson_Common[8])
                  return [0, 726928360, caml_call1(Stdlib_List[10], acc$1[1])];
                throw caml_maybe_attach_backtrace2(_cg_, 0);
              }
              break;
            case 13:
              read_space(v, lexbuf);
              var cons = read_ident(v, lexbuf);
              read_space(v, lexbuf);
              return [0, 708012133, [0, cons, finish_variant(v, lexbuf)]];
            case 14:
              break;
            case 15:
              finish_comment(v, lexbuf);
              break;
            case 16:
              newline(v, lexbuf);
              break;
            case 17:
              break;
            case 18:
              return custom_error(cst_Unexpected_end_of_input, v, lexbuf);
            default:
              return long_error(cst_Invalid_token, v, lexbuf);
          }
        }
      }
      function finish_string(v, lexbuf) {
        for (; ; ) {
          var ocaml_lex_state = 58;
          for (; ; ) {
            var ocaml_lex_state$0 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state, lexbuf);
            if (3 >= ocaml_lex_state$0 >>> 0)
              break;
            caml_call1(lexbuf[1], lexbuf);
            var ocaml_lex_state = ocaml_lex_state$0;
          }
          switch (ocaml_lex_state$0) {
            case 0:
              return caml_call1(Stdlib_Buffer[2], v[1]);
            case 1:
              finish_escaped_char(v, lexbuf);
              break;
            case 2:
              add_lexeme(v[1], lexbuf);
              break;
            default:
              return custom_error(cst_Unexpected_end_of_input$0, v, lexbuf);
          }
        }
      }
      function map_string(v, f, lexbuf) {
        for (; ; ) {
          var ocaml_lex_state = 63;
          for (; ; ) {
            var ocaml_lex_state$0 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state, lexbuf);
            if (3 >= ocaml_lex_state$0 >>> 0)
              break;
            caml_call1(lexbuf[1], lexbuf);
            var ocaml_lex_state = ocaml_lex_state$0;
          }
          switch (ocaml_lex_state$0) {
            case 0:
              var b = v[1], _b7_ = caml_call1(Stdlib_Buffer[7], b);
              return caml_call3(f, caml_call1(Stdlib_Buffer[2], b), 0, _b7_);
            case 1:
              finish_escaped_char(v, lexbuf);
              break;
            case 2:
              add_lexeme(v[1], lexbuf);
              break;
            default:
              return custom_error(cst_Unexpected_end_of_input$1, v, lexbuf);
          }
        }
      }
      function finish_escaped_char(v, lexbuf) {
        var ocaml_lex_state = 68;
        for (; ; ) {
          var ocaml_lex_state$0 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state, lexbuf);
          if (8 >= ocaml_lex_state$0 >>> 0)
            break;
          caml_call1(lexbuf[1], lexbuf);
          var ocaml_lex_state = ocaml_lex_state$0;
        }
        switch (ocaml_lex_state$0) {
          case 0:
            var c = caml_call2(sub_lexeme_char, lexbuf, lexbuf[5]);
            return caml_call2(Stdlib_Buffer[12], v[1], c);
          case 1:
            return caml_call2(Stdlib_Buffer[12], v[1], 8);
          case 2:
            return caml_call2(Stdlib_Buffer[12], v[1], 12);
          case 3:
            return caml_call2(Stdlib_Buffer[12], v[1], 10);
          case 4:
            return caml_call2(Stdlib_Buffer[12], v[1], 13);
          case 5:
            return caml_call2(Stdlib_Buffer[12], v[1], 9);
          case 6:
            var a = caml_call2(sub_lexeme_char, lexbuf, lexbuf[5] + 1 | 0), b = caml_call2(sub_lexeme_char, lexbuf, lexbuf[5] + 2 | 0), c$0 = caml_call2(sub_lexeme_char, lexbuf, lexbuf[5] + 3 | 0), d = caml_call2(sub_lexeme_char, lexbuf, lexbuf[5] + 4 | 0), _b1_ = hex$0(d), _b2_ = hex$0(c$0) << 4, _b3_ = hex$0(b) << 8, x2 = hex$0(a) << 12 | _b3_ | _b2_ | _b1_;
            if (55296 <= x2 && 56319 >= x2) {
              var ocaml_lex_state$1 = 82;
              for (; ; ) {
                var ocaml_lex_state$2 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state$1, lexbuf);
                if (2 >= ocaml_lex_state$2 >>> 0)
                  break;
                caml_call1(lexbuf[1], lexbuf);
                var ocaml_lex_state$1 = ocaml_lex_state$2;
              }
              switch (ocaml_lex_state$2) {
                case 0:
                  var a$0 = caml_call2(sub_lexeme_char, lexbuf, lexbuf[5] + 2 | 0), b$0 = caml_call2(sub_lexeme_char, lexbuf, lexbuf[5] + 3 | 0), c$1 = caml_call2(sub_lexeme_char, lexbuf, lexbuf[5] + 4 | 0), d$0 = caml_call2(sub_lexeme_char, lexbuf, lexbuf[5] + 5 | 0), _b4_ = hex$0(d$0), _b5_ = hex$0(c$1) << 4, _b6_ = hex$0(b$0) << 8, y = hex$0(a$0) << 12 | _b6_ | _b5_ | _b4_;
                  if (56320 <= y && 57343 >= y)
                    return caml_call3(Yojson_Codec[2], v[1], x2, y);
                  return long_error(cst_Invalid_low_surrogate_for_, v, lexbuf);
                case 1:
                  return long_error(cst_Missing_escape_sequence_re, v, lexbuf);
                default:
                  return custom_error(cst_Unexpected_end_of_input$3, v, lexbuf);
              }
            }
            return caml_call2(Yojson_Codec[1], v[1], x2);
          case 7:
            return long_error(cst_Invalid_escape_sequence, v, lexbuf);
          default:
            return custom_error(cst_Unexpected_end_of_input$2, v, lexbuf);
        }
      }
      function finish_stringlit(v, lexbuf) {
        var ocaml_lex_state = 91;
        for (; ; ) {
          var ocaml_lex_state$0 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state, lexbuf);
          if (2 >= ocaml_lex_state$0 >>> 0)
            switch (ocaml_lex_state$0) {
              case 0:
                var len = lexbuf[6] - lexbuf[5] | 0, s2 = runtime.caml_create_bytes(len + 1 | 0);
                runtime.caml_bytes_set(s2, 0, 34);
                caml_call5(Stdlib_Bytes[11], lexbuf[2], lexbuf[5], s2, 1, len);
                return caml_call1(Stdlib_Bytes[6], s2);
              case 1:
                return long_error(cst_Invalid_string_literal, v, lexbuf);
              default:
                return custom_error(cst_Unexpected_end_of_input$4, v, lexbuf);
            }
          caml_call1(lexbuf[1], lexbuf);
          var ocaml_lex_state = ocaml_lex_state$0;
        }
      }
      function finish_variant(v, lexbuf) {
        var ocaml_lex_state = 102;
        for (; ; ) {
          var ocaml_lex_state$0 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state, lexbuf);
          if (3 >= ocaml_lex_state$0 >>> 0)
            switch (ocaml_lex_state$0) {
              case 0:
                var x2 = read_json(v, lexbuf);
                read_space(v, lexbuf);
                read_gt(v, lexbuf);
                return [0, x2];
              case 1:
                return 0;
              case 2:
                return long_error(cst_Expected_or_but_found, v, lexbuf);
              default:
                return custom_error(cst_Unexpected_end_of_input$5, v, lexbuf);
            }
          caml_call1(lexbuf[1], lexbuf);
          var ocaml_lex_state = ocaml_lex_state$0;
        }
      }
      function read_lt(v, lexbuf) {
        var ocaml_lex_state = 107;
        for (; ; ) {
          var ocaml_lex_state$0 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state, lexbuf);
          if (2 >= ocaml_lex_state$0 >>> 0)
            switch (ocaml_lex_state$0) {
              case 0:
                return 0;
              case 1:
                return long_error(cst_Expected_but_found, v, lexbuf);
              default:
                return custom_error(cst_Unexpected_end_of_input$6, v, lexbuf);
            }
          caml_call1(lexbuf[1], lexbuf);
          var ocaml_lex_state = ocaml_lex_state$0;
        }
      }
      function read_gt(v, lexbuf) {
        var ocaml_lex_state = 111;
        for (; ; ) {
          var ocaml_lex_state$0 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state, lexbuf);
          if (2 >= ocaml_lex_state$0 >>> 0)
            switch (ocaml_lex_state$0) {
              case 0:
                return 0;
              case 1:
                return long_error(cst_Expected_but_found$0, v, lexbuf);
              default:
                return custom_error(cst_Unexpected_end_of_input$7, v, lexbuf);
            }
          caml_call1(lexbuf[1], lexbuf);
          var ocaml_lex_state = ocaml_lex_state$0;
        }
      }
      function read_comma(v, lexbuf) {
        var ocaml_lex_state = 115;
        for (; ; ) {
          var ocaml_lex_state$0 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state, lexbuf);
          if (2 >= ocaml_lex_state$0 >>> 0)
            switch (ocaml_lex_state$0) {
              case 0:
                return 0;
              case 1:
                return long_error(cst_Expected_but_found$1, v, lexbuf);
              default:
                return custom_error(cst_Unexpected_end_of_input$8, v, lexbuf);
            }
          caml_call1(lexbuf[1], lexbuf);
          var ocaml_lex_state = ocaml_lex_state$0;
        }
      }
      function start_any_variant(v, lexbuf) {
        var ocaml_lex_state = 119;
        for (; ; ) {
          var ocaml_lex_state$0 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state, lexbuf);
          if (4 >= ocaml_lex_state$0 >>> 0)
            switch (ocaml_lex_state$0) {
              case 0:
                return -154522342;
              case 1:
                caml_call1(Stdlib_Buffer[8], v[1]);
                return -589953938;
              case 2:
                return -124528282;
              case 3:
                return long_error(cst_Expected_or_but_found$0, v, lexbuf);
              default:
                return custom_error(cst_Unexpected_end_of_input$9, v, lexbuf);
            }
          caml_call1(lexbuf[1], lexbuf);
          var ocaml_lex_state = ocaml_lex_state$0;
        }
      }
      function finish_comment(v, lexbuf) {
        for (; ; ) {
          var ocaml_lex_state = 125;
          for (; ; ) {
            var ocaml_lex_state$0 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state, lexbuf);
            if (3 >= ocaml_lex_state$0 >>> 0)
              break;
            caml_call1(lexbuf[1], lexbuf);
            var ocaml_lex_state = ocaml_lex_state$0;
          }
          switch (ocaml_lex_state$0) {
            case 0:
              return 0;
            case 1:
              return long_error(cst_Unterminated_comment, v, lexbuf);
            case 2:
              newline(v, lexbuf);
              break;
          }
        }
      }
      function read_eof(lexbuf) {
        var ocaml_lex_state = 131;
        for (; ; ) {
          var ocaml_lex_state$0 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state, lexbuf);
          if (0 === ocaml_lex_state$0)
            return 1;
          if (1 === ocaml_lex_state$0)
            return 0;
          caml_call1(lexbuf[1], lexbuf);
          var ocaml_lex_state = ocaml_lex_state$0;
        }
      }
      function read_space(v, lexbuf) {
        for (; ; ) {
          var ocaml_lex_state = 133;
          for (; ; ) {
            var ocaml_lex_state$0 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state, lexbuf);
            if (4 >= ocaml_lex_state$0 >>> 0)
              break;
            caml_call1(lexbuf[1], lexbuf);
            var ocaml_lex_state = ocaml_lex_state$0;
          }
          switch (ocaml_lex_state$0) {
            case 0:
              newline(v, lexbuf);
              break;
            case 1:
              finish_comment(v, lexbuf);
              break;
            case 2:
              newline(v, lexbuf);
              break;
            case 3:
              break;
            default:
              return 0;
          }
        }
      }
      function read_null(v, lexbuf) {
        var ocaml_lex_state = 140;
        for (; ; ) {
          var ocaml_lex_state$0 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state, lexbuf);
          if (2 >= ocaml_lex_state$0 >>> 0)
            switch (ocaml_lex_state$0) {
              case 0:
                return 0;
              case 1:
                return long_error(cst_Expected_null_but_found, v, lexbuf);
              default:
                return custom_error(cst_Unexpected_end_of_input$10, v, lexbuf);
            }
          caml_call1(lexbuf[1], lexbuf);
          var ocaml_lex_state = ocaml_lex_state$0;
        }
      }
      function read_null_if_possible(v, lexbuf) {
        var ocaml_lex_state = 147;
        for (; ; ) {
          var ocaml_lex_state$0 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state, lexbuf);
          if (0 === ocaml_lex_state$0)
            return 1;
          if (1 === ocaml_lex_state$0)
            return 0;
          caml_call1(lexbuf[1], lexbuf);
          var ocaml_lex_state = ocaml_lex_state$0;
        }
      }
      function read_bool(v, lexbuf) {
        var ocaml_lex_state = 152;
        for (; ; ) {
          var ocaml_lex_state$0 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state, lexbuf);
          if (5 >= ocaml_lex_state$0 >>> 0)
            switch (ocaml_lex_state$0) {
              case 0:
                return 1;
              case 1:
                return 0;
              case 2:
                return 1;
              case 3:
                return 0;
              case 4:
                return long_error(cst_Expected_true_or_false_but, v, lexbuf);
              default:
                return custom_error(cst_Unexpected_end_of_input$11, v, lexbuf);
            }
          caml_call1(lexbuf[1], lexbuf);
          var ocaml_lex_state = ocaml_lex_state$0;
        }
      }
      function read_int(v, lexbuf) {
        var ocaml_lex_state = 176;
        for (; ; ) {
          var ocaml_lex_state$0 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state, lexbuf);
          if (4 >= ocaml_lex_state$0 >>> 0)
            switch (ocaml_lex_state$0) {
              case 0:
                try {
                  var _bU_ = extract_positive_int(lexbuf);
                  return _bU_;
                } catch (_b0_) {
                  var _bT_ = caml_wrap_exception2(_b0_);
                  if (_bT_ === Int_overflow)
                    return lexer_error(cst_Int_overflow, v, lexbuf);
                  throw caml_maybe_attach_backtrace2(_bT_, 0);
                }
              case 1:
                try {
                  var _bW_ = extract_negative_int(lexbuf);
                  return _bW_;
                } catch (_bZ_) {
                  var _bV_ = caml_wrap_exception2(_bZ_);
                  if (_bV_ === Int_overflow)
                    return lexer_error(cst_Int_overflow$0, v, lexbuf);
                  throw caml_maybe_attach_backtrace2(_bV_, 0);
                }
              case 2:
                caml_call1(Stdlib_Buffer[8], v[1]);
                var s2 = finish_string(v, lexbuf);
                try {
                  var _bX_ = caml_int_of_string2(s2);
                  return _bX_;
                } catch (_bY_) {
                  return custom_error(cst_Expected_an_integer_but_fo, v, lexbuf);
                }
              case 3:
                return long_error(cst_Expected_integer_but_found, v, lexbuf);
              default:
                return custom_error(cst_Unexpected_end_of_input$12, v, lexbuf);
            }
          caml_call1(lexbuf[1], lexbuf);
          var ocaml_lex_state = ocaml_lex_state$0;
        }
      }
      function read_int32(v, lexbuf) {
        var ocaml_lex_state = 185;
        for (; ; ) {
          var ocaml_lex_state$0 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state, lexbuf);
          if (3 >= ocaml_lex_state$0 >>> 0)
            switch (ocaml_lex_state$0) {
              case 0:
                try {
                  var _bP_ = caml_int_of_string2(caml_call1(lexeme, lexbuf));
                  return _bP_;
                } catch (_bS_) {
                  return lexer_error(cst_Int32_overflow, v, lexbuf);
                }
              case 1:
                caml_call1(Stdlib_Buffer[8], v[1]);
                var s2 = finish_string(v, lexbuf);
                try {
                  var _bQ_ = caml_int_of_string2(s2);
                  return _bQ_;
                } catch (_bR_) {
                  return custom_error(cst_Expected_an_int32_but_foun, v, lexbuf);
                }
              case 2:
                return long_error(cst_Expected_int32_but_found, v, lexbuf);
              default:
                return custom_error(cst_Unexpected_end_of_input$13, v, lexbuf);
            }
          caml_call1(lexbuf[1], lexbuf);
          var ocaml_lex_state = ocaml_lex_state$0;
        }
      }
      function read_int64(v, lexbuf) {
        var ocaml_lex_state = 192;
        for (; ; ) {
          var ocaml_lex_state$0 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state, lexbuf);
          if (3 >= ocaml_lex_state$0 >>> 0)
            switch (ocaml_lex_state$0) {
              case 0:
                try {
                  var _bL_ = caml_int64_of_string2(caml_call1(lexeme, lexbuf));
                  return _bL_;
                } catch (_bO_) {
                  return lexer_error(cst_Int32_overflow$0, v, lexbuf);
                }
              case 1:
                caml_call1(Stdlib_Buffer[8], v[1]);
                var s2 = finish_string(v, lexbuf);
                try {
                  var _bM_ = caml_int64_of_string2(s2);
                  return _bM_;
                } catch (_bN_) {
                  return custom_error(cst_Expected_an_int64_but_foun, v, lexbuf);
                }
              case 2:
                return long_error(cst_Expected_int64_but_found, v, lexbuf);
              default:
                return custom_error(cst_Unexpected_end_of_input$14, v, lexbuf);
            }
          caml_call1(lexbuf[1], lexbuf);
          var ocaml_lex_state = ocaml_lex_state$0;
        }
      }
      function read_number(v, lexbuf) {
        var ocaml_lex_state = 199;
        for (; ; ) {
          var ocaml_lex_state$0 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state, lexbuf);
          if (6 >= ocaml_lex_state$0 >>> 0)
            switch (ocaml_lex_state$0) {
              case 0:
                return Stdlib[24];
              case 1:
                return Stdlib[22];
              case 2:
                return Stdlib[23];
              case 3:
                return caml_float_of_string2(caml_call1(lexeme, lexbuf));
              case 4:
                caml_call1(Stdlib_Buffer[8], v[1]);
                var s2 = finish_string(v, lexbuf);
                try {
                  var _bJ_ = caml_float_of_string2(s2);
                  return _bJ_;
                } catch (_bK_) {
                  return caml_string_notequal2(s2, cst_Infinity$4) ? caml_string_notequal2(s2, cst_Infinity$3) ? caml_string_notequal2(s2, cst_NaN$1) ? custom_error(cst_Expected_a_number_but_foun, v, lexbuf) : Stdlib[24] : Stdlib[22] : Stdlib[23];
                }
              case 5:
                return long_error(cst_Expected_number_but_found, v, lexbuf);
              default:
                return custom_error(cst_Unexpected_end_of_input$15, v, lexbuf);
            }
          caml_call1(lexbuf[1], lexbuf);
          var ocaml_lex_state = ocaml_lex_state$0;
        }
      }
      function read_string(v, lexbuf) {
        var ocaml_lex_state = 233;
        for (; ; ) {
          var ocaml_lex_state$0 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state, lexbuf);
          if (2 >= ocaml_lex_state$0 >>> 0)
            switch (ocaml_lex_state$0) {
              case 0:
                caml_call1(Stdlib_Buffer[8], v[1]);
                return finish_string(v, lexbuf);
              case 1:
                return long_error(cst_Expected_but_found$2, v, lexbuf);
              default:
                return custom_error(cst_Unexpected_end_of_input$16, v, lexbuf);
            }
          caml_call1(lexbuf[1], lexbuf);
          var ocaml_lex_state = ocaml_lex_state$0;
        }
      }
      function read_ident(v, lexbuf) {
        var ocaml_lex_state = 237;
        for (; ; ) {
          var ocaml_lex_state$0 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state, lexbuf);
          if (3 >= ocaml_lex_state$0 >>> 0)
            switch (ocaml_lex_state$0) {
              case 0:
                caml_call1(Stdlib_Buffer[8], v[1]);
                return finish_string(v, lexbuf);
              case 1:
                var s2 = caml_call3(sub_lexeme, lexbuf, lexbuf[5], lexbuf[6]);
                return s2;
              case 2:
                return long_error(cst_Expected_string_or_identif, v, lexbuf);
              default:
                return custom_error(cst_Unexpected_end_of_input$17, v, lexbuf);
            }
          caml_call1(lexbuf[1], lexbuf);
          var ocaml_lex_state = ocaml_lex_state$0;
        }
      }
      function map_ident(v, f, lexbuf) {
        var ocaml_lex_state = 242;
        for (; ; ) {
          var ocaml_lex_state$0 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state, lexbuf);
          if (3 >= ocaml_lex_state$0 >>> 0)
            switch (ocaml_lex_state$0) {
              case 0:
                caml_call1(Stdlib_Buffer[8], v[1]);
                return map_string(v, f, lexbuf);
              case 1:
                var len = lexbuf[6] - lexbuf[5] | 0;
                return caml_call3(
                  f,
                  caml_call3(Stdlib_Bytes[8], lexbuf[2], lexbuf[5], len),
                  0,
                  len
                );
              case 2:
                return long_error(cst_Expected_string_or_identif$0, v, lexbuf);
              default:
                return custom_error(cst_Unexpected_end_of_input$18, v, lexbuf);
            }
          caml_call1(lexbuf[1], lexbuf);
          var ocaml_lex_state = ocaml_lex_state$0;
        }
      }
      function read_sequence(read_cell, init_acc, v, lexbuf) {
        var ocaml_lex_state = 247;
        for (; ; ) {
          var ocaml_lex_state$0 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state, lexbuf);
          if (2 >= ocaml_lex_state$0 >>> 0)
            break;
          caml_call1(lexbuf[1], lexbuf);
          var ocaml_lex_state = ocaml_lex_state$0;
        }
        switch (ocaml_lex_state$0) {
          case 0:
            var acc = [0, init_acc];
            try {
              read_space(v, lexbuf);
              read_array_end(lexbuf);
              acc[1] = caml_call3(read_cell, acc[1], v, lexbuf);
              for (; ; ) {
                read_space(v, lexbuf);
                read_array_sep(v, lexbuf);
                read_space(v, lexbuf);
                acc[1] = caml_call3(read_cell, acc[1], v, lexbuf);
              }
            } catch (_bI_) {
              var _bH_ = caml_wrap_exception2(_bI_);
              if (_bH_ === Yojson_Common[6])
                return acc[1];
              throw caml_maybe_attach_backtrace2(_bH_, 0);
            }
            break;
          case 1:
            return long_error(cst_Expected_but_found$3, v, lexbuf);
          default:
            return custom_error(cst_Unexpected_end_of_input$19, v, lexbuf);
        }
      }
      function read_list_rev(read_cell, v, lexbuf) {
        var ocaml_lex_state = 251;
        for (; ; ) {
          var ocaml_lex_state$0 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state, lexbuf);
          if (2 >= ocaml_lex_state$0 >>> 0)
            break;
          caml_call1(lexbuf[1], lexbuf);
          var ocaml_lex_state = ocaml_lex_state$0;
        }
        switch (ocaml_lex_state$0) {
          case 0:
            var acc = [0, 0];
            try {
              read_space(v, lexbuf);
              read_array_end(lexbuf);
              var _bE_ = acc[1];
              acc[1] = [0, caml_call2(read_cell, v, lexbuf), _bE_];
              for (; ; ) {
                read_space(v, lexbuf);
                read_array_sep(v, lexbuf);
                read_space(v, lexbuf);
                var _bF_ = acc[1];
                acc[1] = [0, caml_call2(read_cell, v, lexbuf), _bF_];
              }
            } catch (_bG_) {
              var _bD_ = caml_wrap_exception2(_bG_);
              if (_bD_ === Yojson_Common[6])
                return acc[1];
              throw caml_maybe_attach_backtrace2(_bD_, 0);
            }
            break;
          case 1:
            return long_error(cst_Expected_but_found$4, v, lexbuf);
          default:
            return custom_error(cst_Unexpected_end_of_input$20, v, lexbuf);
        }
      }
      function read_array_end(lexbuf) {
        var ocaml_lex_state = 255;
        for (; ; ) {
          var ocaml_lex_state$0 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state, lexbuf);
          if (0 === ocaml_lex_state$0)
            throw caml_maybe_attach_backtrace2(Yojson_Common[6], 1);
          if (1 === ocaml_lex_state$0)
            return 0;
          caml_call1(lexbuf[1], lexbuf);
          var ocaml_lex_state = ocaml_lex_state$0;
        }
      }
      function read_array_sep(v, lexbuf) {
        var ocaml_lex_state = 257;
        for (; ; ) {
          var ocaml_lex_state$0 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state, lexbuf);
          if (3 >= ocaml_lex_state$0 >>> 0)
            switch (ocaml_lex_state$0) {
              case 0:
                return 0;
              case 1:
                throw caml_maybe_attach_backtrace2(Yojson_Common[6], 1);
              case 2:
                return long_error(cst_Expected_or_but_found$1, v, lexbuf);
              default:
                return custom_error(cst_Unexpected_end_of_input$21, v, lexbuf);
            }
          caml_call1(lexbuf[1], lexbuf);
          var ocaml_lex_state = ocaml_lex_state$0;
        }
      }
      function read_tuple(read_cell, init_acc, v, lexbuf) {
        var ocaml_lex_state = 262;
        for (; ; ) {
          var ocaml_lex_state$0 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state, lexbuf);
          if (2 >= ocaml_lex_state$0 >>> 0)
            break;
          caml_call1(lexbuf[1], lexbuf);
          var ocaml_lex_state = ocaml_lex_state$0;
        }
        switch (ocaml_lex_state$0) {
          case 0:
            var pos = [0, 0], acc = [0, init_acc];
            try {
              read_space(v, lexbuf);
              read_tuple_end(lexbuf);
              acc[1] = caml_call4(read_cell, pos[1], acc[1], v, lexbuf);
              pos[1]++;
              for (; ; ) {
                read_space(v, lexbuf);
                read_tuple_sep(v, lexbuf);
                read_space(v, lexbuf);
                acc[1] = caml_call4(read_cell, pos[1], acc[1], v, lexbuf);
                pos[1]++;
              }
            } catch (_bC_) {
              var _bB_ = caml_wrap_exception2(_bC_);
              if (_bB_ === Yojson_Common[8])
                return acc[1];
              throw caml_maybe_attach_backtrace2(_bB_, 0);
            }
            break;
          case 1:
            return long_error(cst_Expected_but_found$5, v, lexbuf);
          default:
            return custom_error(cst_Unexpected_end_of_input$22, v, lexbuf);
        }
      }
      function read_tuple_end(lexbuf) {
        var ocaml_lex_state = 266;
        for (; ; ) {
          var ocaml_lex_state$0 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state, lexbuf);
          if (0 === ocaml_lex_state$0)
            throw caml_maybe_attach_backtrace2(Yojson_Common[8], 1);
          if (1 === ocaml_lex_state$0)
            return 0;
          caml_call1(lexbuf[1], lexbuf);
          var ocaml_lex_state = ocaml_lex_state$0;
        }
      }
      function read_tuple_end2(v, std, lexbuf) {
        var ocaml_lex_state = 268;
        for (; ; ) {
          var ocaml_lex_state$0 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state, lexbuf);
          if (2 >= ocaml_lex_state$0 >>> 0)
            switch (ocaml_lex_state$0) {
              case 0:
                if (std)
                  return long_error(cst_Expected_or_but_found$2, v, lexbuf);
                throw caml_maybe_attach_backtrace2(Yojson_Common[8], 1);
              case 1:
                if (std)
                  throw caml_maybe_attach_backtrace2(Yojson_Common[8], 1);
                return long_error(cst_Expected_or_but_found$3, v, lexbuf);
              default:
                return 0;
            }
          caml_call1(lexbuf[1], lexbuf);
          var ocaml_lex_state = ocaml_lex_state$0;
        }
      }
      function read_tuple_sep(v, lexbuf) {
        var ocaml_lex_state = 271;
        for (; ; ) {
          var ocaml_lex_state$0 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state, lexbuf);
          if (3 >= ocaml_lex_state$0 >>> 0)
            switch (ocaml_lex_state$0) {
              case 0:
                return 0;
              case 1:
                throw caml_maybe_attach_backtrace2(Yojson_Common[8], 1);
              case 2:
                return long_error(cst_Expected_or_but_found$4, v, lexbuf);
              default:
                return custom_error(cst_Unexpected_end_of_input$23, v, lexbuf);
            }
          caml_call1(lexbuf[1], lexbuf);
          var ocaml_lex_state = ocaml_lex_state$0;
        }
      }
      function read_tuple_sep2(v, std, lexbuf) {
        var ocaml_lex_state = 276;
        for (; ; ) {
          var ocaml_lex_state$0 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state, lexbuf);
          if (4 >= ocaml_lex_state$0 >>> 0)
            switch (ocaml_lex_state$0) {
              case 0:
                return 0;
              case 1:
                if (std)
                  return long_error(cst_Expected_or_but_found$5, v, lexbuf);
                throw caml_maybe_attach_backtrace2(Yojson_Common[8], 1);
              case 2:
                if (std)
                  throw caml_maybe_attach_backtrace2(Yojson_Common[8], 1);
                return long_error(cst_Expected_or_but_found$6, v, lexbuf);
              case 3:
                return long_error(cst_Expected_or_but_found$7, v, lexbuf);
              default:
                return custom_error(cst_Unexpected_end_of_input$24, v, lexbuf);
            }
          caml_call1(lexbuf[1], lexbuf);
          var ocaml_lex_state = ocaml_lex_state$0;
        }
      }
      function read_abstract_fields(read_key, read_field, init_acc, v, lexbuf) {
        var ocaml_lex_state = 282;
        for (; ; ) {
          var ocaml_lex_state$0 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state, lexbuf);
          if (2 >= ocaml_lex_state$0 >>> 0)
            break;
          caml_call1(lexbuf[1], lexbuf);
          var ocaml_lex_state = ocaml_lex_state$0;
        }
        switch (ocaml_lex_state$0) {
          case 0:
            var acc = [0, init_acc];
            try {
              read_space(v, lexbuf);
              read_object_end(lexbuf);
              var field_name = caml_call2(read_key, v, lexbuf);
              read_space(v, lexbuf);
              read_colon(v, lexbuf);
              read_space(v, lexbuf);
              acc[1] = caml_call4(read_field, acc[1], field_name, v, lexbuf);
              for (; ; ) {
                read_space(v, lexbuf);
                read_object_sep(v, lexbuf);
                read_space(v, lexbuf);
                var field_name$0 = caml_call2(read_key, v, lexbuf);
                read_space(v, lexbuf);
                read_colon(v, lexbuf);
                read_space(v, lexbuf);
                acc[1] = caml_call4(read_field, acc[1], field_name$0, v, lexbuf);
              }
            } catch (_bA_) {
              var _bz_ = caml_wrap_exception2(_bA_);
              if (_bz_ === Yojson_Common[7])
                return acc[1];
              throw caml_maybe_attach_backtrace2(_bz_, 0);
            }
            break;
          case 1:
            return long_error(cst_Expected_but_found$6, v, lexbuf);
          default:
            return custom_error(cst_Unexpected_end_of_input$25, v, lexbuf);
        }
      }
      function read_lcurl(v, lexbuf) {
        var ocaml_lex_state = 286;
        for (; ; ) {
          var ocaml_lex_state$0 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state, lexbuf);
          if (2 >= ocaml_lex_state$0 >>> 0)
            switch (ocaml_lex_state$0) {
              case 0:
                return 0;
              case 1:
                return long_error(cst_Expected_but_found$7, v, lexbuf);
              default:
                return custom_error(cst_Unexpected_end_of_input$26, v, lexbuf);
            }
          caml_call1(lexbuf[1], lexbuf);
          var ocaml_lex_state = ocaml_lex_state$0;
        }
      }
      function read_object_end(lexbuf) {
        var ocaml_lex_state = 290;
        for (; ; ) {
          var ocaml_lex_state$0 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state, lexbuf);
          if (0 === ocaml_lex_state$0)
            throw caml_maybe_attach_backtrace2(Yojson_Common[7], 1);
          if (1 === ocaml_lex_state$0)
            return 0;
          caml_call1(lexbuf[1], lexbuf);
          var ocaml_lex_state = ocaml_lex_state$0;
        }
      }
      function read_object_sep(v, lexbuf) {
        var ocaml_lex_state = 292;
        for (; ; ) {
          var ocaml_lex_state$0 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state, lexbuf);
          if (3 >= ocaml_lex_state$0 >>> 0)
            switch (ocaml_lex_state$0) {
              case 0:
                return 0;
              case 1:
                throw caml_maybe_attach_backtrace2(Yojson_Common[7], 1);
              case 2:
                return long_error(cst_Expected_or_but_found$8, v, lexbuf);
              default:
                return custom_error(cst_Unexpected_end_of_input$27, v, lexbuf);
            }
          caml_call1(lexbuf[1], lexbuf);
          var ocaml_lex_state = ocaml_lex_state$0;
        }
      }
      function read_colon(v, lexbuf) {
        var ocaml_lex_state = 297;
        for (; ; ) {
          var ocaml_lex_state$0 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state, lexbuf);
          if (2 >= ocaml_lex_state$0 >>> 0)
            switch (ocaml_lex_state$0) {
              case 0:
                return 0;
              case 1:
                return long_error(cst_Expected_but_found$8, v, lexbuf);
              default:
                return custom_error(cst_Unexpected_end_of_input$28, v, lexbuf);
            }
          caml_call1(lexbuf[1], lexbuf);
          var ocaml_lex_state = ocaml_lex_state$0;
        }
      }
      function start_any_tuple(v, lexbuf) {
        var ocaml_lex_state = 301;
        for (; ; ) {
          var ocaml_lex_state$0 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state, lexbuf);
          if (3 >= ocaml_lex_state$0 >>> 0)
            switch (ocaml_lex_state$0) {
              case 0:
                return 0;
              case 1:
                return 1;
              case 2:
                return long_error(cst_Expected_or_but_found$9, v, lexbuf);
              default:
                return custom_error(cst_Unexpected_end_of_input$29, v, lexbuf);
            }
          caml_call1(lexbuf[1], lexbuf);
          var ocaml_lex_state = ocaml_lex_state$0;
        }
      }
      function read_lpar(v, lexbuf) {
        var ocaml_lex_state = 306;
        for (; ; ) {
          var ocaml_lex_state$0 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state, lexbuf);
          if (2 >= ocaml_lex_state$0 >>> 0)
            switch (ocaml_lex_state$0) {
              case 0:
                return 0;
              case 1:
                return long_error(cst_Expected_but_found$9, v, lexbuf);
              default:
                return custom_error(cst_Unexpected_end_of_input$30, v, lexbuf);
            }
          caml_call1(lexbuf[1], lexbuf);
          var ocaml_lex_state = ocaml_lex_state$0;
        }
      }
      function read_rpar(v, lexbuf) {
        var ocaml_lex_state = 310;
        for (; ; ) {
          var ocaml_lex_state$0 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state, lexbuf);
          if (2 >= ocaml_lex_state$0 >>> 0)
            switch (ocaml_lex_state$0) {
              case 0:
                return 0;
              case 1:
                return long_error(cst_Expected_but_found$10, v, lexbuf);
              default:
                return custom_error(cst_Unexpected_end_of_input$31, v, lexbuf);
            }
          caml_call1(lexbuf[1], lexbuf);
          var ocaml_lex_state = ocaml_lex_state$0;
        }
      }
      function read_lbr(v, lexbuf) {
        var ocaml_lex_state = 314;
        for (; ; ) {
          var ocaml_lex_state$0 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state, lexbuf);
          if (2 >= ocaml_lex_state$0 >>> 0)
            switch (ocaml_lex_state$0) {
              case 0:
                return 0;
              case 1:
                return long_error(cst_Expected_but_found$11, v, lexbuf);
              default:
                return custom_error(cst_Unexpected_end_of_input$32, v, lexbuf);
            }
          caml_call1(lexbuf[1], lexbuf);
          var ocaml_lex_state = ocaml_lex_state$0;
        }
      }
      function read_rbr(v, lexbuf) {
        var ocaml_lex_state = 318;
        for (; ; ) {
          var ocaml_lex_state$0 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state, lexbuf);
          if (2 >= ocaml_lex_state$0 >>> 0)
            switch (ocaml_lex_state$0) {
              case 0:
                return 0;
              case 1:
                return long_error(cst_Expected_but_found$12, v, lexbuf);
              default:
                return custom_error(cst_Unexpected_end_of_input$33, v, lexbuf);
            }
          caml_call1(lexbuf[1], lexbuf);
          var ocaml_lex_state = ocaml_lex_state$0;
        }
      }
      function skip_json(v, lexbuf) {
        for (; ; ) {
          var ocaml_lex_state = 322;
          for (; ; ) {
            var ocaml_lex_state$0 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state, lexbuf);
            if (18 >= ocaml_lex_state$0 >>> 0)
              break;
            caml_call1(lexbuf[1], lexbuf);
            var ocaml_lex_state = ocaml_lex_state$0;
          }
          switch (ocaml_lex_state$0) {
            case 0:
              return 0;
            case 1:
              return 0;
            case 2:
              return 0;
            case 3:
              return 0;
            case 4:
              return 0;
            case 5:
              return 0;
            case 6:
              return finish_skip_stringlit(v, lexbuf);
            case 7:
              return 0;
            case 8:
              return 0;
            case 9:
              try {
                read_space(v, lexbuf);
                read_object_end(lexbuf);
                skip_ident(v, lexbuf);
                read_space(v, lexbuf);
                read_colon(v, lexbuf);
                read_space(v, lexbuf);
                skip_json(v, lexbuf);
                for (; ; ) {
                  read_space(v, lexbuf);
                  read_object_sep(v, lexbuf);
                  read_space(v, lexbuf);
                  skip_ident(v, lexbuf);
                  read_space(v, lexbuf);
                  read_colon(v, lexbuf);
                  read_space(v, lexbuf);
                  skip_json(v, lexbuf);
                }
              } catch (_by_) {
                var _bt_ = caml_wrap_exception2(_by_);
                if (_bt_ === Yojson_Common[7])
                  return 0;
                throw caml_maybe_attach_backtrace2(_bt_, 0);
              }
              break;
            case 10:
              try {
                read_space(v, lexbuf);
                read_array_end(lexbuf);
                skip_json(v, lexbuf);
                for (; ; ) {
                  read_space(v, lexbuf);
                  read_array_sep(v, lexbuf);
                  read_space(v, lexbuf);
                  skip_json(v, lexbuf);
                }
              } catch (_bx_) {
                var _bu_ = caml_wrap_exception2(_bx_);
                if (_bu_ === Yojson_Common[6])
                  return 0;
                throw caml_maybe_attach_backtrace2(_bu_, 0);
              }
              break;
            case 11:
              try {
                read_space(v, lexbuf);
                read_tuple_end(lexbuf);
                skip_json(v, lexbuf);
                for (; ; ) {
                  read_space(v, lexbuf);
                  read_tuple_sep(v, lexbuf);
                  read_space(v, lexbuf);
                  skip_json(v, lexbuf);
                }
              } catch (_bw_) {
                var _bv_ = caml_wrap_exception2(_bw_);
                if (_bv_ === Yojson_Common[8])
                  return 0;
                throw caml_maybe_attach_backtrace2(_bv_, 0);
              }
              break;
            case 12:
              read_space(v, lexbuf);
              skip_ident(v, lexbuf);
              read_space(v, lexbuf);
              return finish_skip_variant(v, lexbuf);
            case 13:
              break;
            case 14:
              finish_comment(v, lexbuf);
              break;
            case 15:
              newline(v, lexbuf);
              break;
            case 16:
              break;
            case 17:
              return custom_error(cst_Unexpected_end_of_input$34, v, lexbuf);
            default:
              return long_error(cst_Invalid_token$0, v, lexbuf);
          }
        }
      }
      function finish_skip_stringlit(v, lexbuf) {
        var ocaml_lex_state = 378;
        for (; ; ) {
          var ocaml_lex_state$0 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state, lexbuf);
          if (2 >= ocaml_lex_state$0 >>> 0)
            switch (ocaml_lex_state$0) {
              case 0:
                return 0;
              case 1:
                return long_error(cst_Invalid_string_literal$0, v, lexbuf);
              default:
                return custom_error(cst_Unexpected_end_of_input$35, v, lexbuf);
            }
          caml_call1(lexbuf[1], lexbuf);
          var ocaml_lex_state = ocaml_lex_state$0;
        }
      }
      function finish_skip_variant(v, lexbuf) {
        var ocaml_lex_state = 389;
        for (; ; ) {
          var ocaml_lex_state$0 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state, lexbuf);
          if (3 >= ocaml_lex_state$0 >>> 0)
            switch (ocaml_lex_state$0) {
              case 0:
                skip_json(v, lexbuf);
                read_space(v, lexbuf);
                return read_gt(v, lexbuf);
              case 1:
                return 0;
              case 2:
                return long_error(cst_Expected_or_but_found$10, v, lexbuf);
              default:
                return custom_error(cst_Unexpected_end_of_input$36, v, lexbuf);
            }
          caml_call1(lexbuf[1], lexbuf);
          var ocaml_lex_state = ocaml_lex_state$0;
        }
      }
      function skip_ident(v, lexbuf) {
        var ocaml_lex_state = 394;
        for (; ; ) {
          var ocaml_lex_state$0 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state, lexbuf);
          if (3 >= ocaml_lex_state$0 >>> 0)
            switch (ocaml_lex_state$0) {
              case 0:
                return finish_skip_stringlit(v, lexbuf);
              case 1:
                return 0;
              case 2:
                return long_error(cst_Expected_string_or_identif$1, v, lexbuf);
              default:
                return custom_error(cst_Unexpected_end_of_input$37, v, lexbuf);
            }
          caml_call1(lexbuf[1], lexbuf);
          var ocaml_lex_state = ocaml_lex_state$0;
        }
      }
      function buffer_json(v, lexbuf) {
        for (; ; ) {
          var ocaml_lex_state = 399;
          for (; ; ) {
            var ocaml_lex_state$0 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state, lexbuf);
            if (11 >= ocaml_lex_state$0 >>> 0)
              break;
            caml_call1(lexbuf[1], lexbuf);
            var ocaml_lex_state = ocaml_lex_state$0;
          }
          switch (ocaml_lex_state$0) {
            case 0:
              return add_lexeme(v[1], lexbuf);
            case 1:
              return finish_buffer_stringlit(v, lexbuf);
            case 2:
              try {
                caml_call2(Stdlib_Buffer[12], v[1], 123);
                buffer_space(v, lexbuf);
                var ocaml_lex_state$3 = 478;
                for (; ; ) {
                  var ocaml_lex_state$4 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state$3, lexbuf);
                  if (0 === ocaml_lex_state$4) {
                    caml_call2(Stdlib_Buffer[12], v[1], 125);
                    throw caml_maybe_attach_backtrace2(Yojson_Common[7], 1);
                  }
                  if (1 === ocaml_lex_state$4)
                    break;
                  caml_call1(lexbuf[1], lexbuf);
                  var ocaml_lex_state$3 = ocaml_lex_state$4;
                }
                buffer_ident(v, lexbuf);
                buffer_space(v, lexbuf);
                buffer_colon(v, lexbuf);
                buffer_space(v, lexbuf);
                buffer_json(v, lexbuf);
                for (; ; ) {
                  buffer_space(v, lexbuf);
                  var ocaml_lex_state$5 = 480;
                  for (; ; ) {
                    var ocaml_lex_state$6 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state$5, lexbuf);
                    if (3 >= ocaml_lex_state$6 >>> 0)
                      break;
                    caml_call1(lexbuf[1], lexbuf);
                    var ocaml_lex_state$5 = ocaml_lex_state$6;
                  }
                  switch (ocaml_lex_state$6) {
                    case 0:
                      caml_call2(Stdlib_Buffer[12], v[1], 44);
                      break;
                    case 1:
                      caml_call2(Stdlib_Buffer[12], v[1], 125);
                      throw caml_maybe_attach_backtrace2(Yojson_Common[7], 1);
                    case 2:
                      long_error(cst_Expected_or_but_found$12, v, lexbuf);
                      break;
                    default:
                      custom_error(cst_Unexpected_end_of_input$42, v, lexbuf);
                  }
                  buffer_space(v, lexbuf);
                  buffer_ident(v, lexbuf);
                  buffer_space(v, lexbuf);
                  buffer_colon(v, lexbuf);
                  buffer_space(v, lexbuf);
                  buffer_json(v, lexbuf);
                }
              } catch (_bs_) {
                var _bn_ = caml_wrap_exception2(_bs_);
                if (_bn_ === Yojson_Common[7])
                  return 0;
                throw caml_maybe_attach_backtrace2(_bn_, 0);
              }
              break;
            case 3:
              try {
                caml_call2(Stdlib_Buffer[12], v[1], 91);
                buffer_space(v, lexbuf);
                var ocaml_lex_state$7 = 485;
                for (; ; ) {
                  var ocaml_lex_state$8 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state$7, lexbuf);
                  if (0 === ocaml_lex_state$8) {
                    caml_call2(Stdlib_Buffer[12], v[1], 93);
                    throw caml_maybe_attach_backtrace2(Yojson_Common[6], 1);
                  }
                  if (1 === ocaml_lex_state$8)
                    break;
                  caml_call1(lexbuf[1], lexbuf);
                  var ocaml_lex_state$7 = ocaml_lex_state$8;
                }
                buffer_json(v, lexbuf);
                for (; ; ) {
                  buffer_space(v, lexbuf);
                  var ocaml_lex_state$9 = 487;
                  for (; ; ) {
                    var ocaml_lex_state$10 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state$9, lexbuf);
                    if (3 >= ocaml_lex_state$10 >>> 0)
                      break;
                    caml_call1(lexbuf[1], lexbuf);
                    var ocaml_lex_state$9 = ocaml_lex_state$10;
                  }
                  switch (ocaml_lex_state$10) {
                    case 0:
                      caml_call2(Stdlib_Buffer[12], v[1], 44);
                      break;
                    case 1:
                      caml_call2(Stdlib_Buffer[12], v[1], 93);
                      throw caml_maybe_attach_backtrace2(Yojson_Common[6], 1);
                    case 2:
                      long_error(cst_Expected_or_but_found$13, v, lexbuf);
                      break;
                    default:
                      custom_error(cst_Unexpected_end_of_input$43, v, lexbuf);
                  }
                  buffer_space(v, lexbuf);
                  buffer_json(v, lexbuf);
                }
              } catch (_br_) {
                var _bo_ = caml_wrap_exception2(_br_);
                if (_bo_ === Yojson_Common[6])
                  return 0;
                throw caml_maybe_attach_backtrace2(_bo_, 0);
              }
              break;
            case 4:
              try {
                caml_call2(Stdlib_Buffer[12], v[1], 40);
                buffer_space(v, lexbuf);
                var ocaml_lex_state$11 = 492;
                for (; ; ) {
                  var ocaml_lex_state$12 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state$11, lexbuf);
                  if (0 === ocaml_lex_state$12) {
                    caml_call2(Stdlib_Buffer[12], v[1], 41);
                    throw caml_maybe_attach_backtrace2(Yojson_Common[8], 1);
                  }
                  if (1 === ocaml_lex_state$12)
                    break;
                  caml_call1(lexbuf[1], lexbuf);
                  var ocaml_lex_state$11 = ocaml_lex_state$12;
                }
                buffer_json(v, lexbuf);
                for (; ; ) {
                  buffer_space(v, lexbuf);
                  var ocaml_lex_state$13 = 494;
                  for (; ; ) {
                    var ocaml_lex_state$14 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state$13, lexbuf);
                    if (3 >= ocaml_lex_state$14 >>> 0)
                      break;
                    caml_call1(lexbuf[1], lexbuf);
                    var ocaml_lex_state$13 = ocaml_lex_state$14;
                  }
                  switch (ocaml_lex_state$14) {
                    case 0:
                      caml_call2(Stdlib_Buffer[12], v[1], 44);
                      break;
                    case 1:
                      caml_call2(Stdlib_Buffer[12], v[1], 41);
                      throw caml_maybe_attach_backtrace2(Yojson_Common[8], 1);
                    case 2:
                      long_error(cst_Expected_or_but_found$14, v, lexbuf);
                      break;
                    default:
                      custom_error(cst_Unexpected_end_of_input$44, v, lexbuf);
                  }
                  buffer_space(v, lexbuf);
                  buffer_json(v, lexbuf);
                }
              } catch (_bq_) {
                var _bp_ = caml_wrap_exception2(_bq_);
                if (_bp_ === Yojson_Common[8])
                  return 0;
                throw caml_maybe_attach_backtrace2(_bp_, 0);
              }
              break;
            case 5:
              caml_call2(Stdlib_Buffer[12], v[1], 60);
              buffer_space(v, lexbuf);
              buffer_ident(v, lexbuf);
              buffer_space(v, lexbuf);
              var ocaml_lex_state$1 = 461;
              for (; ; ) {
                var ocaml_lex_state$2 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state$1, lexbuf);
                if (3 >= ocaml_lex_state$2 >>> 0)
                  break;
                caml_call1(lexbuf[1], lexbuf);
                var ocaml_lex_state$1 = ocaml_lex_state$2;
              }
              switch (ocaml_lex_state$2) {
                case 0:
                  caml_call2(Stdlib_Buffer[12], v[1], 58);
                  buffer_json(v, lexbuf);
                  buffer_space(v, lexbuf);
                  var ocaml_lex_state$15 = 503;
                  for (; ; ) {
                    var ocaml_lex_state$16 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state$15, lexbuf);
                    if (2 >= ocaml_lex_state$16 >>> 0)
                      switch (ocaml_lex_state$16) {
                        case 0:
                          return caml_call2(Stdlib_Buffer[12], v[1], 62);
                        case 1:
                          return long_error(cst_Expected_but_found$14, v, lexbuf);
                        default:
                          return custom_error(cst_Unexpected_end_of_input$46, v, lexbuf);
                      }
                    caml_call1(lexbuf[1], lexbuf);
                    var ocaml_lex_state$15 = ocaml_lex_state$16;
                  }
                  break;
                case 1:
                  return caml_call2(Stdlib_Buffer[12], v[1], 62);
                case 2:
                  return long_error(cst_Expected_or_but_found$11, v, lexbuf);
                default:
                  return custom_error(cst_Unexpected_end_of_input$40, v, lexbuf);
              }
              break;
            case 6:
              add_lexeme(v[1], lexbuf);
              break;
            case 7:
              caml_call2(Stdlib_Buffer[16], v[1], cst$18);
              finish_buffer_comment(v, lexbuf);
              break;
            case 8:
              caml_call2(Stdlib_Buffer[12], v[1], 10);
              newline(v, lexbuf);
              break;
            case 9:
              add_lexeme(v[1], lexbuf);
              break;
            case 10:
              return custom_error(cst_Unexpected_end_of_input$38, v, lexbuf);
            default:
              return long_error(cst_Invalid_token$1, v, lexbuf);
          }
        }
      }
      function finish_buffer_stringlit(v, lexbuf) {
        var ocaml_lex_state = 450;
        for (; ; ) {
          var ocaml_lex_state$0 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state, lexbuf);
          if (2 >= ocaml_lex_state$0 >>> 0)
            switch (ocaml_lex_state$0) {
              case 0:
                caml_call2(Stdlib_Buffer[12], v[1], 34);
                return add_lexeme(v[1], lexbuf);
              case 1:
                return long_error(cst_Invalid_string_literal$1, v, lexbuf);
              default:
                return custom_error(cst_Unexpected_end_of_input$39, v, lexbuf);
            }
          caml_call1(lexbuf[1], lexbuf);
          var ocaml_lex_state = ocaml_lex_state$0;
        }
      }
      function buffer_ident(v, lexbuf) {
        var ocaml_lex_state = 466;
        for (; ; ) {
          var ocaml_lex_state$0 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state, lexbuf);
          if (3 >= ocaml_lex_state$0 >>> 0)
            switch (ocaml_lex_state$0) {
              case 0:
                return finish_buffer_stringlit(v, lexbuf);
              case 1:
                return add_lexeme(v[1], lexbuf);
              case 2:
                return long_error(cst_Expected_string_or_identif$2, v, lexbuf);
              default:
                return custom_error(cst_Unexpected_end_of_input$41, v, lexbuf);
            }
          caml_call1(lexbuf[1], lexbuf);
          var ocaml_lex_state = ocaml_lex_state$0;
        }
      }
      function buffer_space(v, lexbuf) {
        for (; ; ) {
          var ocaml_lex_state = 471;
          for (; ; ) {
            var ocaml_lex_state$0 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state, lexbuf);
            if (4 >= ocaml_lex_state$0 >>> 0)
              break;
            caml_call1(lexbuf[1], lexbuf);
            var ocaml_lex_state = ocaml_lex_state$0;
          }
          switch (ocaml_lex_state$0) {
            case 0:
              add_lexeme(v[1], lexbuf);
              newline(v, lexbuf);
              break;
            case 1:
              caml_call2(Stdlib_Buffer[16], v[1], cst$19);
              finish_buffer_comment(v, lexbuf);
              break;
            case 2:
              caml_call2(Stdlib_Buffer[12], v[1], 10);
              newline(v, lexbuf);
              break;
            case 3:
              add_lexeme(v[1], lexbuf);
              break;
            default:
              return;
          }
        }
      }
      function buffer_colon(v, lexbuf) {
        var ocaml_lex_state = 499;
        for (; ; ) {
          var ocaml_lex_state$0 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state, lexbuf);
          if (2 >= ocaml_lex_state$0 >>> 0)
            switch (ocaml_lex_state$0) {
              case 0:
                return caml_call2(Stdlib_Buffer[12], v[1], 58);
              case 1:
                return long_error(cst_Expected_but_found$13, v, lexbuf);
              default:
                return custom_error(cst_Unexpected_end_of_input$45, v, lexbuf);
            }
          caml_call1(lexbuf[1], lexbuf);
          var ocaml_lex_state = ocaml_lex_state$0;
        }
      }
      function finish_buffer_comment(v, lexbuf) {
        for (; ; ) {
          var ocaml_lex_state = 507;
          for (; ; ) {
            var ocaml_lex_state$0 = caml_lex_engine2(ocaml_lex_tables, ocaml_lex_state, lexbuf);
            if (3 >= ocaml_lex_state$0 >>> 0)
              break;
            caml_call1(lexbuf[1], lexbuf);
            var ocaml_lex_state = ocaml_lex_state$0;
          }
          switch (ocaml_lex_state$0) {
            case 0:
              return caml_call2(Stdlib_Buffer[16], v[1], cst$20);
            case 1:
              return long_error(cst_Unterminated_comment$0, v, lexbuf);
            case 2:
              caml_call2(Stdlib_Buffer[12], v[1], 10);
              newline(v, lexbuf);
              break;
            default:
              add_lexeme(v[1], lexbuf);
          }
        }
      }
      function read_int8(v, lexbuf) {
        var n = read_int(v, lexbuf);
        if (0 <= n && 255 >= n)
          return caml_call1(Stdlib[29], n);
        return lexer_error(cst_Int8_overflow, v, lexbuf);
      }
      function read_list(read_cell, v, lexbuf) {
        var _bm_ = read_list_rev(read_cell, v, lexbuf);
        return caml_call1(Stdlib_List[10], _bm_);
      }
      function read_array(read_cell, v, lexbuf) {
        var l = read_list_rev(read_cell, v, lexbuf);
        if (!l)
          return [0];
        var tl = l[2], x2 = l[1], len = caml_call1(Stdlib_List[1], l), a = runtime.caml_make_vect(len, x2), r = [0, tl], _bj_ = len - 2 | 0;
        if (_bj_ >= 0) {
          var i = _bj_;
          for (; ; ) {
            var _bk_ = caml_call1(Stdlib_List[6], r[1]);
            runtime.caml_check_bound(a, i)[1 + i] = _bk_;
            r[1] = caml_call1(Stdlib_List[7], r[1]);
            var _bl_ = i - 1 | 0;
            if (0 === i)
              break;
            var i = _bl_;
          }
        }
        return a;
      }
      function read_fields(read_field, init_acc, v) {
        return function(_bi_) {
          return read_abstract_fields(read_ident, read_field, init_acc, v, _bi_);
        };
      }
      var init_lexer = Yojson_Common[5];
      function from_lexbuf(v, opt, lexbuf) {
        if (opt)
          var sth = opt[1], stream2 = sth;
        else
          var stream2 = 0;
        read_space(v, lexbuf);
        if (read_eof(lexbuf))
          throw caml_maybe_attach_backtrace2(Yojson_Common[9], 1);
        var x2 = read_json(v, lexbuf);
        if (1 - stream2) {
          read_space(v, lexbuf);
          if (1 - read_eof(lexbuf))
            long_error(cst_Junk_after_end_of_JSON_val, v, lexbuf);
        }
        return x2;
      }
      function from_string$0(buf, fname, lnum, s2) {
        try {
          var lexbuf = caml_call2(from_string, 0, s2), v = caml_call4(init_lexer, buf, fname, lnum, 0), _bg_ = from_lexbuf(v, 0, lexbuf);
          return _bg_;
        } catch (_bh_) {
          var _bf_ = caml_wrap_exception2(_bh_);
          if (_bf_ === Yojson_Common[9])
            return caml_call1(Yojson_Common[3], cst_Blank_input_data);
          throw caml_maybe_attach_backtrace2(_bf_, 0);
        }
      }
      function from_channel$0(buf, fname, lnum, ic) {
        try {
          var lexbuf = caml_call2(from_channel, 0, ic), v = caml_call4(init_lexer, buf, fname, lnum, 0), _bd_ = from_lexbuf(v, 0, lexbuf);
          return _bd_;
        } catch (_be_) {
          var _bc_ = caml_wrap_exception2(_be_);
          if (_bc_ === Yojson_Common[9])
            return caml_call1(Yojson_Common[3], cst_Blank_input_data$0);
          throw caml_maybe_attach_backtrace2(_bc_, 0);
        }
      }
      function from_file(buf, fname, lnum, file) {
        var ic = caml_call1(Stdlib[79], file);
        try {
          var x2 = from_channel$0(buf, fname, lnum, ic);
          caml_call1(Stdlib[93], ic);
          return x2;
        } catch (e$0) {
          var e = caml_wrap_exception2(e$0);
          caml_call1(Stdlib[94], ic);
          throw caml_maybe_attach_backtrace2(e, 0);
        }
      }
      var Finally = [248, cst_Yojson_Safe_Finally, caml_fresh_oo_id2(0)];
      function seq_from_lexbuf(v, opt, lexbuf) {
        if (opt)
          var sth = opt[1], fin = sth;
        else
          var fin = function(param) {
            return;
          };
        function f(param) {
          try {
            var _bb_ = [0, from_lexbuf(v, stream, lexbuf), f];
            return _bb_;
          } catch (e$0) {
            var e = caml_wrap_exception2(e$0);
            if (e === Yojson_Common[9]) {
              caml_call1(fin, 0);
              return 0;
            }
            try {
              caml_call1(fin, 0);
            } catch (fin_e$0) {
              var fin_e = caml_wrap_exception2(fin_e$0);
              throw caml_maybe_attach_backtrace2([0, Finally, e, fin_e], 1);
            }
            throw caml_maybe_attach_backtrace2(e, 0);
          }
        }
        return f;
      }
      function seq_from_string(buf, fname, lnum, s2) {
        var v = caml_call4(init_lexer, buf, fname, lnum, 0);
        return seq_from_lexbuf(v, 0, caml_call2(from_string, 0, s2));
      }
      function seq_from_channel(buf, fin, fname, lnum, ic) {
        var lexbuf = caml_call2(from_channel, 0, ic), v = caml_call4(init_lexer, buf, fname, lnum, 0);
        return seq_from_lexbuf(v, fin, lexbuf);
      }
      function seq_from_file(buf, fname, lnum, file) {
        var ic = caml_call1(Stdlib[79], file);
        function fin(param) {
          return caml_call1(Stdlib[93], ic);
        }
        var fname$0 = fname || [0, file], lexbuf = caml_call2(from_channel, 0, ic), v = caml_call4(init_lexer, buf, fname$0, lnum, 0);
        return seq_from_lexbuf(v, [0, fin], lexbuf);
      }
      function lineseq_from_channel(buf, opt, fname, _a6_, ic) {
        if (opt)
          var sth = opt[1], fin = sth;
        else
          var fin = function(param) {
            return;
          };
        if (_a6_)
          var sth$0 = _a6_[1], lnum0 = sth$0;
        else
          var lnum0 = 1;
        var buf$0 = buf || [0, caml_call1(Stdlib_Buffer[1], 256)];
        function f(lnum, param) {
          try {
            var line = caml_call1(Stdlib[83], ic), _a9_ = lnum + 1 | 0, _a__ = [
              0,
              [0, 826371656, from_string$0(buf$0, fname, [0, lnum], line)],
              function(_ba_) {
                return f(_a9_, _ba_);
              }
            ];
            return _a__;
          } catch (e$0) {
            var e = caml_wrap_exception2(e$0);
            if (e === Stdlib[12]) {
              caml_call1(fin, 0);
              return 0;
            }
            var _a8_ = lnum + 1 | 0;
            return [0, [0, 3458171, e], function(_a$_) {
              return f(_a8_, _a$_);
            }];
          }
        }
        return function(_a7_) {
          return f(lnum0, _a7_);
        };
      }
      function lineseq_from_file(buf, fname, lnum, file) {
        var ic = caml_call1(Stdlib[79], file);
        function fin(param) {
          return caml_call1(Stdlib[93], ic);
        }
        var fname$0 = fname || [0, file];
        return lineseq_from_channel(buf, [0, fin], fname$0, lnum, ic);
      }
      function prettify(std, s2) {
        return pretty_to_string(std, from_string$0(0, 0, 0, s2));
      }
      function compact(param, s2) {
        return to_string(0, 0, 0, 0, from_string$0(0, 0, 0, s2));
      }
      var Type_error = [248, cst_Yojson_Safe_Util_Type_erro, caml_fresh_oo_id2(0)];
      function typerr(msg, js) {
        if (typeof js === "number")
          var _a5_ = cst_null$1;
        else
          var _a4_ = js[1], _a5_ = 726928360 <= _a4_ ? 737456202 === _a4_ ? cst_bool : 928231259 <= _a4_ ? 963043957 <= _a4_ ? cst_object : cst_floatlit : 848054398 <= _a4_ ? cst_array : cst_tuple : -752863768 === _a4_ ? cst_intlit : 365180284 <= _a4_ ? 708012133 <= _a4_ ? cst_variant : cst_float : 3654863 <= _a4_ ? cst_int : cst_string;
        throw caml_maybe_attach_backtrace2([0, Type_error, caml_call2(Stdlib[28], msg, _a5_), js], 1);
      }
      var Undefined = [248, cst_Yojson_Safe_Util_Undefined, caml_fresh_oo_id2(0)];
      function member(name, js) {
        if (typeof js !== "number" && 963043957 === js[1]) {
          var obj = js[2];
          try {
            var _a1_ = caml_call2(Stdlib_List[49], name, obj);
            return _a1_;
          } catch (_a3_) {
            var _a0_ = caml_wrap_exception2(_a3_);
            if (_a0_ === Stdlib[8])
              return 870828711;
            throw caml_maybe_attach_backtrace2(_a0_, 0);
          }
        }
        var _a2_ = caml_call2(Stdlib[28], name, cst_of_non_object_type);
        return typerr(caml_call2(Stdlib[28], cst_Can_t_get_member, _a2_), js);
      }
      function path(l, obj) {
        var l$0 = l, obj$0 = obj;
        for (; ; ) {
          if (!l$0)
            return [0, obj$0];
          var l$1 = l$0[2], key = l$0[1];
          if (typeof obj$0 !== "number" && 963043957 === obj$0[1]) {
            var assoc = obj$0[2];
            try {
              var obj$1 = caml_call2(Stdlib_List[49], key, assoc);
            } catch (_aZ_) {
              var _aY_ = caml_wrap_exception2(_aZ_);
              if (_aY_ === Stdlib[8])
                return 0;
              throw caml_maybe_attach_backtrace2(_aY_, 0);
            }
            var l$0 = l$1, obj$0 = obj$1;
            continue;
          }
          return 0;
        }
      }
      function index(i, js) {
        if (typeof js !== "number" && 848054398 === js[1]) {
          var l = js[2], len = caml_call1(Stdlib_List[1], l), wrapped_index = 0 <= i ? i : len + i | 0;
          if (0 <= wrapped_index && len > wrapped_index)
            return caml_call2(Stdlib_List[8], l, wrapped_index);
          var _aW_ = caml_call1(Stdlib[33], i), _aX_ = caml_call2(Stdlib[28], _aW_, cst_out_of_bounds);
          throw caml_maybe_attach_backtrace2([0, Undefined, caml_call2(Stdlib[28], cst_Index, _aX_), js], 1);
        }
        var _aU_ = caml_call1(Stdlib[33], i), _aV_ = caml_call2(Stdlib[28], _aU_, cst_of_non_array_type);
        return typerr(caml_call2(Stdlib[28], cst_Can_t_get_index, _aV_), js);
      }
      function map(f, js) {
        if (typeof js !== "number" && 848054398 === js[1]) {
          var l = js[2];
          return [0, 848054398, caml_call2(Stdlib_List[20], f, l)];
        }
        return typerr(cst_Can_t_map_function_over_no, js);
      }
      function to_assoc(js) {
        if (typeof js !== "number" && 963043957 === js[1]) {
          var obj = js[2];
          return obj;
        }
        return typerr(cst_Expected_object_got, js);
      }
      function to_option(f, x2) {
        if (typeof x2 === "number" && 870828711 === x2)
          return 0;
        return [0, caml_call1(f, x2)];
      }
      function to_bool(js) {
        if (typeof js !== "number" && 737456202 === js[1]) {
          var b = js[2];
          return b;
        }
        return typerr(cst_Expected_bool_got, js);
      }
      function to_bool_option(js) {
        if (typeof js === "number") {
          if (870828711 === js)
            return 0;
        } else if (737456202 === js[1]) {
          var b = js[2];
          return [0, b];
        }
        return typerr(cst_Expected_bool_or_null_got, js);
      }
      function to_number(js) {
        if (typeof js !== "number") {
          var _aT_ = js[1];
          if (3654863 === _aT_) {
            var i = js[2];
            return i;
          }
          if (365180284 === _aT_) {
            var f = js[2];
            return f;
          }
        }
        return typerr(cst_Expected_number_got, js);
      }
      function to_number_option(js) {
        if (typeof js === "number") {
          if (870828711 === js)
            return 0;
        } else {
          var _aS_ = js[1];
          if (3654863 === _aS_) {
            var i = js[2];
            return [0, i];
          }
          if (365180284 === _aS_) {
            var f = js[2];
            return [0, f];
          }
        }
        return typerr(cst_Expected_number_or_null_go, js);
      }
      function to_float(js) {
        if (typeof js !== "number" && 365180284 === js[1]) {
          var f = js[2];
          return f;
        }
        return typerr(cst_Expected_float_got, js);
      }
      function to_float_option(js) {
        if (typeof js === "number") {
          if (870828711 === js)
            return 0;
        } else if (365180284 === js[1]) {
          var f = js[2];
          return [0, f];
        }
        return typerr(cst_Expected_float_or_null_got, js);
      }
      function to_int(js) {
        if (typeof js !== "number" && 3654863 === js[1]) {
          var i = js[2];
          return i;
        }
        return typerr(cst_Expected_int_got, js);
      }
      function to_int_option(js) {
        if (typeof js === "number") {
          if (870828711 === js)
            return 0;
        } else if (3654863 === js[1]) {
          var i = js[2];
          return [0, i];
        }
        return typerr(cst_Expected_int_or_null_got, js);
      }
      function to_list(js) {
        if (typeof js !== "number" && 848054398 === js[1]) {
          var l = js[2];
          return l;
        }
        return typerr(cst_Expected_array_got, js);
      }
      function to_string$0(js) {
        if (typeof js !== "number" && -976970511 === js[1]) {
          var s2 = js[2];
          return s2;
        }
        return typerr(cst_Expected_string_got, js);
      }
      function to_string_option(js) {
        if (typeof js === "number") {
          if (870828711 === js)
            return 0;
        } else if (-976970511 === js[1]) {
          var s2 = js[2];
          return [0, s2];
        }
        return typerr(cst_Expected_string_or_null_go, js);
      }
      function convert_each(f, js) {
        if (typeof js !== "number" && 848054398 === js[1]) {
          var l = js[2];
          return caml_call2(Stdlib_List[20], f, l);
        }
        return typerr(cst_Can_t_convert_each_element, js);
      }
      function filter_map(f, l$0) {
        var acc = 0, l = l$0;
        for (; ; ) {
          if (!l)
            return caml_call1(Stdlib_List[10], acc);
          var tl = l[2], x2 = l[1], match = caml_call1(f, x2);
          if (match)
            var y = match[1], acc$0 = [0, y, acc], acc = acc$0, l = tl;
          else
            var l = tl;
        }
      }
      function flatten(l$0) {
        var acc = 0, l = l$0;
        for (; ; ) {
          if (!l)
            return caml_call1(Stdlib_List[10], acc);
          var tl = l[2], x2 = l[1];
          if (typeof x2 !== "number" && 848054398 === x2[1]) {
            var l2 = x2[2], acc$0 = caml_call2(Stdlib_List[13], l2, acc), acc = acc$0, l = tl;
            continue;
          }
          var l = tl;
        }
      }
      function filter_index(i, l) {
        return filter_map(
          function(param) {
            if (typeof param !== "number" && 848054398 === param[1]) {
              var l2 = param[2];
              try {
                var _aQ_ = [0, caml_call2(Stdlib_List[8], l2, i)];
                return _aQ_;
              } catch (_aR_) {
                return 0;
              }
            }
            return 0;
          },
          l
        );
      }
      function filter_list(l) {
        return filter_map(
          function(param) {
            if (typeof param !== "number" && 848054398 === param[1]) {
              var l2 = param[2];
              return [0, l2];
            }
            return 0;
          },
          l
        );
      }
      function filter_member(k, l) {
        return filter_map(
          function(param) {
            if (typeof param !== "number" && 963043957 === param[1]) {
              var l2 = param[2];
              try {
                var _aO_ = [0, caml_call2(Stdlib_List[49], k, l2)];
                return _aO_;
              } catch (_aP_) {
                return 0;
              }
            }
            return 0;
          },
          l
        );
      }
      function filter_assoc(l) {
        return filter_map(
          function(param) {
            if (typeof param !== "number" && 963043957 === param[1]) {
              var l2 = param[2];
              return [0, l2];
            }
            return 0;
          },
          l
        );
      }
      function filter_bool(l) {
        return filter_map(
          function(param) {
            if (typeof param !== "number" && 737456202 === param[1]) {
              var x2 = param[2];
              return [0, x2];
            }
            return 0;
          },
          l
        );
      }
      function filter_int(l) {
        return filter_map(
          function(param) {
            if (typeof param !== "number" && 3654863 === param[1]) {
              var x2 = param[2];
              return [0, x2];
            }
            return 0;
          },
          l
        );
      }
      function filter_float(l) {
        return filter_map(
          function(param) {
            if (typeof param !== "number" && 365180284 === param[1]) {
              var x2 = param[2];
              return [0, x2];
            }
            return 0;
          },
          l
        );
      }
      function filter_number(l) {
        return filter_map(
          function(param) {
            if (typeof param !== "number") {
              var _aN_ = param[1];
              if (3654863 === _aN_) {
                var x2 = param[2];
                return [0, x2];
              }
              if (365180284 === _aN_) {
                var x$0 = param[2];
                return [0, x$0];
              }
            }
            return 0;
          },
          l
        );
      }
      function filter_string(l) {
        return filter_map(
          function(param) {
            if (typeof param !== "number" && -976970511 === param[1]) {
              var x2 = param[2];
              return [0, x2];
            }
            return 0;
          },
          l
        );
      }
      function keys(o) {
        var _aM_ = to_assoc(o);
        return caml_call1(
          caml_call1(
            Stdlib_List[20],
            function(param) {
              var key = param[1];
              return key;
            }
          ),
          _aM_
        );
      }
      function values(o) {
        var _aL_ = to_assoc(o);
        return caml_call1(
          caml_call1(
            Stdlib_List[20],
            function(param) {
              var value = param[2];
              return value;
            }
          ),
          _aL_
        );
      }
      function combine(first, second) {
        if (typeof first !== "number" && 963043957 === first[1] && typeof second !== "number" && 963043957 === second[1]) {
          var b = second[2], a = first[2];
          return [0, 963043957, caml_call2(Stdlib[37], a, b)];
        }
        throw caml_maybe_attach_backtrace2([0, Stdlib[6], cst_Expected_two_objects_check], 1);
      }
      var Yojson_Safe = [
        0,
        pp$0,
        show,
        equal,
        to_basic,
        to_string,
        to_channel,
        to_output,
        to_file,
        to_buffer,
        seq_to_string,
        seq_to_channel,
        seq_to_file,
        seq_to_buffer,
        write_json,
        sort,
        write_null,
        write_bool,
        write_int,
        write_float,
        write_std_float,
        write_float_prec,
        write_std_float_prec,
        write_string,
        write_intlit,
        write_assoc,
        write_list,
        write_tuple,
        write_std_tuple,
        write_variant,
        write_std_variant,
        write_json,
        write_std_json,
        pretty_print,
        pretty_to_string,
        pretty_to_channel,
        prettify,
        compact,
        Finally,
        from_string$0,
        from_channel$0,
        from_file,
        init_lexer,
        from_lexbuf,
        seq_from_string,
        seq_from_channel,
        seq_from_file,
        seq_from_lexbuf,
        lineseq_from_channel,
        lineseq_from_file,
        read_json,
        finish_string,
        read_string,
        read_ident,
        map_string,
        map_ident,
        start_any_variant,
        finish_variant,
        finish_skip_variant,
        read_lt,
        read_gt,
        read_comma,
        finish_stringlit,
        finish_skip_stringlit,
        finish_escaped_char,
        finish_comment,
        read_space,
        read_eof,
        read_null,
        read_null_if_possible,
        read_bool,
        read_int,
        read_int8,
        read_int32,
        read_int64,
        read_number,
        skip_ident,
        read_sequence,
        read_list,
        read_list_rev,
        read_array_end,
        read_array_sep,
        read_array,
        read_tuple,
        start_any_tuple,
        read_lpar,
        read_rpar,
        read_tuple_end,
        read_tuple_end2,
        read_tuple_sep,
        read_tuple_sep2,
        read_lbr,
        read_rbr,
        read_fields,
        read_abstract_fields,
        read_lcurl,
        read_object_end,
        read_object_sep,
        read_colon,
        read_json,
        skip_json,
        buffer_json,
        [
          0,
          Type_error,
          Undefined,
          keys,
          values,
          combine,
          member,
          path,
          index,
          map,
          to_assoc,
          to_option,
          to_bool,
          to_bool_option,
          to_number,
          to_number_option,
          to_float,
          to_float_option,
          to_int,
          to_int_option,
          to_list,
          to_string$0,
          to_string_option,
          convert_each,
          filter_map,
          flatten,
          filter_index,
          filter_list,
          filter_member,
          filter_assoc,
          filter_bool,
          filter_int,
          filter_float,
          filter_number,
          filter_string
        ]
      ];
      runtime.caml_register_global(325, Yojson_Safe, "Yojson__Safe");
      return;
    })(globalThis);
    (function(globalThis2) {
      "use strict";
      var runtime = globalThis2.jsoo_runtime, cst_5_7_2 = "5.7.2", s2 = cst_5_7_2, git_version = cst_5_7_2, Jsoo_runtime_Runtime_version = [0, s2, git_version];
      runtime.caml_register_global(2, Jsoo_runtime_Runtime_version, "Jsoo_runtime__Runtime_version");
      return;
    })(globalThis);
    (function(globalThis2) {
      "use strict";
      var runtime = globalThis2.jsoo_runtime;
      function caml_call2(f, a0, a1) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 2 ? f(a0, a1) : runtime.caml_call_gen(f, [a0, a1]);
      }
      var global_data = runtime.caml_get_global_data(), Jsoo_runtime_Runtime_version = global_data.Jsoo_runtime__Runtime_version, Stdlib_Callback = global_data.Stdlib__Callback, Js = [0], Config = [0], version = Jsoo_runtime_Runtime_version[1], git_version = Jsoo_runtime_Runtime_version[2], Sys = [0, Config, version, git_version], Exn = [248, "Jsoo_runtime.Error.Exn", runtime.caml_fresh_oo_id(0)];
      caml_call2(Stdlib_Callback[2], "jsError", [0, Exn, [0]]);
      function raise(exn) {
        throw exn;
      }
      var Error2 = [
        0,
        raise,
        runtime.caml_exn_with_js_backtrace,
        runtime.caml_js_error_option_of_exception,
        Exn
      ], For_compatibility_only = [0], Bigstring = [0], Typed_array = [0, Bigstring], Int64 = [0], Jsoo_runtime = [0, Js, Sys, Error2, For_compatibility_only, Typed_array, Int64];
      runtime.caml_register_global(5, Jsoo_runtime, "Jsoo_runtime");
      return;
    })(globalThis);
    (function(globalThis2) {
      "use strict";
      var runtime = globalThis2.jsoo_runtime, global_data = runtime.caml_get_global_data(), Stdlib_String = global_data.Stdlib__String, Stdlib_Char = global_data.Stdlib__Char, Poly = [0];
      function max(x2, y) {
        return y <= x2 ? x2 : y;
      }
      function min(x2, y) {
        return x2 <= y ? x2 : y;
      }
      var Int_replace_polymorphic_compar = [0, max, min], make = Stdlib_String[1], init = Stdlib_String[2], empty = Stdlib_String[3], of_bytes = Stdlib_String[4], to_bytes = Stdlib_String[5], blit = Stdlib_String[6], concat = Stdlib_String[7], cat = Stdlib_String[8], compare = Stdlib_String[10], starts_with = Stdlib_String[11], ends_with = Stdlib_String[12], contains_from = Stdlib_String[13], rcontains_from = Stdlib_String[14], contains = Stdlib_String[15], sub = Stdlib_String[16], split_on_char = Stdlib_String[17], map = Stdlib_String[18], mapi = Stdlib_String[19], fold_left = Stdlib_String[20], fold_right = Stdlib_String[21], for_all = Stdlib_String[22], exists = Stdlib_String[23], trim = Stdlib_String[24], escaped = Stdlib_String[25], uppercase_ascii = Stdlib_String[26], lowercase_ascii = Stdlib_String[27], capitalize_ascii = Stdlib_String[28], uncapitalize_ascii = Stdlib_String[29], iter = Stdlib_String[30], iteri = Stdlib_String[31], index_from = Stdlib_String[32], index_from_opt = Stdlib_String[33], rindex_from = Stdlib_String[34], rindex_from_opt = Stdlib_String[35], index = Stdlib_String[36], index_opt = Stdlib_String[37], rindex = Stdlib_String[38], rindex_opt = Stdlib_String[39], to_seq = Stdlib_String[40], to_seqi = Stdlib_String[41], of_seq = Stdlib_String[42], get_utf_8_uchar = Stdlib_String[43], is_valid_utf_8 = Stdlib_String[44], get_utf_16be_uchar = Stdlib_String[45], is_valid_utf_16be = Stdlib_String[46], get_utf_16le_uchar = Stdlib_String[47], is_valid_utf_16le = Stdlib_String[48], get_uint8 = Stdlib_String[49], get_int8 = Stdlib_String[50], get_uint16_ne = Stdlib_String[51], get_uint16_be = Stdlib_String[52], get_uint16_le = Stdlib_String[53], get_int16_ne = Stdlib_String[54], get_int16_be = Stdlib_String[55], get_int16_le = Stdlib_String[56], get_int32_ne = Stdlib_String[57], hash = Stdlib_String[58], seeded_hash = Stdlib_String[59], get_int32_be = Stdlib_String[60], get_int32_le = Stdlib_String[61], get_int64_ne = Stdlib_String[62], get_int64_be = Stdlib_String[63], get_int64_le = Stdlib_String[64], equal = runtime.caml_string_equal, String2 = [
        0,
        make,
        init,
        empty,
        of_bytes,
        to_bytes,
        blit,
        concat,
        cat,
        compare,
        starts_with,
        ends_with,
        contains_from,
        rcontains_from,
        contains,
        sub,
        split_on_char,
        map,
        mapi,
        fold_left,
        fold_right,
        for_all,
        exists,
        trim,
        escaped,
        uppercase_ascii,
        lowercase_ascii,
        capitalize_ascii,
        uncapitalize_ascii,
        iter,
        iteri,
        index_from,
        index_from_opt,
        rindex_from,
        rindex_from_opt,
        index,
        index_opt,
        rindex,
        rindex_opt,
        to_seq,
        to_seqi,
        of_seq,
        get_utf_8_uchar,
        is_valid_utf_8,
        get_utf_16be_uchar,
        is_valid_utf_16be,
        get_utf_16le_uchar,
        is_valid_utf_16le,
        get_uint8,
        get_int8,
        get_uint16_ne,
        get_uint16_be,
        get_uint16_le,
        get_int16_ne,
        get_int16_be,
        get_int16_le,
        get_int32_ne,
        hash,
        seeded_hash,
        get_int32_be,
        get_int32_le,
        get_int64_ne,
        get_int64_be,
        get_int64_le,
        equal
      ], chr = Stdlib_Char[1], escaped$0 = Stdlib_Char[2], lowercase_ascii$0 = Stdlib_Char[3], uppercase_ascii$0 = Stdlib_Char[4], compare$0 = Stdlib_Char[5], seeded_hash$0 = Stdlib_Char[7], hash$0 = Stdlib_Char[8];
      function equal$0(x2, y) {
        return x2 === y ? 1 : 0;
      }
      var Char = [
        0,
        chr,
        escaped$0,
        lowercase_ascii$0,
        uppercase_ascii$0,
        compare$0,
        seeded_hash$0,
        hash$0,
        equal$0
      ], max$0 = Int_replace_polymorphic_compar[1], min$0 = Int_replace_polymorphic_compar[2], Js_of_ocaml_Import = [0, Poly, Int_replace_polymorphic_compar, String2, Char, max$0, min$0];
      runtime.caml_register_global(2, Js_of_ocaml_Import, "Js_of_ocaml__Import");
      return;
    })(globalThis);
    (function(globalThis2) {
      "use strict";
      var jsoo_exports = typeof module === "object" && module.exports || globalThis2, runtime = globalThis2.jsoo_runtime, cst_parseFloat$0 = "parseFloat", cst_parseInt$0 = "parseInt", caml_js_get2 = runtime.caml_js_get, caml_js_set2 = runtime.caml_js_set, caml_js_wrap_callback2 = runtime.caml_js_wrap_callback, caml_string_of_jsstring2 = runtime.caml_string_of_jsstring;
      function caml_call1(f, a0) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 1 ? f(a0) : runtime.caml_call_gen(f, [a0]);
      }
      function caml_call2(f, a0, a1) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 2 ? f(a0, a1) : runtime.caml_call_gen(f, [a0, a1]);
      }
      var global_data = runtime.caml_get_global_data(), Js_of_ocaml_Import = global_data.Js_of_ocaml__Import, Stdlib = global_data.Stdlib, Jsoo_runtime = global_data.Jsoo_runtime, Stdlib_Printexc = global_data.Stdlib__Printexc, global = globalThis2, Unsafe = [0, global], null$0 = null, undefined$0 = void 0;
      function return$0(_p_) {
        return _p_;
      }
      function map(x2, f) {
        return x2 == null$0 ? null$0 : caml_call1(f, x2);
      }
      function bind(x2, f) {
        return x2 == null$0 ? null$0 : caml_call1(f, x2);
      }
      function test(x2) {
        return 1 - (x2 == null$0 ? 1 : 0);
      }
      function iter(x2, f) {
        var _o_ = 1 - (x2 == null$0 ? 1 : 0);
        return _o_ ? caml_call1(f, x2) : _o_;
      }
      function case$0(x2, f, g) {
        return x2 == null$0 ? caml_call1(f, 0) : caml_call1(g, x2);
      }
      function get(x2, f) {
        return x2 == null$0 ? caml_call1(f, 0) : x2;
      }
      function option(x2) {
        if (!x2)
          return null$0;
        var x$0 = x2[1];
        return x$0;
      }
      function to_option(x2) {
        return case$0(x2, function(param) {
          return 0;
        }, function(x3) {
          return [0, x3];
        });
      }
      var Opt = [
        0,
        null$0,
        return$0,
        map,
        bind,
        test,
        iter,
        case$0,
        get,
        option,
        to_option
      ];
      function return$1(_n_) {
        return _n_;
      }
      function map$0(x2, f) {
        return x2 === undefined$0 ? undefined$0 : caml_call1(f, x2);
      }
      function bind$0(x2, f) {
        return x2 === undefined$0 ? undefined$0 : caml_call1(f, x2);
      }
      function test$0(x2) {
        return 1 - (x2 === undefined$0 ? 1 : 0);
      }
      function iter$0(x2, f) {
        var _m_ = 1 - (x2 === undefined$0 ? 1 : 0);
        return _m_ ? caml_call1(f, x2) : _m_;
      }
      function case$1(x2, f, g) {
        return x2 === undefined$0 ? caml_call1(f, 0) : caml_call1(g, x2);
      }
      function get$0(x2, f) {
        return x2 === undefined$0 ? caml_call1(f, 0) : x2;
      }
      function option$0(x2) {
        if (!x2)
          return undefined$0;
        var x$0 = x2[1];
        return x$0;
      }
      function to_option$0(x2) {
        return case$1(x2, function(param) {
          return 0;
        }, function(x3) {
          return [0, x3];
        });
      }
      var Optdef = [
        0,
        undefined$0,
        return$1,
        map$0,
        bind$0,
        test$0,
        iter$0,
        case$1,
        get$0,
        option$0,
        to_option$0
      ];
      function coerce(x2, f, g) {
        var _l_ = caml_call1(f, x2);
        return caml_call2(Opt[8], _l_, function(param) {
          return caml_call1(g, x2);
        });
      }
      function coerce_opt(x2, f, g) {
        var _k_ = caml_call2(Opt[4], x2, f);
        return caml_call2(Opt[8], _k_, function(param) {
          return caml_call1(g, x2);
        });
      }
      var true$0 = true, false$0 = false, nfc = "NFC", nfd = "NFD", nfkc = "NFKC", nfkd = "NFKD", t0 = Unsafe[1], string_constr = t0.String, t1 = Unsafe[1], regExp = t1.RegExp, t2 = Unsafe[1], object_constructor = t2.Object;
      function object_keys(o) {
        return object_constructor.keys(o);
      }
      var t5 = Unsafe[1], array_constructor = t5.Array, array_get = caml_js_get2, array_set = caml_js_set2;
      function array_map(f, a) {
        return a.map(caml_js_wrap_callback2(function(x2, idx, param) {
          return caml_call1(f, x2);
        }));
      }
      function array_mapi(f, a) {
        return a.map(caml_js_wrap_callback2(function(x2, idx, param) {
          return caml_call2(f, idx, x2);
        }));
      }
      function str_array(_j_) {
        return _j_;
      }
      function match_result(_i_) {
        return _i_;
      }
      var t8 = Unsafe[1], date_constr = t8.Date, t9 = Unsafe[1], math = t9.Math, t10 = Unsafe[1], error_constr = t10.Error, include = Jsoo_runtime[3], raise = include[1], exn_with_js_backtrace = include[2], of_exn = include[3], Error2 = include[4];
      function name(t11) {
        return caml_string_of_jsstring2(t11.name);
      }
      function message(t12) {
        return caml_string_of_jsstring2(t12.message);
      }
      function stack(t13) {
        var _h_ = caml_call2(Opt[3], t13.stack, caml_string_of_jsstring2);
        return caml_call1(Opt[10], _h_);
      }
      function to_string(e) {
        return caml_string_of_jsstring2(e.toString());
      }
      function raise_js_error(e) {
        return caml_call1(raise, e);
      }
      function string_of_error(e) {
        return to_string(e);
      }
      var t15 = Unsafe[1], JSON2 = t15.JSON, cst_parseInt = cst_parseInt$0, cst_parseFloat = cst_parseFloat$0;
      function decodeURI(s2) {
        var t16 = Unsafe[1];
        return t16.decodeURI(s2);
      }
      function decodeURIComponent(s2) {
        var t17 = Unsafe[1];
        return t17.decodeURIComponent(s2);
      }
      function encodeURI(s2) {
        var t18 = Unsafe[1];
        return t18.encodeURI(s2);
      }
      function encodeURIComponent(s2) {
        var t19 = Unsafe[1];
        return t19.encodeURIComponent(s2);
      }
      function escape(s2) {
        var t20 = Unsafe[1];
        return t20.escape(s2);
      }
      function unescape(s2) {
        var t21 = Unsafe[1];
        return t21.unescape(s2);
      }
      function isNaN2(i) {
        var t22 = Unsafe[1];
        return t22.isNaN(i) | 0;
      }
      function parseInt2(s2) {
        var t23 = Unsafe[1], s$0 = t23.parseInt(s2);
        return isNaN2(s$0) ? caml_call1(Stdlib[2], cst_parseInt) : s$0;
      }
      function parseFloat(s2) {
        var t24 = Unsafe[1], s$0 = t24.parseFloat(s2);
        return isNaN2(s$0) ? caml_call1(Stdlib[2], cst_parseFloat) : s$0;
      }
      caml_call1(
        Stdlib_Printexc[9],
        function(param) {
          if (param[1] !== Error2)
            return 0;
          var e = param[2];
          return [0, to_string(e)];
        }
      );
      caml_call1(
        Stdlib_Printexc[9],
        function(e) {
          return e instanceof array_constructor ? 0 : [0, caml_string_of_jsstring2(e.toString())];
        }
      );
      var cst_function = "function";
      function export_js(field, x2) {
        var _f_ = caml_string_of_jsstring2(typeof x2);
        a: {
          if (caml_call2(Js_of_ocaml_Import[3][64], _f_, cst_function) && 0 < x2.length) {
            var _g_ = caml_js_wrap_callback2(x2);
            break a;
          }
          var _g_ = x2;
        }
        return jsoo_exports[field] = _g_;
      }
      function export$0(field, x2) {
        return export_js(runtime.caml_jsstring_of_string(field), x2);
      }
      function export_all(obj) {
        var keys = object_keys(obj);
        return keys.forEach(caml_js_wrap_callback2(function(key, param, _e_) {
          return export_js(key, obj[key]);
        }));
      }
      var Js_of_ocaml_Js = [
        0,
        null$0,
        function(_d_) {
          return _d_;
        },
        undefined$0,
        function(_c_) {
          return _c_;
        },
        Opt,
        Optdef,
        true$0,
        false$0,
        nfd,
        nfc,
        nfkd,
        nfkc,
        string_constr,
        regExp,
        regExp,
        regExp,
        object_keys,
        array_constructor,
        array_constructor,
        array_get,
        array_set,
        array_map,
        array_mapi,
        str_array,
        match_result,
        date_constr,
        date_constr,
        date_constr,
        date_constr,
        date_constr,
        date_constr,
        date_constr,
        date_constr,
        date_constr,
        math,
        error_constr,
        [
          0,
          to_string,
          name,
          message,
          stack,
          raise,
          exn_with_js_backtrace,
          of_exn,
          Error2,
          function(_b_) {
            return _b_;
          },
          function(_a_) {
            return _a_;
          }
        ],
        JSON2,
        decodeURI,
        decodeURIComponent,
        encodeURI,
        encodeURIComponent,
        escape,
        unescape,
        isNaN2,
        parseInt2,
        parseFloat,
        coerce,
        coerce_opt,
        export$0,
        export_all,
        Unsafe,
        string_of_error,
        raise_js_error,
        exn_with_js_backtrace,
        runtime.caml_js_error_of_exception,
        Error2
      ];
      runtime.caml_register_global(43, Js_of_ocaml_Js, "Js_of_ocaml__Js");
      return;
    })(globalThis);
    (function(globalThis2) {
      "use strict";
      var runtime = globalThis2.jsoo_runtime, cst$0 = "", cst$8 = " =", cst_S = "%S", cst_a = "%a", cst_d = "%d", cst$1 = "(@[", cst$6 = "))", cst$3 = ",@ ", cst$10 = ";@ ", cst_2 = "<2>", cst$2 = "@ ", cst$5 = "@,", cst$7 = "@,))@]", cst_s = "@[%s =@ ", cst$9 = "@]", cst$4 = "@])", caml_update_dummy2 = runtime.caml_update_dummy;
      function caml_call1(f, a0) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 1 ? f(a0) : runtime.caml_call_gen(f, [a0]);
      }
      function caml_call2(f, a0, a1) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 2 ? f(a0, a1) : runtime.caml_call_gen(f, [a0, a1]);
      }
      function caml_call3(f, a0, a1, a2) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 3 ? f(a0, a1, a2) : runtime.caml_call_gen(f, [a0, a1, a2]);
      }
      var global_data = runtime.caml_get_global_data(), cst = ")", Stdlib_Format = global_data.Stdlib__Format, Stdlib_List = global_data.Stdlib__List, _a_ = [0, [12, 40, [18, [1, [0, 0, cst$0]], 0]], cst$1], _b_ = [0, [4, 0, 0, 0, 0], cst_d], _c_ = [0, [12, 44, [17, [0, cst$2, 1, 0], 0]], cst$3], _d_ = [0, [4, 0, 0, 0, 0], cst_d], _e_ = [0, [17, 0, [12, 41, 0]], cst$4], _f_ = [0, [15, 0], cst_a];
      function pp_pos(fmt, param) {
        var a1 = param[2], a0 = param[1];
        caml_call2(Stdlib_Format[137], fmt, _a_);
        caml_call1(caml_call2(Stdlib_Format[137], fmt, _b_), a0);
        caml_call2(Stdlib_Format[137], fmt, _c_);
        caml_call1(caml_call2(Stdlib_Format[137], fmt, _d_), a1);
        return caml_call2(Stdlib_Format[137], fmt, _e_);
      }
      function show_pos(x2) {
        return caml_call3(Stdlib_Format[141], _f_, pp_pos, x2);
      }
      var pp_pstring = function _aB_(_az_, _aA_) {
        return _aB_.fun(_az_, _aA_);
      }, show_pstring = function _ay_(_ax_) {
        return _ay_.fun(_ax_);
      }, _g_ = [0, [12, 40, [18, [1, [0, 0, cst$0]], 0]], cst$1], _h_ = [0, [12, 44, [17, [0, cst$2, 1, 0], 0]], cst$3], _i_ = [0, [18, [1, [0, [11, cst_2, 0], cst_2]], [12, 91, 0]], "@[<2>["], _j_ = [0, [12, 59, [17, [0, cst$2, 1, 0], 0]], cst$10], _k_ = [0, [1, 0], "%C"], _l_ = [0, [17, [0, cst$5, 0, 0], [12, 93, [17, 0, 0]]], "@,]@]"], _m_ = [0, [17, 0, [12, 41, 0]], cst$4];
      caml_update_dummy2(
        pp_pstring,
        function(fmt, param) {
          var a1 = param[2], a0 = param[1];
          caml_call2(Stdlib_Format[137], fmt, _g_);
          pp_pos(fmt, a0);
          caml_call2(Stdlib_Format[137], fmt, _h_);
          caml_call2(Stdlib_Format[137], fmt, _i_);
          caml_call3(
            Stdlib_List[26],
            function(sep, x2) {
              if (sep)
                caml_call2(Stdlib_Format[137], fmt, _j_);
              caml_call1(caml_call2(Stdlib_Format[137], fmt, _k_), x2);
              return 1;
            },
            0,
            a1
          );
          caml_call2(Stdlib_Format[137], fmt, _l_);
          return caml_call2(Stdlib_Format[137], fmt, _m_);
        }
      );
      var _n_ = [0, [15, 0], cst_a];
      caml_update_dummy2(
        show_pstring,
        function(x2) {
          return caml_call3(Stdlib_Format[141], _n_, pp_pstring, x2);
        }
      );
      var pp_location = function _aw_(_au_, _av_) {
        return _aw_.fun(_au_, _av_);
      }, show_location = function _at_(_as_) {
        return _at_.fun(_as_);
      }, _o_ = [0, [12, 40, [18, [1, [0, 0, cst$0]], 0]], cst$1], _p_ = [0, [12, 44, [17, [0, cst$2, 1, 0], 0]], cst$3], _q_ = [0, [17, 0, [12, 41, 0]], cst$4];
      caml_update_dummy2(
        pp_location,
        function(fmt, param) {
          var a1 = param[2], a0 = param[1];
          caml_call2(Stdlib_Format[137], fmt, _o_);
          pp_pos(fmt, a0);
          caml_call2(Stdlib_Format[137], fmt, _p_);
          pp_pos(fmt, a1);
          return caml_call2(Stdlib_Format[137], fmt, _q_);
        }
      );
      var _r_ = [0, [15, 0], cst_a];
      caml_update_dummy2(
        show_location,
        function(x2) {
          return caml_call3(Stdlib_Format[141], _r_, pp_location, x2);
        }
      );
      var pp_ty = function _ar_(_ap_, _aq_) {
        return _ar_.fun(_ap_, _aq_);
      }, show_ty = function _ao_(_an_) {
        return _ao_.fun(_an_);
      }, cst_TyBool = "TyBool", cst_TyInt = "TyInt", _s_ = [
        0,
        [
          12,
          40,
          [
            18,
            [1, [0, [11, cst_2, 0], cst_2]],
            [11, "TyArr (", [17, [0, cst$5, 0, 0], 0]]
          ]
        ],
        "(@[<2>TyArr (@,"
      ], _t_ = [0, [12, 44, [17, [0, cst$2, 1, 0], 0]], cst$3], _u_ = [0, [17, [0, cst$5, 0, 0], [11, cst$6, [17, 0, 0]]], cst$7], _v_ = [
        0,
        [
          12,
          40,
          [
            18,
            [1, [0, [11, cst_2, 0], cst_2]],
            [11, "TyId", [17, [0, cst$2, 1, 0], 0]]
          ]
        ],
        "(@[<2>TyId@ "
      ], _w_ = [0, [3, 0, 0], cst_S], _x_ = [0, [17, 0, [12, 41, 0]], cst$4], _y_ = [
        0,
        [
          12,
          40,
          [
            18,
            [1, [0, [11, cst_2, 0], cst_2]],
            [11, "TyQId", [17, [0, cst$2, 1, 0], 0]]
          ]
        ],
        "(@[<2>TyQId@ "
      ], _z_ = [0, [3, 0, 0], cst_S], _A_ = [0, [17, 0, [12, 41, 0]], cst$4];
      caml_update_dummy2(
        pp_ty,
        function(fmt, param) {
          if (typeof param === "number")
            return 0 === param ? caml_call2(Stdlib_Format[13], fmt, cst_TyBool) : caml_call2(Stdlib_Format[13], fmt, cst_TyInt);
          switch (param[0]) {
            case 0:
              var a1 = param[2], a0 = param[1];
              caml_call2(Stdlib_Format[137], fmt, _s_);
              caml_call1(caml_call1(pp_ty, fmt), a0);
              caml_call2(Stdlib_Format[137], fmt, _t_);
              caml_call1(caml_call1(pp_ty, fmt), a1);
              return caml_call2(Stdlib_Format[137], fmt, _u_);
            case 1:
              var a0$0 = param[1];
              caml_call2(Stdlib_Format[137], fmt, _v_);
              caml_call1(caml_call2(Stdlib_Format[137], fmt, _w_), a0$0);
              return caml_call2(Stdlib_Format[137], fmt, _x_);
            default:
              var a0$1 = param[1];
              caml_call2(Stdlib_Format[137], fmt, _y_);
              caml_call1(caml_call2(Stdlib_Format[137], fmt, _z_), a0$1);
              return caml_call2(Stdlib_Format[137], fmt, _A_);
          }
        }
      );
      var _B_ = [0, [15, 0], cst_a];
      caml_update_dummy2(
        show_ty,
        function(x2) {
          return caml_call3(Stdlib_Format[141], _B_, pp_ty, x2);
        }
      );
      var pp_term = function _am_(_ak_, _al_) {
        return _am_.fun(_ak_, _al_);
      }, show_term = function _aj_(_ai_) {
        return _aj_.fun(_ai_);
      }, pp_term_desc = function _ah_(_af_, _ag_) {
        return _ah_.fun(_af_, _ag_);
      }, show_term_desc = function _ae_(_ad_) {
        return _ae_.fun(_ad_);
      }, _C_ = [0, [18, [1, [0, [11, cst_2, 0], cst_2]], [11, "{ ", 0]], "@[<2>{ "], cst_desc = "desc", _D_ = [
        0,
        [
          18,
          [1, [0, 0, cst$0]],
          [2, 0, [11, cst$8, [17, [0, cst$2, 1, 0], 0]]]
        ],
        cst_s
      ], _E_ = [0, [17, 0, 0], cst$9], _F_ = [0, [12, 59, [17, [0, cst$2, 1, 0], 0]], cst$10], cst_loc = "loc", _G_ = [
        0,
        [
          18,
          [1, [0, 0, cst$0]],
          [2, 0, [11, cst$8, [17, [0, cst$2, 1, 0], 0]]]
        ],
        cst_s
      ], _H_ = [0, [17, 0, 0], cst$9], _I_ = [0, [17, [0, cst$2, 1, 0], [12, 125, [17, 0, 0]]], "@ }@]"];
      caml_update_dummy2(
        pp_term,
        function(fmt, x2) {
          caml_call2(Stdlib_Format[137], fmt, _C_);
          caml_call3(Stdlib_Format[137], fmt, _D_, cst_desc);
          var _ab_ = x2[1];
          caml_call1(caml_call1(pp_term_desc, fmt), _ab_);
          caml_call2(Stdlib_Format[137], fmt, _E_);
          caml_call2(Stdlib_Format[137], fmt, _F_);
          caml_call3(Stdlib_Format[137], fmt, _G_, cst_loc);
          var _ac_ = x2[2];
          caml_call1(caml_call1(pp_location, fmt), _ac_);
          caml_call2(Stdlib_Format[137], fmt, _H_);
          return caml_call2(Stdlib_Format[137], fmt, _I_);
        }
      );
      var _J_ = [0, [15, 0], cst_a];
      caml_update_dummy2(
        show_term,
        function(x2) {
          return caml_call3(Stdlib_Format[141], _J_, pp_term, x2);
        }
      );
      var cst_TmInt = "TmInt", cst_TmBool = "TmBool", _K_ = [
        0,
        [
          12,
          40,
          [
            18,
            [1, [0, [11, cst_2, 0], cst_2]],
            [11, "TmVar", [17, [0, cst$2, 1, 0], 0]]
          ]
        ],
        "(@[<2>TmVar@ "
      ], _L_ = [0, [3, 0, 0], cst_S], _M_ = [0, [17, 0, [12, 41, 0]], cst$4], _N_ = [
        0,
        [
          12,
          40,
          [
            18,
            [1, [0, [11, cst_2, 0], cst_2]],
            [11, "TmAbs (", [17, [0, cst$5, 0, 0], 0]]
          ]
        ],
        "(@[<2>TmAbs (@,"
      ], _O_ = [0, [3, 0, 0], cst_S], _P_ = [0, [12, 44, [17, [0, cst$2, 1, 0], 0]], cst$3], cst_Some = "(Some ", cst_None = "None", _Q_ = [0, [12, 44, [17, [0, cst$2, 1, 0], 0]], cst$3], _R_ = [0, [17, [0, cst$5, 0, 0], [11, cst$6, [17, 0, 0]]], cst$7], _S_ = [
        0,
        [
          12,
          40,
          [
            18,
            [1, [0, [11, cst_2, 0], cst_2]],
            [11, "TmApp (", [17, [0, cst$5, 0, 0], 0]]
          ]
        ],
        "(@[<2>TmApp (@,"
      ], _T_2 = [0, [12, 44, [17, [0, cst$2, 1, 0], 0]], cst$3], _U_ = [0, [17, [0, cst$5, 0, 0], [11, cst$6, [17, 0, 0]]], cst$7], _V_ = [
        0,
        [
          12,
          40,
          [
            18,
            [1, [0, [11, cst_2, 0], cst_2]],
            [11, "TmLet (", [17, [0, cst$5, 0, 0], 0]]
          ]
        ],
        "(@[<2>TmLet (@,"
      ], _W_ = [0, [9, 0, 0], "%B"], _X_ = [0, [12, 44, [17, [0, cst$2, 1, 0], 0]], cst$3], _Y_ = [0, [3, 0, 0], cst_S], _Z_ = [0, [12, 44, [17, [0, cst$2, 1, 0], 0]], cst$3], ___ = [0, [12, 44, [17, [0, cst$2, 1, 0], 0]], cst$3], _$_ = [0, [17, [0, cst$5, 0, 0], [11, cst$6, [17, 0, 0]]], cst$7];
      caml_update_dummy2(
        pp_term_desc,
        function(fmt, param) {
          if (typeof param === "number")
            return 0 === param ? caml_call2(Stdlib_Format[13], fmt, cst_TmInt) : caml_call2(Stdlib_Format[13], fmt, cst_TmBool);
          switch (param[0]) {
            case 0:
              var a0 = param[1];
              caml_call2(Stdlib_Format[137], fmt, _K_);
              caml_call1(caml_call2(Stdlib_Format[137], fmt, _L_), a0);
              return caml_call2(Stdlib_Format[137], fmt, _M_);
            case 1:
              var a2 = param[3], a1 = param[2], a0$0 = param[1];
              caml_call2(Stdlib_Format[137], fmt, _N_);
              caml_call1(caml_call2(Stdlib_Format[137], fmt, _O_), a0$0);
              caml_call2(Stdlib_Format[137], fmt, _P_);
              if (a1) {
                var x2 = a1[1];
                caml_call2(Stdlib_Format[13], fmt, cst_Some);
                caml_call1(caml_call1(pp_ty, fmt), x2);
                caml_call2(Stdlib_Format[13], fmt, cst);
              } else
                caml_call2(Stdlib_Format[13], fmt, cst_None);
              caml_call2(Stdlib_Format[137], fmt, _Q_);
              caml_call1(caml_call1(pp_term, fmt), a2);
              return caml_call2(Stdlib_Format[137], fmt, _R_);
            case 2:
              var a1$0 = param[2], a0$1 = param[1];
              caml_call2(Stdlib_Format[137], fmt, _S_);
              caml_call1(caml_call1(pp_term, fmt), a0$1);
              caml_call2(Stdlib_Format[137], fmt, _T_2);
              caml_call1(caml_call1(pp_term, fmt), a1$0);
              return caml_call2(Stdlib_Format[137], fmt, _U_);
            default:
              var a3 = param[4], a2$0 = param[3], a1$1 = param[2], a0$2 = param[1];
              caml_call2(Stdlib_Format[137], fmt, _V_);
              caml_call1(caml_call2(Stdlib_Format[137], fmt, _W_), a0$2);
              caml_call2(Stdlib_Format[137], fmt, _X_);
              caml_call1(caml_call2(Stdlib_Format[137], fmt, _Y_), a1$1);
              caml_call2(Stdlib_Format[137], fmt, _Z_);
              caml_call1(caml_call1(pp_term, fmt), a2$0);
              caml_call2(Stdlib_Format[137], fmt, ___);
              caml_call1(caml_call1(pp_term, fmt), a3);
              return caml_call2(Stdlib_Format[137], fmt, _$_);
          }
        }
      );
      var _aa_ = [0, [15, 0], cst_a];
      caml_update_dummy2(
        show_term_desc,
        function(x2) {
          return caml_call3(Stdlib_Format[141], _aa_, pp_term_desc, x2);
        }
      );
      var Parsing_Syntax = [
        0,
        pp_pos,
        show_pos,
        pp_pstring,
        show_pstring,
        pp_location,
        show_location,
        pp_ty,
        show_ty,
        pp_term,
        show_term,
        pp_term_desc,
        show_term_desc
      ];
      runtime.caml_register_global(66, Parsing_Syntax, "Parsing__Syntax");
      return;
    })(globalThis);
    (function(globalThis2) {
      "use strict";
      var runtime = globalThis2.jsoo_runtime;
      function caml_call1(f, a0) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 1 ? f(a0) : runtime.caml_call_gen(f, [a0]);
      }
      function caml_call2(f, a0, a1) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 2 ? f(a0, a1) : runtime.caml_call_gen(f, [a0, a1]);
      }
      var global_data = runtime.caml_get_global_data(), Result = global_data.Result, cst_zero = "zero";
      function return$0(v, s2) {
        return [0, [0, v, s2]];
      }
      function bind(stm, f, s2) {
        var _E_ = caml_call1(stm, s2);
        return caml_call2(
          Result[6],
          _E_,
          function(param) {
            var s3 = param[2], v = param[1];
            return caml_call2(f, v, s3);
          }
        );
      }
      function fail(msg, s2) {
        return [1, [0, msg, s2]];
      }
      function zero(s2) {
        return fail(cst_zero, s2);
      }
      function symbol(p1, p2, s2) {
        var match = caml_call1(p1, s2);
        if (0 !== match[0])
          return caml_call1(p2, s2);
        var v = match[1];
        return [0, v];
      }
      function update(f, s2) {
        return [0, [0, s2, caml_call1(f, s2)]];
      }
      function set(s2) {
        function _C_(param) {
          return s2;
        }
        return function(_D_) {
          return update(_C_, _D_);
        };
      }
      function fetch(s2) {
        return update(function(x2) {
          return x2;
        }, s2);
      }
      function many(p) {
        var _q_ = 0;
        function _r_(_B_) {
          return return$0(_q_, _B_);
        }
        function _s_(x2) {
          function _w_(xs) {
            var _z_ = [0, x2, xs];
            return function(_A_) {
              return return$0(_z_, _A_);
            };
          }
          var _x_ = many(p);
          return function(_y_) {
            return bind(_x_, _w_, _y_);
          };
        }
        function _t_(_v_) {
          return bind(p, _s_, _v_);
        }
        return function(_u_) {
          return symbol(_t_, _r_, _u_);
        };
      }
      function many1(p) {
        function _j_(x2) {
          function _l_(xs) {
            var _o_ = [0, x2, xs];
            return function(_p_) {
              return return$0(_o_, _p_);
            };
          }
          var _m_ = many(p);
          return function(_n_) {
            return bind(_m_, _l_, _n_);
          };
        }
        return function(_k_) {
          return bind(p, _j_, _k_);
        };
      }
      function optional(p) {
        var _a_ = 0;
        function _b_(_i_) {
          return return$0(_a_, _i_);
        }
        function _c_(x2) {
          var _g_ = [0, x2];
          return function(_h_) {
            return return$0(_g_, _h_);
          };
        }
        function _d_(_f_) {
          return bind(p, _c_, _f_);
        }
        return function(_e_) {
          return symbol(_d_, _b_, _e_);
        };
      }
      var Parsing_Monad = [
        0,
        return$0,
        bind,
        bind,
        fail,
        zero,
        symbol,
        update,
        set,
        fetch,
        many,
        many1,
        optional
      ];
      runtime.caml_register_global(2, Parsing_Monad, "Parsing__Monad");
      return;
    })(globalThis);
    (function(globalThis2) {
      "use strict";
      var runtime = globalThis2.jsoo_runtime, cst$3 = "", cst_2 = "<2>", caml_update_dummy2 = runtime.caml_update_dummy;
      function caml_call1(f, a0) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 1 ? f(a0) : runtime.caml_call_gen(f, [a0]);
      }
      function caml_call2(f, a0, a1) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 2 ? f(a0, a1) : runtime.caml_call_gen(f, [a0, a1]);
      }
      function caml_call3(f, a0, a1, a2) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 3 ? f(a0, a1, a2) : runtime.caml_call_gen(f, [a0, a1, a2]);
      }
      var global_data = runtime.caml_get_global_data(), cst$1 = cst$3, cst$2 = "->", cst$0 = ")", cst = cst$3, Parsing_Monad = global_data.Parsing__Monad, Stdlib_Option = global_data.Stdlib__Option, Stdlib = global_data.Stdlib, Stdlib_List = global_data.Stdlib__List, Stdlib_Format = global_data.Stdlib__Format, Parsing_Syntax = global_data.Parsing__Syntax, Stdlib_String = global_data.Stdlib__String, cst_Empty_char_list = "Empty char list", cst_sat = "sat: ", cst_char = "char(";
      function item(s2) {
        var chars = s2[2], pos = s2[1];
        if (!chars)
          return caml_call2(Parsing_Monad[4], cst_Empty_char_list, s2);
        var c = chars[1];
        if (10 === c) {
          var xs = chars[2];
          return [0, [0, 10, [0, [0, pos[1] + 1 | 0, 0], xs]]];
        }
        var xs$0 = chars[2];
        return [0, [0, c, [0, [0, pos[1], pos[2] + 1 | 0], xs$0]]];
      }
      function sat(opt, p) {
        if (opt)
          var sth = opt[1], msg = sth;
        else
          var msg = cst;
        return caml_call2(
          Parsing_Monad[3],
          item,
          function(c) {
            return caml_call1(p, c) ? caml_call1(Parsing_Monad[1], c) : function(s2) {
              var _T_2 = caml_call2(Stdlib[28], cst_sat, msg);
              return caml_call2(Parsing_Monad[4], _T_2, s2);
            };
          }
        );
      }
      function char$0(c) {
        var _R_ = caml_call2(Stdlib_String[1], 1, c), _S_ = caml_call2(Stdlib[28], _R_, cst$0);
        return sat(
          [0, caml_call2(Stdlib[28], cst_char, _S_)],
          function(x2) {
            return x2 === c ? 1 : 0;
          }
        );
      }
      function peek_char(s2) {
        var s$0 = s2[2];
        if (!s$0)
          return caml_call2(Parsing_Monad[1], 0, s2);
        var x2 = s$0[1];
        return caml_call2(Parsing_Monad[1], [0, x2], s2);
      }
      var ws = sat(
        [0, "ws"],
        function(param) {
          if (10 !== param && 32 !== param)
            return 0;
          return 1;
        }
      ), wss = caml_call1(Parsing_Monad[10], ws);
      function is_upper(param) {
        return 25 < param - 65 >>> 0 ? 0 : 1;
      }
      var upper = sat([0, "is_upper"], is_upper);
      function is_lower(param) {
        return 25 < param - 97 >>> 0 ? 0 : 1;
      }
      var lower = sat([0, "is_lower"], is_lower), letter = sat(
        [0, "letter"],
        function(c) {
          var _Q_ = is_lower(c);
          return _Q_ ? _Q_ : is_upper(c);
        }
      );
      function is_digit(param) {
        return 9 < param - 48 >>> 0 ? 0 : 1;
      }
      var digit = sat([0, "is_digit"], is_digit);
      function is_letter_or_digit(c) {
        var _N_ = is_upper(c);
        if (_N_)
          var _O_ = _N_;
        else {
          var _P_ = is_lower(c);
          if (!_P_)
            return is_digit(c);
          var _O_ = _P_;
        }
        return _O_;
      }
      var letter_or_digit = sat(0, is_letter_or_digit);
      function explode(s2) {
        var _M_ = caml_call1(Stdlib_String[40], s2);
        return caml_call1(Stdlib_List[65], _M_);
      }
      function implode(l) {
        var _L_ = caml_call1(Stdlib_List[64], l);
        return caml_call1(Stdlib_String[42], _L_);
      }
      function symbol(p1, p2) {
        return caml_call2(Parsing_Monad[3], p1, function(param) {
          return p2;
        });
      }
      function tchar(c) {
        return symbol(wss, char$0(c));
      }
      function symbol$0(p1, p2) {
        return caml_call2(
          Parsing_Monad[3],
          p1,
          function(v) {
            return caml_call2(
              Parsing_Monad[3],
              p2,
              function(param) {
                return caml_call1(Parsing_Monad[1], v);
              }
            );
          }
        );
      }
      function string(s2) {
        var match = explode(s2);
        if (!match)
          return caml_call1(Parsing_Monad[1], cst$1);
        var xs = match[2], x2 = match[1], _J_ = caml_call1(Parsing_Monad[1], s2), _K_ = string(implode(xs));
        return symbol(symbol(char$0(x2), _K_), _J_);
      }
      function tstring(s2) {
        return symbol(wss, string(s2));
      }
      var tlparent = symbol(wss, char$0(40)), trparent = symbol(wss, char$0(41)), tlet = symbol(wss, string("let")), trec = symbol(wss, string("rec")), tin = symbol(wss, string("in")), tfun = symbol(wss, string("fun")), keywords = [0, tlet, [0, trec, [0, tin, [0, tfun, 0]]]], keyword_parser = caml_call3(
        Stdlib_List[26],
        function(acc, p) {
          return caml_call2(Parsing_Monad[6], acc, p);
        },
        Parsing_Monad[5],
        keywords
      ), _a_ = [0, 0, 0], cst_is_a_keyword = " is a keyword", _b_ = symbol(wss, letter), ident = caml_call2(
        Parsing_Monad[3],
        _b_,
        function(x2) {
          var _H_ = caml_call1(Parsing_Monad[10], letter_or_digit);
          return caml_call2(
            Parsing_Monad[3],
            _H_,
            function(xs) {
              var s2 = implode([0, x2, xs]), t = caml_call1(keyword_parser, [0, _a_, explode(s2)]);
              if (0 === t[0]) {
                var s22 = t[1][2][2];
                if (0 === caml_call1(Stdlib_List[1], s22)) {
                  var _I_ = caml_call2(Stdlib[28], s2, cst_is_a_keyword);
                  return caml_call1(Parsing_Monad[4], _I_);
                }
              }
              return caml_call1(Parsing_Monad[1], s2);
            }
          );
        }
      ), number = symbol(wss, caml_call1(Parsing_Monad[11], digit)), _c_ = sat(
        0,
        function(param) {
          if (10 !== param && 32 !== param)
            return 1;
          return 0;
        }
      ), unknown = caml_call1(Parsing_Monad[11], _c_), pp_term_list = function _G_(_E_, _F_) {
        return _G_.fun(_E_, _F_);
      }, show_term_list = function _D_(_C_) {
        return _D_.fun(_C_);
      }, _d_ = [0, [18, [1, [0, [11, cst_2, 0], cst_2]], [12, 91, 0]], "@[<2>["], _e_ = [0, [12, 59, [17, [0, "@ ", 1, 0], 0]], ";@ "], _f_ = [0, [17, [0, "@,", 0, 0], [12, 93, [17, 0, 0]]], "@,]@]"];
      caml_update_dummy2(
        pp_term_list,
        function(fmt, x2) {
          caml_call2(Stdlib_Format[137], fmt, _d_);
          caml_call3(
            Stdlib_List[26],
            function(sep, x3) {
              if (sep)
                caml_call2(Stdlib_Format[137], fmt, _e_);
              caml_call1(caml_call1(Parsing_Syntax[9], fmt), x3);
              return 1;
            },
            0,
            x2
          );
          return caml_call2(Stdlib_Format[137], fmt, _f_);
        }
      );
      var _g_ = [0, [15, 0], "%a"];
      caml_update_dummy2(
        show_term_list,
        function(x2) {
          return caml_call3(Stdlib_Format[141], _g_, pp_term_list, x2);
        }
      );
      function term_parser(s2) {
        var _p_ = symbol(
          wss,
          caml_call2(
            Parsing_Monad[3],
            Parsing_Monad[9],
            function(param) {
              var pos1 = param[1], _q_ = symbol(tfun, ident), _r_ = caml_call2(
                Parsing_Monad[3],
                _q_,
                function(id) {
                  caml_call1(Stdlib[46], id);
                  var _y_ = symbol(tchar(58), ident), _z_ = caml_call1(Parsing_Monad[12], _y_);
                  return caml_call2(
                    Parsing_Monad[3],
                    _z_,
                    function(ty) {
                      var _A_ = symbol(tstring(cst$2), term_parser);
                      return caml_call2(
                        Parsing_Monad[3],
                        _A_,
                        function(t) {
                          var _B_ = [
                            1,
                            id,
                            caml_call2(Stdlib_Option[7], function(x2) {
                              return [1, x2];
                            }, ty),
                            t
                          ];
                          return caml_call1(Parsing_Monad[1], _B_);
                        }
                      );
                    }
                  );
                }
              ), _s_ = symbol(tlet, caml_call1(Parsing_Monad[12], trec)), _t_ = caml_call2(
                Parsing_Monad[3],
                _s_,
                function(r) {
                  return caml_call2(
                    Parsing_Monad[3],
                    ident,
                    function(id) {
                      var _v_ = symbol(tchar(61), term_parser);
                      return caml_call2(
                        Parsing_Monad[3],
                        _v_,
                        function(t1) {
                          var _w_ = symbol(tin, term_parser);
                          return caml_call2(
                            Parsing_Monad[3],
                            _w_,
                            function(t2) {
                              var _x_ = r ? 1 : 0;
                              return caml_call1(Parsing_Monad[1], [3, _x_, id, t1, t2]);
                            }
                          );
                        }
                      );
                    }
                  );
                }
              ), _u_ = caml_call2(Parsing_Monad[6], _t_, _r_);
              return caml_call2(
                Parsing_Monad[3],
                _u_,
                function(tm) {
                  return caml_call2(
                    Parsing_Monad[3],
                    Parsing_Monad[9],
                    function(param2) {
                      var pos2 = param2[1];
                      return caml_call1(Parsing_Monad[1], [0, tm, [0, pos1, pos2]]);
                    }
                  );
                }
              );
            }
          )
        );
        return caml_call1(caml_call2(Parsing_Monad[6], _p_, app_term), s2);
      }
      function app_term(s2) {
        var _l_ = caml_call1(Parsing_Monad[11], atom_term);
        return caml_call1(
          caml_call2(
            Parsing_Monad[3],
            _l_,
            function(xs) {
              var _m_ = caml_call1(Stdlib_List[7], xs), _n_ = caml_call1(Stdlib_List[6], xs), _o_ = caml_call3(
                Stdlib_List[26],
                function(acc, tm) {
                  return [0, [2, acc, tm], [0, acc[2][1], tm[2][2]]];
                },
                _n_,
                _m_
              );
              return caml_call1(Parsing_Monad[1], _o_);
            }
          ),
          s2
        );
      }
      function atom_term(s2) {
        var a0 = caml_call2(
          Parsing_Monad[3],
          Parsing_Monad[9],
          function(param) {
            var pos1 = param[1], _i_ = symbol(number, caml_call1(Parsing_Monad[1], 0)), _j_ = caml_call2(
              Parsing_Monad[3],
              ident,
              function(x2) {
                return caml_call1(Parsing_Monad[1], [0, x2]);
              }
            ), _k_ = caml_call2(Parsing_Monad[6], _j_, _i_);
            return caml_call2(
              Parsing_Monad[3],
              _k_,
              function(tm) {
                return caml_call2(
                  Parsing_Monad[3],
                  Parsing_Monad[9],
                  function(param2) {
                    var pos2 = param2[1];
                    return caml_call1(Parsing_Monad[1], [0, tm, [0, pos1, pos2]]);
                  }
                );
              }
            );
          }
        ), _h_ = symbol$0(symbol(tlparent, term_parser), trparent);
        return caml_call1(caml_call2(Parsing_Monad[6], a0, _h_), s2);
      }
      var Parsing_Parser = [
        0,
        item,
        sat,
        char$0,
        peek_char,
        ws,
        wss,
        is_upper,
        upper,
        is_lower,
        lower,
        letter,
        is_digit,
        digit,
        is_letter_or_digit,
        letter_or_digit,
        explode,
        implode,
        symbol,
        tchar,
        symbol$0,
        string,
        tstring,
        tlparent,
        trparent,
        tlet,
        trec,
        tin,
        tfun,
        keywords,
        keyword_parser,
        ident,
        number,
        unknown,
        pp_term_list,
        show_term_list,
        term_parser,
        app_term,
        atom_term
      ];
      runtime.caml_register_global(29, Parsing_Parser, "Parsing__Parser");
      return;
    })(globalThis);
    (function(globalThis2) {
      "use strict";
      var runtime = globalThis2.jsoo_runtime, cst$3 = "", cst$9 = " =", cst_S = "%S", cst_a = "%a", cst$4 = "(@[", cst$6 = ",@ ", cst$2 = ": ", cst$11 = ";@ ", cst_2 = "<2>", cst$5 = "@ ", cst$8 = "@,", cst$12 = "@,]@]", cst_s = "@[%s =@ ", cst_2$0 = "@[<2>[", cst$10 = "@]", cst$7 = "@])", caml_equal2 = runtime.caml_equal, caml_maybe_attach_backtrace2 = runtime.caml_maybe_attach_backtrace, caml_update_dummy2 = runtime.caml_update_dummy, caml_wrap_exception2 = runtime.caml_wrap_exception;
      function caml_call1(f2, a0) {
        return (f2.l >= 0 ? f2.l : f2.l = f2.length) == 1 ? f2(a0) : runtime.caml_call_gen(f2, [a0]);
      }
      function caml_call2(f2, a0, a1) {
        return (f2.l >= 0 ? f2.l : f2.l = f2.length) == 2 ? f2(a0, a1) : runtime.caml_call_gen(f2, [a0, a1]);
      }
      function caml_call3(f2, a0, a1, a2) {
        return (f2.l >= 0 ? f2.l : f2.l = f2.length) == 3 ? f2(a0, a1, a2) : runtime.caml_call_gen(f2, [a0, a1, a2]);
      }
      function caml_call4(f2, a0, a1, a2, a3) {
        return (f2.l >= 0 ? f2.l : f2.l = f2.length) == 4 ? f2(a0, a1, a2, a3) : runtime.caml_call_gen(f2, [a0, a1, a2, a3]);
      }
      function caml_call5(f2, a0, a1, a2, a3, a4) {
        return (f2.l >= 0 ? f2.l : f2.l = f2.length) == 5 ? f2(a0, a1, a2, a3, a4) : runtime.caml_call_gen(f2, [a0, a1, a2, a3, a4]);
      }
      var global_data = runtime.caml_get_global_data(), cst$0 = cst$3, cst$1 = cst$3, cst = ")", initialenv = [0, [0, "true", 0], [0, [0, "false", 0], 0]], Stdlib_Printf = global_data.Stdlib__Printf, Assert_failure = global_data.Assert_failure, Stdlib_Option = global_data.Stdlib__Option, Stdlib = global_data.Stdlib, Stdlib_List = global_data.Stdlib__List, Stdlib_Format = global_data.Stdlib__Format, Parsing_Syntax = global_data.Parsing__Syntax, cst_bool = "bool", cst_int = "int", _a_ = [0, [2, 0, [11, " -> ", [2, 0, 0]]], "%s -> %s"], _b_ = [0, [12, 40, [2, 0, [11, ") -> ", [2, 0, 0]]]], "(%s) -> %s"], _c_ = [0, "typing/typexpr.ml", 12, 15];
      function print_ty(ty) {
        if (typeof ty === "number")
          return 0 === ty ? cst_bool : cst_int;
        switch (ty[0]) {
          case 0:
            var ty2 = ty[2], ty1 = ty[1], _bb_ = print_ty(ty2);
            a: {
              var _bc_ = print_ty(ty1);
              if (typeof ty1 !== "number" && 0 === ty1[0]) {
                var _bd_ = _b_;
                break a;
              }
              var _bd_ = _a_;
            }
            return caml_call3(Stdlib_Printf[4], _bd_, _bc_, _bb_);
          case 1:
            var x2 = ty[1];
            return x2;
          default:
            throw caml_maybe_attach_backtrace2([0, Assert_failure, _c_], 1);
        }
      }
      var pp_constr = function _ba_(_a__, _a$_) {
        return _ba_.fun(_a__, _a$_);
      }, show_constr = function _a9_(_a8_) {
        return _a9_.fun(_a8_);
      }, _d_ = [0, [18, [1, [0, [11, cst_2, 0], cst_2]], [12, 91, 0]], cst_2$0], _e_ = [0, [12, 59, [17, [0, cst$5, 1, 0], 0]], cst$11], _f_ = [0, [12, 40, [18, [1, [0, 0, cst$3]], 0]], cst$4], _g_ = [0, [12, 44, [17, [0, cst$5, 1, 0], 0]], cst$6], _h_ = [0, [17, 0, [12, 41, 0]], cst$7], _i_ = [0, [17, [0, cst$8, 0, 0], [12, 93, [17, 0, 0]]], cst$12];
      caml_update_dummy2(
        pp_constr,
        function(fmt, x2) {
          caml_call2(Stdlib_Format[137], fmt, _d_);
          caml_call3(
            Stdlib_List[26],
            function(sep, x3) {
              if (sep)
                caml_call2(Stdlib_Format[137], fmt, _e_);
              var a1 = x3[2], a0 = x3[1];
              caml_call2(Stdlib_Format[137], fmt, _f_);
              caml_call1(caml_call1(Parsing_Syntax[7], fmt), a0);
              caml_call2(Stdlib_Format[137], fmt, _g_);
              caml_call1(caml_call1(Parsing_Syntax[7], fmt), a1);
              caml_call2(Stdlib_Format[137], fmt, _h_);
              return 1;
            },
            0,
            x2
          );
          return caml_call2(Stdlib_Format[137], fmt, _i_);
        }
      );
      var _j_ = [0, [15, 0], cst_a];
      caml_update_dummy2(
        show_constr,
        function(x2) {
          return caml_call3(Stdlib_Format[141], _j_, pp_constr, x2);
        }
      );
      var cst_X = "?X_";
      function f(n, param) {
        var _a5_ = n + 1 | 0, _a6_ = caml_call1(Stdlib[33], n);
        return [
          0,
          caml_call2(Stdlib[28], cst_X, _a6_),
          function(_a7_) {
            return f(_a5_, _a7_);
          }
        ];
      }
      var _k_ = 0;
      function uvargen(_a4_) {
        return f(_k_, _a4_);
      }
      var pp_env = function _a3_(_a1_, _a2_) {
        return _a3_.fun(_a1_, _a2_);
      }, show_env = function _a0_(_aZ_) {
        return _a0_.fun(_aZ_);
      }, _l_ = [0, [18, [1, [0, [11, cst_2, 0], cst_2]], [12, 91, 0]], cst_2$0], _m_ = [0, [12, 59, [17, [0, cst$5, 1, 0], 0]], cst$11], _n_ = [0, [12, 40, [18, [1, [0, 0, cst$3]], 0]], cst$4], _o_ = [0, [3, 0, 0], cst_S], _p_ = [0, [12, 44, [17, [0, cst$5, 1, 0], 0]], cst$6], _q_ = [0, [17, 0, [12, 41, 0]], cst$7], _r_ = [0, [17, [0, cst$8, 0, 0], [12, 93, [17, 0, 0]]], cst$12];
      caml_update_dummy2(
        pp_env,
        function(fmt, x2) {
          caml_call2(Stdlib_Format[137], fmt, _l_);
          caml_call3(
            Stdlib_List[26],
            function(sep, x3) {
              if (sep)
                caml_call2(Stdlib_Format[137], fmt, _m_);
              var a1 = x3[2], a0 = x3[1];
              caml_call2(Stdlib_Format[137], fmt, _n_);
              caml_call1(caml_call2(Stdlib_Format[137], fmt, _o_), a0);
              caml_call2(Stdlib_Format[137], fmt, _p_);
              caml_call1(caml_call1(Parsing_Syntax[7], fmt), a1);
              caml_call2(Stdlib_Format[137], fmt, _q_);
              return 1;
            },
            0,
            x2
          );
          return caml_call2(Stdlib_Format[137], fmt, _r_);
        }
      );
      var _s_ = [0, [15, 0], cst_a];
      caml_update_dummy2(
        show_env,
        function(x2) {
          return caml_call3(Stdlib_Format[141], _s_, pp_env, x2);
        }
      );
      var pp_typed_tm = function _aY_(_aW_, _aX_) {
        return _aY_.fun(_aW_, _aX_);
      }, show_typed_tm = function _aV_(_aU_) {
        return _aV_.fun(_aU_);
      }, pp_tm_desc = function _aT_(_aR_, _aS_) {
        return _aT_.fun(_aR_, _aS_);
      }, show_tm_desc = function _aQ_(_aP_) {
        return _aQ_.fun(_aP_);
      }, _t_ = [0, [18, [1, [0, [11, cst_2, 0], cst_2]], [11, "{ ", 0]], "@[<2>{ "], cst_tm = "tm", _u_ = [
        0,
        [
          18,
          [1, [0, 0, cst$3]],
          [2, 0, [11, cst$9, [17, [0, cst$5, 1, 0], 0]]]
        ],
        cst_s
      ], _v_ = [0, [17, 0, 0], cst$10], _w_ = [0, [12, 59, [17, [0, cst$5, 1, 0], 0]], cst$11], cst_ty = "ty", _x_ = [
        0,
        [
          18,
          [1, [0, 0, cst$3]],
          [2, 0, [11, cst$9, [17, [0, cst$5, 1, 0], 0]]]
        ],
        cst_s
      ], _y_ = [0, [17, 0, 0], cst$10], _z_ = [0, [12, 59, [17, [0, cst$5, 1, 0], 0]], cst$11], cst_env = "env", _A_ = [
        0,
        [
          18,
          [1, [0, 0, cst$3]],
          [2, 0, [11, cst$9, [17, [0, cst$5, 1, 0], 0]]]
        ],
        cst_s
      ], _B_ = [0, [17, 0, 0], cst$10], _C_ = [0, [12, 59, [17, [0, cst$5, 1, 0], 0]], cst$11], cst_loc = "loc", _D_ = [
        0,
        [
          18,
          [1, [0, 0, cst$3]],
          [2, 0, [11, cst$9, [17, [0, cst$5, 1, 0], 0]]]
        ],
        cst_s
      ], _E_ = [0, [17, 0, 0], cst$10], _F_ = [0, [17, [0, cst$5, 1, 0], [12, 125, [17, 0, 0]]], "@ }@]"];
      caml_update_dummy2(
        pp_typed_tm,
        function(fmt, x2) {
          caml_call2(Stdlib_Format[137], fmt, _t_);
          caml_call3(Stdlib_Format[137], fmt, _u_, cst_tm);
          var _aL_ = x2[1];
          caml_call1(caml_call1(pp_tm_desc, fmt), _aL_);
          caml_call2(Stdlib_Format[137], fmt, _v_);
          caml_call2(Stdlib_Format[137], fmt, _w_);
          caml_call3(Stdlib_Format[137], fmt, _x_, cst_ty);
          var _aM_ = x2[2];
          caml_call1(caml_call1(Parsing_Syntax[7], fmt), _aM_);
          caml_call2(Stdlib_Format[137], fmt, _y_);
          caml_call2(Stdlib_Format[137], fmt, _z_);
          caml_call3(Stdlib_Format[137], fmt, _A_, cst_env);
          var _aN_ = x2[3];
          caml_call1(caml_call1(pp_env, fmt), _aN_);
          caml_call2(Stdlib_Format[137], fmt, _B_);
          caml_call2(Stdlib_Format[137], fmt, _C_);
          caml_call3(Stdlib_Format[137], fmt, _D_, cst_loc);
          var _aO_ = x2[4];
          caml_call1(caml_call1(Parsing_Syntax[5], fmt), _aO_);
          caml_call2(Stdlib_Format[137], fmt, _E_);
          return caml_call2(Stdlib_Format[137], fmt, _F_);
        }
      );
      var _G_ = [0, [15, 0], cst_a];
      caml_update_dummy2(
        show_typed_tm,
        function(x2) {
          return caml_call3(Stdlib_Format[141], _G_, pp_typed_tm, x2);
        }
      );
      var cst_Tint = "Tint", cst_Tbool = "Tbool", _H_ = [
        0,
        [
          12,
          40,
          [
            18,
            [1, [0, [11, cst_2, 0], cst_2]],
            [11, "Tvar", [17, [0, cst$5, 1, 0], 0]]
          ]
        ],
        "(@[<2>Tvar@ "
      ], _I_ = [0, [3, 0, 0], cst_S], _J_ = [0, [17, 0, [12, 41, 0]], cst$7], _K_ = [
        0,
        [
          12,
          40,
          [
            18,
            [1, [0, [11, cst_2, 0], cst_2]],
            [11, "Tabs", [17, [0, cst$5, 1, 0], 0]]
          ]
        ],
        "(@[<2>Tabs@ "
      ], _L_ = [0, [12, 40, [18, [1, [0, 0, cst$3]], 0]], cst$4], _M_ = [0, [3, 0, 0], cst_S], _N_ = [0, [12, 44, [17, [0, cst$5, 1, 0], 0]], cst$6], cst_Some = "(Some ", cst_None = "None", _O_ = [0, [12, 44, [17, [0, cst$5, 1, 0], 0]], cst$6], _P_ = [0, [17, 0, [12, 41, 0]], cst$7], _Q_ = [0, [17, 0, [12, 41, 0]], cst$7], _R_ = [
        0,
        [
          12,
          40,
          [
            18,
            [1, [0, [11, cst_2, 0], cst_2]],
            [11, "Tapp (", [17, [0, cst$8, 0, 0], 0]]
          ]
        ],
        "(@[<2>Tapp (@,"
      ], _S_ = [0, [12, 44, [17, [0, cst$5, 1, 0], 0]], cst$6], _T_2 = [0, [17, [0, cst$8, 0, 0], [11, "))", [17, 0, 0]]], "@,))@]"], _U_ = [
        0,
        [
          12,
          40,
          [
            18,
            [1, [0, [11, cst_2, 0], cst_2]],
            [11, "Tlet", [17, [0, cst$5, 1, 0], 0]]
          ]
        ],
        "(@[<2>Tlet@ "
      ], _V_ = [0, [12, 40, [18, [1, [0, 0, cst$3]], 0]], cst$4], _W_ = [0, [9, 0, 0], "%B"], _X_ = [0, [12, 44, [17, [0, cst$5, 1, 0], 0]], cst$6], _Y_ = [0, [3, 0, 0], cst_S], _Z_ = [0, [12, 44, [17, [0, cst$5, 1, 0], 0]], cst$6], ___ = [0, [12, 44, [17, [0, cst$5, 1, 0], 0]], cst$6], _$_ = [0, [17, 0, [12, 41, 0]], cst$7], _aa_ = [0, [17, 0, [12, 41, 0]], cst$7];
      caml_update_dummy2(
        pp_tm_desc,
        function(fmt, param) {
          if (typeof param === "number")
            return 0 === param ? caml_call2(Stdlib_Format[13], fmt, cst_Tint) : caml_call2(Stdlib_Format[13], fmt, cst_Tbool);
          switch (param[0]) {
            case 0:
              var a0 = param[1];
              caml_call2(Stdlib_Format[137], fmt, _H_);
              caml_call1(caml_call2(Stdlib_Format[137], fmt, _I_), a0);
              return caml_call2(Stdlib_Format[137], fmt, _J_);
            case 1:
              var a0$0 = param[1];
              caml_call2(Stdlib_Format[137], fmt, _K_);
              var a2 = a0$0[3], a1 = a0$0[2], a0$1 = a0$0[1];
              caml_call2(Stdlib_Format[137], fmt, _L_);
              caml_call1(caml_call2(Stdlib_Format[137], fmt, _M_), a0$1);
              caml_call2(Stdlib_Format[137], fmt, _N_);
              if (a1) {
                var x2 = a1[1];
                caml_call2(Stdlib_Format[13], fmt, cst_Some);
                caml_call1(caml_call1(Parsing_Syntax[7], fmt), x2);
                caml_call2(Stdlib_Format[13], fmt, cst);
              } else
                caml_call2(Stdlib_Format[13], fmt, cst_None);
              caml_call2(Stdlib_Format[137], fmt, _O_);
              caml_call1(caml_call1(pp_typed_tm, fmt), a2);
              caml_call2(Stdlib_Format[137], fmt, _P_);
              return caml_call2(Stdlib_Format[137], fmt, _Q_);
            case 2:
              var a1$0 = param[2], a0$2 = param[1];
              caml_call2(Stdlib_Format[137], fmt, _R_);
              caml_call1(caml_call1(pp_typed_tm, fmt), a0$2);
              caml_call2(Stdlib_Format[137], fmt, _S_);
              caml_call1(caml_call1(pp_typed_tm, fmt), a1$0);
              return caml_call2(Stdlib_Format[137], fmt, _T_2);
            default:
              var a0$3 = param[1];
              caml_call2(Stdlib_Format[137], fmt, _U_);
              var a3 = a0$3[4], a2$0 = a0$3[3], a1$1 = a0$3[2], a0$4 = a0$3[1];
              caml_call2(Stdlib_Format[137], fmt, _V_);
              caml_call1(caml_call2(Stdlib_Format[137], fmt, _W_), a0$4);
              caml_call2(Stdlib_Format[137], fmt, _X_);
              caml_call1(caml_call2(Stdlib_Format[137], fmt, _Y_), a1$1);
              caml_call2(Stdlib_Format[137], fmt, _Z_);
              caml_call1(caml_call1(pp_typed_tm, fmt), a2$0);
              caml_call2(Stdlib_Format[137], fmt, ___);
              caml_call1(caml_call1(pp_typed_tm, fmt), a3);
              caml_call2(Stdlib_Format[137], fmt, _$_);
              return caml_call2(Stdlib_Format[137], fmt, _aa_);
          }
        }
      );
      var _ab_ = [0, [15, 0], cst_a];
      caml_update_dummy2(
        show_tm_desc,
        function(x2) {
          return caml_call3(Stdlib_Format[141], _ab_, pp_tm_desc, x2);
        }
      );
      var _ac_ = [0, [11, "(intv: ", [2, 0, [12, 41, 0]]], "(intv: %s)"], _ad_ = [0, [11, "(boolv: ", [2, 0, [12, 41, 0]]], "(boolv: %s)"], _ae_ = [0, [12, 40, [2, 0, [11, cst$2, [2, 0, [12, 41, 0]]]]], "(%s: %s)"], _af_ = [
        0,
        [
          11,
          "((\\",
          [
            2,
            0,
            [
              11,
              cst$2,
              [2, 0, [11, ". ", [2, 0, [11, "): ", [2, 0, [12, 41, 0]]]]]]
            ]
          ]
        ],
        "((\\%s: %s. %s): %s)"
      ], _ag_ = [
        0,
        [12, 40, [2, 0, [12, 32, [2, 0, [11, cst$2, [2, 0, [12, 41, 0]]]]]]],
        "(%s %s: %s)"
      ], cst_rec = "rec", _ah_ = [
        0,
        [
          11,
          "(let ",
          [
            2,
            0,
            [
              12,
              32,
              [2, 0, [11, " = ", [2, 0, [11, " in ", [2, 0, [12, 41, 0]]]]]]
            ]
          ]
        ],
        "(let %s %s = %s in %s)"
      ], cst_occurs = "occurs", cst_unify = "unify", cst_Unbound = "Unbound: ";
      function print_typed(typed) {
        var ty = typed[2], tm = typed[1];
        if (typeof tm !== "number")
          switch (tm[0]) {
            case 0:
              var x2 = tm[1], _aB_ = print_ty(ty);
              return caml_call3(Stdlib_Printf[4], _ae_, x2, _aB_);
            case 1:
              var match = tm[1], t2 = match[3], ty0 = match[2], x$0 = match[1], _aC_ = print_ty(ty), _aD_ = print_typed(t2), _aE_ = caml_call3(Stdlib_Option[8], cst$0, print_ty, ty0);
              return caml_call5(Stdlib_Printf[4], _af_, x$0, _aE_, _aD_, _aC_);
            case 2:
              var t2$0 = tm[2], t1 = tm[1], _aF_ = print_ty(ty), _aG_ = print_typed(t2$0), _aH_ = print_typed(t1);
              return caml_call4(Stdlib_Printf[4], _ag_, _aH_, _aG_, _aF_);
            default:
              var match$0 = tm[1], t2$1 = match$0[4], t1$0 = match$0[3], x$1 = match$0[2], r = match$0[1], _aI_ = print_typed(t2$1), _aJ_ = print_typed(t1$0), _aK_ = r ? cst_rec : cst$1;
              return caml_call5(Stdlib_Printf[4], _ah_, _aK_, x$1, _aJ_, _aI_);
          }
        if (0 === tm) {
          var _az_ = print_ty(ty);
          return caml_call2(Stdlib_Printf[4], _ac_, _az_);
        }
        var _aA_ = print_ty(ty);
        return caml_call2(Stdlib_Printf[4], _ad_, _aA_);
      }
      function is_value(t) {
        if (typeof t !== "number" && 2 === t[0])
          return 0;
        return 1;
      }
      function is_occurs(t1, t2) {
        var t2$0 = t2;
        for (; ; ) {
          if (typeof t2$0 === "number")
            return 0;
          switch (t2$0[0]) {
            case 0:
              var ty2 = t2$0[2], ty1 = t2$0[1], _ay_ = is_occurs(t1, ty1);
              if (_ay_)
                return _ay_;
              var t2$0 = ty2;
              break;
            case 1:
              return caml_equal2(t1, t2$0);
            default:
              return 0;
          }
        }
      }
      function occurs(t1, t2) {
        var _ax_ = is_occurs(t1, t2);
        return _ax_ ? caml_call1(Stdlib[2], cst_occurs) : _ax_;
      }
      function subst(s2, t) {
        var s$0 = s2, t$0 = t;
        for (; ; ) {
          if (typeof t$0 === "number")
            return 0 === t$0 ? 0 : 1;
          switch (t$0[0]) {
            case 0:
              var ty2 = t$0[2], ty1 = t$0[1], _aw_ = subst(s$0, ty2);
              return [0, subst(s$0, ty1), _aw_];
            case 1:
              if (!s$0)
                return t$0;
              var rest = s$0[2], match = s$0[1], ty = match[2], x2 = match[1];
              if (caml_equal2(t$0, x2))
                var s$0 = rest, t$0 = ty;
              else
                var s$0 = rest;
              break;
            default:
              var x$0 = t$0[1];
              return [2, x$0];
          }
        }
      }
      function unify(c) {
        var c$0 = c;
        for (; ; ) {
          if (!c$0)
            return 0;
          var match = c$0[1], ty1 = match[1], rest = c$0[2], ty2 = match[2];
          if (!caml_equal2(ty1, ty2)) {
            a: {
              b: {
                c:
                  if (typeof ty1 !== "number")
                    switch (ty1[0]) {
                      case 2:
                        break;
                      case 0:
                        var match$0 = match[2], ty12 = ty1[2], ty11 = ty1[1];
                        if (typeof match$0 !== "number")
                          switch (match$0[0]) {
                            case 2:
                              break;
                            case 0:
                              var rest$1 = c$0[2], ty22 = match$0[2], ty21 = match$0[1], c$1 = [0, [0, ty11, ty21], [0, [0, ty12, ty22], rest$1]], c$0 = c$1;
                              continue;
                            default:
                              break c;
                          }
                        break a;
                      default:
                        var t = match[2], id = ty1[1];
                        break b;
                    }
                var _au_ = match[2];
                if (typeof _au_ !== "number" && 1 === _au_[0]) {
                  var t = ty1, id = _au_[1];
                  break b;
                }
                break a;
              }
              var rest$0 = c$0[2];
              occurs([1, id], t);
              return [
                0,
                [0, [1, id], t],
                unify(caml_call2(
                  Stdlib_List[20],
                  function(param) {
                    var ty = param[2], x2 = param[1], _av_ = subst([0, [0, [1, id], t], 0], ty);
                    return [0, subst([0, [0, [1, id], t], 0], x2), _av_];
                  },
                  rest$0
                ))
              ];
            }
            return caml_call1(Stdlib[2], cst_unify);
          }
          var c$0 = rest;
        }
      }
      function unify_subst(c, t) {
        return subst(unify(c), t);
      }
      function gen(env, t) {
        if (typeof t !== "number")
          switch (t[0]) {
            case 0:
              var ty2 = t[2], ty1 = t[1], _at_ = gen(env, ty2);
              return [0, gen(env, ty1), _at_];
            case 1:
              var x2 = t[1];
              if (caml_call2(
                Stdlib_List[33],
                function(param) {
                  var ty = param[2];
                  return 1 - is_occurs(t, ty);
                },
                env
              ))
                return [2, x2];
              break;
          }
        return t;
      }
      function inst(f2, m, t) {
        if (typeof t !== "number")
          switch (t[0]) {
            case 0:
              var ty2 = t[2], ty1 = t[1], match = inst(f2, m, ty1), f$0 = match[3], m$0 = match[2], ty1$0 = match[1], match$0 = inst(f$0, m$0, ty2), f$1 = match$0[3], m$1 = match$0[2], ty2$0 = match$0[1];
              return [0, [0, ty1$0, ty2$0], m$1, f$1];
            case 2:
              var id = t[1];
              if (caml_call2(Stdlib_List[53], id, m))
                return [0, caml_call2(Stdlib_List[49], id, m), m, f2];
              var match$1 = caml_call1(f2, 0), f$2 = match$1[2], x2 = match$1[1], t$0 = [1, x2];
              return [0, t$0, [0, [0, id, t$0], m], f$2];
          }
        return [0, t, m, f2];
      }
      function gen_constr(env, f2, t) {
        var loc = t[2], match = t[1];
        if (typeof match === "number")
          return 0 === match ? [0, [0, 0, 1, env, loc], f2, 0] : [0, [0, 1, 0, env, loc], f2, 0];
        switch (match[0]) {
          case 0:
            var x2 = match[1];
            try {
              var _ao_ = caml_call2(Stdlib_List[49], x2, env), ty = _ao_;
            } catch (_as_) {
              var _am_ = caml_wrap_exception2(_as_);
              if (_am_ !== Stdlib[8])
                throw caml_maybe_attach_backtrace2(_am_, 0);
              var _an_ = caml_call2(Stdlib[28], cst_Unbound, x2), ty = caml_call1(Stdlib[2], _an_);
            }
            var match$0 = inst(f2, 0, ty), f$0 = match$0[3], ty$0 = match$0[1];
            return [0, [0, [0, x2], ty$0, env, loc], f$0, 0];
          case 1:
            var match$1 = match[2], x$0 = match[1];
            if (match$1) {
              var t2 = match[3], ty1 = match$1[1], match$2 = gen_constr([0, [0, x$0, ty1], env], f2, t2), c = match$2[3], f$1 = match$2[2], ty2 = match$2[1];
              return [
                0,
                [0, [1, [0, x$0, [0, ty1], ty2]], [0, ty1, ty2[2]], env, loc],
                f$1,
                c
              ];
            }
            var t2$0 = match[3], match$3 = caml_call1(f2, 0), f$2 = match$3[2], name = match$3[1], ty_x = [1, name], match$4 = gen_constr([0, [0, x$0, ty_x], env], f$2, t2$0), c$0 = match$4[3], f$3 = match$4[2], ty$1 = match$4[1];
            return [
              0,
              [0, [1, [0, x$0, 0, ty$1]], [0, ty_x, ty$1[2]], env, loc],
              f$3,
              c$0
            ];
          case 2:
            var t2$1 = match[2], t1 = match[1], match$5 = gen_constr(env, f2, t1), c1 = match$5[3], f$4 = match$5[2], ty1$0 = match$5[1], match$6 = gen_constr(env, f$4, t2$1), c2 = match$6[3], f$5 = match$6[2], ty2$0 = match$6[1], match$7 = caml_call1(f$5, 0), f$6 = match$7[2], x$1 = match$7[1], ty_r = [1, x$1], _ap_ = caml_call2(Stdlib[37], c2, [0, [0, ty1$0[2], [0, ty2$0[2], ty_r]], 0]), c$1 = caml_call2(Stdlib[37], c1, _ap_);
            return [0, [0, [2, ty1$0, ty2$0], ty_r, env, loc], f$6, c$1];
          default:
            var t2$2 = match[4], t1$0 = match[3], x$2 = match[2], r = match[1];
            if (r)
              var match$8 = caml_call1(f2, 0), f$7 = match$8[2], id = match$8[1], match$9 = gen_constr([0, [0, x$2, [1, id]], env], f$7, t1$0);
            else
              var match$9 = gen_constr(env, f2, t1$0);
            var c1$0 = match$9[3], f$8 = match$9[2], typed_tm = match$9[1], ty1$1 = unify_subst(c1$0, typed_tm[2]), _aq_ = is_value(t1$0[1]) ? gen(env, ty1$1) : ty1$1, match$10 = gen_constr([0, [0, x$2, _aq_], env], f$8, t2$2), c2$0 = match$10[3], f$9 = match$10[2], ty2$1 = match$10[1], _ar_ = caml_call2(Stdlib[37], c1$0, c2$0);
            return [
              0,
              [0, [3, [0, r, x$2, typed_tm, ty2$1]], ty2$1[2], env, loc],
              f$9,
              _ar_
            ];
        }
      }
      function subst_typed(s2, typed) {
        var loc = typed[4], env = typed[3], ty = typed[2], tm = typed[1], _ai_ = caml_call2(
          Stdlib_List[20],
          function(param) {
            var ty2 = param[2], x3 = param[1];
            return [0, x3, subst(s2, ty2)];
          },
          env
        );
        a: {
          var _aj_ = subst(s2, ty);
          if (typeof tm !== "number")
            switch (tm[0]) {
              case 1:
                var match = tm[1], t2 = match[3], ty$0 = match[2], x2 = match[1], tm$0 = [1, [0, x2, ty$0, subst_typed(s2, t2)]];
                break a;
              case 2:
                var t2$0 = tm[2], t1 = tm[1], _ak_ = subst_typed(s2, t2$0), tm$0 = [2, subst_typed(s2, t1), _ak_];
                break a;
              case 3:
                var match$0 = tm[1], t2$1 = match$0[4], t1$0 = match$0[3], x$0 = match$0[2], r = match$0[1], _al_ = subst_typed(s2, t2$1), tm$0 = [3, [0, r, x$0, subst_typed(s2, t1$0), _al_]];
                break a;
            }
          var tm$0 = tm;
        }
        return [0, tm$0, _aj_, _ai_, loc];
      }
      function type_expr(e) {
        var match = gen_constr(initialenv, uvargen, e), c = match[3], typed = match[1], s2 = unify(c);
        return subst_typed(s2, typed);
      }
      var Typing_Typexpr = [
        0,
        print_ty,
        pp_constr,
        show_constr,
        uvargen,
        pp_env,
        show_env,
        pp_typed_tm,
        show_typed_tm,
        pp_tm_desc,
        show_tm_desc,
        print_typed,
        is_value,
        is_occurs,
        occurs,
        subst,
        unify,
        unify_subst,
        gen,
        inst,
        gen_constr,
        subst_typed,
        initialenv,
        type_expr
      ];
      runtime.caml_register_global(87, Typing_Typexpr, "Typing__Typexpr");
      return;
    })(globalThis);
    (function(globalThis2) {
      "use strict";
      var runtime = globalThis2.jsoo_runtime, cst_Main_loc = "Main.loc", cst_Main_loc_end = "Main.loc._end", cst_Main_loc_type = "Main.loc._type", cst_Main_loc_start = "Main.loc.start", cst_end$0 = "end", cst_start$0 = "start", cst_type$0 = "type", cst_unknown$0 = "unknown", caml_equal2 = runtime.caml_equal, caml_greaterthan2 = runtime.caml_greaterthan, caml_js_wrap_meth_callback2 = runtime.caml_js_wrap_meth_callback, caml_lessequal2 = runtime.caml_lessequal, caml_notequal2 = runtime.caml_notequal, caml_string_notequal2 = runtime.caml_string_notequal, caml_update_dummy2 = runtime.caml_update_dummy;
      function caml_call1(f, a0) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 1 ? f(a0) : runtime.caml_call_gen(f, [a0]);
      }
      function caml_call2(f, a0, a1) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 2 ? f(a0, a1) : runtime.caml_call_gen(f, [a0, a1]);
      }
      function caml_call3(f, a0, a1, a2) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 3 ? f(a0, a1, a2) : runtime.caml_call_gen(f, [a0, a1, a2]);
      }
      function caml_call5(f, a0, a1, a2, a3, a4) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 5 ? f(a0, a1, a2, a3, a4) : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
      }
      var global_data = runtime.caml_get_global_data(), state = [
        0,
        [1, cst_Main_loc_start],
        [1, cst_Main_loc_end],
        [1, cst_Main_loc_type]
      ], Ppx_deriving_yojson_runtime = global_data.Ppx_deriving_yojson_runtime;
      global_data.CamlinternalOO;
      var Typing_Typexpr = global_data.Typing__Typexpr, Parsing_Parser = global_data.Parsing__Parser, Parsing_Syntax = global_data.Parsing__Syntax, Stdlib = global_data.Stdlib, Parsing_Monad = global_data.Parsing__Monad, Stdlib_List = global_data.Stdlib__List, Yojson_Safe = global_data.Yojson__Safe, Js_of_ocaml_Js = global_data.Js_of_ocaml__Js, loc_list_to_yojson = function _am_(_al_) {
        return _am_.fun(_al_);
      }, loc_list_of_yojson = function _ak_(_aj_) {
        return _ak_.fun(_aj_);
      }, cst_type = cst_type$0, cst_end = cst_end$0, cst_start = cst_start$0;
      caml_update_dummy2(
        loc_list_to_yojson,
        function(x2) {
          return [
            0,
            848054398,
            caml_call2(
              Ppx_deriving_yojson_runtime[4],
              function(x$0) {
                var x3 = x$0[3], fields = [0, [0, cst_type, [0, -976970511, x3]], 0], param = x$0[2], arg1 = param[2], arg0 = param[1], fields$0 = [
                  0,
                  [
                    0,
                    cst_end,
                    [
                      0,
                      848054398,
                      [0, [0, 3654863, arg0], [0, [0, 3654863, arg1], 0]]
                    ]
                  ],
                  fields
                ], param$0 = x$0[1], arg1$0 = param$0[2], arg0$0 = param$0[1], fields$1 = [
                  0,
                  [
                    0,
                    cst_start,
                    [
                      0,
                      848054398,
                      [0, [0, 3654863, arg0$0], [0, [0, 3654863, arg1$0], 0]]
                    ]
                  ],
                  fields$0
                ];
                return [0, 963043957, fields$1];
              },
              x2
            )
          ];
        }
      );
      var _a_ = [1, cst_Main_loc], _b_ = [1, cst_Main_loc], _c_ = [1, cst_Main_loc_type], _d_ = [1, cst_Main_loc_start], _e_ = [1, cst_Main_loc_start], _f_ = [1, cst_Main_loc_start], _g_ = [1, cst_Main_loc_end], _h_ = [1, cst_Main_loc_end], _i_ = [1, cst_Main_loc_end], _j_ = [1, "Main.loc_list"];
      caml_update_dummy2(
        loc_list_of_yojson,
        function(param) {
          if (typeof param !== "number" && 848054398 === param[1]) {
            var xs = param[2];
            return caml_call3(
              Ppx_deriving_yojson_runtime[3],
              function(x$5) {
                if (typeof x$5 !== "number" && 963043957 === x$5[1]) {
                  var xs2 = x$5[2], xs$0 = xs2, state$0 = state;
                  for (; ; ) {
                    var arg2 = state$0[3], arg1 = state$0[2], arg0 = state$0[1];
                    if (!xs$0)
                      break;
                    var _U_ = xs$0[1], _V_ = _U_[1];
                    if (caml_string_notequal2(_V_, cst_end$0))
                      if (caml_string_notequal2(_V_, cst_start$0)) {
                        if (caml_string_notequal2(_V_, cst_type$0))
                          return _b_;
                        var xs$1 = xs$0[2], x2 = _U_[2];
                        a: {
                          if (typeof x2 !== "number" && -976970511 === x2[1]) {
                            var x$0 = x2[2], _W_ = [0, x$0];
                            break a;
                          }
                          var _W_ = _c_;
                        }
                        var state$1 = [0, arg0, arg1, _W_], xs$0 = xs$1, state$0 = state$1;
                      } else {
                        var xs$2 = xs$0[2], x$1 = _U_[2];
                        a: {
                          if (typeof x$1 !== "number" && 848054398 === x$1[1]) {
                            var _X_ = x$1[2];
                            if (_X_) {
                              var _Y_ = _X_[2];
                              if (_Y_ && !_Y_[2]) {
                                var arg1$0 = _Y_[1], arg0$0 = _X_[1];
                                let arg02 = arg0$0;
                                b: {
                                  var _Z_ = function(arg12) {
                                    a: {
                                      var _af_ = function(arg03) {
                                        return [0, [0, arg03, arg12]];
                                      };
                                      if (typeof arg02 !== "number" && 3654863 === arg02[1]) {
                                        var x3 = arg02[2], _ag_ = [0, x3];
                                        break a;
                                      }
                                      var _ag_ = _e_;
                                    }
                                    return caml_call2(Ppx_deriving_yojson_runtime[1], _ag_, _af_);
                                  };
                                  if (typeof arg1$0 !== "number" && 3654863 === arg1$0[1]) {
                                    var x$2 = arg1$0[2], ___ = [0, x$2];
                                    break b;
                                  }
                                  var ___ = _f_;
                                }
                                var _$_ = caml_call2(Ppx_deriving_yojson_runtime[1], ___, _Z_);
                                break a;
                              }
                            }
                          }
                          var _$_ = _d_;
                        }
                        var state$2 = [0, _$_, arg1, arg2], xs$0 = xs$2, state$0 = state$2;
                      }
                    else {
                      var xs$3 = xs$0[2], x$3 = _U_[2];
                      a: {
                        if (typeof x$3 !== "number" && 848054398 === x$3[1]) {
                          var _aa_ = x$3[2];
                          if (_aa_) {
                            var _ab_ = _aa_[2];
                            if (_ab_ && !_ab_[2]) {
                              var arg1$1 = _ab_[1], arg0$1 = _aa_[1];
                              let arg02 = arg0$1;
                              b: {
                                var _ac_ = function(arg12) {
                                  a: {
                                    var _ah_ = function(arg03) {
                                      return [0, [0, arg03, arg12]];
                                    };
                                    if (typeof arg02 !== "number" && 3654863 === arg02[1]) {
                                      var x3 = arg02[2], _ai_ = [0, x3];
                                      break a;
                                    }
                                    var _ai_ = _h_;
                                  }
                                  return caml_call2(Ppx_deriving_yojson_runtime[1], _ai_, _ah_);
                                };
                                if (typeof arg1$1 !== "number" && 3654863 === arg1$1[1]) {
                                  var x$4 = arg1$1[2], _ad_ = [0, x$4];
                                  break b;
                                }
                                var _ad_ = _i_;
                              }
                              var _ae_ = caml_call2(Ppx_deriving_yojson_runtime[1], _ad_, _ac_);
                              break a;
                            }
                          }
                        }
                        var _ae_ = _g_;
                      }
                      var state$3 = [0, arg0, _ae_, arg2], xs$0 = xs$3, state$0 = state$3;
                    }
                  }
                  return caml_call2(
                    Ppx_deriving_yojson_runtime[1],
                    arg2,
                    function(arg22) {
                      return caml_call2(
                        Ppx_deriving_yojson_runtime[1],
                        arg1,
                        function(arg12) {
                          return caml_call2(
                            Ppx_deriving_yojson_runtime[1],
                            arg0,
                            function(arg02) {
                              return [0, [0, arg02, arg12, arg22]];
                            }
                          );
                        }
                      );
                    }
                  );
                }
                return _a_;
              },
              0,
              xs
            );
          }
          return _j_;
        }
      );
      var cst_unknown = cst_unknown$0, cst_number = "number", cst_keyword = "keyword", cst_variable = "variable", _k_ = caml_call2(Parsing_Parser[18], Parsing_Parser[6], Parsing_Monad[9]), token_parser = caml_call2(
        Parsing_Monad[3],
        _k_,
        function(param) {
          var pos1 = param[1], _J_ = caml_call1(Parsing_Monad[1], cst_unknown), _K_ = caml_call2(Parsing_Parser[18], Parsing_Parser[33], _J_), _L_ = caml_call1(Parsing_Monad[1], cst_number), _M_ = caml_call2(Parsing_Parser[18], Parsing_Parser[32], _L_), _N_ = caml_call1(Parsing_Monad[1], cst_keyword), _O_ = caml_call2(Parsing_Parser[18], Parsing_Parser[30], _N_), _P_ = caml_call1(Parsing_Monad[1], cst_variable), _Q_ = caml_call2(Parsing_Parser[18], Parsing_Parser[31], _P_), _R_ = caml_call2(Parsing_Monad[6], _Q_, _O_), _S_ = caml_call2(Parsing_Monad[6], _R_, _M_), _T_2 = caml_call2(Parsing_Monad[6], _S_, _K_);
          return caml_call2(
            Parsing_Monad[3],
            _T_2,
            function(t) {
              return caml_call2(
                Parsing_Monad[3],
                Parsing_Monad[9],
                function(param2) {
                  var pos2 = param2[1];
                  return caml_call1(Parsing_Monad[1], [0, pos1, pos2, t]);
                }
              );
            }
          );
        }
      ), _l_ = [0, 0, 0], cst_fail = "fail", _m_ = [0, 0, 0], cst_fail_parse = "fail parse";
      function in_range(p1, param) {
        var p3 = param[2], c2 = p3[2], l2 = p3[1], p2 = param[1], c1 = p2[2], l1 = p2[1], c = p1[2], l = p1[1], _x_ = runtime.caml_lessthan(l1, l), _y_ = _x_ ? caml_greaterthan2(l2, l) : _x_;
        if (_y_)
          var _z_ = _y_;
        else {
          var _A_ = caml_notequal2(l1, l2);
          if (_A_)
            var _B_ = caml_equal2(l1, l), _C_ = _B_ ? caml_lessequal2(c1, c) : _B_;
          else
            var _C_ = _A_;
          if (_C_)
            var _z_ = _C_;
          else {
            var _D_ = caml_notequal2(l1, l2);
            if (_D_)
              var _E_ = caml_equal2(l2, l), _F_ = _E_ ? caml_greaterthan2(c2, c) : _E_;
            else
              var _F_ = _D_;
            if (_F_)
              var _z_ = _F_;
            else {
              var _G_ = caml_equal2(l1, l2);
              if (_G_) {
                var _H_ = caml_equal2(l1, l);
                if (_H_)
                  var _I_ = caml_lessequal2(c1, c), _z_ = _I_ ? caml_greaterthan2(c2, c) : _I_;
                else
                  var _z_ = _H_;
              } else
                var _z_ = _G_;
            }
          }
        }
        return _z_;
      }
      function t5(param, src, l, c) {
        var pos = [0, l, c], _p_ = [0, _m_, caml_call1(Parsing_Parser[16], src)], _q_ = caml_call1(Parsing_Parser[36], _p_);
        if (0 === _q_[0])
          var v = _q_[1][1], _w_ = v;
        else
          var match = _q_[1], s2 = match[2], msg = match[1], _r_ = caml_call1(Parsing_Parser[17], s2[2]), _s_ = caml_call1(Parsing_Syntax[2], s2[1]), _t_ = caml_call2(Stdlib[28], _s_, _r_), _u_ = caml_call2(Stdlib[28], msg, _t_), _v_ = caml_call2(Stdlib[28], cst_fail_parse, _u_), _w_ = caml_call1(Stdlib[2], _v_);
        var typed_tm = caml_call1(Typing_Typexpr[23], _w_), tm = typed_tm;
        for (; ; ) {
          var match$0 = tm[1];
          if (typeof match$0 !== "number")
            switch (match$0[0]) {
              case 1:
                var body = match$0[1][3];
                if (!in_range(pos, body[4]))
                  return caml_call1(Typing_Typexpr[1], tm[2]);
                var tm = body;
                continue;
              case 2:
                var t2 = match$0[2], t1 = match$0[1];
                if (in_range(pos, t1[4])) {
                  var tm = t1;
                  continue;
                }
                if (!in_range(pos, t2[4]))
                  return caml_call1(Typing_Typexpr[1], tm[2]);
                var tm = t2;
                continue;
              case 3:
                var match$1 = match$0[1], t2$0 = match$1[4], t1$0 = match$1[3];
                if (in_range(pos, t1$0[4])) {
                  var tm = t1$0;
                  continue;
                }
                if (!in_range(pos, t2$0[4]))
                  return caml_call1(Typing_Typexpr[1], tm[2]);
                var tm = t2$0;
                continue;
            }
          return caml_call1(Typing_Typexpr[1], tm[2]);
        }
      }
      function t4(param, src) {
        var _n_ = [0, _l_, caml_call1(Parsing_Parser[16], src)], match = caml_call1(caml_call1(Parsing_Monad[10], token_parser), _n_);
        if (0 !== match[0])
          return caml_call1(Stdlib[2], cst_fail);
        var v = match[1][1], _o_ = caml_call1(
          loc_list_to_yojson,
          caml_call2(
            Stdlib_List[44],
            function(param2) {
              var type = param2[3];
              return caml_string_notequal2(type, cst_unknown$0);
            },
            v
          )
        );
        return caml_call5(Yojson_Safe[5], 0, 0, 0, 0, _o_);
      }
      caml_call1(
        Js_of_ocaml_Js[51],
        {
          lexing: caml_js_wrap_meth_callback2(t4),
          typeinfo: caml_js_wrap_meth_callback2(t5)
        }
      );
      var Dune_exe_Main = [0];
      runtime.caml_register_global(40, Dune_exe_Main, "Dune__exe__Main");
      return;
    })(globalThis);
    (function(globalThis2) {
      "use strict";
      var runtime = globalThis2.jsoo_runtime;
      function caml_call1(f, a0) {
        return (f.l >= 0 ? f.l : f.l = f.length) == 1 ? f(a0) : runtime.caml_call_gen(f, [a0]);
      }
      var global_data = runtime.caml_get_global_data(), Stdlib = global_data.Stdlib;
      caml_call1(Stdlib[103], 0);
      var Std_exit = [0];
      runtime.caml_register_global(1, Std_exit, "Std_exit");
      return;
    })(globalThis);
  }
});

// src/server.ts
var import_browser = __toESM(require_browser3());

// node_modules/vscode-languageserver-textdocument/lib/esm/main.js
var FullTextDocument2 = class _FullTextDocument {
  constructor(uri, languageId, version, content) {
    this._uri = uri;
    this._languageId = languageId;
    this._version = version;
    this._content = content;
    this._lineOffsets = void 0;
  }
  get uri() {
    return this._uri;
  }
  get languageId() {
    return this._languageId;
  }
  get version() {
    return this._version;
  }
  getText(range) {
    if (range) {
      const start = this.offsetAt(range.start);
      const end = this.offsetAt(range.end);
      return this._content.substring(start, end);
    }
    return this._content;
  }
  update(changes, version) {
    for (let change of changes) {
      if (_FullTextDocument.isIncremental(change)) {
        const range = getWellformedRange(change.range);
        const startOffset = this.offsetAt(range.start);
        const endOffset = this.offsetAt(range.end);
        this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
        const startLine = Math.max(range.start.line, 0);
        const endLine = Math.max(range.end.line, 0);
        let lineOffsets = this._lineOffsets;
        const addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
        if (endLine - startLine === addedLineOffsets.length) {
          for (let i = 0, len = addedLineOffsets.length; i < len; i++) {
            lineOffsets[i + startLine + 1] = addedLineOffsets[i];
          }
        } else {
          if (addedLineOffsets.length < 1e4) {
            lineOffsets.splice(startLine + 1, endLine - startLine, ...addedLineOffsets);
          } else {
            this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
          }
        }
        const diff = change.text.length - (endOffset - startOffset);
        if (diff !== 0) {
          for (let i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {
            lineOffsets[i] = lineOffsets[i] + diff;
          }
        }
      } else if (_FullTextDocument.isFull(change)) {
        this._content = change.text;
        this._lineOffsets = void 0;
      } else {
        throw new Error("Unknown change event received");
      }
    }
    this._version = version;
  }
  getLineOffsets() {
    if (this._lineOffsets === void 0) {
      this._lineOffsets = computeLineOffsets(this._content, true);
    }
    return this._lineOffsets;
  }
  positionAt(offset) {
    offset = Math.max(Math.min(offset, this._content.length), 0);
    let lineOffsets = this.getLineOffsets();
    let low = 0, high = lineOffsets.length;
    if (high === 0) {
      return { line: 0, character: offset };
    }
    while (low < high) {
      let mid = Math.floor((low + high) / 2);
      if (lineOffsets[mid] > offset) {
        high = mid;
      } else {
        low = mid + 1;
      }
    }
    let line = low - 1;
    return { line, character: offset - lineOffsets[line] };
  }
  offsetAt(position) {
    let lineOffsets = this.getLineOffsets();
    if (position.line >= lineOffsets.length) {
      return this._content.length;
    } else if (position.line < 0) {
      return 0;
    }
    let lineOffset = lineOffsets[position.line];
    let nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
    return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
  }
  get lineCount() {
    return this.getLineOffsets().length;
  }
  static isIncremental(event) {
    let candidate = event;
    return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
  }
  static isFull(event) {
    let candidate = event;
    return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
  }
};
var TextDocument2;
(function(TextDocument3) {
  function create(uri, languageId, version, content) {
    return new FullTextDocument2(uri, languageId, version, content);
  }
  TextDocument3.create = create;
  function update(document2, changes, version) {
    if (document2 instanceof FullTextDocument2) {
      document2.update(changes, version);
      return document2;
    } else {
      throw new Error("TextDocument.update: document must be created by TextDocument.create");
    }
  }
  TextDocument3.update = update;
  function applyEdits(document2, edits) {
    let text = document2.getText();
    let sortedEdits = mergeSort(edits.map(getWellformedEdit), (a, b) => {
      let diff = a.range.start.line - b.range.start.line;
      if (diff === 0) {
        return a.range.start.character - b.range.start.character;
      }
      return diff;
    });
    let lastModifiedOffset = 0;
    const spans = [];
    for (const e of sortedEdits) {
      let startOffset = document2.offsetAt(e.range.start);
      if (startOffset < lastModifiedOffset) {
        throw new Error("Overlapping edit");
      } else if (startOffset > lastModifiedOffset) {
        spans.push(text.substring(lastModifiedOffset, startOffset));
      }
      if (e.newText.length) {
        spans.push(e.newText);
      }
      lastModifiedOffset = document2.offsetAt(e.range.end);
    }
    spans.push(text.substr(lastModifiedOffset));
    return spans.join("");
  }
  TextDocument3.applyEdits = applyEdits;
})(TextDocument2 || (TextDocument2 = {}));
function mergeSort(data, compare) {
  if (data.length <= 1) {
    return data;
  }
  const p = data.length / 2 | 0;
  const left = data.slice(0, p);
  const right = data.slice(p);
  mergeSort(left, compare);
  mergeSort(right, compare);
  let leftIdx = 0;
  let rightIdx = 0;
  let i = 0;
  while (leftIdx < left.length && rightIdx < right.length) {
    let ret = compare(left[leftIdx], right[rightIdx]);
    if (ret <= 0) {
      data[i++] = left[leftIdx++];
    } else {
      data[i++] = right[rightIdx++];
    }
  }
  while (leftIdx < left.length) {
    data[i++] = left[leftIdx++];
  }
  while (rightIdx < right.length) {
    data[i++] = right[rightIdx++];
  }
  return data;
}
function computeLineOffsets(text, isAtLineStart, textOffset = 0) {
  const result = isAtLineStart ? [textOffset] : [];
  for (let i = 0; i < text.length; i++) {
    let ch = text.charCodeAt(i);
    if (ch === 13 || ch === 10) {
      if (ch === 13 && i + 1 < text.length && text.charCodeAt(i + 1) === 10) {
        i++;
      }
      result.push(textOffset + i + 1);
    }
  }
  return result;
}
function getWellformedRange(range) {
  const start = range.start;
  const end = range.end;
  if (start.line > end.line || start.line === end.line && start.character > end.character) {
    return { start: end, end: start };
  }
  return range;
}
function getWellformedEdit(textEdit) {
  const range = getWellformedRange(textEdit.range);
  if (range !== textEdit.range) {
    return { newText: textEdit.newText, range };
  }
  return textEdit;
}

// src/server.ts
var lib = __toESM(require_main_bc());
var messageReader = new import_browser.BrowserMessageReader(self);
var messageWriter = new import_browser.BrowserMessageWriter(self);
var connection = (0, import_browser.createConnection)(messageReader, messageWriter);
var documents = new import_browser.TextDocuments(TextDocument2);
var hasConfigurationCapability = false;
var hasWorkspaceFolderCapability = false;
var hasDiagnosticRelatedInformationCapability = false;
var tokenTypes = [import_browser.SemanticTokenTypes.function, import_browser.SemanticTokenTypes.variable, import_browser.SemanticTokenTypes.keyword, import_browser.SemanticTokenTypes.number];
var tokenModifiers = [import_browser.SemanticTokenModifiers.definition];
connection.onInitialize((params) => {
  console.log("onInitialize", params);
  const capabilities = params.capabilities;
  hasConfigurationCapability = !!(capabilities.workspace && !!capabilities.workspace.configuration);
  hasWorkspaceFolderCapability = !!(capabilities.workspace && !!capabilities.workspace.workspaceFolders);
  hasDiagnosticRelatedInformationCapability = !!(capabilities.textDocument && capabilities.textDocument.publishDiagnostics && capabilities.textDocument.publishDiagnostics.relatedInformation);
  const result = {
    capabilities: {
      textDocumentSync: import_browser.TextDocumentSyncKind.Incremental,
      // Tell the client that this server supports code completion.
      completionProvider: {
        resolveProvider: true
      },
      diagnosticProvider: {
        interFileDependencies: false,
        workspaceDiagnostics: false
      },
      semanticTokensProvider: {
        legend: { tokenTypes, tokenModifiers },
        documentSelector: [{ language: "mod" }],
        full: true
      },
      hoverProvider: true
    }
  };
  if (hasWorkspaceFolderCapability) {
    result.capabilities.workspace = {
      workspaceFolders: {
        supported: true
      }
    };
  }
  return result;
});
connection.onInitialized(() => {
  console.log("onInitialized");
  if (hasConfigurationCapability) {
    connection.client.register(import_browser.DidChangeConfigurationNotification.type, void 0);
  }
  if (hasWorkspaceFolderCapability) {
    connection.workspace.onDidChangeWorkspaceFolders((_event) => {
      connection.console.log("Workspace folder change event received.");
    });
  }
});
var documentSettings = /* @__PURE__ */ new Map();
connection.languages.semanticTokens.on(async ({ textDocument }) => {
  const doc = documents.get(textDocument.uri);
  const text = doc.getText();
  const t = JSON.parse(lib.lexing(text));
  const data = t.map((e, i) => {
    const len = doc.offsetAt({ line: e.end[0], character: e.end[1] }) - doc.offsetAt({ line: e.start[0], character: e.start[1] });
    const type = tokenTypes.findIndex((t2) => t2 === e.type);
    if (i === 0)
      return [e.start[0], e.start[1], len, type, 0];
    else {
      const prev = t[i - 1];
      let deltaLine = e.start[0] - prev.start[0];
      let deltaChar = e.start[1];
      if (e.start[0] === prev.start[0])
        deltaChar = deltaChar - prev.start[1];
      return [deltaLine, deltaChar, len, type, 0];
    }
  });
  return {
    data: data.flat()
  };
});
documents.onDidClose((e) => {
  console.log("onDidClose", e);
  documentSettings.delete(e.document.uri);
});
connection.onHover(async ({ textDocument, position }) => {
  const text = documents.get(textDocument.uri).getText();
  console.log(text, position);
  const ty = lib.typeinfo(text, position.line, position.character);
  console.log(ty);
  return {
    "contents": ty
  };
});
connection.languages.diagnostics.on(async (params) => {
  return {
    kind: import_browser.DocumentDiagnosticReportKind.Full,
    items: []
  };
});
documents.onDidChangeContent((change) => {
  console.log("onDidChangeContent", change);
});
connection.onDidChangeWatchedFiles((_change) => {
  connection.console.log("We received a file change event");
});
connection.onDocumentHighlight;
connection.onCompletion(
  (_textDocumentPosition) => {
    console.log("onCompletion");
    return [
      {
        label: "TypeScript",
        kind: import_browser.CompletionItemKind.Text,
        data: 1
      },
      {
        label: "JavaScript",
        kind: import_browser.CompletionItemKind.Text,
        data: 2
      }
    ];
  }
);
connection.onCompletionResolve(
  (item) => {
    console.log("onCompletionResolve", item);
    if (item.data === 1) {
      item.detail = "TypeScript details";
      item.documentation = "TypeScript documentation";
    } else if (item.data === 2) {
      item.detail = "JavaScript details";
      item.documentation = "JavaScript documentation";
    }
    return item;
  }
);
documents.listen(connection);
connection.listen();
//# sourceMappingURL=server.mjs.map