/*! https://github.com/nevware21/ts-utils v0.10.1 */
/*
 * Copyright (c) NevWare21 and contributors. All rights reserved.
 * Licensed under the MIT license.
 */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.nevware21 = global.nevware21 || {}, global.nevware21["ts-utils"] = {})));
})(this, (function (exports) { 'use strict';

    const UNDEF_VALUE = undefined;
    const NULL_VALUE = null;
    const EMPTY = "";
    const BOOLEAN = "boolean";
    const FUNCTION = "function";
    const NUMBER = "number";
    const OBJECT = "object";
    const PROTOTYPE = "prototype";
    const __PROTO__ = "__proto__";
    const STRING = "string";
    const UNDEFINED = "undefined";
    const CONSTRUCTOR = "constructor";
    const SYMBOL = "Symbol";
    const POLYFILL_TAG = "_polyfill";
    const INDEX_OF = "indexOf";
    const LAST_INDEX_OF = "lastIndexOf";
    const LENGTH = "length";
    const DONE = "done";
    const VALUE = "value";
    const NAME = "name";
    const SLICE = "slice";
    const ObjClass = Object;
    const ObjProto = ObjClass[PROTOTYPE];
    const StrCls = String;
    const StrProto = StrCls[PROTOTYPE];
    const MathCls = Math;
    const ArrCls = Array;
    const ArrProto = ArrCls[PROTOTYPE];

    function safeGet(cb, defValue) {
        let result = defValue;
        try {
            result = cb();
        }
        catch (e) {
        }
        return result;
    }

    const PRIMITIVE_TYPES = [STRING, NUMBER, BOOLEAN, UNDEFINED, "symbol", "bigint"];
    function _createIs(theType) {
        return function (value) {
            return typeof value === theType;
        };
    }
    function _createObjIs(theName) {
        const theType = "[object " + theName + "]";
        return function (value) {
            return !!(value && objToString(value) === theType);
        };
    }
    function objToString(value) {
        return ObjProto.toString.call(value);
    }
    function isTypeof(value, theType) {
        return typeof value === theType;
    }
    function isUndefined(value) {
        return typeof value === UNDEFINED || value === UNDEFINED;
    }
    function isStrictUndefined(arg) {
        return !isDefined(arg);
    }
    function isNullOrUndefined(value) {
        return value === NULL_VALUE || isUndefined(value);
    }
    function isStrictNullOrUndefined(value) {
        return value === NULL_VALUE || !isDefined(value);
    }
    function isDefined(arg) {
        return !!arg || arg !== UNDEF_VALUE;
    }
    const isPrimitive = (value) => {
        return value === NULL_VALUE || isPrimitiveType(typeof value);
    };
    const isPrimitiveType = (theType) => {
        return theType !== OBJECT && PRIMITIVE_TYPES.indexOf(theType) !== -1;
    };
    const isString = _createIs(STRING);
    const isFunction = _createIs(FUNCTION);
    function isObject(value) {
        if (!value && isNullOrUndefined(value)) {
            return false;
        }
        return !!value && typeof value === OBJECT;
    }
    const isArray = ArrCls.isArray;
    const isDate = _createObjIs("Date");
    const isNumber = _createIs(NUMBER);
    const isBoolean = _createIs(BOOLEAN);
    const isRegExp = _createObjIs("RegExp");
    const isFile = _createObjIs("File");
    const isFormData = _createObjIs("FormData");
    const isBlob = _createObjIs("Blob");
    const isArrayBuffer = _createObjIs("ArrayBuffer");
    const isError = _createObjIs("Error");
    function isPromiseLike(value) {
        return !!value && isFunction(value.then);
    }
    const isThenable = isPromiseLike;
    function isPromise(value) {
        return isPromiseLike(value) && isFunction(value.catch);
    }
    function isNotTruthy(value) {
        return !value || !safeGet(() => (value && (0 + value)), value);
    }
    function isTruthy(value) {
        return !(!value || safeGet(() => !(value && (0 + value)), !value));
    }

    const objGetOwnPropertyDescriptor = ObjClass.getOwnPropertyDescriptor;

    function objHasOwnProperty(obj, prop) {
        return obj && ObjProto.hasOwnProperty.call(obj, prop);
    }

    const objHasOwn = ObjClass["hasOwn"] || polyObjHasOwn;
    function polyObjHasOwn(obj, prop) {
        return objHasOwnProperty(obj, prop) || !!objGetOwnPropertyDescriptor(obj, prop);
    }

    function objForEachKey(theObject, callbackfn, thisArg) {
        if (theObject && isObject(theObject)) {
            for (const prop in theObject) {
                if (objHasOwn(theObject, prop)) {
                    if (callbackfn.call(thisArg || theObject, prop, theObject[prop]) === -1) {
                        break;
                    }
                }
            }
        }
    }

    function _createKeyValueMap(values, keyType, valueType, completeFn) {
        let theMap = {};
        objForEachKey(values, (key, value) => {
            theMap[key] = keyType ? value : key;
            theMap[value] = valueType ? value : key;
        });
        return completeFn(theMap);
    }

    function throwError(message) {
        throw new Error(message);
    }
    function throwTypeError(message) {
        throw new TypeError(message);
    }
    function throwRangeError(message) {
        throw new RangeError(message);
    }

    function polyObjKeys(obj) {
        if (!isObject(obj) || obj === NULL_VALUE) {
            throw new TypeError("polyObjKeys called on non-object");
        }
        const result = [];
        for (const prop in obj) {
            if (objHasOwn(obj, prop)) {
                result.push(prop);
            }
        }
        return result;
    }
    function polyObjEntries(value) {
        let result = [];
        objForEachKey(value, (key, value) => {
            result.push([key, value]);
        });
        return result;
    }

    const _objFreeze = ObjClass["freeze"];
    const _doNothing = (value) => value;
    const _getProto = (value) => value[__PROTO__] || NULL_VALUE;
    const objAssign = ObjClass["assign"];
    function objKeys(value) {
        if (!isObject(value) || value === NULL_VALUE) {
            throwTypeError("objKeys called on non-object");
        }
        return ObjClass.keys(value);
    }
    function objDeepFreeze(value) {
        if (_objFreeze) {
            objForEachKey(value, (key, value) => {
                if (isArray(value) || isObject(value)) {
                    _objFreeze(value);
                }
            });
        }
        return objFreeze(value);
    }
    const objFreeze = _objFreeze || _doNothing;
    const objSeal = ObjClass["seal"] || _doNothing;
    const objGetPrototypeOf = ObjClass["getPrototypeOf"] || _getProto;
    const objEntries = ObjClass.entries || polyObjEntries;

    function createEnum(values) {
        return _createKeyValueMap(values, 1 , 0 , objDeepFreeze);
    }
    function createEnumKeyMap(values) {
        return _createKeyValueMap(values, 0 , 0 , objDeepFreeze);
    }
    function createEnumValueMap(values) {
        return _createKeyValueMap(values, 1 , 1 , objDeepFreeze);
    }
    function createSimpleMap(values) {
        let mapClass = {};
        objForEachKey(values, (key, value) => {
            mapClass[key] = value[1];
            mapClass[value[0]] = value[1];
        });
        return objDeepFreeze(mapClass);
    }
    function createTypeMap(values) {
        return createSimpleMap(values);
    }

    const _wellKnownSymbolMap = createEnumKeyMap({
        asyncIterator: 0 ,
        hasInstance: 1 ,
        isConcatSpreadable: 2 ,
        iterator: 3 ,
        match: 4 ,
        matchAll: 5 ,
        replace: 6 ,
        search: 7 ,
        species: 8 ,
        split: 9 ,
        toPrimitive: 10 ,
        toStringTag: 11 ,
        unscopables: 12
    });

    const asString = StrCls;

    const GLOBAL_CONFIG_KEY = "__tsUtils$gblCfg";
    let _globalCfg;
    function _getGlobalValue() {
        let result;
        if (typeof globalThis !== UNDEFINED) {
            result = globalThis;
        }
        if (!result && typeof self !== UNDEFINED) {
            result = self;
        }
        if (!result && typeof window !== UNDEFINED) {
            result = window;
        }
        if (!result && typeof global !== UNDEFINED) {
            result = global;
        }
        return result;
    }
    function _getGlobalConfig() {
        if (!_globalCfg) {
            let gbl = _getGlobalValue() || {};
            _globalCfg = gbl[GLOBAL_CONFIG_KEY] = gbl[GLOBAL_CONFIG_KEY] || {};
        }
        return _globalCfg;
    }

    function dumpObj(object, format) {
        let propertyValueDump = EMPTY;
        if (isError(object)) {
            propertyValueDump = "{ stack: '" + object.stack + "', message: '" + object.message + "', name: '" + object.name + "'";
        }
        else {
            try {
                propertyValueDump = JSON.stringify(object, NULL_VALUE, format ? (isNumber(format) ? format : 4) : UNDEF_VALUE);
            }
            catch (e) {
                propertyValueDump = " - " + dumpObj(e, format);
            }
        }
        return objToString(object) + ": " + propertyValueDump;
    }

    const _arrSlice = ArrProto[SLICE];
    const _throwMissingFunction = (funcName, thisArg) => {
        throwTypeError("'" + asString(funcName) + "' not defined for " + dumpObj(thisArg));
    };
    const _unwrapInstFunction = (funcName) => {
        return function (thisArg) {
            return thisArg[funcName].apply(thisArg, _arrSlice.call(arguments, 1));
        };
    };
    const _unwrapFunction = (funcName, clsProto) => {
        let clsFn = clsProto && clsProto[funcName];
        return function (thisArg) {
            let theFunc = (thisArg && thisArg[funcName]) || clsFn;
            if (theFunc) {
                return theFunc.apply(thisArg, _arrSlice.call(arguments, 1));
            }
            _throwMissingFunction(funcName, thisArg);
        };
    };
    const _unwrapFunctionWithPoly = (funcName, clsProto, polyFunc) => {
        let clsFn = clsProto && clsProto[funcName];
        return function (thisArg) {
            let theFunc = (thisArg && thisArg[funcName]) || clsFn;
            if (theFunc || polyFunc) {
                let theArgs = arguments;
                return (theFunc || polyFunc).apply(thisArg, theFunc ? _arrSlice.call(theArgs, 1) : theArgs);
            }
            _throwMissingFunction(funcName, thisArg);
        };
    };
    function _unwrapProp(propName) {
        return function (thisArg) {
            return thisArg[propName];
        };
    }

    const mathMin = MathCls.min;
    const mathMax = MathCls.max;

    const strSlice = _unwrapFunction(SLICE, StrProto);

    const strSubstring = _unwrapFunction("substring", StrProto);
    const strSubstr = _unwrapFunctionWithPoly("substr", StrProto, polyStrSubstr);
    function polyStrSubstr(value, start, length) {
        if (isNullOrUndefined(value)) {
            throwTypeError("'polyStrSubstr called with invalid " + dumpObj(value));
        }
        if (length < 0) {
            return EMPTY;
        }
        start = start || 0;
        if (start < 0) {
            start = mathMax(start + value[LENGTH], 0);
        }
        if (isUndefined(length)) {
            return strSlice(value, start);
        }
        return strSlice(value, start, start + length);
    }
    function strLeft(value, count) {
        return strSubstring(value, 0, count);
    }
    function strRight(value, count) {
        let len = value[LENGTH];
        if (count <= 0) {
            return EMPTY;
        }
        return len > count ? strSubstring(value, len - count) : value;
    }

    const strStartsWith = _unwrapFunctionWithPoly("startsWith", StrProto, polyStrStartsWith);
    function polyStrStartsWith(value, searchString, position) {
        if (!isString(value)) {
            throwTypeError("'" + dumpObj(value) + "' is not a string");
        }
        let searchValue = isString(searchString) ? searchString : asString(searchString);
        let chkLen = searchValue[LENGTH];
        let pos = position > 0 ? position : 0;
        return strSubstring(value, pos, pos + chkLen) === searchValue;
    }

    const UNIQUE_REGISTRY_ID = "_urid";
    let _polySymbols;
    function _globalSymbolRegistry() {
        if (!_polySymbols) {
            let gblCfg = _getGlobalConfig();
            _polySymbols = gblCfg.gblSym = gblCfg.gblSym || { k: {}, s: {} };
        }
        return _polySymbols;
    }
    let _wellKnownSymbolCache = {};
    function polyNewSymbol(description) {
        let theSymbol = {
            description: asString(description),
            toString: () => SYMBOL + "(" + description + ")"
        };
        theSymbol[POLYFILL_TAG] = true;
        return theSymbol;
    }
    function polySymbolFor(key) {
        let registry = _globalSymbolRegistry();
        if (!objHasOwn(registry.k, key)) {
            let newSymbol = polyNewSymbol(key);
            let regId = objKeys(registry.s).length;
            newSymbol[UNIQUE_REGISTRY_ID] = () => regId + "_" + newSymbol.toString();
            registry.k[key] = newSymbol;
            registry.s[newSymbol[UNIQUE_REGISTRY_ID]()] = asString(key);
        }
        return registry.k[key];
    }
    function polySymbolKeyFor(sym) {
        if (!sym || !sym.toString || !strStartsWith(sym.toString(), SYMBOL)) {
            throwTypeError(sym + " is not a symbol");
        }
        const regId = sym[POLYFILL_TAG] && sym[UNIQUE_REGISTRY_ID] && sym[UNIQUE_REGISTRY_ID]();
        return regId ? _globalSymbolRegistry().s[regId] : undefined;
    }
    function polyGetKnownSymbol(name) {
        let result;
        let knownName = _wellKnownSymbolMap[name];
        if (knownName) {
            result = _wellKnownSymbolCache[knownName] = _wellKnownSymbolCache[knownName] || polyNewSymbol(SYMBOL + "." + knownName);
        }
        return result;
    }

    const propMap = {
        e: "enumerable",
        c: "configurable",
        v: VALUE,
        w: "writable",
        g: "get",
        s: "set"
    };
    function _createProp(value) {
        let prop = {};
        prop[propMap["c"]] = true;
        prop[propMap["e"]] = true;
        if (value.l) {
            prop.get = () => value.l.v;
            let desc = objGetOwnPropertyDescriptor(value.l, "v");
            if (desc && desc.set) {
                prop.set = (newValue) => {
                    value.l.v = newValue;
                };
            }
        }
        objForEachKey(value, (key, value) => {
            prop[propMap[key]] = isUndefined(value) ? prop[propMap[key]] : value;
        });
        return prop;
    }
    const objDefineProp = ObjClass["defineProperty"];
    const objDefineProperties = ObjClass["defineProperties"];
    function objDefineGet(target, key, value, configurable, enumerable) {
        return objDefineProp(target, key, _createProp({
            e: enumerable,
            c: configurable,
            [isFunction(value) ? "g" : "v"]: value
        }));
    }
    function objDefineAccessors(target, prop, getProp, setProp, configurable, enumerable) {
        let desc = {
            e: enumerable,
            c: configurable
        };
        if (getProp) {
            desc.g = getProp;
        }
        if (setProp) {
            desc.s = setProp;
        }
        return objDefineProp(target, prop, _createProp(desc));
    }
    function objDefine(target, key, propDesc) {
        return objDefineProp(target, key, _createProp(propDesc));
    }
    function objDefineProps(target, propDescMap) {
        let props = {};
        objForEachKey(propDescMap, (key, value) => {
            props[key] = _createProp(value);
        });
        return objDefineProperties(target, props);
    }

    let _globalLazyTestHooks;
    let _fetchLazyTestHooks = function () {
        _globalLazyTestHooks = _getGlobalConfig();
        _fetchLazyTestHooks = NULL_VALUE;
    };
    function getLazy(cb) {
        let lazyValue = {};
        _fetchLazyTestHooks && _fetchLazyTestHooks();
        lazyValue.b = _globalLazyTestHooks.lzy;
        objDefineProp(lazyValue, "v", {
            configurable: true,
            get: function () {
                let result = cb();
                if (!_globalLazyTestHooks.lzy) {
                    objDefineProp(lazyValue, "v", {
                        value: result
                    });
                    if (lazyValue.b) {
                        delete lazyValue.b;
                    }
                }
                if (_globalLazyTestHooks.lzy && lazyValue.b !== _globalLazyTestHooks.lzy) {
                    lazyValue.b = _globalLazyTestHooks.lzy;
                }
                return result;
            }
        });
        return lazyValue;
    }
    function setBypassLazyCache(newValue) {
        _fetchLazyTestHooks && _fetchLazyTestHooks();
        _globalLazyTestHooks.lzy = newValue;
    }

    function safeGetLazy(cb, defValue) {
        return getLazy(() => safeGet(cb, defValue));
    }

    const WINDOW = "window";
    let _cachedGlobal;
    let _cachedWindow;
    let _cachedDocument;
    let _cachedNavigator;
    let _cachedHistory;
    let _isWebWorker;
    let _isNode;
    const lazySafeGetInst = (name) => safeGetLazy(() => getInst(name) || UNDEF_VALUE, UNDEF_VALUE);
    const getGlobal = (useCached) => {
        (!_cachedGlobal || useCached === false || (_globalLazyTestHooks && _globalLazyTestHooks.lzy && !_cachedGlobal.b)) && (_cachedGlobal = safeGetLazy(_getGlobalValue, NULL_VALUE));
        return _cachedGlobal.v;
    };
    const getInst = (name, useCached) => {
        const gbl = (!_cachedGlobal || useCached === false) ? getGlobal(useCached) : _cachedGlobal.v;
        if (gbl && gbl[name]) {
            return gbl[name];
        }
        if (name === WINDOW && _cachedWindow) {
            return _cachedWindow.v;
        }
        return NULL_VALUE;
    };
    const hasDocument = () => !!getDocument();
    const getDocument = () => {
        (!_cachedDocument || (_globalLazyTestHooks && _globalLazyTestHooks.lzy && !_cachedDocument.b)) && (_cachedDocument = lazySafeGetInst("document"));
        return _cachedDocument.v;
    };
    const hasWindow = () => !!getWindow();
    const getWindow = () => {
        (!_cachedWindow || (_globalLazyTestHooks && _globalLazyTestHooks.lzy && !_cachedWindow.b)) && (_cachedWindow = lazySafeGetInst(WINDOW));
        return _cachedWindow.v;
    };
    const hasNavigator = () => !!getNavigator();
    const getNavigator = () => {
        (!_cachedNavigator || (_globalLazyTestHooks && _globalLazyTestHooks.lzy && !_cachedNavigator.b)) && (_cachedNavigator = lazySafeGetInst("navigator"));
        return _cachedNavigator.v;
    };
    const hasHistory = () => !!getHistory();
    const getHistory = () => {
        (!_cachedHistory || (_globalLazyTestHooks && _globalLazyTestHooks.lzy && !_cachedHistory.b)) && (_cachedHistory = lazySafeGetInst("history"));
        return _cachedHistory.v;
    };
    const isNode = () => {
        !_isNode && (_isNode = safeGetLazy(() => !!(process && (process.versions || {}).node), false));
        return _isNode.v;
    };
    const isWebWorker = () => {
        !_isWebWorker && (_isWebWorker = safeGetLazy(() => !!(self && self instanceof WorkerGlobalScope), false));
        return _isWebWorker.v;
    };

    let _symbol;
    let _symbolFor;
    let _symbolKeyFor;
    function _getSymbolValue(name) {
        return safeGetLazy(function () {
            return (_symbol.v ? _symbol.v[name] : UNDEF_VALUE);
        }, UNDEF_VALUE);
    }
    const isSymbol = _createIs("symbol");
    function hasSymbol() {
        return !!getSymbol();
    }
    function getSymbol() {
        let resetCache = !_symbol || (_globalLazyTestHooks && _globalLazyTestHooks.lzy && !_symbol.b);
        resetCache && (_symbol = lazySafeGetInst(SYMBOL));
        (!_symbolFor || resetCache) && (_symbolFor = _getSymbolValue("for"));
        (!_symbolKeyFor || resetCache) && (_symbolKeyFor = _getSymbolValue("keyFor"));
        return _symbol.v;
    }
    function getKnownSymbol(name, noPoly) {
        let knownName = _wellKnownSymbolMap[name];
        (!_symbol || (_globalLazyTestHooks.lzy && !_symbol.b)) && getSymbol();
        return _symbol.v ? _symbol.v[knownName || name] : (!noPoly ? polyGetKnownSymbol(name) : UNDEF_VALUE);
    }
    function newSymbol(description, noPoly) {
        (!_symbol || (_globalLazyTestHooks.lzy && !_symbol.b)) && getSymbol();
        return _symbol.v ? _symbol.v(description) : (!noPoly ? polyNewSymbol(description) : NULL_VALUE);
    }
    function symbolFor(key) {
        (!_symbolFor || (_globalLazyTestHooks.lzy && !_symbol.b)) && getSymbol();
        return (_symbolFor.v || polySymbolFor)(key);
    }
    function symbolKeyFor(sym) {
        (!_symbolKeyFor || (_globalLazyTestHooks.lzy && !_symbol.b)) && getSymbol();
        return (_symbolKeyFor.v || polySymbolKeyFor)(sym);
    }

    function isIterator(value) {
        return !!value && isFunction(value.next);
    }
    function isIterable(value) {
        return !isStrictNullOrUndefined(value) && isFunction(value[getKnownSymbol(3 )]);
    }

    let _iterSymbol$1;
    function iterForOf(iter, callbackfn, thisArg) {
        if (iter) {
            if (!isIterator(iter)) {
                !_iterSymbol$1 && (_iterSymbol$1 = getLazy(() => getKnownSymbol(3 )));
                iter = iter[_iterSymbol$1.v] ? iter[_iterSymbol$1.v]() : null;
            }
            if (isIterator(iter)) {
                let err;
                let iterResult;
                try {
                    let count = 0;
                    while (!(iterResult = iter.next())[DONE]) {
                        if (callbackfn.call(thisArg || iter, iterResult[VALUE], count, iter) === -1) {
                            break;
                        }
                        count++;
                    }
                }
                catch (failed) {
                    err = { e: failed };
                    if (iter.throw) {
                        iterResult = null;
                        iter.throw(err);
                    }
                }
                finally {
                    try {
                        if (iterResult && !iterResult[DONE]) {
                            iter.return && iter.return(iterResult);
                        }
                    }
                    finally {
                        if (err) {
                            throw err.e;
                        }
                    }
                }
            }
        }
    }

    const fnApply = _unwrapInstFunction("apply");

    function arrAppend(target, elms) {
        if (!isUndefined(elms) && target) {
            if (isArray(elms)) {
                fnApply(target.push, target, elms);
            }
            else if (isIterator(elms) || isIterable(elms)) {
                iterForOf(elms, (elm) => {
                    target.push(elm);
                });
            }
            else {
                target.push(elms);
            }
        }
        return target;
    }

    const arrEvery = _unwrapFunction("every", ArrProto);
    const arrFilter = _unwrapFunction("filter", ArrProto);

    function arrForEach(theArray, callbackfn, thisArg) {
        if (theArray) {
            const len = theArray[LENGTH] >>> 0;
            for (let idx = 0; idx < len; idx++) {
                if (idx in theArray) {
                    if (callbackfn.call(thisArg || theArray, theArray[idx], idx, theArray) === -1) {
                        break;
                    }
                }
            }
        }
    }

    const arrIndexOf = _unwrapFunction(INDEX_OF, ArrProto);
    const arrLastIndexOf = _unwrapFunction(LAST_INDEX_OF, ArrProto);

    const arrMap = _unwrapFunction("map", ArrProto);

    const arrSlice = _unwrapFunction(SLICE, ArrProto);

    const fnCall = _unwrapInstFunction("call");

    function polyIsArray(value) {
        if (isNullOrUndefined(value)) {
            return false;
        }
        return objToString(value) === "[object Array]";
    }
    function polyArrIncludes(theArray, searchElement, fromIndex) {
        return arrIndexOf(theArray, searchElement, fromIndex) !== -1;
    }
    function polyArrFind(theArray, callbackFn, thisArg) {
        let result;
        let idx = polyArrFindIndex(theArray, callbackFn, thisArg);
        return idx !== -1 ? theArray[idx] : result;
    }
    function polyArrFindIndex(theArray, callbackFn, thisArg) {
        let result = -1;
        arrForEach(theArray, (value, index) => {
            if (fnCall(callbackFn, thisArg | theArray, value, index, theArray)) {
                result = index;
                return -1;
            }
        });
        return result;
    }
    function polyArrFindLast(theArray, callbackFn, thisArg) {
        let result;
        let idx = polyArrFindLastIndex(theArray, callbackFn, thisArg);
        return idx !== -1 ? theArray[idx] : result;
    }
    function polyArrFindLastIndex(theArray, callbackFn, thisArg) {
        let result = -1;
        let len = theArray[LENGTH] >>> 0;
        for (let idx = len - 1; idx >= 0; idx--) {
            if (idx in theArray && fnCall(callbackFn, thisArg | theArray, theArray[idx], idx, theArray)) {
                result = idx;
                break;
            }
        }
        return result;
    }
    function polyArrFrom(theValue, mapFn, thisArg) {
        if (isArray(theValue)) {
            let result = arrSlice(theValue);
            return mapFn ? arrMap(result, mapFn, thisArg) : result;
        }
        let result = [];
        iterForOf(theValue, (value, cnt) => {
            return result.push(mapFn ? fnCall(mapFn, thisArg, value, cnt) : value);
        });
        return result;
    }

    const arrFind = _unwrapFunctionWithPoly("find", ArrProto, polyArrFind);
    const arrFindIndex = _unwrapFunctionWithPoly("findIndex", ArrProto, polyArrFindIndex);
    const arrFindLast = _unwrapFunctionWithPoly("findLast", ArrProto, polyArrFindLast);
    const arrFindLastIndex = _unwrapFunctionWithPoly("findLastIndex", ArrProto, polyArrFindLastIndex);

    const arrFrom = ArrCls.from || polyArrFrom;

    const arrIncludes = _unwrapFunctionWithPoly("includes", ArrProto, polyArrIncludes);
    const arrContains = arrIncludes;

    const arrReduce = _unwrapFunction("reduce", ArrProto);

    const arrSome = _unwrapFunction("some", ArrProto);

    const fnBind = _unwrapInstFunction("bind");

    const createFnDeferredProxy = (hostFn, funcName) => {
        return function () {
            var theArgs = arrSlice(arguments);
            let theHost = hostFn();
            return fnApply(theHost[funcName], theHost, theArgs);
        };
    };
    const createProxyFuncs = (target, host, funcDefs) => {
        if (target && host && isArray(funcDefs)) {
            let isDeferred = isFunction(host);
            arrForEach(funcDefs, (funcDef) => {
                let targetName = (funcDef.as || funcDef.n);
                if (funcDef.rp === false && target[targetName]) {
                    return;
                }
                target[targetName] = isDeferred ?
                    createFnDeferredProxy(host, funcDef.n) :
                    fnBind(host[funcDef.n], host);
            });
        }
        return target;
    };

    let _iterSymbol;
    const readArgs = (theArgs, start, end) => {
        if (!_iterSymbol) {
            _iterSymbol = getLazy(() => hasSymbol() && getKnownSymbol(3 ));
        }
        if (!objHasOwn(theArgs, LENGTH)) {
            let iterFn = _iterSymbol.v && theArgs[_iterSymbol.v];
            if (iterFn) {
                let values = [];
                let from = (start === UNDEF_VALUE || start < 0) ? 0 : start;
                let to = end < 0 || start < 0 ? UNDEF_VALUE : end;
                iterForOf(iterFn.call(theArgs), (value, cnt) => {
                    if (to !== UNDEF_VALUE && cnt >= to) {
                        return -1;
                    }
                    if (cnt >= from) {
                        values.push(value);
                    }
                });
                if ((start === UNDEF_VALUE || start >= 0) && (end === UNDEF_VALUE || end >= 0)) {
                    return values;
                }
                theArgs = values;
            }
        }
        return arrSlice(theArgs, start, end);
    };

    const _objCreate = ObjClass["create"];
    const objCreate = _objCreate || polyObjCreate;
    function polyObjCreate(obj) {
        if (!obj) {
            return {};
        }
        let type = typeof obj;
        if (type !== OBJECT && type !== FUNCTION) {
            throw new TypeError("Prototype must be an Object or function: " + dumpObj(obj));
        }
        function tempFunc() { }
        tempFunc[PROTOTYPE] = obj;
        return new tempFunc();
    }

    let _isProtoArray;
    function objSetPrototypeOf(obj, proto) {
        let fn = ObjClass["setPrototypeOf"] ||
            function (d, b) {
                !_isProtoArray && (_isProtoArray = getLazy(() => ({ [__PROTO__]: [] } instanceof Array)));
                _isProtoArray.v ? d[__PROTO__] = b : objForEachKey(b, (key, value) => d[key] = value);
            };
        return fn(obj, proto);
    }

    const _createCustomError = (name, d, b) => {
        _safeDefineName(d, name);
        d = objSetPrototypeOf(d, b);
        function __() {
            this.constructor = d;
            _safeDefineName(this, name);
        }
        d[PROTOTYPE] = b === NULL_VALUE ? objCreate(b) : (__[PROTOTYPE] = b[PROTOTYPE], new __());
        return d;
    };
    const _safeSetName = (baseClass, name) => {
        try {
            name && (baseClass[NAME] = name);
        }
        catch (e) {
        }
    };
    const _safeDefineName = (target, name) => {
        try {
            objDefine(target, NAME, { v: name, c: true, e: false });
        }
        catch (e) {
        }
    };
    function createCustomError(name, constructCb, errorBase) {
        let theBaseClass = errorBase || Error;
        let orgName = theBaseClass[PROTOTYPE][NAME];
        let captureFn = Error.captureStackTrace;
        return _createCustomError(name, function () {
            let _this = this;
            try {
                _safeSetName(theBaseClass, name);
                let _self = fnApply(theBaseClass, _this, arrSlice(arguments)) || _this;
                if (_self !== _this) {
                    let orgProto = objGetPrototypeOf(_this);
                    if (orgProto !== objGetPrototypeOf(_self)) {
                        objSetPrototypeOf(_self, orgProto);
                    }
                }
                captureFn && captureFn(_self, _this[CONSTRUCTOR]);
                constructCb && constructCb(_self, arguments);
                return _self;
            }
            finally {
                _safeSetName(theBaseClass, orgName);
            }
        }, theBaseClass);
    }
    let _unsupportedError;
    function throwUnsupported(message) {
        if (!_unsupportedError) {
            _unsupportedError = createCustomError("UnsupportedError");
        }
        throw new _unsupportedError(message);
    }

    function utcNow() {
        return (Date.now || polyUtcNow)();
    }
    function polyUtcNow() {
        return new Date().getTime();
    }

    function _createTrimFn(exp) {
        return function _doTrim(value) {
            if (isNullOrUndefined(value)) {
                throwTypeError("strTrim called [" + dumpObj(value) + "]");
            }
            if (value && value.replace) {
                value = value.replace(exp, EMPTY);
            }
            return value;
        };
    }
    const polyStrTrim = _createTrimFn(/^\s+|(?=\s)\s+$/g);
    const polyStrTrimStart = _createTrimFn(/^\s+/g);
    const polyStrTrimEnd = _createTrimFn(/(?=\s)\s+$/g);

    const strTrim = _unwrapFunctionWithPoly("trim", StrProto, polyStrTrim);
    const strTrimStart = _unwrapFunctionWithPoly("trimStart", StrProto, polyStrTrimStart);
    const strTrimLeft = strTrimStart;
    const strTrimEnd = _unwrapFunctionWithPoly("trimEnd", StrProto, polyStrTrimEnd);
    const strTrimRight = strTrimEnd;

    const strUpper = _unwrapFunction("toUpperCase", StrProto);
    const strLower = _unwrapFunction("toLowerCase", StrProto);

    function _convertCase(value, newPrefix, upperWord) {
        return strTrim(asString(value)).replace(/((_|\W)+(\w){0,1}|([a-z])([A-Z]))/g, (_match, _g1, _g2, wordStart, upperPrefix, upperLetter) => {
            let convertMatch = wordStart || upperLetter || EMPTY;
            if (upperWord) {
                convertMatch = strUpper(convertMatch);
            }
            return (upperPrefix || EMPTY) + newPrefix + convertMatch;
        });
    }
    function strLetterCase(value) {
        return asString(value).replace(/(_|\b)\w/g, strUpper);
    }
    function strCamelCase(value, upperFirst) {
        let result = _convertCase(value, "", true);
        return result.replace(/^\w/, upperFirst ? strUpper : strLower);
    }
    function strKebabCase(value, scream) {
        let result = _convertCase(value, "-");
        return (scream ? strUpper : strLower)(result);
    }
    function strSnakeCase(value, scream) {
        let result = _convertCase(value, "_");
        return (scream ? strUpper : strLower)(result);
    }

    const mathFloor = MathCls.floor;
    const mathCeil = MathCls.ceil;

    const _mathTrunc = MathCls.trunc;
    const mathTrunc = _mathTrunc ? _mathTrunc : polyMathTrunc;
    function polyMathTrunc(value) {
        let theValue = +value;
        return (theValue > 0 ? mathFloor : mathCeil)(theValue);
    }

    function mathToInt(value, throwInfinity) {
        let result = +value;
        if (result == Infinity && throwInfinity) {
            throwRangeError("invalid value [" + dumpObj(value) + "]");
        }
        return result !== result || result === 0 ? 0 : mathTrunc(result);
    }

    const strRepeat = _unwrapFunctionWithPoly("repeat", StrProto, polyStrRepeat);
    function polyStrRepeat(value, count) {
        if (isNullOrUndefined(value)) {
            throwTypeError("can't convert [" + dumpObj(value) + "]");
        }
        count = mathToInt(count, true);
        if (count < 0) {
            throwRangeError("invalid count must be >= 0 && < Infinity");
        }
        let pad = isString(value) ? value : asString(value);
        let result = EMPTY;
        for (; count > 0; (count >>>= 1) && (pad += pad)) {
            if (count & 1) {
                result += pad;
            }
        }
        return result;
    }

    function _padValue(value, targetLength, padString) {
        let result = EMPTY;
        targetLength = mathToInt(targetLength, true);
        targetLength >>= 0;
        let len = value[LENGTH];
        if (len < targetLength) {
            result = isNullOrUndefined(padString) ? " " : asString(padString);
            targetLength = targetLength - len;
            if (targetLength > result[LENGTH]) {
                result = strRepeat(result, mathCeil(targetLength / result[LENGTH]));
            }
            if (result[LENGTH] > targetLength) {
                result = strSubstring(result, 0, targetLength);
            }
        }
        return result;
    }
    const strPadStart = _unwrapFunctionWithPoly("padStart", StrProto, polyStrPadStart);
    const strPadEnd = _unwrapFunctionWithPoly("padEnd", StrProto, polyStrPadEnd);
    function polyStrPadStart(value, targetLength, padString) {
        return _padValue(value, targetLength, padString) + value;
    }
    function polyStrPadEnd(value, targetLength, padString) {
        return value + _padValue(value, targetLength, padString);
    }

    const DBL_QUOTE = "\"";
    const INVALID_JS_NAME = /([^\w\d_$])/g;
    let _htmlEntityCache;
    function normalizeJsName(jsName, camelCase) {
        let result = asString(jsName).replace(INVALID_JS_NAME, "_");
        return !isUndefined(camelCase) ? strCamelCase(result, !camelCase) : result;
    }
    function encodeAsJson(value, format) {
        let result;
        if (isString(value)) {
            result = DBL_QUOTE + value.replace(/[^\w .,\-!@#$%\^&*\(\)_+={}\[\]:;|<>?]/g, (match) => {
                if (match === DBL_QUOTE || match === "\\") {
                    return "\\" + match;
                }
                var hex = match.charCodeAt(0).toString(16);
                return "\\u" + strPadStart(strUpper(hex), 4, "0");
            }) + DBL_QUOTE;
        }
        else {
            try {
                result = JSON.stringify(value, NULL_VALUE, format ? (isNumber(format) ? format : 4) : UNDEF_VALUE);
            }
            catch (e) {
                result = DBL_QUOTE + dumpObj(e) + DBL_QUOTE;
            }
        }
        return result;
    }
    function encodeAsHtml(value) {
        !_htmlEntityCache && (_htmlEntityCache = getLazy(() => {
            return {
                "&": "amp",
                "<": "lt",
                ">": "gt",
                [DBL_QUOTE]: "quot",
                "'": "#39"
            };
        }));
        return asString(value).replace(/[&<>"']/g, match => "&" + _htmlEntityCache.v[match] + ";");
    }

    let _fnToString;
    let _objCtrFnString;
    let _gblWindow;
    function isPlainObject(value) {
        if (!value || typeof value !== OBJECT) {
            return false;
        }
        if (!_gblWindow) {
            _gblWindow = hasWindow() ? getWindow() : true;
        }
        let result = false;
        if (value !== _gblWindow) {
            if (!_objCtrFnString) {
                _fnToString = Function[PROTOTYPE].toString;
                _objCtrFnString = fnCall(_fnToString, ObjClass);
            }
            try {
                let proto = objGetPrototypeOf(value);
                result = !proto;
                if (!result) {
                    if (objHasOwnProperty(proto, CONSTRUCTOR)) {
                        proto = proto[CONSTRUCTOR];
                    }
                    result = proto && typeof proto === FUNCTION && _fnToString.call(proto) === _objCtrFnString;
                }
            }
            catch (ex) {
            }
        }
        return result;
    }

    const _defaultDeepCopyHandler = (details) => {
        details.value && plainObjDeepCopyHandler(details);
        return true;
    };
    const defaultDeepCopyHandlers = [
        arrayDeepCopyHandler,
        plainObjDeepCopyHandler,
        functionDeepCopyHandler,
        dateDeepCopyHandler
    ];
    function _getSetVisited(visitMap, source, newPath, cb) {
        let theEntry;
        arrForEach(visitMap, (entry) => {
            if (entry.k === source) {
                theEntry = entry;
                return -1;
            }
        });
        if (!theEntry) {
            theEntry = { k: source, v: source };
            visitMap.push(theEntry);
            cb(theEntry);
        }
        return theEntry.v;
    }
    function _deepCopy(visitMap, value, ctx, key) {
        let userHandler = ctx.handler;
        let newPath = ctx.path ? (key ? ctx.path.concat(key) : ctx.path) : [];
        let newCtx = {
            handler: ctx.handler,
            src: ctx.src,
            path: newPath
        };
        const theType = typeof value;
        let isPlain = false;
        let isPrim = false;
        if (value && theType === OBJECT) {
            isPlain = isPlainObject(value);
        }
        else {
            isPrim = value === NULL_VALUE || isPrimitiveType(theType);
        }
        let details = {
            type: theType,
            isPrim: isPrim,
            isPlain: isPlain,
            value: value,
            result: value,
            path: newPath,
            origin: ctx.src,
            copy: (source, newKey) => {
                return _deepCopy(visitMap, source, newKey ? newCtx : ctx, newKey);
            },
            copyTo: (target, source) => {
                return _copyProps(visitMap, target, source, newCtx);
            }
        };
        if (!details.isPrim) {
            return _getSetVisited(visitMap, value, newPath, (newEntry) => {
                objDefine(details, "result", {
                    g: function () {
                        return newEntry.v;
                    },
                    s: function (newValue) {
                        newEntry.v = newValue;
                    }
                });
                let idx = 0;
                let handler = userHandler;
                while (!fnCall(handler || (idx < defaultDeepCopyHandlers.length ? defaultDeepCopyHandlers[idx++] : _defaultDeepCopyHandler), ctx, details)) {
                    handler = NULL_VALUE;
                }
            });
        }
        if (userHandler && fnCall(userHandler, ctx, details)) {
            return details.result;
        }
        return value;
    }
    function _copyProps(visitMap, target, source, ctx) {
        if (!isNullOrUndefined(source)) {
            for (const key in source) {
                target[key] = _deepCopy(visitMap, source[key], ctx, key);
            }
        }
        return target;
    }
    function objCopyProps(target, source, handler) {
        let ctx = {
            handler: handler,
            src: source,
            path: []
        };
        return _copyProps([], target, source, ctx);
    }
    function objDeepCopy(source, handler) {
        let ctx = {
            handler: handler,
            src: source
        };
        return _deepCopy([], source, ctx);
    }
    function arrayDeepCopyHandler(details) {
        let value = details.value;
        if (isArray(value)) {
            let target = details.result = [];
            target.length = value.length;
            details.copyTo(target, value);
            return true;
        }
        return false;
    }
    function dateDeepCopyHandler(details) {
        let value = details.value;
        if (isDate(value)) {
            details.result = new Date(value.getTime());
            return true;
        }
        return false;
    }
    function functionDeepCopyHandler(details) {
        if (details.type === FUNCTION) {
            return true;
        }
        return false;
    }
    function plainObjDeepCopyHandler(details) {
        let value = details.value;
        if (value && details.isPlain) {
            let target = details.result = {};
            details.copyTo(target, value);
            return true;
        }
        return false;
    }

    function _doExtend(target, theArgs) {
        arrForEach(theArgs, (theArg) => {
            objCopyProps(target, theArg);
        });
        return target;
    }
    function deepExtend(target, obj1, obj2, obj3, obj4, obj5, obj6) {
        return _doExtend(objDeepCopy(target) || {}, arrSlice(arguments));
    }
    function objExtend(target, obj1, obj2, obj3, obj4, obj5, obj6) {
        return _doExtend(target || {}, arrSlice(arguments));
    }

    const getLength = _unwrapProp(LENGTH);

    function getIntValue(value, defValue) {
        if (!isNullOrUndefined(value)) {
            if (isNumber(value)) {
                return value;
            }
            let theValue = parseInt(value, 10);
            return isNaN(theValue) ? defValue : theValue;
        }
        return defValue;
    }

    let _perf;
    function hasPerformance() {
        return !!getPerformance();
    }
    function getPerformance() {
        (!_perf || (!_perf.b && _globalLazyTestHooks && _globalLazyTestHooks.lzy)) && (_perf = lazySafeGetInst("performance"));
        return _perf.v;
    }
    function perfNow() {
        let perf = getPerformance();
        if (perf && perf.now) {
            return perf.now();
        }
        return utcNow();
    }
    function elapsedTime(startTime) {
        return perfNow() - startTime;
    }

    const MATCH_ANY = "(.*)";
    const MATCH_SINGLE = "(.)";
    function _createRegExp(value, escapeRgx, replaceFn, ignoreCase, fullMatch) {
        return new RegExp((fullMatch ? "^" : EMPTY) + replaceFn(value.replace(escapeRgx, "\\$1")) + (fullMatch ? "$" : EMPTY), ignoreCase ? "i" : "");
    }
    function createWildcardRegex(value, ignoreCase, fullMatch) {
        return _createRegExp(asString(value), /([-+|^$#.\?{}()\[\]\\/\"\'])/g, (value) => {
            return value.replace(/\*/g, MATCH_ANY);
        }, !!ignoreCase, fullMatch);
    }
    function createFilenameRegex(value, ignoreCase, fullMatch) {
        return _createRegExp(asString(value), /([-+|^$#.{}()\\\/\[\]\"\'])/g, (value) => {
            return value.replace(/(\\\\|\\\/|\*|\?)/g, function (_all, g1) {
                if (g1 == "\\/" || g1 == "\\\\") {
                    return "[\\\\\\/]{1}";
                }
                return g1 == "*" ? MATCH_ANY : MATCH_SINGLE;
            });
        }, !!ignoreCase, fullMatch);
    }
    function makeGlobRegex(value, ignoreCase, fullMatch) {
        return _createRegExp(asString(value), /([-+|^$#.{}()\\\/\[\]\"\'])/g, (value) => {
            return value.replace(/(\*\*\\[\\\/]|\\\\|\\\/|\*\*|\*|\?)/g, function (_all, g1) {
                if (g1 == "**\\/" || g1 == "**\\\\") {
                    return "(.*[\\\\\\/])*";
                }
                if (g1 === "\\/" || g1 == "\\\\") {
                    return "[\\\\\\/]{1}";
                }
                if (g1 === "**") {
                    return MATCH_ANY;
                }
                return g1 === "*" ? "([^\\\\\\/]*)" : "([^\\\\\\/]{1})";
            });
        }, !!ignoreCase, fullMatch);
    }

    function _checkLength(value, props) {
        let result;
        arrForEach(props, (prop) => {
            if (prop in value) {
                let propValue = value[prop];
                result = (isFunction(propValue) ? propValue() : propValue) > 0;
                return -1;
            }
        });
        return result;
    }
    function _hasValue(value, depth) {
        let result = value === false || value === 0;
        if (!result && !isNullOrUndefined(value)) {
            if (isArray(value)) {
                result = value[LENGTH] > 0;
            }
            else if (isDate(value)) {
                result = !isNaN(value.getTime());
            }
            else if (isBoolean(value)) {
                return true;
            }
            else if (isObject(value)) {
                try {
                    let chkValue = _checkLength(value, [LENGTH, "byteLength", "size", "count"]);
                    if (isBoolean(chkValue)) {
                        return chkValue;
                    }
                    if (isFunction(value.valueOf) && depth < 5) {
                        return _hasValue(value.valueOf(), ++depth);
                    }
                }
                catch (e) {
                }
                return !!objKeys(value)[LENGTH];
            }
            else {
                result = isTruthy(value);
            }
        }
        return result;
    }
    function hasValue(value) {
        return _hasValue(value, 0);
    }

    function createIterable(ctx) {
        return makeIterable({}, ctx);
    }
    function makeIterable(target, ctx) {
        let itSymbol = getKnownSymbol(3 );
        function _createIterator() {
            return createIterator(ctx);
        }
        target[itSymbol] = _createIterator;
        return target;
    }
    function createIterator(ctx) {
        let isDone = false;
        function _value() {
            return ctx.v;
        }
        function _next() {
            isDone = isDone || (ctx.n ? ctx.n(arguments) : true);
            let result = {
                [DONE]: isDone
            };
            if (!isDone) {
                objDefine(result, VALUE, { g: _value });
            }
            return result;
        }
        function _return(value) {
            isDone = true;
            return {
                [DONE]: true,
                [VALUE]: ctx.r && ctx.r(value)
            };
        }
        function _throw(e) {
            isDone = true;
            return {
                [DONE]: true,
                [VALUE]: ctx.t && ctx.t(e)
            };
        }
        let theIterator = {
            next: _next
        };
        if (ctx.r) {
            theIterator.return = _return;
        }
        if (ctx.t) {
            theIterator.throw = _throw;
        }
        return theIterator;
    }

    function createArrayIterator(values) {
        let idx = -1;
        let theValues = values ? values.slice() : [];
        let len = theValues[LENGTH];
        function _value() {
            if (idx >= 0 && idx < len) {
                return theValues[idx];
            }
        }
        function _getNext() {
            idx++;
            return idx >= len;
        }
        let ctx = {
            n: _getNext
        };
        objDefine(ctx, "v", { g: _value });
        return createIterator(ctx);
    }

    function createRangeIterator(start, end, step) {
        let nextValue = start;
        let theValue = UNDEF_VALUE;
        if (isNullOrUndefined(end)) {
            end = start;
        }
        let theStep = step || ((start <= end) ? 1 : -1);
        function _value() {
            return theValue;
        }
        function _getNext() {
            let isDone = false;
            if (theStep > 0) {
                isDone = nextValue > end;
            }
            else {
                isDone = nextValue < end;
            }
            if (!isDone) {
                theValue = nextValue;
                nextValue += theStep;
            }
            return isDone;
        }
        let ctx = {
            n: _getNext
        };
        objDefine(ctx, "v", { g: _value });
        return createIterator(ctx);
    }

    function polyStrSymSplit(value, splitter, limit) {
        let splitFn = splitter && splitter[getKnownSymbol(9 )];
        return splitFn ? splitFn(value, limit) : [value];
    }

    const strSplit = _unwrapFunction("split", StrProto);
    const strSymSplit = hasSymbol() ? _unwrapFunction("split", StrProto) : polyStrSymSplit;

    function getValueByKey(target, path, defValue) {
        if (!path || !target) {
            return defValue;
        }
        let parts = strSplit(path, ".");
        let cnt = parts.length;
        for (let lp = 0; lp < cnt && !isNullOrUndefined(target); lp++) {
            target = target[parts[lp]];
        }
        return (!isNullOrUndefined(target) ? target : defValue);
    }
    function getValueByIter(target, iter, defValue) {
        if (!iter || !target) {
            return defValue;
        }
        iterForOf(iter, (value) => {
            if (isNullOrUndefined(target)) {
                return -1;
            }
            target = target[value];
        });
        return (!isNullOrUndefined(target) ? target : defValue);
    }
    function setValueByKey(target, path, value) {
        if (target && path) {
            let parts = strSplit(path, ".");
            let lastKey = parts.pop();
            arrForEach(parts, (key) => {
                if (isNullOrUndefined(target[key])) {
                    target[key] = {};
                }
                target = target[key];
            });
            target[lastKey] = value;
        }
    }
    function setValueByIter(target, iter, value) {
        if (target && iter) {
            let lastKey;
            iterForOf(iter, (key) => {
                if (lastKey) {
                    if (isNullOrUndefined(target[lastKey])) {
                        target[lastKey] = {};
                    }
                    target = target[lastKey];
                }
                lastKey = key;
            });
            target[lastKey] = value;
        }
    }

    const strEndsWith = _unwrapFunctionWithPoly("endsWith", StrProto, polyStrEndsWith);
    function polyStrEndsWith(value, searchString, length) {
        if (!isString(value)) {
            throwTypeError("'" + dumpObj(value) + "' is not a string");
        }
        let searchValue = isString(searchString) ? searchString : asString(searchString);
        let chkLen = searchValue[LENGTH];
        let len = value[LENGTH];
        let end = !isUndefined(length) && length < len ? length : len;
        return strSubstring(value, end - chkLen, end) === searchValue;
    }

    const strIndexOf = _unwrapFunction(INDEX_OF, StrProto);
    const strLastIndexOf = _unwrapFunction(LAST_INDEX_OF, StrProto);

    const strIncludes = _unwrapFunctionWithPoly("includes", StrProto, polyStrIncludes);
    const strContains = strIncludes;
    function polyStrIncludes(value, searchString, position) {
        if (isRegExp(searchString)) {
            throwTypeError("'searchString' must not be a regular expression" + dumpObj(searchString));
        }
        return strIndexOf(value, asString(searchString), position) !== -1;
    }

    function strIsNullOrWhiteSpace(value) {
        if (isString(value)) {
            return value.replace(/[\s\t\r\n\f]+/g, EMPTY) === EMPTY;
        }
        return isNullOrUndefined(value);
    }
    function strIsNullOrEmpty(value) {
        if (isString(value)) {
            return value === EMPTY;
        }
        return isNullOrUndefined(value);
    }

    const REF = "ref";
    const UNREF = "un" + REF;
    const HAS_REF = "hasRef";
    const ENABLED = "enabled";
    function _createTimerHandler(startTimer, refreshFn, cancelFn) {
        let ref = true;
        let timerId = startTimer ? refreshFn(NULL_VALUE) : NULL_VALUE;
        let theTimerHandler;
        const _unref = () => {
            ref = false;
            timerId && timerId[UNREF] && timerId[UNREF]();
            return theTimerHandler;
        };
        const _ref = () => {
            ref = true;
            timerId && timerId[REF] && timerId[REF]();
            return theTimerHandler;
        };
        const _hasRef = () => {
            if (timerId && timerId[HAS_REF]) {
                return timerId[HAS_REF]();
            }
            return ref;
        };
        const _refresh = () => {
            timerId = refreshFn(timerId);
            if (!ref) {
                _unref();
            }
            return theTimerHandler;
        };
        const _cancel = () => {
            timerId && cancelFn(timerId);
            timerId = NULL_VALUE;
        };
        const _setEnabled = (value) => {
            !value && timerId && _cancel();
            value && !timerId && _refresh();
        };
        theTimerHandler = {
            cancel: _cancel,
            refresh: _refresh,
            [HAS_REF]: _hasRef,
            [REF]: _ref,
            [UNREF]: _unref,
            [ENABLED]: false
        };
        objDefineProp(theTimerHandler, ENABLED, {
            get: () => !!timerId,
            set: _setEnabled
        });
        return {
            h: theTimerHandler,
            dn: () => {
                timerId = NULL_VALUE;
            }
        };
    }

    function _createTimeoutWith(self, startTimer, overrideFn, theArgs) {
        let isArr = isArray(overrideFn);
        let len = isArr ? overrideFn.length : 0;
        let setFn = (len > 0 ? overrideFn[0] : (!isArr ? overrideFn : UNDEF_VALUE)) || setTimeout;
        let clearFn = (len > 1 ? overrideFn[1] : UNDEF_VALUE) || clearTimeout;
        let timerFn = theArgs[0];
        theArgs[0] = function () {
            handler.dn();
            fnApply(timerFn, self, arrSlice(arguments));
        };
        let handler = _createTimerHandler(startTimer, (timerId) => {
            if (timerId) {
                if (timerId.refresh) {
                    timerId.refresh();
                    return timerId;
                }
                fnApply(clearFn, self, [timerId]);
            }
            return fnApply(setFn, self, theArgs);
        }, function (timerId) {
            fnApply(clearFn, self, [timerId]);
        });
        return handler.h;
    }
    function scheduleTimeout(callback, timeout) {
        return _createTimeoutWith(this, true, UNDEF_VALUE, arrSlice(arguments));
    }
    function scheduleTimeoutWith(overrideFn, callback, timeout) {
        return _createTimeoutWith(this, true, overrideFn, arrSlice(arguments, 1));
    }
    function createTimeout(callback, timeout) {
        return _createTimeoutWith(this, false, UNDEF_VALUE, arrSlice(arguments));
    }
    function createTimeoutWith(overrideFn, callback, timeout) {
        return _createTimeoutWith(this, false, overrideFn, arrSlice(arguments, 1));
    }

    let _hasIdleCallback;
    let _defaultIdleTimeout = 100;
    let _maxExecutionTime = 50;
    function hasIdleCallback() {
        !_hasIdleCallback && (_hasIdleCallback = safeGetLazy(() => isDefined(requestIdleCallback), false));
        return !!(_hasIdleCallback.v ? requestIdleCallback : false);
    }
    function setDefaultIdleTimeout(timeout) {
        _defaultIdleTimeout = timeout;
    }
    function setDefaultMaxExecutionTime(maxTime) {
        _maxExecutionTime = maxTime;
    }
    function scheduleIdleCallback(callback, options) {
        function _createDeadline(timedOut) {
            let startTime = perfNow();
            return {
                didTimeout: timedOut,
                timeRemaining: () => {
                    return _maxExecutionTime - elapsedTime(startTime);
                }
            };
        }
        if (hasIdleCallback()) {
            let handler = _createTimerHandler(true, (idleId) => {
                idleId && cancelIdleCallback(idleId);
                return requestIdleCallback((deadline) => {
                    handler.dn();
                    callback(deadline || _createDeadline(false));
                }, options);
            }, (idleId) => {
                cancelIdleCallback(idleId);
            });
            return handler.h;
        }
        let timeout = (options || {}).timeout;
        if (isUndefined(timeout)) {
            timeout = _defaultIdleTimeout;
        }
        return scheduleTimeout(() => {
            callback(_createDeadline(true));
        }, timeout);
    }

    function scheduleInterval(callback, timeout) {
        let self = this;
        let theArguments = arrSlice(arguments);
        let handler = _createTimerHandler(true, (intervalId) => {
            intervalId && clearInterval(intervalId);
            return fnApply(setInterval, self, theArguments);
        }, (intervalId) => {
            fnApply(clearInterval, self, [intervalId]);
        });
        return handler.h;
    }

    exports.arrAppend = arrAppend;
    exports.arrContains = arrContains;
    exports.arrEvery = arrEvery;
    exports.arrFilter = arrFilter;
    exports.arrFind = arrFind;
    exports.arrFindIndex = arrFindIndex;
    exports.arrFindLast = arrFindLast;
    exports.arrFindLastIndex = arrFindLastIndex;
    exports.arrForEach = arrForEach;
    exports.arrFrom = arrFrom;
    exports.arrIncludes = arrIncludes;
    exports.arrIndexOf = arrIndexOf;
    exports.arrLastIndexOf = arrLastIndexOf;
    exports.arrMap = arrMap;
    exports.arrReduce = arrReduce;
    exports.arrSlice = arrSlice;
    exports.arrSome = arrSome;
    exports.arrayDeepCopyHandler = arrayDeepCopyHandler;
    exports.asString = asString;
    exports.createArrayIterator = createArrayIterator;
    exports.createCustomError = createCustomError;
    exports.createEnum = createEnum;
    exports.createEnumKeyMap = createEnumKeyMap;
    exports.createEnumValueMap = createEnumValueMap;
    exports.createFilenameRegex = createFilenameRegex;
    exports.createFnDeferredProxy = createFnDeferredProxy;
    exports.createIterable = createIterable;
    exports.createIterator = createIterator;
    exports.createProxyFuncs = createProxyFuncs;
    exports.createRangeIterator = createRangeIterator;
    exports.createSimpleMap = createSimpleMap;
    exports.createTimeout = createTimeout;
    exports.createTimeoutWith = createTimeoutWith;
    exports.createTypeMap = createTypeMap;
    exports.createWildcardRegex = createWildcardRegex;
    exports.dateDeepCopyHandler = dateDeepCopyHandler;
    exports.deepExtend = deepExtend;
    exports.dumpObj = dumpObj;
    exports.elapsedTime = elapsedTime;
    exports.encodeAsHtml = encodeAsHtml;
    exports.encodeAsJson = encodeAsJson;
    exports.fnApply = fnApply;
    exports.fnBind = fnBind;
    exports.fnCall = fnCall;
    exports.functionDeepCopyHandler = functionDeepCopyHandler;
    exports.getDocument = getDocument;
    exports.getGlobal = getGlobal;
    exports.getHistory = getHistory;
    exports.getInst = getInst;
    exports.getIntValue = getIntValue;
    exports.getKnownSymbol = getKnownSymbol;
    exports.getLazy = getLazy;
    exports.getLength = getLength;
    exports.getNavigator = getNavigator;
    exports.getPerformance = getPerformance;
    exports.getSymbol = getSymbol;
    exports.getValueByIter = getValueByIter;
    exports.getValueByKey = getValueByKey;
    exports.getWindow = getWindow;
    exports.hasDocument = hasDocument;
    exports.hasHistory = hasHistory;
    exports.hasIdleCallback = hasIdleCallback;
    exports.hasNavigator = hasNavigator;
    exports.hasPerformance = hasPerformance;
    exports.hasSymbol = hasSymbol;
    exports.hasValue = hasValue;
    exports.hasWindow = hasWindow;
    exports.isArray = isArray;
    exports.isArrayBuffer = isArrayBuffer;
    exports.isBlob = isBlob;
    exports.isBoolean = isBoolean;
    exports.isDate = isDate;
    exports.isDefined = isDefined;
    exports.isError = isError;
    exports.isFile = isFile;
    exports.isFormData = isFormData;
    exports.isFunction = isFunction;
    exports.isIterable = isIterable;
    exports.isIterator = isIterator;
    exports.isNode = isNode;
    exports.isNotTruthy = isNotTruthy;
    exports.isNullOrUndefined = isNullOrUndefined;
    exports.isNumber = isNumber;
    exports.isObject = isObject;
    exports.isPlainObject = isPlainObject;
    exports.isPrimitive = isPrimitive;
    exports.isPrimitiveType = isPrimitiveType;
    exports.isPromise = isPromise;
    exports.isPromiseLike = isPromiseLike;
    exports.isRegExp = isRegExp;
    exports.isStrictNullOrUndefined = isStrictNullOrUndefined;
    exports.isStrictUndefined = isStrictUndefined;
    exports.isString = isString;
    exports.isSymbol = isSymbol;
    exports.isThenable = isThenable;
    exports.isTruthy = isTruthy;
    exports.isTypeof = isTypeof;
    exports.isUndefined = isUndefined;
    exports.isWebWorker = isWebWorker;
    exports.iterForOf = iterForOf;
    exports.lazySafeGetInst = lazySafeGetInst;
    exports.makeGlobRegex = makeGlobRegex;
    exports.makeIterable = makeIterable;
    exports.mathCeil = mathCeil;
    exports.mathFloor = mathFloor;
    exports.mathMax = mathMax;
    exports.mathMin = mathMin;
    exports.mathToInt = mathToInt;
    exports.mathTrunc = mathTrunc;
    exports.newSymbol = newSymbol;
    exports.normalizeJsName = normalizeJsName;
    exports.objAssign = objAssign;
    exports.objCopyProps = objCopyProps;
    exports.objCreate = objCreate;
    exports.objDeepCopy = objDeepCopy;
    exports.objDeepFreeze = objDeepFreeze;
    exports.objDefine = objDefine;
    exports.objDefineAccessors = objDefineAccessors;
    exports.objDefineGet = objDefineGet;
    exports.objDefineProp = objDefineProp;
    exports.objDefineProperties = objDefineProperties;
    exports.objDefineProps = objDefineProps;
    exports.objEntries = objEntries;
    exports.objExtend = objExtend;
    exports.objForEachKey = objForEachKey;
    exports.objFreeze = objFreeze;
    exports.objGetOwnPropertyDescriptor = objGetOwnPropertyDescriptor;
    exports.objGetPrototypeOf = objGetPrototypeOf;
    exports.objHasOwn = objHasOwn;
    exports.objHasOwnProperty = objHasOwnProperty;
    exports.objKeys = objKeys;
    exports.objSeal = objSeal;
    exports.objSetPrototypeOf = objSetPrototypeOf;
    exports.objToString = objToString;
    exports.perfNow = perfNow;
    exports.plainObjDeepCopyHandler = plainObjDeepCopyHandler;
    exports.polyArrFind = polyArrFind;
    exports.polyArrFindIndex = polyArrFindIndex;
    exports.polyArrFindLast = polyArrFindLast;
    exports.polyArrFindLastIndex = polyArrFindLastIndex;
    exports.polyArrFrom = polyArrFrom;
    exports.polyArrIncludes = polyArrIncludes;
    exports.polyGetKnownSymbol = polyGetKnownSymbol;
    exports.polyIsArray = polyIsArray;
    exports.polyNewSymbol = polyNewSymbol;
    exports.polyObjEntries = polyObjEntries;
    exports.polyObjHasOwn = polyObjHasOwn;
    exports.polyObjKeys = polyObjKeys;
    exports.polyStrIncludes = polyStrIncludes;
    exports.polyStrSubstr = polyStrSubstr;
    exports.polyStrSymSplit = polyStrSymSplit;
    exports.polyStrTrim = polyStrTrim;
    exports.polyStrTrimEnd = polyStrTrimEnd;
    exports.polyStrTrimStart = polyStrTrimStart;
    exports.polySymbolFor = polySymbolFor;
    exports.polySymbolKeyFor = polySymbolKeyFor;
    exports.polyUtcNow = polyUtcNow;
    exports.readArgs = readArgs;
    exports.safeGet = safeGet;
    exports.safeGetLazy = safeGetLazy;
    exports.scheduleIdleCallback = scheduleIdleCallback;
    exports.scheduleInterval = scheduleInterval;
    exports.scheduleTimeout = scheduleTimeout;
    exports.scheduleTimeoutWith = scheduleTimeoutWith;
    exports.setBypassLazyCache = setBypassLazyCache;
    exports.setDefaultIdleTimeout = setDefaultIdleTimeout;
    exports.setDefaultMaxExecutionTime = setDefaultMaxExecutionTime;
    exports.setValueByIter = setValueByIter;
    exports.setValueByKey = setValueByKey;
    exports.strCamelCase = strCamelCase;
    exports.strContains = strContains;
    exports.strEndsWith = strEndsWith;
    exports.strIncludes = strIncludes;
    exports.strIndexOf = strIndexOf;
    exports.strIsNullOrEmpty = strIsNullOrEmpty;
    exports.strIsNullOrWhiteSpace = strIsNullOrWhiteSpace;
    exports.strKebabCase = strKebabCase;
    exports.strLastIndexOf = strLastIndexOf;
    exports.strLeft = strLeft;
    exports.strLetterCase = strLetterCase;
    exports.strLower = strLower;
    exports.strPadEnd = strPadEnd;
    exports.strPadStart = strPadStart;
    exports.strRepeat = strRepeat;
    exports.strRight = strRight;
    exports.strSlice = strSlice;
    exports.strSnakeCase = strSnakeCase;
    exports.strSplit = strSplit;
    exports.strStartsWith = strStartsWith;
    exports.strSubstr = strSubstr;
    exports.strSubstring = strSubstring;
    exports.strSymSplit = strSymSplit;
    exports.strTrim = strTrim;
    exports.strTrimEnd = strTrimEnd;
    exports.strTrimLeft = strTrimLeft;
    exports.strTrimRight = strTrimRight;
    exports.strTrimStart = strTrimStart;
    exports.strUpper = strUpper;
    exports.symbolFor = symbolFor;
    exports.symbolKeyFor = symbolKeyFor;
    exports.throwError = throwError;
    exports.throwRangeError = throwRangeError;
    exports.throwTypeError = throwTypeError;
    exports.throwUnsupported = throwUnsupported;
    exports.utcNow = utcNow;

}));
//# sourceMappingURL=ts-utils.js.map
