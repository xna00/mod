/*
 * NevWare21 - ts-utils Polyfills, v0.10.1
 * https://github.com/nevware21/ts-utils
 * Copyright (c) NevWare21 and contributors. All rights reserved.
 * Licensed under the MIT license.
 */
(function () {
    'use strict';

    var UNDEF_VALUE = undefined;
    var NULL_VALUE = null;
    var EMPTY = "";
    var FUNCTION = "function";
    var NUMBER = "number";
    var OBJECT = "object";
    var PROTOTYPE = "prototype";
    var STRING = "string";
    var UNDEFINED = "undefined";
    var SYMBOL = "Symbol";
    var POLYFILL_TAG = "_polyfill";
    var INDEX_OF = "indexOf";
    var LAST_INDEX_OF = "lastIndexOf";
    var LENGTH = "length";
    var DONE = "done";
    var VALUE = "value";
    var SLICE = "slice";
    var ObjClass = Object;
    var ObjProto = ObjClass[PROTOTYPE];
    var StrCls = String;
    var StrProto = StrCls[PROTOTYPE];
    var MathCls = Math;
    var ArrCls = Array;
    var ArrProto = ArrCls[PROTOTYPE];

    function arrForEach(theArray, callbackfn, thisArg) {
        if (theArray) {
            var len = theArray[LENGTH] >>> 0;
            for (var idx = 0; idx < len; idx++) {
                if (idx in theArray) {
                    if (callbackfn.call(thisArg || theArray, theArray[idx], idx, theArray) === -1) {
                        break;
                    }
                }
            }
        }
    }

    function safeGet(cb, defValue) {
        var result = defValue;
        try {
            result = cb();
        }
        catch (e) {
        }
        return result;
    }

    function _createIs(theType) {
        return function (value) {
            return typeof value === theType;
        };
    }
    function _createObjIs(theName) {
        var theType = "[object " + theName + "]";
        return function (value) {
            return !!(value && objToString(value) === theType);
        };
    }
    function objToString(value) {
        return ObjProto.toString.call(value);
    }
    function isUndefined(value) {
        return typeof value === UNDEFINED || value === UNDEFINED;
    }
    function isNullOrUndefined(value) {
        return value === NULL_VALUE || isUndefined(value);
    }
    var isString = _createIs(STRING);
    var isFunction = _createIs(FUNCTION);
    function isObject(value) {
        if (!value && isNullOrUndefined(value)) {
            return false;
        }
        return !!value && typeof value === OBJECT;
    }
    var isArray = ArrCls.isArray;
    var isNumber = _createIs(NUMBER);
    var isRegExp = _createObjIs("RegExp");
    var isError = _createObjIs("Error");

    function dumpObj(object, format) {
        var propertyValueDump = EMPTY;
        if (isError(object)) {
            propertyValueDump = "{ stack: '" + object.stack + "', message: '" + object.message + "', name: '" + object.name + "'";
        }
        else {
            try {
                propertyValueDump = JSON.stringify(object, NULL_VALUE, format ? (isNumber(format) ? format : 4) : UNDEF_VALUE);
            }
            catch (e) {
                propertyValueDump = " - " + dumpObj(e, format);
            }
        }
        return objToString(object) + ": " + propertyValueDump;
    }

    function throwTypeError(message) {
        throw new TypeError(message);
    }
    function throwRangeError(message) {
        throw new RangeError(message);
    }

    var asString = StrCls;

    var _arrSlice = ArrProto[SLICE];
    var _throwMissingFunction = function (funcName, thisArg) {
        throwTypeError("'" + asString(funcName) + "' not defined for " + dumpObj(thisArg));
    };
    var _unwrapInstFunction = function (funcName) {
        return function (thisArg) {
            return thisArg[funcName].apply(thisArg, _arrSlice.call(arguments, 1));
        };
    };
    var _unwrapFunction = function (funcName, clsProto) {
        var clsFn = clsProto && clsProto[funcName];
        return function (thisArg) {
            var theFunc = (thisArg && thisArg[funcName]) || clsFn;
            if (theFunc) {
                return theFunc.apply(thisArg, _arrSlice.call(arguments, 1));
            }
            _throwMissingFunction(funcName, thisArg);
        };
    };
    var _unwrapFunctionWithPoly = function (funcName, clsProto, polyFunc) {
        var clsFn = clsProto && clsProto[funcName];
        return function (thisArg) {
            var theFunc = (thisArg && thisArg[funcName]) || clsFn;
            if (theFunc || polyFunc) {
                var theArgs = arguments;
                return (theFunc || polyFunc).apply(thisArg, theFunc ? _arrSlice.call(theArgs, 1) : theArgs);
            }
            _throwMissingFunction(funcName, thisArg);
        };
    };

    var arrIndexOf = _unwrapFunction(INDEX_OF, ArrProto);
    _unwrapFunction(LAST_INDEX_OF, ArrProto);

    var arrMap = _unwrapFunction("map", ArrProto);

    var arrSlice = _unwrapFunction(SLICE, ArrProto);

    var fnCall = _unwrapInstFunction("call");

    var GLOBAL_CONFIG_KEY = "__tsUtils$gblCfg";
    var _globalCfg;
    function _getGlobalValue() {
        var result;
        if (typeof globalThis !== UNDEFINED) {
            result = globalThis;
        }
        if (!result && typeof self !== UNDEFINED) {
            result = self;
        }
        if (!result && typeof window !== UNDEFINED) {
            result = window;
        }
        if (!result && typeof global !== UNDEFINED) {
            result = global;
        }
        return result;
    }
    function _getGlobalConfig() {
        if (!_globalCfg) {
            var gbl = _getGlobalValue() || {};
            _globalCfg = gbl[GLOBAL_CONFIG_KEY] = gbl[GLOBAL_CONFIG_KEY] || {};
        }
        return _globalCfg;
    }

    var objGetOwnPropertyDescriptor = ObjClass.getOwnPropertyDescriptor;

    function objHasOwnProperty(obj, prop) {
        return obj && ObjProto.hasOwnProperty.call(obj, prop);
    }

    var objHasOwn = ObjClass["hasOwn"] || polyObjHasOwn;
    function polyObjHasOwn(obj, prop) {
        return objHasOwnProperty(obj, prop) || !!objGetOwnPropertyDescriptor(obj, prop);
    }

    function objForEachKey(theObject, callbackfn, thisArg) {
        if (theObject && isObject(theObject)) {
            for (var prop in theObject) {
                if (objHasOwn(theObject, prop)) {
                    if (callbackfn.call(thisArg || theObject, prop, theObject[prop]) === -1) {
                        break;
                    }
                }
            }
        }
    }

    var objDefineProp = ObjClass["defineProperty"];

    var _globalLazyTestHooks;
    var _fetchLazyTestHooks = function () {
        _globalLazyTestHooks = _getGlobalConfig();
        _fetchLazyTestHooks = NULL_VALUE;
    };
    function getLazy(cb) {
        var lazyValue = {};
        _fetchLazyTestHooks && _fetchLazyTestHooks();
        lazyValue.b = _globalLazyTestHooks.lzy;
        objDefineProp(lazyValue, "v", {
            configurable: true,
            get: function () {
                var result = cb();
                if (!_globalLazyTestHooks.lzy) {
                    objDefineProp(lazyValue, "v", {
                        value: result
                    });
                    if (lazyValue.b) {
                        delete lazyValue.b;
                    }
                }
                if (_globalLazyTestHooks.lzy && lazyValue.b !== _globalLazyTestHooks.lzy) {
                    lazyValue.b = _globalLazyTestHooks.lzy;
                }
                return result;
            }
        });
        return lazyValue;
    }

    function _createKeyValueMap(values, keyType, valueType, completeFn) {
        var theMap = {};
        objForEachKey(values, function (key, value) {
            theMap[key] = keyType ? value : key;
            theMap[value] = valueType ? value : key;
        });
        return completeFn(theMap);
    }

    function polyObjKeys(obj) {
        if (!isObject(obj) || obj === NULL_VALUE) {
            throw new TypeError("polyObjKeys called on non-object");
        }
        var result = [];
        for (var prop in obj) {
            if (objHasOwn(obj, prop)) {
                result.push(prop);
            }
        }
        return result;
    }

    var _objFreeze = ObjClass["freeze"];
    var _doNothing = function (value) { return value; };
    function objDeepFreeze(value) {
        if (_objFreeze) {
            objForEachKey(value, function (key, value) {
                if (isArray(value) || isObject(value)) {
                    _objFreeze(value);
                }
            });
        }
        return objFreeze(value);
    }
    var objFreeze = _objFreeze || _doNothing;

    function createEnumKeyMap(values) {
        return _createKeyValueMap(values, 0 , 0 , objDeepFreeze);
    }

    var _wellKnownSymbolMap = createEnumKeyMap({
        asyncIterator: 0 ,
        hasInstance: 1 ,
        isConcatSpreadable: 2 ,
        iterator: 3 ,
        match: 4 ,
        matchAll: 5 ,
        replace: 6 ,
        search: 7 ,
        species: 8 ,
        split: 9 ,
        toPrimitive: 10 ,
        toStringTag: 11 ,
        unscopables: 12
    });

    var mathMax = MathCls.max;

    var strSlice = _unwrapFunction(SLICE, StrProto);

    var strSubstring = _unwrapFunction("substring", StrProto);
    _unwrapFunctionWithPoly("substr", StrProto, polyStrSubstr);
    function polyStrSubstr(value, start, length) {
        if (isNullOrUndefined(value)) {
            throwTypeError("'polyStrSubstr called with invalid " + dumpObj(value));
        }
        if (length < 0) {
            return EMPTY;
        }
        start = start || 0;
        if (start < 0) {
            start = mathMax(start + value[LENGTH], 0);
        }
        if (isUndefined(length)) {
            return strSlice(value, start);
        }
        return strSlice(value, start, start + length);
    }

    _unwrapFunctionWithPoly("startsWith", StrProto, polyStrStartsWith);
    function polyStrStartsWith(value, searchString, position) {
        if (!isString(value)) {
            throwTypeError("'" + dumpObj(value) + "' is not a string");
        }
        var searchValue = isString(searchString) ? searchString : asString(searchString);
        var chkLen = searchValue[LENGTH];
        var pos = position > 0 ? position : 0;
        return strSubstring(value, pos, pos + chkLen) === searchValue;
    }

    var _wellKnownSymbolCache = {};
    function polyNewSymbol(description) {
        var theSymbol = {
            description: asString(description),
            toString: function () { return SYMBOL + "(" + description + ")"; }
        };
        theSymbol[POLYFILL_TAG] = true;
        return theSymbol;
    }
    function polyGetKnownSymbol(name) {
        var result;
        var knownName = _wellKnownSymbolMap[name];
        if (knownName) {
            result = _wellKnownSymbolCache[knownName] = _wellKnownSymbolCache[knownName] || polyNewSymbol(SYMBOL + "." + knownName);
        }
        return result;
    }

    function safeGetLazy(cb, defValue) {
        return getLazy(function () { return safeGet(cb, defValue); });
    }

    var WINDOW = "window";
    var _cachedGlobal;
    var _cachedWindow;
    var lazySafeGetInst = function (name) { return safeGetLazy(function () { return getInst(name) || UNDEF_VALUE; }, UNDEF_VALUE); };
    var getGlobal = function (useCached) {
        (!_cachedGlobal || useCached === false || (_globalLazyTestHooks && _globalLazyTestHooks.lzy && !_cachedGlobal.b)) && (_cachedGlobal = safeGetLazy(_getGlobalValue, NULL_VALUE));
        return _cachedGlobal.v;
    };
    var getInst = function (name, useCached) {
        var gbl = (!_cachedGlobal || useCached === false) ? getGlobal(useCached) : _cachedGlobal.v;
        if (gbl && gbl[name]) {
            return gbl[name];
        }
        if (name === WINDOW && _cachedWindow) {
            return _cachedWindow.v;
        }
        return NULL_VALUE;
    };

    var _symbol;
    var _symbolFor;
    var _symbolKeyFor;
    function _getSymbolValue(name) {
        return safeGetLazy(function () {
            return (_symbol.v ? _symbol.v[name] : UNDEF_VALUE);
        }, UNDEF_VALUE);
    }
    function getSymbol() {
        var resetCache = !_symbol || (_globalLazyTestHooks && _globalLazyTestHooks.lzy && !_symbol.b);
        resetCache && (_symbol = lazySafeGetInst(SYMBOL));
        (!_symbolFor || resetCache) && (_symbolFor = _getSymbolValue("for"));
        (!_symbolKeyFor || resetCache) && (_symbolKeyFor = _getSymbolValue("keyFor"));
        return _symbol.v;
    }
    function getKnownSymbol(name, noPoly) {
        var knownName = _wellKnownSymbolMap[name];
        (!_symbol || (_globalLazyTestHooks.lzy && !_symbol.b)) && getSymbol();
        return _symbol.v ? _symbol.v[knownName || name] : (!noPoly ? polyGetKnownSymbol(name) : UNDEF_VALUE);
    }

    function isIterator(value) {
        return !!value && isFunction(value.next);
    }

    var _iterSymbol;
    function iterForOf(iter, callbackfn, thisArg) {
        if (iter) {
            if (!isIterator(iter)) {
                !_iterSymbol && (_iterSymbol = getLazy(function () { return getKnownSymbol(3 ); }));
                iter = iter[_iterSymbol.v] ? iter[_iterSymbol.v]() : null;
            }
            if (isIterator(iter)) {
                var err = void 0;
                var iterResult = void 0;
                try {
                    var count = 0;
                    while (!(iterResult = iter.next())[DONE]) {
                        if (callbackfn.call(thisArg || iter, iterResult[VALUE], count, iter) === -1) {
                            break;
                        }
                        count++;
                    }
                }
                catch (failed) {
                    err = { e: failed };
                    if (iter.throw) {
                        iterResult = null;
                        iter.throw(err);
                    }
                }
                finally {
                    try {
                        if (iterResult && !iterResult[DONE]) {
                            iter.return && iter.return(iterResult);
                        }
                    }
                    finally {
                        if (err) {
                            throw err.e;
                        }
                    }
                }
            }
        }
    }

    function polyIsArray(value) {
        if (isNullOrUndefined(value)) {
            return false;
        }
        return objToString(value) === "[object Array]";
    }
    function polyArrIncludes(theArray, searchElement, fromIndex) {
        return arrIndexOf(theArray, searchElement, fromIndex) !== -1;
    }
    function polyArrFind(theArray, callbackFn, thisArg) {
        var result;
        var idx = polyArrFindIndex(theArray, callbackFn, thisArg);
        return idx !== -1 ? theArray[idx] : result;
    }
    function polyArrFindIndex(theArray, callbackFn, thisArg) {
        var result = -1;
        arrForEach(theArray, function (value, index) {
            if (fnCall(callbackFn, thisArg | theArray, value, index, theArray)) {
                result = index;
                return -1;
            }
        });
        return result;
    }
    function polyArrFindLast(theArray, callbackFn, thisArg) {
        var result;
        var idx = polyArrFindLastIndex(theArray, callbackFn, thisArg);
        return idx !== -1 ? theArray[idx] : result;
    }
    function polyArrFindLastIndex(theArray, callbackFn, thisArg) {
        var result = -1;
        var len = theArray[LENGTH] >>> 0;
        for (var idx = len - 1; idx >= 0; idx--) {
            if (idx in theArray && fnCall(callbackFn, thisArg | theArray, theArray[idx], idx, theArray)) {
                result = idx;
                break;
            }
        }
        return result;
    }
    function polyArrFrom(theValue, mapFn, thisArg) {
        if (isArray(theValue)) {
            var result_1 = arrSlice(theValue);
            return mapFn ? arrMap(result_1, mapFn, thisArg) : result_1;
        }
        var result = [];
        iterForOf(theValue, function (value, cnt) {
            return result.push(mapFn ? fnCall(mapFn, thisArg, value, cnt) : value);
        });
        return result;
    }

    _unwrapFunctionWithPoly("endsWith", StrProto, polyStrEndsWith);
    function polyStrEndsWith(value, searchString, length) {
        if (!isString(value)) {
            throwTypeError("'" + dumpObj(value) + "' is not a string");
        }
        var searchValue = isString(searchString) ? searchString : asString(searchString);
        var chkLen = searchValue[LENGTH];
        var len = value[LENGTH];
        var end = !isUndefined(length) && length < len ? length : len;
        return strSubstring(value, end - chkLen, end) === searchValue;
    }

    function _createTrimFn(exp) {
        return function _doTrim(value) {
            if (isNullOrUndefined(value)) {
                throwTypeError("strTrim called [" + dumpObj(value) + "]");
            }
            if (value && value.replace) {
                value = value.replace(exp, EMPTY);
            }
            return value;
        };
    }
    var polyStrTrim = _createTrimFn(/^\s+|(?=\s)\s+$/g);
    var polyStrTrimStart = _createTrimFn(/^\s+/g);
    var polyStrTrimEnd = _createTrimFn(/(?=\s)\s+$/g);

    var mathFloor = MathCls.floor;
    var mathCeil = MathCls.ceil;

    var _mathTrunc = MathCls.trunc;
    var mathTrunc = _mathTrunc ? _mathTrunc : polyMathTrunc;
    function polyMathTrunc(value) {
        var theValue = +value;
        return (theValue > 0 ? mathFloor : mathCeil)(theValue);
    }

    function mathToInt(value, throwInfinity) {
        var result = +value;
        if (result == Infinity && throwInfinity) {
            throwRangeError("invalid value [" + dumpObj(value) + "]");
        }
        return result !== result || result === 0 ? 0 : mathTrunc(result);
    }

    var strRepeat = _unwrapFunctionWithPoly("repeat", StrProto, polyStrRepeat);
    function polyStrRepeat(value, count) {
        if (isNullOrUndefined(value)) {
            throwTypeError("can't convert [" + dumpObj(value) + "]");
        }
        count = mathToInt(count, true);
        if (count < 0) {
            throwRangeError("invalid count must be >= 0 && < Infinity");
        }
        var pad = isString(value) ? value : asString(value);
        var result = EMPTY;
        for (; count > 0; (count >>>= 1) && (pad += pad)) {
            if (count & 1) {
                result += pad;
            }
        }
        return result;
    }

    function _padValue(value, targetLength, padString) {
        var result = EMPTY;
        targetLength = mathToInt(targetLength, true);
        targetLength >>= 0;
        var len = value[LENGTH];
        if (len < targetLength) {
            result = isNullOrUndefined(padString) ? " " : asString(padString);
            targetLength = targetLength - len;
            if (targetLength > result[LENGTH]) {
                result = strRepeat(result, mathCeil(targetLength / result[LENGTH]));
            }
            if (result[LENGTH] > targetLength) {
                result = strSubstring(result, 0, targetLength);
            }
        }
        return result;
    }
    _unwrapFunctionWithPoly("padStart", StrProto, polyStrPadStart);
    _unwrapFunctionWithPoly("padEnd", StrProto, polyStrPadEnd);
    function polyStrPadStart(value, targetLength, padString) {
        return _padValue(value, targetLength, padString) + value;
    }
    function polyStrPadEnd(value, targetLength, padString) {
        return value + _padValue(value, targetLength, padString);
    }

    function makePolyFn(poly) {
        return function () {
            var theArgs = [this];
            for (var lp = 0; lp < arguments[LENGTH]; lp++) {
                theArgs[lp + 1] = arguments[lp];
            }
            return poly.apply(this, theArgs);
        };
    }

    var strIndexOf = _unwrapFunction(INDEX_OF, StrProto);
    _unwrapFunction(LAST_INDEX_OF, StrProto);

    _unwrapFunctionWithPoly("includes", StrProto, polyStrIncludes);
    function polyStrIncludes(value, searchString, position) {
        if (isRegExp(searchString)) {
            throwTypeError("'searchString' must not be a regular expression" + dumpObj(searchString));
        }
        return strIndexOf(value, asString(searchString), position) !== -1;
    }

    (function () {
        var objectPolyfills = {
            "keys": polyObjKeys,
            "hasOwn": polyObjHasOwn
        };
        var stringPolyfills = {
            "startsWith": polyStrStartsWith,
            "endsWith": polyStrEndsWith,
            "padStart": polyStrPadStart,
            "padEnd": polyStrPadEnd,
            "trim": polyStrTrim,
            "trimStart": polyStrTrimStart,
            "trimLeft": polyStrTrimStart,
            "trimEnd": polyStrTrimEnd,
            "trimRight": polyStrTrimEnd,
            "substr": polyStrSubstr,
            "includes": polyStrIncludes
        };
        var arrayClsPolyfills = {
            "isArray": polyIsArray,
            "from": polyArrFrom
        };
        var arrayPolyfills = {
            "includes": polyArrIncludes,
            "find": polyArrFind,
            "findIndex": polyArrFindIndex,
            "findLast": polyArrFindLast,
            "findLastIndex": polyArrFindLastIndex
        };
        arrForEach(polyObjKeys(objectPolyfills), function (key) {
            if (!ObjClass[key]) {
                ObjClass[key] = makePolyFn(objectPolyfills[key]);
            }
        });
        arrForEach(polyObjKeys(arrayClsPolyfills), function (key) {
            if (!ArrCls[key]) {
                ArrCls[key] = makePolyFn(arrayClsPolyfills[key]);
            }
        });
        arrForEach(polyObjKeys(arrayPolyfills), function (key) {
            if (!ArrProto[key]) {
                ArrProto[key] = makePolyFn(arrayPolyfills[key]);
            }
        });
        arrForEach(polyObjKeys(stringPolyfills), function (key) {
            if (!StrProto[key]) {
                StrProto[key] = makePolyFn(stringPolyfills[key]);
            }
        });
    })();

})();
//# sourceMappingURL=ts-polyfills-utils.js.map
