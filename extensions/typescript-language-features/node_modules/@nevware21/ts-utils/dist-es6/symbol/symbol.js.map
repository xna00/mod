{"version":3,"file":"symbol.js","sourceRoot":"","sources":["../../src/symbol/symbol.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAE,UAAU,EAAE,MAAM,EAAE,WAAW,EAAE,MAAM,uBAAuB,CAAC;AACxE,OAAO,EAAE,kBAAkB,EAAE,aAAa,EAAE,aAAa,EAAE,gBAAgB,EAAE,MAAM,qBAAqB,CAAC;AACzG,OAAO,EAAoB,mBAAmB,EAAE,MAAM,cAAc,CAAC;AACrE,OAAO,EAAE,SAAS,EAAE,MAAM,iBAAiB,CAAC;AAC5C,OAAO,EAAc,oBAAoB,EAAE,MAAM,iBAAiB,CAAC;AACnE,OAAO,EAAE,WAAW,EAAE,MAAM,sBAAsB,CAAC;AACnD,OAAO,EAAE,eAAe,EAAE,MAAM,wBAAwB,CAAC;AAEzD,IAAI,OAA2B,CAAC;AAChC,IAAI,UAA+C,CAAC;AACpD,IAAI,aAA8D,CAAC;AAEnE,SAAS,eAAe,CAAI,IAAY;IACpC,OAAO,WAAW,CAAI;QAClB,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,WAAW,CAAM,CAAC;IAC5D,CAAC,EAAE,WAAW,CAAC,CAAC;AACpB,CAAC;AAED;;;;;GAKG;AACH,MAAM,CAAC,MAAM,QAAQ,GAAoC,SAAS,CAAS,QAAQ,CAAC,CAAC;AAErF;;;;GAIG;AACH,MAAM,UAAU,SAAS;IACrB,OAAO,CAAC,CAAC,SAAS,EAAE,CAAC;AACzB,CAAC;AAED;;;;GAIG;AACH,MAAM,UAAU,SAAS;IACrB,IAAI,UAAU,GAAG,CAAC,OAAO,IAAI,CAAC,oBAAoB,IAAI,oBAAoB,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;IAC9F,UAAU,IAAI,CAAC,OAAO,GAAG,eAAe,CAAC,MAAM,CAAC,CAAC,CAAC;IAClD,CAAC,CAAC,UAAU,IAAI,UAAU,CAAC,IAAI,CAAC,UAAU,GAAG,eAAe,CAAoB,KAAK,CAAC,CAAC,CAAC;IACxF,CAAC,CAAC,aAAa,IAAI,UAAU,CAAC,IAAI,CAAC,aAAa,GAAG,eAAe,CAAuB,QAAQ,CAAC,CAAC,CAAC;IAEpG,OAAO,OAAO,CAAC,CAAC,CAAC;AACrB,CAAC;AAED;;;;;;;;;;;;;GAaG;AACH,MAAM,UAAU,cAAc,CAAa,IAA+B,EAAE,MAAgB;IACxF,IAAI,SAAS,GAAG,mBAAmB,CAAC,IAAI,CAAC,CAAC;IAC1C,uCAAuC;IACvC,CAAC,CAAC,OAAO,IAAI,CAAC,oBAAoB,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,IAAI,SAAS,EAAE,CAAC;IAEtE,OAAO,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,SAAS,IAAI,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC;AACzG,CAAC;AAED;;;;;;;GAOG;AACH,MAAM,UAAU,SAAS,CAAC,WAA6B,EAAE,MAAgB;IACrE,wCAAwC;IACxC,CAAC,CAAC,OAAO,IAAI,CAAC,oBAAoB,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,IAAI,SAAS,EAAE,CAAC;IAEtE,OAAO,OAAO,CAAC,CAAC,CAAC,CAAC,CAAE,OAAO,CAAC,CAAS,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,aAAa,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC;AAC7G,CAAC;AAED;;;;;;GAMG;AACH,MAAM,UAAU,SAAS,CAAC,GAAW;IACjC,uCAAuC;IACvC,CAAC,CAAC,UAAU,IAAI,CAAC,oBAAoB,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,IAAI,SAAS,EAAE,CAAC;IAEzE,OAAO,CAAC,UAAU,CAAC,CAAC,IAAI,aAAa,CAAC,CAAC,GAAG,CAAC,CAAC;AAChD,CAAC;AAED;;;;;;GAMG;AACH,MAAM,UAAU,YAAY,CAAC,GAAW;IACpC,uCAAuC;IACvC,CAAC,CAAC,aAAa,IAAI,CAAC,oBAAoB,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,IAAI,SAAS,EAAE,CAAC;IAE5E,OAAO,CAAC,aAAa,CAAC,CAAC,IAAI,gBAAgB,CAAC,CAAC,GAAG,CAAC,CAAC;AACtD,CAAC","sourcesContent":["/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { NULL_VALUE, SYMBOL, UNDEF_VALUE } from \"../internal/constants\";\r\nimport { polyGetKnownSymbol, polyNewSymbol, polySymbolFor, polySymbolKeyFor } from \"../polyfills/symbol\";\r\nimport { WellKnownSymbols, _wellKnownSymbolMap } from \"./well_known\";\r\nimport { _createIs } from \"../helpers/base\";\r\nimport { ILazyValue, _globalLazyTestHooks } from \"../helpers/lazy\";\r\nimport { safeGetLazy } from \"../helpers/safe_lazy\";\r\nimport { lazySafeGetInst } from \"../helpers/environment\";\r\n\r\nlet _symbol: ILazyValue<Symbol>;\r\nlet _symbolFor: ILazyValue<(key: string) => symbol>;\r\nlet _symbolKeyFor: ILazyValue<(sym: symbol) => string | undefined>;\r\n\r\nfunction _getSymbolValue<T>(name: string): ILazyValue<T> {\r\n    return safeGetLazy<T>(function() {\r\n        return (_symbol.v ? _symbol.v[name] : UNDEF_VALUE) as T;\r\n    }, UNDEF_VALUE);\r\n}\r\n\r\n/**\r\n * Checks if the type of value is a symbol.\r\n * @group Symbol\r\n * @param {any} value - Value to be checked.\r\n * @return {boolean} True if the value is a symbol, false otherwise.\r\n */\r\nexport const isSymbol: (value: any) => value is symbol = _createIs<symbol>(\"symbol\");\r\n\r\n/**\r\n * Helper to identify whether the runtime support the Symbols either via native or an installed polyfill\r\n * @group Symbol\r\n * @returns true if Symbol's are support otherwise false\r\n */\r\nexport function hasSymbol(): boolean {\r\n    return !!getSymbol();\r\n}\r\n\r\n/**\r\n * If Symbols are supported then attempt to return the named Symbol\r\n * @group Symbol\r\n * @returns The value of the named Symbol (if available)\r\n */\r\nexport function getSymbol(): Symbol {\r\n    let resetCache = !_symbol || (_globalLazyTestHooks && _globalLazyTestHooks.lzy && !_symbol.b);\r\n    resetCache && (_symbol = lazySafeGetInst(SYMBOL));\r\n    (!_symbolFor || resetCache) && (_symbolFor = _getSymbolValue<typeof Symbol.for>(\"for\"));\r\n    (!_symbolKeyFor || resetCache) && (_symbolKeyFor = _getSymbolValue<typeof Symbol.keyFor>(\"keyFor\"));\r\n    \r\n    return _symbol.v;\r\n}\r\n\r\n/**\r\n * If Symbols are supported then get the property of the global Symbol, if Symbol's are\r\n * not supported and noPoly is true it returns null. Used to access the well known symbols.\r\n * @group Symbol\r\n * @param name - The property name to return (if it exists) for Symbol\r\n * @param noPoly - Flag indicating whether to return a polyfill if symbols are not supported.\r\n * @returns The value of the property if present\r\n * @example\r\n * ```ts\r\n * // If Symbol is supported in the runtime\r\n * getKnownSymbol(\"toStringTag\") === Symbol.toStringTag;                // true\r\n * getKnownSymbol(WellKnownSymbols.toStringTag) === Symbol.toStringTag; // true\r\n * ```\r\n */\r\nexport function getKnownSymbol<T = symbol>(name: string | WellKnownSymbols, noPoly?: boolean): T {\r\n    let knownName = _wellKnownSymbolMap[name];\r\n    // Cause lazy symbol to get initialized\r\n    (!_symbol || (_globalLazyTestHooks.lzy && !_symbol.b)) && getSymbol();\r\n\r\n    return _symbol.v ? _symbol.v[knownName || name] : (!noPoly ? polyGetKnownSymbol(name) : UNDEF_VALUE);\r\n}\r\n\r\n/**\r\n * Returns a new unique Symbol value. If noPoly is true and symbols are not supported\r\n * then this will return null.\r\n * @group Symbol\r\n * @param description Description of the new Symbol object.\r\n * @param noPoly - Flag indicating whether to return a polyfil if symbols are not supported.\r\n * @returns The new symbol\r\n */\r\nexport function newSymbol(description?: string | number, noPoly?: boolean): symbol {\r\n    // Cause lazy _symbol to get initialized\r\n    (!_symbol || (_globalLazyTestHooks.lzy && !_symbol.b)) && getSymbol();\r\n\r\n    return _symbol.v ? (_symbol.v as any)(description) : (!noPoly ? polyNewSymbol(description) : NULL_VALUE);\r\n}\r\n\r\n/**\r\n * Returns a Symbol object from the global symbol registry matching the given key if found.\r\n * Otherwise, returns a new symbol with this key. This will always return a polyfill if symbols\r\n * are not supported.\r\n * @group Symbol\r\n * @param key key to search for.\r\n */\r\nexport function symbolFor(key: string): symbol {\r\n    // Cause lazy symbol to get initialized\r\n    (!_symbolFor || (_globalLazyTestHooks.lzy && !_symbol.b)) && getSymbol();\r\n\r\n    return (_symbolFor.v || polySymbolFor)(key);\r\n}\r\n\r\n/**\r\n * Returns a key from the global symbol registry matching the given Symbol if found.\r\n * Otherwise, returns a undefined. This will always attempt to lookup the polyfill\r\n * implementation if symbols are not supported\r\n * @group Symbol\r\n * @param sym Symbol to find the key for.\r\n */\r\nexport function symbolKeyFor(sym: symbol): string | undefined {\r\n    // Cause lazy symbol to get initialized\r\n    (!_symbolKeyFor || (_globalLazyTestHooks.lzy && !_symbol.b)) && getSymbol();\r\n\r\n    return (_symbolKeyFor.v || polySymbolKeyFor)(sym);\r\n}\r\n"]}