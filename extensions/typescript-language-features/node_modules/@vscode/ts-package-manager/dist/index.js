"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.packagePath = exports.ResolvedProject = exports.PackageManager = exports.PackageType = void 0;
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
const path_1 = require("path");
const node_maintainer_1 = require("../node-maintainer/node_maintainer");
const node_maintainer_bg_wasm_1 = __importDefault(require("../node-maintainer/node_maintainer_bg.wasm"));
(0, node_maintainer_1.initSync)(dataURItoUint8Array(node_maintainer_bg_wasm_1.default));
const decoder = new TextDecoder();
var PackageType;
(function (PackageType) {
    PackageType["Dependency"] = "dependencies";
    PackageType["DevDependency"] = "devDependencies";
    PackageType["OptionalDependency"] = "optionalDependencies";
    PackageType["PeerDependency"] = "peerDependencies";
})(PackageType || (exports.PackageType = PackageType = {}));
class PackageManager {
    constructor(fs) {
        this.fs = fs;
        this.nassun = new node_maintainer_1.Nassun({});
    }
    async resolveProject(root, opts = {}) {
        if (opts.addPackages || opts.removePackages) {
            await this.updateJson((0, path_1.join)(root, 'package.json'), opts);
        }
        console.time(`dependency resolution: ${root}`);
        const maintainer = await this.resolveMaintainer(root, opts);
        console.timeEnd(`dependency resolution: ${root}`);
        return new ResolvedProject(this.fs, maintainer, root);
    }
    async updateJson(packageJsonPath, opts = {}) {
        const packageType = opts.packageType ?? PackageType.Dependency;
        const corgis = await Promise.all((opts.addPackages ?? []).map(async (pkg) => this.nassun.corgiMetadata(pkg)));
        let pkgJson;
        try {
            pkgJson = this.readJson(packageJsonPath);
        }
        catch (e) {
            console.error('failed to read package.json', e);
            pkgJson = {};
        }
        for (const packageName of opts.removePackages ?? []) {
            delete pkgJson.dependencies?.[packageName];
            delete pkgJson.devDependencies?.[packageName];
            delete pkgJson.optionalDependencies?.[packageName];
            delete pkgJson.peerDependencies?.[packageName];
        }
        for (const corgi of corgis) {
            if (!pkgJson[packageType]) {
                pkgJson[packageType] = {};
            }
            pkgJson[packageType][corgi.name] = `^${corgi.version}`;
        }
        const stringified = JSON.stringify(pkgJson, undefined, 2);
        this.fs.writeFile(packageJsonPath, stringified);
    }
    async resolveMaintainer(root, opts) {
        const pkgJson = opts.pkgJson || this.fs.readFile((0, path_1.join)(root, 'package.json')) || '{}';
        const kdlPkgLock = opts.kdlLock || this.fs.readFile((0, path_1.join)(root, 'package-lock.kdl'));
        const npmPkgLock = opts.npmLock || this.fs.readFile((0, path_1.join)(root, 'package-lock.json'));
        return (0, node_maintainer_1.resolveManifest)(JSON.parse(pkgJson.trim()), { kdlLock: kdlPkgLock, npmLock: npmPkgLock });
    }
    /**
     * What it says on the tin. Reads a JSON file from the given path. Throws
     * if the file doesn't exist (as opposed to returning `undefined`, like
     * fs.readFile does).
     */
    readJson(path) {
        const data = this.fs.readFile(path);
        if (!data) {
            throw new Error('Failed to read file: ' + path);
        }
        return JSON.parse(data.trim());
    }
}
exports.PackageManager = PackageManager;
class ResolvedProject {
    constructor(fs, maintainer, root) {
        this.fs = fs;
        this.maintainer = maintainer;
        this.root = root;
        this.prefix = (0, path_1.join)(root, 'node_modules');
        this.metaPath = (0, path_1.join)(this.prefix, '.meta.json');
    }
    /**
     * Synchronizes the project's node_modules directory with the current resolved dependencies, pruning any extraneous ones.
     */
    async restore() {
        console.time(`project restore: ${this.root}`);
        this.pruneExtraneous();
        await this.extractMissing();
        this.writeLockfile();
        console.timeEnd(`project restore: ${this.root}`);
    }
    /**
     * Extracts a package at the given path. If a package has already been
     * extracted to that location, it will be replaced.
     *
     * @param path to a package
     * @returns The number of files extracted, or undefined if the path
     */
    async restorePackageAt(path) {
        console.time(`restore package at: ${path}`);
        this.checkPath(path);
        const meta = JSON.parse(this.fs.readFile(this.metaPath) || '{}');
        if (!meta.packages) {
            meta.packages = {};
        }
        const projRoot = this.getProjectRoot(path);
        if (!projRoot) {
            console.error('root not found for ', path);
            console.timeEnd(`restore package at: ${path}`);
            return;
        }
        const pkgPath = packagePath(path);
        const pkg = this.packageAtPath(path.slice(projRoot.length));
        if (!pkg) {
            console.error('no package at path', path, pkgPath);
            console.timeEnd(`restore package at: ${path}`);
            return;
        }
        if (pkg && pkgPath && meta.packages?.[pkgPath.slice(this.prefix.length)]?.resolved === pkg.resolved) {
            // Already installed and synced. No need to do anything else!
            console.timeEnd(`restore package at: ${path}`);
            return;
        }
        else {
            rimraf(this.fs, pkgPath);
        }
        let count;
        try {
            // NB(zkat): load-bearing `await`. We need to await here because
            // otherwise we'll have a use-after-free error when extracting the
            // package entries.
            count = await this.extractPackageTo(pkg, pkgPath);
            meta.packages[pkgPath.slice(this.prefix.length)] = {
                name: pkg.name,
                resolved: pkg.resolved
            };
        }
        catch (e) {
            console.error('error extracting: ', e);
            console.timeEnd(`restore package at: ${path}`);
            throw e;
        }
        finally {
            pkg.free();
        }
        rimraf(this.fs, this.metaPath);
        this.fs.writeFile(this.metaPath, JSON.stringify(meta, null, 2));
        this.writeLockfile();
        console.timeEnd(`restore package at: ${path}`);
        return count;
    }
    /**
     * Deletes/prunes files and directories that aren't expected to be there
     * by the currently-calculated tree. Extraneous calculation happens based on the contents of `.meta.json`
     * @returns
     */
    pruneExtraneous() {
        const meta = JSON.parse(this.fs.readFile(this.metaPath) || '{}');
        let count = 0;
        if (!this.fs.directoryExists(this.prefix)) {
            return count;
        }
        for (const entryPath of walkDir(this.fs, this.prefix)) {
            if (entryPath === this.metaPath) {
                // Leave the meta path alone.
                continue;
            }
            const pkgPath = packagePath(entryPath);
            // Only look at toplevel package paths.
            if (pkgPath === entryPath) {
                const subPath = pkgPath.slice(this.prefix.length);
                const pkg = this.packageAtPath(subPath);
                try {
                    if (pkg && meta.packages?.[pkgPath.slice(this.prefix.length)]?.resolved === pkg.resolved) {
                        // There's a valid package here. Move along.
                    }
                    else {
                        // Extraneous!
                        count++;
                        rimraf(this.fs, entryPath);
                    }
                }
                finally {
                    pkg?.free();
                }
            }
        }
        return count;
    }
    packageAtPath(path) {
        return this.maintainer.packageAtPath(path);
    }
    getProjectRoot(path) {
        const pkgPath = path.match(/(^.*\/)node_modules/);
        return pkgPath?.[1];
    }
    checkPath(path) {
        if (!path.startsWith(this.root)) {
            throw new Error(`Path ${path} is not in project root ${this.root}`);
        }
        if (!(0, path_1.isAbsolute)(path)) {
            throw new Error(`Path ${path} is not absolute`);
        }
    }
    async extractPackageTo(pkg, pkgPath) {
        const mkdirCache = new Set();
        mkdirp(mkdirCache, this.fs, pkgPath);
        // Clean up the directory, in case it already exists, but leave
        // node_modules alone to avoid clobbering other packages.
        for (const file of this.fs.readDirectory(pkgPath)) {
            if ((0, path_1.basename)(file) === 'node_modules') {
                continue;
            }
            rimraf(this.fs, file);
        }
        const entries = await pkg.entries();
        const reader = entries.getReader();
        let fileCount = 0;
        while (true) {
            const { done, value: entry } = await reader.read();
            if (done) {
                break;
            }
            // Strip the first level of a package, just like NPM does.
            const entryPath = (0, path_1.join)(pkgPath, entry.path.replace(/^([^/]*\/)?/, ''));
            // We simulate directories based on files we find.
            mkdirp(mkdirCache, this.fs, (0, path_1.dirname)(entryPath));
            // Types are registered here:
            // https://www.gnu.org/software/tar/manual/html_node/Standard.html.
            // You can get these numbers by just doing `'5'.codePointAt(0)`,
            // but we may as well hard-code the three values we actually care
            // about here.
            if (entry.type === 53) {
                // '5' == 53 == directory
                mkdirp(mkdirCache, this.fs, entryPath);
                await drainStream(entry.contents);
            }
            else if (entry.type === 0 || entry.type === 48) {
                // '0' == 48 or '\x00' == 0 == regular file
                const data = await streamToArrayBuffer(entry.contents, entry.size);
                this.fs.writeFile(entryPath, decoder.decode(data));
                fileCount++;
            }
            else {
                // Anything else, we throw away, but we have to make sure to
                // drain any contents before we can continue reading the
                // tarball.
                await drainStream(entry.contents);
            }
        }
        return fileCount;
    }
    async extractMissing() {
        const meta = { packages: {} };
        await this.maintainer.forEachPackage(async (pkg, path) => {
            const fullPath = (0, path_1.join)(this.prefix, path);
            meta.packages[path] = {
                name: pkg.name,
                resolved: pkg.resolved
            };
            try {
                if (!this.fs.directoryExists(fullPath)) {
                    await this.extractPackageTo(pkg, fullPath);
                }
            }
            finally {
                pkg.free();
            }
        });
        rimraf(this.fs, this.metaPath);
        this.fs.writeFile(this.metaPath, JSON.stringify(meta, null, 2));
    }
    writeLockfile() {
        this.fs.writeFile((0, path_1.join)(this.root, 'package-lock.kdl'), this.maintainer.toKdl());
    }
}
exports.ResolvedProject = ResolvedProject;
//---- Utils
/**
 * Given a full path to a particular file, presumably inside a package,
 * this returns the path of the package containing that file.
 * @param path the full file path to the file.
 * @returns the subpath of the package itself
 */
function packagePath(path) {
    return path.replace(/(^.*\/node_modules\/(?:@[^/]+\/)?[^/]+)\/?(?!node_modules\/).*/, '$1');
}
exports.packagePath = packagePath;
// via https://stackoverflow.com/questions/12168909/blob-from-dataurl
function dataURItoUint8Array(dataURI) {
    const byteString = atob(dataURI.split(',')[1]);
    const ab = new ArrayBuffer(byteString.length);
    const ia = new Uint8Array(ab);
    for (let i = 0; i < byteString.length; i++) {
        ia[i] = byteString.charCodeAt(i);
    }
    return ia;
}
async function drainStream(stream) {
    const reader = stream.getReader();
    while (true) { // eslint-disable-line no-constant-condition
        const { done } = await reader.read();
        if (done) {
            break;
        }
    }
    return reader.closed;
}
async function streamToArrayBuffer(stream, length) {
    const result = new Uint8Array(length);
    const reader = stream.getReader();
    let idx = 0;
    while (true) { // eslint-disable-line no-constant-condition
        const { done, value } = await reader.read();
        if (done) {
            break;
        }
        result.set(value, idx);
        idx += value.length;
    }
    return result;
}
function* walkDir(fs, path) {
    let contents = fs.readDirectory(path);
    while (contents.length) {
        const entry = contents.shift();
        const entryPath = (0, path_1.join)(path, entry);
        if (fs.directoryExists(entryPath)) {
            contents = fs.readDirectory(entryPath).map(e => (0, path_1.join)(entry, e)).concat(contents);
        }
        yield entryPath;
    }
}
function mkdirp(cache, fs, path) {
    path.split('/').reduce((dir, next) => {
        const joined = (0, path_1.join)(dir, next);
        if (!cache.has(joined) && !fs.directoryExists(joined)) {
            fs.createDirectory(joined);
            cache.add(joined);
        }
        return joined;
    }, '');
}
function rimraf(fs, path) {
    if (fs.directoryExists(path)) {
        for (const subPath of fs.readDirectory(path).map(e => (0, path_1.join)(path, e))) {
            rimraf(fs, subPath);
        }
    }
    try {
        fs.deleteFile?.(path);
    }
    catch (e) {
        // shou ga nai
    }
}
