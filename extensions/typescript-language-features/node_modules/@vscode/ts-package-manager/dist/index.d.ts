import { NodeMaintainer } from '../node-maintainer/node_maintainer';
export interface InstallProjectOpts {
    addPackages?: string[];
    removePackages?: string[];
    packageType?: PackageType;
    pkgJson?: string;
    npmLock?: string;
    kdlLock?: string;
}
export declare enum PackageType {
    Dependency = "dependencies",
    DevDependency = "devDependencies",
    OptionalDependency = "optionalDependencies",
    PeerDependency = "peerDependencies"
}
export interface FileSystem {
    readDirectory(path: string, extensions?: readonly string[], exclude?: readonly string[], include?: readonly string[], depth?: number): string[];
    deleteFile?(path: string): void;
    createDirectory(path: string): void;
    writeFile(path: string, data: string, writeByteOrderMark?: boolean): void;
    directoryExists(path: string): boolean;
    readFile(path: string, encoding?: string): string | undefined;
}
export declare class PackageManager {
    private readonly fs;
    private readonly nassun;
    constructor(fs: FileSystem);
    resolveProject(root: string, opts?: InstallProjectOpts): Promise<ResolvedProject>;
    private updateJson;
    private resolveMaintainer;
    /**
     * What it says on the tin. Reads a JSON file from the given path. Throws
     * if the file doesn't exist (as opposed to returning `undefined`, like
     * fs.readFile does).
     */
    private readJson;
}
export declare class ResolvedProject {
    private readonly fs;
    private readonly maintainer;
    private readonly root;
    private readonly prefix;
    private readonly metaPath;
    constructor(fs: FileSystem, maintainer: NodeMaintainer, root: string);
    /**
     * Synchronizes the project's node_modules directory with the current resolved dependencies, pruning any extraneous ones.
     */
    restore(): Promise<void>;
    /**
     * Extracts a package at the given path. If a package has already been
     * extracted to that location, it will be replaced.
     *
     * @param path to a package
     * @returns The number of files extracted, or undefined if the path
     */
    restorePackageAt(path: string): Promise<number | undefined>;
    /**
     * Deletes/prunes files and directories that aren't expected to be there
     * by the currently-calculated tree. Extraneous calculation happens based on the contents of `.meta.json`
     * @returns
     */
    pruneExtraneous(): number;
    private packageAtPath;
    private getProjectRoot;
    private checkPath;
    private extractPackageTo;
    private extractMissing;
    private writeLockfile;
}
/**
 * Given a full path to a particular file, presumably inside a package,
 * this returns the path of the package containing that file.
 * @param path the full file path to the file.
 * @returns the subpath of the package itself
 */
export declare function packagePath(path: string): string;
