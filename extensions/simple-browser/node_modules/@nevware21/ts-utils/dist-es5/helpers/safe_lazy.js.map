{"version":3,"file":"safe_lazy.js","sourceRoot":"","sources":["../../src/helpers/safe_lazy.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH,OAAO,EAAE,OAAO,EAAc,MAAM,QAAQ,CAAC;AAC7C,OAAO,EAAE,OAAO,EAAE,MAAM,YAAY,CAAC;AAErC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA6BG;AACH,MAAM,UAAU,WAAW,CAAc,EAAW,EAAE,QAAW;IAC7D,OAAO,OAAO,CAAI,cAAM,OAAA,OAAO,CAAI,EAAE,EAAE,QAAQ,CAAC,EAAxB,CAAwB,CAAC,CAAC;AACtD,CAAC","sourcesContent":["/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-utils\r\n *\r\n * Copyright (c) 2022 Nevware21\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { getLazy, ILazyValue } from \"./lazy\";\r\nimport { safeGet } from \"./safe_get\";\r\n\r\n/**\r\n * Create and return an readonly {@link ILazyValue} instance which will cache and return the value returned\r\n * by the callback function. The callback function will only be called once, multiple access of the value\r\n * does not cause re-execution of the callback as the result from the first call is cached internally.\r\n * If the callback throws the default value will be returned.\r\n * @since 0.9.5\r\n * @group Lazy\r\n * @group Safe\r\n * @param cb - The callback function to fetch the value to be lazily evaluated and cached\r\n * @param defValue - The default value to return when an exception is thrown\r\n * @returns A new readonly {@link ILazyValue} instance which wraps the callback and will be used to cache\r\n * the result of the callback\r\n * @example\r\n * ```ts\r\n * // This does not cause the evaluation to occur\r\n * let cachedValue = safeGetLazy(() => callSomeExpensiveFunctionWhichMightThrow(), \"someDefaultValue\");\r\n * let theValue;\r\n *\r\n * // Just checking if there is an object still does not cause the evaluation\r\n * if (cachedValue) {\r\n *     // This will cause the evaluation to occur and the result will be cached\r\n *     theValue = cachedValue.v;\r\n * }\r\n *\r\n * // Accessing the value again will not cause the re-evaluation to occur, it will just return the same\r\n * // result value again.\r\n * theValue === cachedValue.v;  // true\r\n *\r\n * ```\r\n */\r\nexport function safeGetLazy<T = boolean>(cb: () => T, defValue: T): ILazyValue<T> {\r\n    return getLazy<T>(() => safeGet<T>(cb, defValue));\r\n}\r\n"]}